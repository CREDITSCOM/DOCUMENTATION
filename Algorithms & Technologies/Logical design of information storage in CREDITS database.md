![Logical design](https://c.radikal.ru/c24/1805/18/28195f6925e5.jpg)

The storage concept delivered by CREDITS entails transaction data storage in a unidirectional chain of interrelated pools. Let us discuss how the CREDITS database (CSDB) is arranged: what its logical and software structure looks like, what types of information are stored in the platform database.
Information stored.

## The information saved by CREDITS on a mandatory basis is as follows:

currency data;

sums;

addresses;

transaction data;

transaction blocks/pools.

**Currency.** This type of data is stored as any random-length string, not necessarily human-readable, with any set of bytes. CREDITS uses its own currency known as CS by default, but users are allowed to carry out transactions in other currencies, too, depending on their preferences. There is a clear distinction between currencies: the platform does not offer any currency conversion options, the sums for different currencies are calculated separately, one currency – one transaction.

**Sums.** In this case, it means the sums of users' funds that match with different currencies manipulated by the user while carrying out transactions. Sums are stored as pairs of numbers. A 32-bit integer with a sign to denote the integral part of the sum and a 64-bit integer without such sign.

**Addresses**. The owners of funds are identified using their address, which represents a unique character set. The address is linked to the user's public key. The address is recorded as a Base58 encoded string with a prefix, which makes it possible to find out the address if a public key is known and vice versa – find out the wallet owner’s public key if the address is known. It is noteworthy that the same address can be used for a variety of currencies.

**Transactions**. “Transaction” means an entry recording the transfer of a certain sum in any given currency from one address to one or more other addresses. All transactions end up in a pool/block, with unique identifier (TransactionID) assigned to each transaction in order to ease transaction searching across the storage. TransactionID includes pool identifier and transaction number in this pool. Transaction information encompasses the following data:

*“Inputs”* mean the list of one or more TransactionIDs based on which the inbound transaction amount is generated. It is always expressed in the transaction currency, with one of inbound transaction “outputs” acting as payer.  

*“Outputs”* mean how an inbound sum is allocated among outputs and are represented as the list of pairs “sum; address.” The total sum of inputs is equal to the sum of outputs. There is an option to specify the address for “change” if a partial transfer of funds from one address to another is required.  

*Currency* means transaction currency.

*Payer* means the address of the transaction initiator who is in a position to dispose of funds associated with this address. Before being moved to the pool, each transaction is signed by the payer using his/her digital signature to confirm this right.

*Additional fields* mean the triplets “identifier (integer); type (integer or string); value (a random set of -length binary data).” These fields are not a must-have, neither are they processed by the storage.

Any transaction is generated by the payer who selects transactions for input and determines a set of outputs. The information to be checked before transactions end up in the pool is whether or not they are owned by the payer and if the payer used them as inputs for other transactions of his/hers, which is not allowed.

Blocks/pools. Block generation is timed, blocks include all transaction data which, however, is not required unless transactions are carried out within a preset period of time. The pool contains:

*The ordinal number and hash value of the previous pool in the chain.* Ordinal number is greater than the ordinal number of the previous pool by 1, whereas hash is counted after the pool generation is complete and may not be altered in the future. 

*pool generator’s address;*

*digital signature of the pool* based on the generator’s secret key;

*additional fields* similar to those of a transaction (not a must-have either).

# Physical design of storage
Currently, binary representation of the listed data is not strictly prescribed and can vary according to version. The serialization method selected for recording, and distinguishing between, such variations entails adding the serialization version to serialized data. It is delivered as the consecutive recording of all fields onto a binary block. Serialization algorithms and techniques are currently in their development stage and will, presumably, be optimized for data search and verification purposes. The interfaces of object classes will remain unchanged.
The storage used to store these blocks is known as LevelDB and classifies information on a “key; value” basis. The chain’s physical storage options can vary. Hypothetically speaking, these include any other similar storage, such as file system where pool hash acts as file name, and pool itself as substance. 
At opening, storage is analyzed by checking data integrity and building a chain of pools. Chain branching is not possible. Otherwise, storage is held invalid.

# Software implementation of storage
Storage management is arranged through a set of classes which represent methods for handling the above-listed and related objects. All objects constitute Copy-on-write classes protected against direct copying and modification, this kind of delivery makes it possible to quickly transmit the objects of a class value-wise and to organize containers efficiently.

*Key classes:*

**Storage** is arranged as a shared pointer with link calculation option and thus constitutes an exception.

**Currency** correlates with the object “Currency”;

**Sum** correlates with the object “Sum”; 

**TransactionID** correlates with the transaction identifier;

**Transaction** means transaction generation and transaction data acquisition methods. There are three modes of handling any object of a class:
Handling a transaction derived from the pool – an object is generated based on data that is already in the pool. This mode makes it possible to acquire all data concerning a transaction that cannot be modified or placed into a newly generated pool.
Handling a transaction derived from binary data – an object is generated based on data acquired across the network; all data other than transaction identifier can be acquired. No modification is possible. Transaction can be placed into a newly generated pool.
Generating a new transaction – an empty object with empty data is generated. Any data (save for identifier) can be acquired, any data can be added. Then a transaction is signed using a digital signature and can be serialized in a binary format or placed into a newly generated pool. 

**PoolHash** correlates with the pool hash;

**Pool** – a class provides methods for pool generation and data acquisition from the pool. There are two modes of handling any object of the Pool class:
Acquisition of data from the existing pool – any object of a class is generated based on binary data acquired across the network or from the storage. Only const methods for acquiring data from the pool are in place.
Pool generation – an “empty” object of a class is generated, with the option of adding fields and transactions to the pool in this mode. Once the generation process is completed, the pool is signed by the generator and becomes read-only. Then it can be put into storage and transmitted across the network. 
The hash value of a new pool is not available until digital signature is generated.

**Wallet** represents an additional class.

Accordingly, it can be observed that critical information concerning transactions is always saved in the CREDITS database that relies on the LevelDB storage principle. Storage management is arranged through a set of classes. Since the binary representation of stored data can vary according to version, the serialization method is used for change logging purposes. 

Here you can find code update on GitHub
https://github.com/CREDITSCOM/csdb
