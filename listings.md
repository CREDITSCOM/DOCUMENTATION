# ..\node\api\include\apihandler.hpp 
```cpp 
#ifndef APIHANDLER_HPP
#define APIHANDLER_HPP

#if defined(_MSC_VER)
#pragma warning(push)
// 4706 - assignment within conditional expression
// 4373 - 'api::APIHandler::TokenTransfersListGet': virtual function overrides 'api::APINull::TokenTransfersListGet',
//         previous versions of the compiler did not override when parameters only differed by const/volatile qualifiers
// 4245 - 'return' : conversion from 'int' to 'SOCKET', signed / unsigned mismatch
#pragma warning(disable : 4706 4373 4245) 
#endif

#include <API.h>
#include <APIEXEC.h>
#include <executor_types.h>
#include <general_types.h>

#include <thrift/transport/TSocket.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/transport/TBufferTransports.h>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#include <csnode/blockchain.hpp>

#include <csstats.hpp>
#include <deque>
#include <queue>

#include <client/params.hpp>
#include <lib/system/concurrent.hpp>

#include "tokens.hpp"

#include <optional>

#include <csdb/currency.hpp>
#include <solvercore.hpp>

namespace csconnector {
class connector;
}  // namespace csconnector

class APIHandlerBase {
public:
    enum class APIRequestStatusType : uint8_t {
        SUCCESS,
        FAILURE,
        NOT_IMPLEMENTED,
        NOT_FOUND,
		INPROGRESS,
        MAX		
    };

    static void SetResponseStatus(general::APIResponse& response, APIRequestStatusType status, const std::string& details = "");
    static void SetResponseStatus(general::APIResponse& response, bool commandWasHandled);
};

struct APIHandlerInterface : public api::APINull, public APIHandlerBase {};

template <typename T>
T deserialize(std::string&& s) {
    using namespace ::apache;

    // https://stackoverflow.com/a/16261758/2016154
    static_assert(CHAR_BIT == 8 && std::is_same<std::uint8_t, unsigned char>::value, "This code requires std::uint8_t to be implemented as unsigned char.");

    const auto buffer = thrift::stdcxx::make_shared<thrift::transport::TMemoryBuffer>(reinterpret_cast<uint8_t*>(&(s[0])), static_cast<uint32_t>(s.size()));
    thrift::protocol::TBinaryProtocol proto(buffer);
    T sc;
    sc.read(&proto);
    return sc;
}

template <typename T>
std::string serialize(const T& sc) {
    using namespace ::apache;

    auto buffer = thrift::stdcxx::make_shared<thrift::transport::TMemoryBuffer>();
    thrift::protocol::TBinaryProtocol proto(buffer);
    sc.write(&proto);
    return buffer->getBufferAsString();
}

namespace cs {
class SolverCore;
}

namespace csconnector {
struct Config;
}

namespace executor {
class APIResponse;
class ContractExecutorConcurrentClient;
}  // namespace executor

namespace executor {
class Executor {
public:  // wrappers
    void executeByteCode(executor::ExecuteByteCodeResult& resp, const std::string& address, const std::string& smart_address, const std::vector<general::ByteCodeObject>& code,
                         const std::string& state, const std::string& method, const std::vector<general::Variant>& params, const int64_t& timeout) {
        csunused(timeout);
        static std::mutex m;
        std::lock_guard lk(m);  // temporary solution

        if (!code.empty()) {
            executor::SmartContractBinary smartContractBinary;
            smartContractBinary.contractAddress = smart_address;
            smartContractBinary.object.byteCodeObjects = code;
            smartContractBinary.object.instance = state;
            smartContractBinary.stateCanModify = solver_.isContractLocked(BlockChain::getAddressFromKey(smart_address)) ? true : false;
            if (auto optOriginRes = execute(address, smartContractBinary, method, params))
                resp = optOriginRes.value().resp;
        }
    }

    void executeByteCodeMultiple(ExecuteByteCodeMultipleResult& _return, const ::general::Address& initiatorAddress, const SmartContractBinary& invokedContract,
        const std::string& method, const std::vector<std::vector<::general::Variant>>& params, const int64_t executionTime) {
        if (!connect()) {
            _return.status.code = 1;
            _return.status.message = "No executor connection!";
            return;
        }
        const auto acceess_id = generateAccessId();
        ++execCount_;
        try {
			std::shared_lock slk(shErrMt);
            origExecutor_->executeByteCodeMultiple(_return, acceess_id, initiatorAddress, invokedContract, method, params, executionTime, EXECUTOR_VERSION);
        }
        catch (::apache::thrift::transport::TTransportException & x) {
            // sets stop_ flag to true forever, replace with new instance
            if (x.getType() == ::apache::thrift::transport::TTransportException::NOT_OPEN) {
                reCreationOriginExecutor();
            }
            _return.status.code = 1;
            _return.status.message = x.what();
        }
        catch( std::exception & x ) {
            _return.status.code = 1;
            _return.status.message = x.what();
        }
        --execCount_;
        deleteAccessId(acceess_id);
        disconnect();
    }

    void getContractMethods(GetContractMethodsResult& _return, const std::vector<::general::ByteCodeObject>& byteCodeObjects) {
        if (!connect()) {
            _return.status.code = 1;
            _return.status.message = "No executor connection!";
            return;
        }
        try {
			std::shared_lock slk(shErrMt);
            origExecutor_->getContractMethods(_return, byteCodeObjects, EXECUTOR_VERSION);
        }
        catch (::apache::thrift::transport::TTransportException & x) {
            // sets stop_ flag to true forever, replace with new instance
            if (x.getType() == ::apache::thrift::transport::TTransportException::NOT_OPEN) {
                reCreationOriginExecutor();
            }
            _return.status.code = 1;
            _return.status.message = x.what();
        }
        catch( std::exception & x ) {
            _return.status.code = 1;
            _return.status.message = x.what();
        }
        disconnect();
    }

    void getContractVariables(GetContractVariablesResult& _return, const std::vector<::general::ByteCodeObject>& byteCodeObjects, const std::string& contractState) {
        if (!connect()) {
            _return.status.code = 1;
            _return.status.message = "No executor connection!";
            return;
        }
        try {
			std::shared_lock slk(shErrMt);
            origExecutor_->getContractVariables(_return, byteCodeObjects, contractState, EXECUTOR_VERSION);
        }
        catch (::apache::thrift::transport::TTransportException & x) {
            // sets stop_ flag to true forever, replace with new instance
            if (x.getType() == ::apache::thrift::transport::TTransportException::NOT_OPEN) {
                reCreationOriginExecutor();
            }
            _return.status.code = 1;
            _return.status.message = x.what();
        }
        catch( std::exception & x ) {
            _return.status.code = 1;
            _return.status.message = x.what();
        }
        disconnect();
    }

    void compileSourceCode(CompileSourceCodeResult& _return, const std::string& sourceCode) {
        if (!connect()) {
            _return.status.code = 1;
            _return.status.message = "No executor connection!";
            return;
        }
        try {
			std::shared_lock slk(shErrMt);
            origExecutor_->compileSourceCode(_return, sourceCode, EXECUTOR_VERSION);
        }
        catch (::apache::thrift::transport::TTransportException & x) {
            // sets stop_ flag to true forever, replace with new instance
            if (x.getType() == ::apache::thrift::transport::TTransportException::NOT_OPEN) {
                reCreationOriginExecutor();
            }
            _return.status.code = 1;
            _return.status.message = x.what();
        }
        catch( std::exception & x ) {
            _return.status.code = 1;
            _return.status.message = x.what();
        }
        disconnect();
    }

public:
    static Executor& getInstance(const BlockChain* p_blockchain = nullptr, const cs::SolverCore* solver = nullptr, const int p_exec_port = 0) {  // singlton
        static Executor executor(*p_blockchain, *solver, p_exec_port);
        return executor;
    }

    std::optional<cs::Sequence> getSequence(const general::AccessID& accessId) {
        std::shared_lock slk(mtx_);
        if (auto it = accessSequence_.find(accessId); it != accessSequence_.end())
            return std::make_optional(it->second);
        return std::nullopt;
    }

    std::optional<csdb::TransactionID> getDeployTrxn(const csdb::Address& p_address) {
        std::shared_lock slk(mtx_);
        if (const auto it = deployTrxns_.find(p_address); it != deployTrxns_.end())
            return std::make_optional(it->second);
        return std::nullopt;
    }

    void updateDeployTrxns(const csdb::Address& p_address, const csdb::TransactionID& p_trxnsId) {
        std::lock_guard lk(mtx_);
        deployTrxns_[p_address] = p_trxnsId;
    }

    void setLastState(const csdb::Address& p_address, const std::string& p_state) {
        std::lock_guard lk(mtx_);
        lastState_[p_address] = p_state;
    }

    std::optional<std::string> getState(const csdb::Address& p_address) {
        std::shared_lock slk(mtx_);
        if (const auto it_last_state = lastState_.find(p_address); it_last_state != lastState_.end())
            return std::make_optional(it_last_state->second);
        return std::nullopt;
    }

    void updateCacheLastStates(const csdb::Address& p_address, const cs::Sequence& sequence, const std::string& state) {
        std::lock_guard lk(mtx_);
        if (execCount_)
            (cacheLastStates_[p_address])[sequence] = state;
        else if (cacheLastStates_.size())
            cacheLastStates_.clear();
    }

    std::optional<std::string> getAccessState(const general::AccessID& p_access_id, const csdb::Address& p_address) {
        std::shared_lock slk(mtx_);
        const auto access_sequence = getSequence(p_access_id);
        if (const auto unmap_states_it = cacheLastStates_.find(p_address); unmap_states_it != cacheLastStates_.end()) {
            std::pair<cs::Sequence, std::string> prev_seq_state{};
            for (const auto& [curr_seq, curr_state] : unmap_states_it->second) {
                if (curr_seq > access_sequence)
                    return prev_seq_state.first ? std::make_optional<std::string>(prev_seq_state.second) : std::nullopt;
                prev_seq_state = {curr_seq, curr_state};
            }
        }
        auto opt_last_sate = getState(p_address);
        return opt_last_sate.has_value() ? std::make_optional<std::string>(opt_last_sate.value()) : std::nullopt;
    }

    struct ExecuteResult {
        std::string newState;
        std::map<csdb::Address, std::string> states;
        std::vector<csdb::Transaction> trxns;
        csdb::Amount fee;
        general::Variant retValue;
    };

    void addInnerSendTransaction(const general::AccessID& accessId, const csdb::Transaction& transaction) {
        std::lock_guard lk(mtx_);
        innerSendTransactions_[accessId].push_back(transaction);
    }

    std::optional<std::vector<csdb::Transaction>> getInnerSendTransactions(const general::AccessID& accessId) {
        std::shared_lock slk(mtx_);
        if (const auto it = innerSendTransactions_.find(accessId); it != innerSendTransactions_.end())
            return std::make_optional<std::vector<csdb::Transaction>>(it->second);
        return std::nullopt;
    }

    void deleteInnerSendTransactions(const general::AccessID& accessId) {
        std::lock_guard lk(mtx_);
        innerSendTransactions_.erase(accessId);
    }

    bool isDeploy(const csdb::Transaction& trxn) {
        if (trxn.user_field(0).is_valid()) {
            const auto sci = deserialize<api::SmartContractInvocation>(trxn.user_field(0).value<std::string>());
            if (sci.method.empty())
                return true;
        }
        return false;
    }

    std::optional<ExecuteResult> executeTransaction(const csdb::Pool& pool, const uint64_t& offsetTrx, const csdb::Amount& feeLimit, const std::string& force_new_state) {
        csunused(feeLimit);
        static std::mutex m;
        std::lock_guard lk(m);  // temporary solution

        auto smartTrxn = *(pool.transactions().begin() + offsetTrx);

        auto smartSource = blockchain_.getAddressByType(smartTrxn.source(), BlockChain::AddressType::PublicKey);
        auto smartTarget = blockchain_.getAddressByType(smartTrxn.target(), BlockChain::AddressType::PublicKey);

        csdb::Transaction deployTrxn;
        const auto isdeploy = isDeploy(smartTrxn);
        if (!isdeploy) {  // execute
            const auto optDeployId = getDeployTrxn(smartTarget);
            if (!optDeployId.has_value())
                return std::nullopt;
            deployTrxn = blockchain_.loadTransaction(optDeployId.value());
        }
        else
            deployTrxn = smartTrxn;

        const auto sci_deploy = deserialize<api::SmartContractInvocation>(deployTrxn.user_field(0).value<std::string>());
        executor::SmartContractBinary smartContractBinary;
        smartContractBinary.contractAddress = smartTarget.to_api_addr();
        smartContractBinary.object.byteCodeObjects = sci_deploy.smartContractDeploy.byteCodeObjects;
        // may contain temporary last new state not yet written into block chain (to allow "speculative" multi-executions af the same contract)
        if (!force_new_state.empty()) {
            smartContractBinary.object.instance = force_new_state;
        }
        else {
            auto optState = getState(smartTarget);
            if (optState.has_value())
                smartContractBinary.object.instance = optState.value();
        }
        smartContractBinary.stateCanModify = solver_.isContractLocked(BlockChain::getAddressFromKey(smartTarget.to_api_addr())) ? true : false;

        std::string method;
        std::vector<general::Variant> params;
        api::SmartContractInvocation sci;
        if (!smartTrxn.user_field(0).is_valid() && smartTrxn.amount().to_double()) {  // payable
            method = "payable";
            general::Variant var;
            var.__set_v_string(smartTrxn.amount().to_string());
            params.emplace_back(var);

			if (smartTrxn.user_field(1).is_valid()) {
				var.__set_v_string(smartTrxn.user_field(1).value<std::string>());
				params.emplace_back(var);
			}
			else {
				var.__set_v_string("");
				params.emplace_back(var);
			}
        }
        else if (!isdeploy) {
            sci = deserialize<api::SmartContractInvocation>(smartTrxn.user_field(0).value<std::string>());
            method = sci.method;
            params = sci.params;

            for (const auto& addrLock : sci.usedContracts) {
                addToLockSmart(addrLock, getFutureAccessId());
            }
        }

        const auto optOriginRes = execute(smartSource.to_api_addr(), smartContractBinary, method, params);

        if (!isdeploy) {
            for (const auto& addrLock : sci.usedContracts) {
                deleteFromLockSmart(addrLock, getFutureAccessId());
            }
        }

        if (!optOriginRes.has_value())
            return std::nullopt;

        const auto optInnerTransactions = getInnerSendTransactions(optOriginRes.value().acceessId);

        ExecuteResult res;
        const auto resp = optOriginRes.value().resp;
        if (resp.status.code != 0) {
            if (!resp.status.message.empty()) {
                res.retValue.__set_v_string(resp.status.message);
            }
            else {
                res.retValue = resp.ret_val;
            }
        }
        else {
            if (optInnerTransactions.has_value())
                res.trxns = optInnerTransactions.value();
            deleteInnerSendTransactions(optOriginRes.value().acceessId);
            constexpr double FEE_IN_SECOND = kMinFee * 4.0;
            const double fee = std::min(kMinFee, static_cast<double>(optOriginRes.value().timeExecute) * FEE_IN_SECOND);
            res.fee = csdb::Amount(fee);
            res.newState = optOriginRes.value().resp.invokedContractState;
            for (const auto& [itAddress, itState] : optOriginRes.value().resp.externalContractsState) {
                const csdb::Address addr = BlockChain::getAddressFromKey(itAddress);
                res.states[addr] = itState;
            }
            res.retValue = optOriginRes.value().resp.ret_val;
        }
        return res;
    }

    csdb::Transaction make_transaction(const api::Transaction& transaction) {
        csdb::Transaction send_transaction;
        const auto source = BlockChain::getAddressFromKey(transaction.source);
        const uint64_t WALLET_DENOM = csdb::Amount::AMOUNT_MAX_FRACTION;  // 1'000'000'000'000'000'000ull;
        send_transaction.set_amount(csdb::Amount(transaction.amount.integral, transaction.amount.fraction, WALLET_DENOM));
        BlockChain::WalletData wallData{};
        BlockChain::WalletId id{};

        if (!blockchain_.findWalletData(source, wallData, id))
            return csdb::Transaction{};

        send_transaction.set_currency(csdb::Currency(1));
        send_transaction.set_source(source);
        send_transaction.set_target(BlockChain::getAddressFromKey(transaction.target));
        send_transaction.set_max_fee(csdb::AmountCommission((uint16_t)transaction.fee.commission));
        send_transaction.set_innerID(transaction.id & 0x3fffffffffff);

        // TODO Change Thrift to avoid copy
        cs::Signature signature;
        if (transaction.signature.size() == signature.size())
            std::copy(transaction.signature.begin(), transaction.signature.end(), signature.begin());
        else
            signature.fill(0);
        send_transaction.set_signature(signature);
        return send_transaction;
    }

    bool isConnect() {
        return isConnect_;
    }

    void state_update(const csdb::Pool& pool) {
        if (!pool.transactions().size())
            return;
        for (const auto& trxn : pool.transactions()) {
            if (trxn.is_valid() && (trxn.user_field(-2).type() == csdb::UserField::Type::String && trxn.user_field(1).type() == csdb::UserField::Type::String)) {
                const auto address = blockchain_.getAddressByType(trxn.target(), BlockChain::AddressType::PublicKey);
                const auto newstate = trxn.user_field(-2).value<std::string>();
                if (!newstate.empty()) {
                    setLastState(address, newstate);
                    updateCacheLastStates(address, pool.sequence(), newstate);
                }
            }
        }
    }

    void addToLockSmart(const general::Address& address, const general::AccessID& accessId) {
        std::lock_guard lk(mtx_);
        lockSmarts[address] = accessId;
    }

    void deleteFromLockSmart(const general::Address& address, const general::AccessID& accessId) {
        csunused(accessId);
        std::lock_guard lk(mtx_);
        lockSmarts.erase(address);
    }

    bool isLockSmart(const general::Address& address, const general::AccessID& accessId) {
        std::lock_guard lk(mtx_);
        if (auto addrLock = lockSmarts.find(address); addrLock != lockSmarts.end() && addrLock->second == accessId)
            return true;
        return false;
    }

public slots:
    void onBlockStored(const csdb::Pool& pool) {
        state_update(pool);
    }

    void onReadBlock(const csdb::Pool& block, bool* test_failed) {
        csunused(test_failed);
        state_update(block);
    }

private:
    std::map<general::Address, general::AccessID> lockSmarts;
    explicit Executor(const BlockChain& p_blockchain, const cs::SolverCore& solver, const int p_exec_port)
    : blockchain_(p_blockchain)
    , solver_(solver)
    , executorTransport_(new ::apache::thrift::transport::TBufferedTransport(::apache::thrift::stdcxx::make_shared<::apache::thrift::transport::TSocket>("localhost", p_exec_port)))
    , origExecutor_(
          std::make_unique<executor::ContractExecutorConcurrentClient>(::apache::thrift::stdcxx::make_shared<apache::thrift::protocol::TBinaryProtocol>(executorTransport_))) {
        std::thread th([&]() {
            while (true) {
                if (isConnect_) {
                    static std::mutex mt;
                    std::unique_lock ulk(mt);
                    cvErrorConnect_.wait(ulk, [&] { return !isConnect_; });
                }

                static const int RECONNECT_TIME = 10;
                std::this_thread::sleep_for(std::chrono::seconds(RECONNECT_TIME));
                if (connect())
                    disconnect();
            }
        });
        th.detach();
    }

    struct OriginExecuteResult {
        ExecuteByteCodeResult resp;
        general::AccessID acceessId;
        long long timeExecute;
    };

    uint64_t generateAccessId() {
        std::lock_guard lk(mtx_);
        ++lastAccessId_;
        accessSequence_[lastAccessId_] = blockchain_.getLastSequence();
        return lastAccessId_;
    }

    uint64_t getFutureAccessId() {
        return lastAccessId_ + 1;
    }

    void deleteAccessId(const general::AccessID& p_access_id) {
        std::lock_guard lk(mtx_);
        accessSequence_.erase(p_access_id);
    }

    std::optional<OriginExecuteResult> execute(const std::string& address, const SmartContractBinary& smartContractBinary, const std::string& method,
        const std::vector<general::Variant>& params) {
        constexpr uint64_t EXECUTION_TIME = Consensus::T_smart_contract;
        OriginExecuteResult originExecuteRes{};
        if (!connect())
            return std::nullopt;
        const auto access_id = generateAccessId();
        ++execCount_;
        const auto timeBeg = std::chrono::steady_clock::now();
        try {
			std::shared_lock slk(shErrMt);
            origExecutor_->executeByteCode(originExecuteRes.resp, access_id, address, smartContractBinary, method, params, EXECUTION_TIME, EXECUTOR_VERSION);
        }
        catch (::apache::thrift::transport::TTransportException & x) {
            // sets stop_ flag to true forever, replace with new instance
            if (x.getType() == ::apache::thrift::transport::TTransportException::NOT_OPEN) {
                reCreationOriginExecutor();
            }
            originExecuteRes.resp.status.code = 1;
            originExecuteRes.resp.status.message = x.what();
        }
        catch( std::exception & x ) {
            originExecuteRes.resp.status.code = 1;
            originExecuteRes.resp.status.message = x.what();
        }
        originExecuteRes.timeExecute = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - timeBeg).count();
        --execCount_;
        deleteAccessId(access_id);
        disconnect();
        originExecuteRes.acceessId = access_id;
        return std::make_optional<OriginExecuteResult>(std::move(originExecuteRes));
    }

    bool connect() {
        try {
            if (executorTransport_->isOpen())
                executorTransport_->close();

            executorTransport_->open();
            isConnect_ = true;
        }
        catch (...) {
            isConnect_ = false;
            cvErrorConnect_.notify_one();
        }
        return isConnect_;
    }

    void disconnect() {
        try {
            executorTransport_->close();
        }
        catch (::apache::thrift::transport::TTransportException&) {
            isConnect_ = false;
            cvErrorConnect_.notify_one();
        }
    }

	//
	using OriginExecutor = executor::ContractExecutorConcurrentClient;
	using BinaryProtocol = apache::thrift::protocol::TBinaryProtocol;
	std::shared_mutex shErrMt;
	void reCreationOriginExecutor() {
		std::lock_guard glk(shErrMt);
		origExecutor_.reset(new OriginExecutor(::apache::thrift::stdcxx::make_shared<BinaryProtocol>(executorTransport_)));
	}
	//	

private:
    const BlockChain& blockchain_;
    const cs::SolverCore& solver_;
    ::apache::thrift::stdcxx::shared_ptr<::apache::thrift::transport::TTransport> executorTransport_;
    std::unique_ptr<executor::ContractExecutorConcurrentClient> origExecutor_;

    general::AccessID lastAccessId_{};
    std::map<general::AccessID, cs::Sequence> accessSequence_;
    std::map<csdb::Address, csdb::TransactionID> deployTrxns_;
    std::map<csdb::Address, std::string> lastState_;
    std::map<csdb::Address, std::unordered_map<cs::Sequence, std::string>> cacheLastStates_;
    std::map<general::AccessID, std::vector<csdb::Transaction>> innerSendTransactions_;

    std::shared_mutex mtx_;
    std::atomic_size_t execCount_{0};

    std::condition_variable cvErrorConnect_;
    std::atomic_bool isConnect_{false};

    const uint16_t EXECUTOR_VERSION = 0;
};
}  // namespace executor
namespace apiexec {
class APIEXECHandler : public APIEXECNull, public APIHandlerBase {
public:
    explicit APIEXECHandler(BlockChain& blockchain, cs::SolverCore& _solver, executor::Executor& executor, const csconnector::Config& config);
    APIEXECHandler(const APIEXECHandler&) = delete;
    void GetSeed(apiexec::GetSeedResult& _return, const general::AccessID accessId) override;
    void SendTransaction(apiexec::SendTransactionResult& _return, const general::AccessID accessId, const api::Transaction& transaction) override;
    void WalletIdGet(api::WalletIdGetResult& _return, const general::AccessID accessId, const general::Address& address) override;
    void SmartContractGet(SmartContractGetResult& _return, const general::AccessID accessId, const general::Address& address) override;
    void WalletBalanceGet(api::WalletBalanceGetResult& _return, const general::Address& address) override;

    executor::Executor& getExecutor() const {
        return executor_;
    }

private:
    executor::Executor& executor_;
    BlockChain& blockchain_;
    cs::SolverCore& solver_;
};
}  // namespace apiexec

namespace api {
class APIFaker : public APINull {
public:
    APIFaker(BlockChain&, cs::SolverCore&) {
    }
};

class APIHandler : public APIHandlerInterface {
public:
    explicit APIHandler(BlockChain& blockchain, cs::SolverCore& _solver, executor::Executor& executor, const csconnector::Config& config);
    ~APIHandler() override;

    APIHandler(const APIHandler&) = delete;

    void WalletDataGet(api::WalletDataGetResult& _return, const general::Address& address) override;
    void WalletIdGet(api::WalletIdGetResult& _return, const general::Address& address) override;
    void WalletTransactionsCountGet(api::WalletTransactionsCountGetResult& _return, const general::Address& address) override;
    void WalletBalanceGet(api::WalletBalanceGetResult& _return, const general::Address& address) override;

    void TransactionGet(api::TransactionGetResult& _return, const api::TransactionId& transactionId) override;
    void TransactionsGet(api::TransactionsGetResult& _return, const general::Address& address, const int64_t offset, const int64_t limit) override;
    void TransactionFlow(api::TransactionFlowResult& _return, const api::Transaction& transaction) override;

    // Get list of pools from last one (head pool) to the first one.
    void PoolListGet(api::PoolListGetResult& _return, const int64_t offset, const int64_t limit) override;

    // Get pool info by pool hash. Starts looking from last one (head pool).
    void PoolInfoGet(api::PoolInfoGetResult& _return, const api::PoolHash& hash, const int64_t index) override;
    void PoolTransactionsGet(api::PoolTransactionsGetResult& _return, const api::PoolHash& hash, const int64_t offset, const int64_t limit) override;
    void StatsGet(api::StatsGetResult& _return) override;

    void SmartContractGet(api::SmartContractGetResult& _return, const general::Address& address) override;

    void SmartContractsListGet(api::SmartContractsListGetResult& _return, const general::Address& deployer) override;

    void SmartContractAddressesListGet(api::SmartContractAddressesListGetResult& _return, const general::Address& deployer) override;

    void GetLastHash(api::PoolHash& _return) override;
    void PoolListGetStable(api::PoolListGetResult& _return, const api::PoolHash& hash, const int64_t limit) override;

    void WaitForSmartTransaction(api::TransactionId& _return, const general::Address& smart_public) override;

    void SmartContractsAllListGet(api::SmartContractsListGetResult& _return, const int64_t offset, const int64_t limit) override;

    void WaitForBlock(PoolHash& _return, const PoolHash& obsolete) override;

    void SmartMethodParamsGet(SmartMethodParamsGetResult& _return, const general::Address& address, const int64_t id) override;

    void TransactionsStateGet(TransactionsStateGetResult& _return, const general::Address& address, const std::vector<int64_t>& v) override;

    void ContractAllMethodsGet(ContractAllMethodsGetResult& _return, const std::vector<::general::ByteCodeObject>& byteCodeObjects) override;

    ////////new
    void iterateOverTokenTransactions(const csdb::Address&, const std::function<bool(const csdb::Pool&, const csdb::Transaction&)>);
    ////////new
    api::SmartContractInvocation getSmartContract(const csdb::Address&, bool&);
    std::vector<general::ByteCodeObject> getSmartByteCode(const csdb::Address&, bool&);
    void SmartContractDataGet(api::SmartContractDataResult&, const general::Address&) override;
    void SmartContractCompile(api::SmartContractCompileResult&, const std::string&) override;

    void TokenBalancesGet(api::TokenBalancesResult&, const general::Address&) override;
    void TokenTransfersGet(api::TokenTransfersResult&, const general::Address& token, int64_t offset, int64_t limit) override;
    void TokenTransferGet(api::TokenTransfersResult& _return, const general::Address& token, const TransactionId& id) override;
    void TokenWalletTransfersGet(api::TokenTransfersResult&, const general::Address& token, const general::Address& address, int64_t offset, int64_t limit) override;
    void TokenTransactionsGet(api::TokenTransactionsResult&, const general::Address&, int64_t offset, int64_t limit) override;
    void TokenInfoGet(api::TokenInfoResult&, const general::Address&) override;
    void TokenHoldersGet(api::TokenHoldersResult&, const general::Address&, int64_t offset, int64_t limit, const TokenHoldersSortField order, const bool desc) override;
    void TokensListGet(api::TokensListResult&, int64_t offset, int64_t limit, const TokensListSortField order, const bool desc) override;
#ifdef TRANSACTIONS_INDEX
    void TokenTransfersListGet(api::TokenTransfersResult&, int64_t offset, int64_t limit) override;
    void TransactionsListGet(api::TransactionsGetResult&, int64_t offset, int64_t limit) override;
#endif
    void WalletsGet(api::WalletsGetResult& _return, int64_t offset, int64_t limit, int8_t ordCol, bool desc) override;
    void TrustedGet(api::TrustedGetResult& _return, int32_t page) override;
    ////////new

    void SyncStateGet(api::SyncStateResult& _return) override;

    BlockChain& get_s_blockchain() const noexcept {
        return s_blockchain;
    }

    executor::Executor& getExecutor() {
        return executor_;
    }

private:
	::csstats::AllStats stats_;
    executor::Executor& executor_;

    struct smart_trxns_queue {
        cs::SpinLock lock{ATOMIC_FLAG_INIT};
        std::condition_variable_any new_trxn_cv{};
        size_t awaiter_num{0};
        std::deque<csdb::TransactionID> trid_queue{};
    };

    struct PendingSmartTransactions {
        std::queue<std::pair<cs::Sequence, csdb::Transaction>> queue;
        csdb::PoolHash last_pull_hash{};
        cs::Sequence last_pull_sequence = 0;
    };

    struct SmartState {
        std::string state;
        bool lastEmpty;
        csdb::TransactionID transaction;
        csdb::TransactionID initer;
    };

    using smart_state_entry = cs::WorkerQueue<SmartState>;
    using client_type = executor::ContractExecutorConcurrentClient;

    BlockChain& s_blockchain;
    cs::SolverCore& solver;
#ifdef MONITOR_NODE
    csstats::csstats stats;
#endif
    ::apache::thrift::stdcxx::shared_ptr<::apache::thrift::transport::TTransport> executorTransport_;

    struct SmartOperation {
        enum class State : uint8_t {
            Pending,
            Success,
            Failed
        };

        State state = State::Pending;
        csdb::TransactionID stateTransaction;

        bool hasRetval : 1;
        bool returnsBool : 1;
        bool boolResult : 1;

        SmartOperation()
        : hasRetval(false)
        , returnsBool(false) {
        }
        SmartOperation(const SmartOperation& rhs)
        : state(rhs.state)
        , stateTransaction(rhs.stateTransaction.clone())
        , hasRetval(rhs.hasRetval)
        , returnsBool(rhs.returnsBool)
        , boolResult(rhs.boolResult) {
        }

        // SmartOperation(SmartOperation&&) = delete; //not compiled!? (will not be called because there is "SmartOperation (const SmartOperation & rhs)")
        SmartOperation& operator=(const SmartOperation&) = delete;
        SmartOperation& operator=(SmartOperation&&) = delete;

        bool hasReturnValue() const {
            return hasRetval;
        }
        bool getReturnedBool() const {
            return returnsBool && boolResult;
        }
    };

    SmartOperation getSmartStatus(const csdb::TransactionID);

    cs::SpinLockable<std::map<csdb::TransactionID, SmartOperation>> smart_operations;
    cs::SpinLockable<std::map<cs::Sequence, std::vector<csdb::TransactionID>>> smarts_pending;

    cs::SpinLockable<std::map<csdb::Address, csdb::TransactionID>> smart_origin;
    cs::SpinLockable<std::map<csdb::Address, smart_state_entry>> smart_state;
    cs::SpinLockable<std::map<csdb::Address, smart_trxns_queue>> smart_last_trxn;

	//
	/*using TrxInPrgss = std::pair<csdb::Address, int64_t>;
	using CVInPrgss = std::pair<std::condition_variable, bool>;
	cs::SpinLockable<std::map<TrxInPrgss, CVInPrgss>> trxInProgress;*/
	//

    cs::SpinLockable<std::map<csdb::Address, std::vector<csdb::TransactionID>>> deployed_by_creator;
    cs::SpinLockable<PendingSmartTransactions> pending_smart_transactions;
    std::map<csdb::PoolHash, api::Pool> poolCache;
    std::atomic_flag state_updater_running = ATOMIC_FLAG_INIT;
    std::thread state_updater;

    api::SmartContract fetch_smart_body(const csdb::Transaction&);

private:
    void state_updater_work_function();

    std::vector<api::SealedTransaction> extractTransactions(const csdb::Pool& pool, int64_t limit, const int64_t offset);

    api::SealedTransaction convertTransaction(const csdb::Transaction& transaction);

    std::vector<api::SealedTransaction> convertTransactions(const std::vector<csdb::Transaction>& transactions);

    api::Pool convertPool(const csdb::Pool& pool);

    api::Pool convertPool(const csdb::PoolHash& poolHash);

    // bool convertAddrToPublicKey(const csdb::Address& address);

    template <typename Mapper>
    size_t getMappedDeployerSmart(const csdb::Address& deployer, Mapper mapper, std::vector<decltype(mapper(api::SmartContract()))>& out);

    bool update_smart_caches_once(const csdb::PoolHash&, bool = false);
    void run();

    ::csdb::Transaction make_transaction(const ::api::Transaction&);
    void dumb_transaction_flow(api::TransactionFlowResult& _return, const ::api::Transaction&);
    void smart_transaction_flow(api::TransactionFlowResult& _return, const ::api::Transaction&);

    TokensMaster tm;

    const uint32_t MAX_EXECUTION_TIME = 1000;

    const uint8_t ERROR_CODE = 1;

    friend class ::csconnector::connector;

    std::condition_variable_any newBlockCv_;
    std::mutex dbLock_;

private slots:
    void update_smart_caches_slot(const csdb::Pool& pool);
    void store_block_slot(const csdb::Pool& pool);
	void collect_all_stats_slot(const csdb::Pool& pool);
};
}  // namespace api

bool is_deploy_transaction(const csdb::Transaction& tr);
bool is_smart(const csdb::Transaction& tr);
bool is_smart_state(const csdb::Transaction& tr);
bool is_smart_deploy(const api::SmartContractInvocation& smart);

#endif  // APIHANDLER_HPP
```
# ..\node\api\include\csstats.hpp 
```cpp 
#ifndef CSSTATS_HPP
#define CSSTATS_HPP

#include <atomic>
#include <csnode/blockchain.hpp>
#include <cstdint>
#include <deque>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

#define NO_STATS_TEST
#define NO_FAST_UPDATE
#define LOG_STATS_TO_FILE

namespace csstats {

using period_t = std::chrono::seconds::rep;

using Period = period_t;
using Periods = std::vector<period_t>;

using Count = uint32_t;

using Integral = int32_t;
using Fraction = int64_t;

struct Amount {
    Integral integral = 0;
    Fraction fraction = 0;
};

using Balance = Amount;
using Currency = uint8_t;

struct TotalAmount {
    int64_t integral = 0;
    int64_t fraction = 0;
};

using BalancePerCurrency = std::unordered_map<Currency, TotalAmount>;
using TimeStamp = std::chrono::system_clock::time_point;

struct PeriodStats {
    period_t periodSec = 0;
    Count poolsCount = 0;
    Count transactionsCount = 0;
    BalancePerCurrency balancePerCurrency;
    Count smartContractsCount = 0;
    Count transactionsSmartCount = 0;
    TimeStamp timeStamp;
};

using StatsPerPeriod = std::vector<PeriodStats>;
using StatsCut = std::deque<PeriodStats>;
using AllStats = std::pair<StatsCut, StatsPerPeriod>;

enum PeriodIndex {
    Day = 0,
    Week,
    Month,
    Total,

    PeriodsCount
};

#ifdef NO_FAST_UPDATE
const uint32_t updateTimeSec = 3;
#else
const uint32_t updateTimeSec = 30;
#endif
const uint32_t secondsPerDay = 24 * 60 * 60;
const Periods collectionPeriods = {secondsPerDay, secondsPerDay * 7, secondsPerDay * 30, secondsPerDay * 365 * 100};

class csstats {
public:
    csstats(BlockChain& blockchain);

    StatsPerPeriod getStats();

    ~csstats();

	void run(const ::csstats::AllStats& allStats);

private:
    std::thread thread;

    std::mutex mutex;
    using ScopedLock = std::lock_guard<std::mutex>;
    std::atomic<bool> quit = {false};

    StatsPerPeriod currentStats;
    StatsCut statsCut;

    std::mutex currentStatsMutex;
    std::chrono::system_clock::time_point lastUpdateTime = std::chrono::system_clock::from_time_t(0);

    BlockChain& blockchain;

    StatsPerPeriod collectStats(const Periods& periods);
    //AllStats collectAllStats(const Periods& periods);

    template <class F>
    void matchPeriod(const Periods& periods, period_t period, F func);

    std::map<std::string, Currency> currencies_indexed = {{"CS", (Currency)1}};
};
}  // namespace csstats

#endif  // CSSTATS_HPP
```
# ..\node\api\include\debuglog.hpp 
```cpp 
#ifndef DEBUG_LOG_HPP
#define DEBUG_LOG_HPP

#define DEBUG_LOG

#ifdef DEBUG_LOG
#include <iostream>
#endif

#ifdef DEBUG_LOG

inline void Log() {
    std::cerr << std::endl;
}

template <typename T, typename... Args>
inline void Log(T t, Args&&... args) {
    std::cerr << t;
    Log(args...);
}

#else

template <typename... Args>
inline void Log(Args&&... args) {
}

#endif

#ifdef NDEBUG
template <typename T, typename... Args>
inline void DebugLog(T, Args&&...) {
}
#else
template <typename T, typename... Args>
inline void DebugLog(T t, Args&&... args) {
    std::cerr << t;
    Log(args...);
}
#endif

#endif  // DEBUG_LOG_HPP
```
# ..\node\api\include\stdafx.h 
```cpp 
#ifndef STDAFX_H
#define STDAFX_H

#include <cassert>
#include <mutex>

#include <boost/io/ios_state.hpp>

#include <csdb/address.hpp>
#include <csdb/amount.hpp>
#include <csdb/amount_commission.hpp>
#include <csdb/currency.hpp>
#include <csdb/pool.hpp>
#include <csdb/storage.hpp>
#include <csdb/transaction.hpp>

#if defined(_MSC_VER)
#pragma warning(push)
// 4245: 'return': conversion from 'int' to 'SOCKET', signed/unsigned mismatch
#pragma warning(disable: 4245 4706 4373)
#endif // _MSC_VER
#include <thrift/protocol/TJSONProtocol.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/THttpServer.h>
#include <thrift/transport/TBufferTransports.h>
#if defined(_MSC_VER)
#pragma warning(pop)
#endif // _MSC_VER

#include <iomanip>
#include <solver/solvercore.hpp>
#include <ContractExecutor.h>

#endif //STDAFX_H
```
# ..\node\api\include\tokens.hpp 
```cpp 
#ifndef TOKENS_HPP
#define TOKENS_HPP

#include <condition_variable>
#include <map>
#include <mutex>
#include <set>
#include <string>
#include <thread>
#include <queue>
#include <unordered_map>

#include <boost/functional/hash.hpp>
#include <csdb/address.hpp>

#include <ContractExecutor.h>

namespace api {
class APIHandler;
class SmartContractInvocation;
}

/*namespace std {
  template<>
  struct hash<csdb::Address> {
    size_t operator()(const csdb::Address& addr) const {
      const auto vec = addr.public_key();
      return boost::hash_range(vec.begin(), vec.end());
    }
  };
}*/

using TokenId = csdb::Address;
using HolderKey = csdb::Address;

enum TokenStandart {
    NotAToken = 0,
    CreditsBasic = 1,
    CreditsExtended = 2
};

struct Token {
    TokenStandart standart;
    csdb::Address owner;

    std::string name;
    std::string symbol;
    std::string totalSupply;

    uint64_t transactionsCount = 0;
    uint64_t transfersCount = 0;

    uint64_t realHoldersCount = 0;  // Non-zero balance

    struct HolderInfo {
        std::string balance = "0";
        uint64_t transfersCount = 0;
    };
    std::map<HolderKey, HolderInfo> holders;  // Including guys with zero balance
};

using TokensMap = std::unordered_map<TokenId, Token>;
using HoldersMap = std::unordered_map<HolderKey, std::set<TokenId>>;

class TokensMaster {
public:
    TokensMaster(api::APIHandler*);
    ~TokensMaster();

    void run();

    void checkNewDeploy(const csdb::Address& sc, const csdb::Address& deployer, const api::SmartContractInvocation&);

    void checkNewState(const csdb::Address& sc, const csdb::Address& initiator, const api::SmartContractInvocation&, const std::string& newState);

    void applyToInternal(const std::function<void(const TokensMap&, const HoldersMap&)>);

    static bool isTransfer(const std::string& method, const std::vector<general::Variant>& params);

    static std::pair<csdb::Address, csdb::Address> getTransferData(const csdb::Address& initiator, const std::string& method, const std::vector<general::Variant>& params);

    static std::string getAmount(const api::SmartContractInvocation&);

    static bool isZeroAmount(const std::string& str) {
        return str == "0";
    }

    static TokenStandart getTokenStandart(const std::vector<::general::MethodDescription>&);

private:
    void refreshTokenState(const csdb::Address& token, const std::string& newState);

    void initiateHolder(Token&, const csdb::Address& token, const csdb::Address& holder, bool increaseTransfers = false);

    api::APIHandler* api_;

    std::mutex cvMut_;
    std::condition_variable tokCv_;

    struct DeployTask {
        csdb::Address address;
        csdb::Address deployer;
        std::vector<general::ByteCodeObject> byteCodeObjects;
    };
    std::queue<DeployTask> deployQueue_;

    struct TokenInvocationData {
        struct Params {
            csdb::Address initiator;
            std::string method;
            std::vector<general::Variant> params;
        };

        std::string newState;
        std::list<Params> invocations;
    };
    std::map<csdb::Address, TokenInvocationData> newExecutes_;

    std::mutex dataMut_;
    TokensMap tokens_;
    HoldersMap holders_;

    std::atomic<bool> running_ = {false};
    std::thread tokThread_;
};

#endif  // TOKENS_HPP
```
# ..\node\api\include\csconnector\csconnector.hpp 
```cpp 
#ifndef CSCONNCETOR_HPP
#define CSCONNCETOR_HPP

#if defined(_MSC_VER)
#pragma warning(push)
// 4245: 'return': conversion from 'int' to 'SOCKET', signed/unsigned mismatch
#pragma warning(disable : 4245)
#endif

#include <apihandler.hpp>

#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#include <client/params.hpp>
#include <csdb/pool.hpp>
#include <solvercore.hpp>

#include <memory>
#include <thread>

namespace csconnector {

struct Config {
    int port = 9090;
#ifdef AJAX_IFACE
    int ajax_port = 8081;
#endif
    int executor_port = 9080;
    int apiexec_port = 9070;
};

class connector {
public:
    using ApiHandlerPtr = ::apache::thrift::stdcxx::shared_ptr<api::APIHandler>;
    using ApiExecHandlerPtr = ::apache::thrift::stdcxx::shared_ptr<apiexec::APIEXECHandler>;

    explicit connector(BlockChain& m_blockchain, cs::SolverCore* solver, const Config& config = Config{});
    ~connector();

    connector(const connector&) = delete;
    connector& operator=(const connector&) = delete;

    void onReadFromDB(csdb::Pool pool, bool* should_stop) {
        if (!*should_stop) {
            api_handler->update_smart_caches_slot(pool);
#ifdef MONITOR_NODE
			api_handler->collect_all_stats_slot(pool);
#endif
        }
    }

    void onStoreBlock(const csdb::Pool& pool) {
        api_handler->store_block_slot(pool);
    }

    void run();

    // interface
    ApiHandlerPtr apiHandler() const;
    ApiExecHandlerPtr apiExecHandler() const;

private:
    executor::Executor& executor_;
    ApiHandlerPtr api_handler;
    ApiExecHandlerPtr apiexec_handler;
    ::apache::thrift::stdcxx::shared_ptr<::api::APIProcessor> p_api_processor;
    ::apache::thrift::stdcxx::shared_ptr<::apiexec::APIEXECProcessor> p_apiexec_processor;
#ifdef BINARY_TCP_API
    ::apache::thrift::server::TThreadedServer server;
    std::thread thread;
    uint16_t server_port;
#endif
#ifdef AJAX_IFACE
    ::apache::thrift::server::TThreadedServer ajax_server;
    std::thread ajax_thread;
    uint16_t ajax_server_port;
#endif
#ifdef BINARY_TCP_EXECAPI
    ::apache::thrift::server::TThreadedServer exec_server;
    std::thread exec_thread;
    uint16_t exec_server_port;
#endif
};
}  // namespace csconnector

#endif  // CSCONNCETOR_HPP
```
# ..\node\api\src\apihandler.cpp 
```cpp 
#include <apihandler.hpp>

#include <csnode/conveyer.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>
#include <solver/smartcontracts.hpp>
#include <src/priv_crypto.hpp>
#include "csconnector/csconnector.hpp"
#include "stdafx.h"
#include <csnode/fee.hpp>

#include <base58.h>

constexpr csdb::user_field_id_t smart_state_idx = ~1;
using namespace api;
using namespace ::apache;

apiexec::APIEXECHandler::APIEXECHandler(BlockChain& blockchain, cs::SolverCore& solver, executor::Executor& executor, const csconnector::Config& config)
: executor_(executor)
, blockchain_(blockchain)
, solver_(solver) {
    csunused(config);
}

APIHandler::APIHandler(BlockChain& blockchain, cs::SolverCore& _solver, executor::Executor& executor, const csconnector::Config& config)
: executor_(executor)
, s_blockchain(blockchain)
, solver(_solver)
#ifdef MONITOR_NODE
, stats(blockchain)
#endif
, executorTransport_(
      new ::apache::thrift::transport::TBufferedTransport(::apache::thrift::stdcxx::make_shared<::apache::thrift::transport::TSocket>("localhost", config.executor_port)))
, tm(this) {
#ifdef MONITOR_NODE
	if (static bool firstTime = true; firstTime) {
		stats_.second.resize(::csstats::collectionPeriods.size());
		auto nowGlobal = std::chrono::system_clock::now();
		auto lastTimePoint = nowGlobal - std::chrono::seconds(::csstats::collectionPeriods[::csstats::PeriodIndex::Month]);

		for (auto time = nowGlobal; time > lastTimePoint; time -= std::chrono::seconds(::csstats::updateTimeSec)) {
			::csstats::PeriodStats cut;
			cut.timeStamp = time;
			stats_.first.push_back(cut);
		}
		firstTime = false;
	}
#endif
}

void APIHandler::run() {
    if (!s_blockchain.isGood()) {
        return;
    }

#ifdef MONITOR_NODE
    stats.run(stats_);
#endif
    tm.run();  // Run this AFTER updating all the caches for maximal efficiency

    state_updater_running.test_and_set(std::memory_order_acquire);
    state_updater = std::thread([this]() { state_updater_work_function(); });
}

APIHandler::~APIHandler() {
    state_updater_running.clear(std::memory_order_release);

    if (state_updater.joinable()) {
        state_updater.join();
    }
}

template <typename ResultType>
bool validatePagination(ResultType& _return, APIHandler& handler, int64_t offset, int64_t limit) {
    if (offset < 0 || limit <= 0 || limit > 100) {
        handler.SetResponseStatus(_return.status, APIHandlerBase::APIRequestStatusType::FAILURE);
        return false;
    }

    return true;
}

void APIHandler::state_updater_work_function() {
    try {
        auto lasthash = s_blockchain.getLastHash();
        while (state_updater_running.test_and_set(std::memory_order_acquire)) {
            if (!update_smart_caches_once(lasthash)) {
                {
                    std::unique_lock lk(dbLock_);
                    newBlockCv_.wait(lk);
                }
                lasthash = s_blockchain.getLastHash();
            }
        }
    }
    catch (std::exception& ex) {
        std::stringstream ss;
        ss << "error [" << ex.what() << "] in file'" << __FILE__ << "' line'" << __LINE__ << "'";
        cserror() << ss.str().c_str();
    }
    catch (...) {
        std::stringstream ss;
        ss << "unknown error in file'" << __FILE__ << "' line'" << __LINE__ << "'";
        cslog() << ss.str().c_str();
    }
}

void APIHandlerBase::SetResponseStatus(general::APIResponse& response, APIRequestStatusType status, const std::string& details) {
    struct APIRequestStatus {
        APIRequestStatus(uint8_t code, std::string message)
        : message(message)
        , code(code) {
        }
        std::string message;
        uint8_t code;
    };

    APIRequestStatus statuses[static_cast<size_t>(APIHandlerBase::APIRequestStatusType::MAX)] = {
        {0, "Success"},
        {1, "Failure"},
        {2, "Not Implemented"},
        {3, "Not found"},
		{4, "Transaction in progress"}
    };
    response.code = statuses[static_cast<uint8_t>(status)].code;
    response.message = statuses[static_cast<uint8_t>(status)].message + details;
}

void APIHandlerBase::SetResponseStatus(general::APIResponse& response, bool commandWasHandled) {
    SetResponseStatus(response, (commandWasHandled ? APIRequestStatusType::SUCCESS : APIRequestStatusType::NOT_IMPLEMENTED));
}

void APIHandler::WalletDataGet(WalletDataGetResult& _return, const general::Address& address) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    BlockChain::WalletData wallData{};
    BlockChain::WalletId wallId{};
    if (!s_blockchain.findWalletData(addr, wallData, wallId)) {
        SetResponseStatus(_return.status, APIRequestStatusType::NOT_FOUND);
        return;
    }
    _return.walletData.walletId = wallId;
    _return.walletData.balance.integral = wallData.balance_.integral();
    _return.walletData.balance.fraction = static_cast<decltype(_return.walletData.balance.fraction)>(wallData.balance_.fraction());
    const cs::TransactionsTail& tail = wallData.trxTail_;
    _return.walletData.lastTransactionId = tail.empty() ? 0 : tail.getLastTransactionId();

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::WalletIdGet(api::WalletIdGetResult& _return, const general::Address& address) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    BlockChain::WalletData wallData{};
    BlockChain::WalletId wallId{};
    if (!s_blockchain.findWalletData(addr, wallData, wallId)) {
        SetResponseStatus(_return.status, APIRequestStatusType::NOT_FOUND);
        return;
    }

    _return.walletId = wallId;
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::WalletTransactionsCountGet(api::WalletTransactionsCountGetResult& _return, const general::Address& address) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    BlockChain::WalletData wallData{};
    BlockChain::WalletId wallId{};
    if (!s_blockchain.findWalletData(addr, wallData, wallId)) {
        SetResponseStatus(_return.status, APIRequestStatusType::NOT_FOUND);
        return;
    }
    _return.lastTransactionInnerId = wallData.trxTail_.empty() ? 0 : wallData.trxTail_.getLastTransactionId();
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::WalletBalanceGet(api::WalletBalanceGetResult& _return, const general::Address& address) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    BlockChain::WalletData wallData{};
    BlockChain::WalletId wallId{};
    if (!s_blockchain.findWalletData(addr, wallData, wallId)) {
        SetResponseStatus(_return.status, APIRequestStatusType::NOT_FOUND);
        return;
    }
    _return.balance.integral = wallData.balance_.integral();
    _return.balance.fraction = static_cast<decltype(_return.balance.fraction)>(wallData.balance_.fraction());
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

std::string fromByteArray(const cs::Bytes& bar) {
    std::string res;
    {
        res.reserve(bar.size());
        std::transform(bar.begin(), bar.end(), std::back_inserter<std::string>(res), [](uint8_t _) { return char(_); });
    }
    return res;
}

std::string fromByteArray(const cs::PublicKey& bar) {
    std::string res;
    {
        res.reserve(bar.size());
        std::transform(bar.begin(), bar.end(), std::back_inserter<std::string>(res), [](uint8_t _) { return char(_); });
    }
    return res;
}

cs::Bytes toByteArray(const std::string& s) {
    cs::Bytes res;
    {
        res.reserve(s.size());
        std::transform(s.begin(), s.end(), std::back_inserter<decltype(res)>(res), [](uint8_t _) { return uint8_t(_); });
    }
    return res;
}

api::Amount convertAmount(const csdb::Amount& amount) {
    api::Amount result;
    result.integral = amount.integral();
    result.fraction = amount.fraction();
    assert(result.fraction >= 0);
    return result;
}

api::TransactionId convert_transaction_id(const csdb::TransactionID& trid) {
    api::TransactionId result_id;
    result_id.index = (uint32_t) trid.index();
    result_id.poolHash = fromByteArray(trid.pool_hash().to_binary());
    return result_id;
}

csdb::TransactionID convert_transaction_id(const api::TransactionId& trid) {
    return csdb::TransactionID(csdb::PoolHash::from_binary(toByteArray(trid.poolHash)), trid.index);
}

bool is_smart(const csdb::Transaction& tr) {
    using namespace cs::trx_uf;
    // deploy::Code == start::Methods == 0
    return tr.user_field(deploy::Code).type() == csdb::UserField::Type::String;
}

bool is_smart_state(const csdb::Transaction& tr) {
    using namespace cs::trx_uf;
    // test user_field[RefStart] helps filter out ancient smart contracts:
    return (tr.user_field(new_state::Value).type() == csdb::UserField::Type::String && tr.user_field(new_state::RefStart).type() == csdb::UserField::Type::String);
}

bool is_smart_deploy(const api::SmartContractInvocation& smart) {
    return smart.method.empty();
}

bool is_deploy_transaction(const csdb::Transaction& tr) {
    using namespace cs::trx_uf;
    auto uf = tr.user_field(deploy::Code);
    return uf.type() == csdb::UserField::Type::String && is_smart_deploy(deserialize<api::SmartContractInvocation>(uf.value<std::string>()));
}

APIHandler::SmartOperation APIHandler::getSmartStatus(const csdb::TransactionID tId) {
    auto sop = lockedReference(smart_operations);
    auto it = sop->find(tId);
    if (it == sop->end())
        return SmartOperation();
    return it->second;
}

template <typename SmartOp, typename TransInfo>
static void fillTransInfoWithOpData(const SmartOp& op, TransInfo& ti) {
    ti.state = (api::SmartOperationState)(uint32_t)op.state;
    if (op.stateTransaction.is_valid())
        ti.__set_stateTransaction(convert_transaction_id(op.stateTransaction));
}

api::SealedTransaction APIHandler::convertTransaction(const csdb::Transaction& transaction) {
    api::SealedTransaction result;
    const csdb::Amount amount = transaction.amount();
    csdb::Currency currency = transaction.currency();
    csdb::Address address = transaction.source();
    if (address.is_wallet_id()) {
        BlockChain::WalletData data_to_fetch_pulic_key;
        s_blockchain.findWalletData(transaction.source().wallet_id(), data_to_fetch_pulic_key);
        address = csdb::Address::from_public_key(data_to_fetch_pulic_key.address_);
    }

    csdb::Address target = transaction.target();
    if (target.is_wallet_id()) {
        BlockChain::WalletData data_to_fetch_pulic_key;
        s_blockchain.findWalletData(transaction.target().wallet_id(), data_to_fetch_pulic_key);
        target = csdb::Address::from_public_key(data_to_fetch_pulic_key.address_);
    }

    result.id = convert_transaction_id(transaction.id());
    result.__isset.id = true;
    result.__isset.trxn = true;
    result.trxn.id = transaction.innerID();
    result.trxn.amount = convertAmount(amount);
    result.trxn.currency = DEFAULT_CURRENCY;
    result.trxn.source = fromByteArray(address.public_key());
    result.trxn.target = fromByteArray(target.public_key());
    result.trxn.fee.commission = transaction.counted_fee().get_raw();

    result.trxn.timeCreation = transaction.get_time();

    if (is_smart(transaction)) {
        using namespace cs::trx_uf;
        auto sci = deserialize<api::SmartContractInvocation>(transaction.user_field(deploy::Code).value<std::string>());
        bool isToken = false;

        auto smartResult = getSmartStatus(transaction.id());
        result.trxn.__set_smartInfo(api::SmartTransInfo{});

        if (is_smart_deploy(sci)) {
            result.trxn.type = api::TransactionType::TT_SmartDeploy;
            tm.applyToInternal([&isToken, &target, &result](const TokensMap& tokens, const HoldersMap&) {
                auto it = tokens.find(target);
                if (it != tokens.end()) {
                    isToken = true;
                    api::TokenDeployTransInfo dti;
                    dti.name = it->second.name;
                    dti.code = it->second.symbol;
                    dti.standart = (api::TokenStandart)(uint32_t)it->second.standart;
                    result.trxn.smartInfo.__set_v_tokenDeploy(dti);
                }
            });

            if (isToken)
                fillTransInfoWithOpData(smartResult, result.trxn.smartInfo.v_tokenDeploy);
            else {
                result.trxn.smartInfo.__set_v_smartDeploy(SmartDeployTransInfo());
                fillTransInfoWithOpData(smartResult, result.trxn.smartInfo.v_smartDeploy);
            }
        }
        else {
            bool isTransfer = TokensMaster::isTransfer(sci.method, sci.params);
            result.trxn.type = api::TransactionType::TT_SmartExecute;
            if (isTransfer) {
                tm.applyToInternal([&isToken, &isTransfer, &target, &result](const TokensMap& tokens, const HoldersMap&) {
                    auto it = tokens.find(target);
                    if (it != tokens.end()) {
                        isToken = true;
                        api::TokenTransferTransInfo tti;
                        tti.code = it->second.symbol;
                        result.trxn.smartInfo.__set_v_tokenTransfer(tti);
                    }
                    else
                        isTransfer = false;
                });
            }

            if (isTransfer) {
                auto addrPair = TokensMaster::getTransferData(address, sci.method, sci.params);

                result.trxn.smartInfo.v_tokenTransfer.sender = fromByteArray(addrPair.first.public_key());
                result.trxn.smartInfo.v_tokenTransfer.receiver = fromByteArray(addrPair.second.public_key());
                result.trxn.smartInfo.v_tokenTransfer.amount = TokensMaster::getAmount(sci);

                if (smartResult.hasReturnValue())
                    result.trxn.smartInfo.v_tokenTransfer.__set_transferSuccess(smartResult.getReturnedBool());

                fillTransInfoWithOpData(smartResult, result.trxn.smartInfo.v_tokenTransfer);
            }
            else {
                SmartExecutionTransInfo eti;
                eti.method = sci.method;
                eti.params = sci.params;
                fillTransInfoWithOpData(smartResult, eti);

                result.trxn.smartInfo.__set_v_smartExecution(eti);
            }
        }

        result.trxn.__set_smartContract(sci);
    }
    else if (is_smart_state(transaction)) {
        result.trxn.type = api::TransactionType::TT_SmartState;
        api::SmartStateTransInfo sti;
        sti.success = !(transaction.user_field(cs::trx_uf::new_state::Value).value<std::string>().empty());
        sti.executionFee = convertAmount(transaction.user_field(cs::trx_uf::new_state::Fee).value<csdb::Amount>());
        cs::SmartContractRef scr;
        scr.from_user_field(transaction.user_field(cs::trx_uf::new_state::RefStart));
        sti.startTransaction = convert_transaction_id(scr.getTransactionID());

        auto fld = transaction.user_field(cs::trx_uf::new_state::RetVal);
        if (fld.is_valid()) {
            auto retVal = fld.value<std::string>();
            auto variant = deserialize<::general::Variant>(std::move(retVal));
            // override retValue with text message if new state is empty
            if (sti.success) {
                sti.__set_returnValue(variant);
            }
            else {
                if (variant.__isset.v_byte) {
                    // if not success and variant is of byte type there is an error code
                    variant.__set_v_string(cs::SmartContracts::get_error_message(variant.v_byte));
                }
                sti.__set_returnValue(variant);
            }
        }
        result.trxn.smartInfo.__set_v_smartState(sti);
        result.trxn.__isset.smartInfo = true;
    }
    else {
        result.trxn.type = api::TransactionType::TT_Normal;
        auto ufd = transaction.user_field(1);
        if (ufd.is_valid())
            result.trxn.__set_userFields(ufd.value<std::string>());
    }

    return result;
}

std::vector<api::SealedTransaction> APIHandler::convertTransactions(const std::vector<csdb::Transaction>& transactions) {
    std::vector<api::SealedTransaction> result;
    result.resize(transactions.size());
    /*const auto convert = std::bind(&APIHandler::convertTransaction, this, std::placeholders::_1);
    std::transform(transactions.begin(), transactions.end(), result.begin(), convert);
    for (auto& it : result) {
      auto poolHash = csdb::PoolHash::from_binary(toByteArray(it.id.poolHash));
      it.trxn.timeCreation = convertPool(poolHash).time;

      auto smartResult = getSmartStatus(it.trxn.id());
      it.trxn.__set_smartInfo(api::SmartTransInfo{});
      it.trxn.smartInfo.__set_v_smartDeploy(SmartDeployTransInfo());
      fillTransInfoWithOpData(smartResult, trxn.smartInfo.v_smartDeploy);
    }*/
    for (size_t Count = 0; Count < result.size(); Count++) {
        result[Count] = convertTransaction(transactions[Count]);
    }
    return result;
}

api::Pool APIHandler::convertPool(const csdb::Pool& pool) {
    api::Pool result;
    pool.is_valid();
    if (pool.is_valid()) {
        result.hash = fromByteArray(pool.hash().to_binary());
        result.poolNumber = pool.sequence();
        assert(result.poolNumber >= 0);
        result.prevHash = fromByteArray(pool.previous_hash().to_binary());
        result.time = pool.get_time();

        result.transactionsCount = (int32_t)pool.transactions_count();  // DO NOT EVER CREATE POOLS WITH
                                                                        // MORE THAN 2 BILLION
                                                                        // TRANSACTIONS, EVEN AT NIGHT

        const auto& wpk = pool.writer_public_key();
        result.writer = fromByteArray(cs::Bytes(wpk.begin(), wpk.end()));

        double totalFee = 0;
        const auto& transs = const_cast<csdb::Pool&>(pool).transactions();
        for (auto& t : transs)
            totalFee += t.counted_fee().to_double();

        const auto tf = csdb::Amount(totalFee);
        result.totalFee.integral = tf.integral();
        result.totalFee.fraction = tf.fraction();
    }
    return result;
}

api::Pool APIHandler::convertPool(const csdb::PoolHash& poolHash) {
    return convertPool(s_blockchain.loadBlock(poolHash));
}

std::vector<api::SealedTransaction> APIHandler::extractTransactions(const csdb::Pool& pool, int64_t limit, const int64_t offset) {
    int64_t transactionsCount = pool.transactions_count();
    assert(transactionsCount >= 0);
    std::vector<api::SealedTransaction> result;
    if (offset > transactionsCount)
        return result;  // если запрашиваемые // транзакций выходят за // пределы пула возвращаем пустой результат
    transactionsCount -= offset;  // мы можем отдать все транзакции в пуле за вычетом смещения
    if (limit > transactionsCount)
        limit = transactionsCount;  // лимит уменьшается до реального количества // транзакций которые можно отдать
    for (int64_t index = offset; index < (offset + limit); ++index) {
        result.push_back(convertTransaction(pool.transaction(index)));
    }
    return result;
}

void APIHandler::TransactionGet(TransactionGetResult& _return, const TransactionId& transactionId) {
    const csdb::PoolHash poolhash = csdb::PoolHash::from_binary(toByteArray(transactionId.poolHash));
    const csdb::TransactionID tmpTransactionId = csdb::TransactionID(poolhash, (transactionId.index));
    csdb::Transaction transaction = s_blockchain.loadTransaction(tmpTransactionId);
    _return.found = transaction.is_valid();
    if (_return.found)
        _return.transaction = convertTransaction(transaction);

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS, std::to_string(transaction.counted_fee().to_double()));
}

void APIHandler::TransactionsGet(TransactionsGetResult& _return, const general::Address& address, const int64_t _offset, const int64_t limit) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    BlockChain::Transactions transactions;
    if (limit > 0) {
        const int64_t offset = (_offset < 0) ? 0 : _offset;
        s_blockchain.getTransactions(transactions, addr, static_cast<uint64_t>(offset), static_cast<uint64_t>(limit));
    }
    _return.transactions = convertTransactions(transactions);

#ifdef MONITOR_NODE
    _return.total_trxns_count = s_blockchain.getTransactionsCount(addr);
#endif

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

api::SmartContractInvocation fetch_smart(const csdb::Transaction& tr) {
    if (tr.is_valid()) {
        const auto uf = tr.user_field(cs::trx_uf::deploy::Code);
        if (uf.is_valid()) {
            std::string data = uf.value<std::string>();
            if (!data.empty()) {
                return deserialize<api::SmartContractInvocation>(std::move(data));
            }
        }
    }
    return api::SmartContractInvocation();
}

api::SmartContract APIHandler::fetch_smart_body(const csdb::Transaction& tr) {
    using namespace cs::trx_uf;
    api::SmartContract res;
    if (!tr.is_valid())
        return res;
    const auto sci = deserialize<api::SmartContractInvocation>(tr.user_field(deploy::Code).value<std::string>());
    res.smartContractDeploy.byteCodeObjects = sci.smartContractDeploy.byteCodeObjects;
    res.smartContractDeploy.sourceCode = sci.smartContractDeploy.sourceCode;
    res.smartContractDeploy.hashState = sci.smartContractDeploy.hashState;
    res.deployer = fromByteArray(s_blockchain.getAddressByType(tr.source(), BlockChain::AddressType::PublicKey).public_key());
    res.address = fromByteArray(s_blockchain.getAddressByType(tr.target(), BlockChain::AddressType::PublicKey).public_key());

#ifdef TOKENS_CACHE
    tm.applyToInternal([&tr, &res](const TokensMap& tokens, const HoldersMap&) {
        auto it = tokens.find(tr.target());
        if (it != tokens.end())
            res.smartContractDeploy.tokenStandart = (api::TokenStandart)(uint32_t)it->second.standart;
        else
            res.smartContractDeploy.tokenStandart = TokenStandart::NotAToken;
    });
#else
    res.smartContractDeploy.tokenStandart = TokenStandart::NotAToken;
#endif

#ifdef MONITOR_NODE
    s_blockchain.applyToWallet(tr.target(), [&res](const cs::WalletsCache::WalletData& wd) { res.createTime = wd.createTime_; });
#endif
	if (tr.user_field(0).is_valid())
		res.transactionsCount = s_blockchain.getTransactionsCount(tr.target());

    auto pool = s_blockchain.loadBlock(tr.id().pool_hash());
    res.createTime = pool.get_time();

    return res;
}

template <typename T>
auto set_max_fee(T& trx, const csdb::Amount& am, int) -> decltype(trx.set_max_fee(am), void()) {
    trx.set_max_fee(am);
}

template <typename T>
void set_max_fee(T&, const csdb::Amount&, long) {
}

csdb::Transaction APIHandler::make_transaction(const Transaction& transaction) {
    csdb::Transaction send_transaction;
    const auto source = BlockChain::getAddressFromKey(transaction.source);
    const uint64_t WALLET_DENOM = csdb::Amount::AMOUNT_MAX_FRACTION;  // 1'000'000'000'000'000'000ull;
    send_transaction.set_amount(csdb::Amount(transaction.amount.integral, transaction.amount.fraction, WALLET_DENOM));
    BlockChain::WalletData wallData{};
    BlockChain::WalletId id{};

    if (!s_blockchain.findWalletData(source, wallData, id))
        return csdb::Transaction{};

    send_transaction.set_currency(csdb::Currency(1));
    send_transaction.set_source(source);
    send_transaction.set_target(BlockChain::getAddressFromKey(transaction.target));
    send_transaction.set_max_fee(csdb::AmountCommission((uint16_t)transaction.fee.commission));
    send_transaction.set_innerID(transaction.id & 0x3fffffffffff);

    // TODO Change Thrift to avoid copy
    cs::Signature signature;
    if (transaction.signature.size() == signature.size()) {
        std::copy(transaction.signature.begin(), transaction.signature.end(), signature.begin());
    }
    else {
        signature.fill(0);
    }
    send_transaction.set_signature(signature);
    return send_transaction;
}

std::string get_delimited_transaction_sighex(const csdb::Transaction& tr) {
    auto bs = fromByteArray(tr.to_byte_stream_for_sig());
    return std::string({' '}) + cs::Utils::byteStreamToHex(bs.data(), bs.length());
}

void APIHandler::dumb_transaction_flow(api::TransactionFlowResult& _return, const Transaction& transaction) {
	auto tr = make_transaction(transaction);
	if (!transaction.userFields.empty())
		tr.add_user_field(1, transaction.userFields);

	// check money
	const auto source_addr = s_blockchain.getAddressByType(tr.source(), BlockChain::AddressType::PublicKey);
	BlockChain::WalletData wallData{};
	BlockChain::WalletId wallId{};
	if (!s_blockchain.findWalletData(source_addr, wallData, wallId)) {
		_return.status.code = ERROR_CODE;
		_return.status.message = "wallet not found!";
		return;
	}

	const auto max_sum = tr.amount().to_double() + kMinFee;
	const auto balance = wallData.balance_.to_double();
	if (max_sum > balance) {
		cslog() << "API: reject transaction with insufficient balance, max_sum = " << max_sum << ", balance = " << balance;
		_return.status.code = ERROR_CODE;
		_return.status.message = "not enough money!\nmax_sum: " + std::to_string(max_sum) + "\nbalance: " + std::to_string(balance);
		return;
	}
  
	// check max fee
	if (csdb::AmountCommission countedFee; !cs::fee::estimateMaxFee(tr, countedFee)) {
		_return.status.code = ERROR_CODE;
		_return.status.message = "max fee is not enough, counted fee will be " + std::to_string(countedFee.to_double());
		return;
	}

	// check signature
	const auto byteStream = tr.to_byte_stream_for_sig();
	if (!cscrypto::verifySignature(tr.signature(), s_blockchain.getAddressByType(tr.source(), BlockChain::AddressType::PublicKey).public_key(), byteStream.data(), byteStream.size())) {
		cslog() << "API: reject transaction with wrong signature";
		_return.status.code = ERROR_CODE;
		_return.status.message = "wrong signature! ByteStream: " + cs::Utils::byteStreamToHex(fromByteArray(byteStream));
		return;
	} 

	solver.send_wallet_transaction(tr);

	//
	/*const static unsigned int WAIT_SECONDS_TIME{ 10 };
	const auto pair = std::pair(tr.source(), tr.innerID());
	auto lockRef{ lockedReference(this->trxInProgress) };
	auto& cvTrxn = (*lockRef)[pair];
	static std::mutex mt;
	std::unique_lock lock(mt);
	const auto resWait = cvTrxn.first.wait_for(lock, std::chrono::seconds(WAIT_SECONDS_TIME), [&cvflg = (cvTrxn.second = false)]{ return cvflg; });
	lockedReference(this->trxInProgress)->erase(pair);
	//

	if (!resWait) // time is over
		SetResponseStatus(_return.status, APIRequestStatusType::INPROGRESS, get_delimited_transaction_sighex(tr));
	else*/
		SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS, get_delimited_transaction_sighex(tr));
}

template <typename T>
std::enable_if<std::is_convertible<T*, ::apache::thrift::TBase*>::type, std::ostream&> operator<<(std::ostream& s, const T& t) {
    t.printTo(s);
    return s;
}

void APIHandler::smart_transaction_flow(api::TransactionFlowResult& _return, const Transaction& transaction) {
    auto input_smart = transaction.smartContract;
    auto send_transaction = make_transaction(transaction);
    const auto smart_addr = s_blockchain.getAddressByType(send_transaction.target(), BlockChain::AddressType::PublicKey);
    const bool deploy = is_smart_deploy(input_smart);

    send_transaction.add_user_field(cs::trx_uf::deploy::Code, serialize(transaction.smartContract));

    // check money
    const auto source_addr = s_blockchain.getAddressByType(send_transaction.source(), BlockChain::AddressType::PublicKey);
    BlockChain::WalletData wallData{};
    BlockChain::WalletId wallId{};
    if (!s_blockchain.findWalletData(source_addr, wallData, wallId)) {
        _return.status.code = ERROR_CODE;
        _return.status.message = "wallet not found!";
        return;
    }

    const auto max_fee = send_transaction.max_fee().to_double();
    const auto balance = wallData.balance_.to_double();
    if (max_fee > balance) {
        _return.status.code = ERROR_CODE;
        _return.status.message = "not enough money!\nmax_fee: " + std::to_string(max_fee) + "\nbalance: " + std::to_string(balance);
        return;
    }
    //
    
    // check max fee
    {
     csdb::AmountCommission countedFee;
     if (!cs::fee::estimateMaxFee(send_transaction, countedFee)) {
         _return.status.code = ERROR_CODE;
         _return.status.message = "max fee is not enough, counted fee will be " + std::to_string(countedFee.to_double());
         return;
     }
    }

  // check signature
  const auto byteStream = send_transaction.to_byte_stream_for_sig();
  if (!cscrypto::verifySignature(send_transaction.signature(), s_blockchain.getAddressByType(send_transaction.source(), BlockChain::AddressType::PublicKey).public_key(), byteStream.data(), byteStream.size())) {
    _return.status.code = ERROR_CODE;
    cslog() << "API: reject transaction with wrong signature";
    _return.status.message = "wrong signature! ByteStream: " + cs::Utils::byteStreamToHex(fromByteArray(byteStream));
    return;
  }
  //

    std::vector<general::ByteCodeObject> origin_bytecode;
    if (!deploy) {
        for (auto& it : input_smart.smartContractDeploy.byteCodeObjects) {
            it.byteCode.clear();
        }

        input_smart.smartContractDeploy.sourceCode.clear();

        decltype(auto) locked_smart_origin = lockedReference(this->smart_origin);
        auto it = locked_smart_origin->find(smart_addr);
        if (it != locked_smart_origin->end())
            origin_bytecode = fetch_smart(s_blockchain.loadTransaction(it->second)).smartContractDeploy.byteCodeObjects;
        else {
            SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
            return;
        }
    }
    else {
        csdb::Address addr = s_blockchain.getAddressByType(send_transaction.target(), BlockChain::AddressType::PublicKey);
        csdb::Address deployer = s_blockchain.getAddressByType(send_transaction.source(), BlockChain::AddressType::PublicKey);
        auto scKey = cs::SmartContracts::get_valid_smart_address(deployer, send_transaction.innerID(), input_smart.smartContractDeploy);
        if (scKey != addr) {
            _return.status.code = ERROR_CODE;
            const auto data = scKey.public_key().data();
            std::string str = EncodeBase58(data, data + cscrypto::kPublicKeySize);
            _return.status.message = "Bad smart contract address, expected " + str;
            return;
        }
    }

    auto& contract_state_entry = [this, &smart_addr]() -> decltype(auto) {
        auto smart_state(lockedReference(this->smart_state));
        return (*smart_state)[smart_addr];
    }();

    contract_state_entry.getPosition();

    if (input_smart.forgetNewState) {
        // -- prevent start transaction from flow to solver, so move it here:
        std::string contract_state;
        if (!deploy) {
            auto resWait = contract_state_entry.waitTillFront([&](SmartState& ss) {
                if (ss.state.empty())
                    return false;
                contract_state = ss.state;
                return true;
            });
			if (!resWait) { // time is over
				SetResponseStatus(_return.status, APIRequestStatusType::INPROGRESS);
				return;
			}
        }
        // --
        auto source_pk = s_blockchain.getAddressByType(send_transaction.source(), BlockChain::AddressType::PublicKey);
        auto target_pk = s_blockchain.getAddressByType(send_transaction.target(), BlockChain::AddressType::PublicKey);
        executor::ExecuteByteCodeResult api_resp;
        const std::vector<general::ByteCodeObject>& bytecode = deploy ? input_smart.smartContractDeploy.byteCodeObjects : origin_bytecode;
        if (!deploy || !input_smart.smartContractDeploy.byteCodeObjects.empty()) {
            executor_.executeByteCode(api_resp, source_pk.to_api_addr(), target_pk.to_api_addr(), bytecode, contract_state, input_smart.method, input_smart.params,
                                      MAX_EXECUTION_TIME);

            if (api_resp.status.code) {
                _return.status.code = api_resp.status.code;
                _return.status.message = api_resp.status.message;
                contract_state_entry.yield();
                return;
            }
            _return.__isset.smart_contract_result = api_resp.__isset.ret_val;
            if (_return.__isset.smart_contract_result)
                _return.__set_smart_contract_result(api_resp.ret_val);
        }

        SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
        contract_state_entry.yield();
        return;
    }

    solver.send_wallet_transaction(send_transaction);

    if (deploy) {
		auto resWait = contract_state_entry.waitTillFront([&](SmartState& ss) { return !ss.state.empty(); });
		if (!resWait) { // time is over
			SetResponseStatus(_return.status, APIRequestStatusType::INPROGRESS);
			return;
		}
    }
    else {
        std::string new_state;
        csdb::TransactionID trId;

        auto resWait = contract_state_entry.waitTillFront([&](SmartState& ss) {
            auto execTrans = s_blockchain.loadTransaction(ss.initer);
            if (execTrans.is_valid() && execTrans.signature() == send_transaction.signature()) {
                new_state = ss.lastEmpty ? std::string() : ss.state;
                trId = ss.transaction.clone();
                return true;
            }
            return false;
        });

		if (!resWait) { // time is over
			SetResponseStatus(_return.status, APIRequestStatusType::INPROGRESS);
			return;
		}

        if (new_state.empty()) {
            _return.status.code = ERROR_CODE;
            _return.status.message = "state is empty!";
            return;
        }
        else {
            auto stateTrans = s_blockchain.loadTransaction(trId);
            if (stateTrans.is_valid() && stateTrans.user_field_ids().count(cs::trx_uf::new_state::RetVal) > 0) {
                auto var_state = deserialize<::general::Variant>(stateTrans.user_field(cs::trx_uf::new_state::RetVal).value<std::string>());
                _return.__set_smart_contract_result(var_state);
            }
        }
    }
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS, get_delimited_transaction_sighex(send_transaction));
}

void APIHandler::TransactionFlow(api::TransactionFlowResult& _return, const Transaction& transaction) {
    if (!transaction.__isset.smartContract)
        dumb_transaction_flow(_return, transaction);
    else
        smart_transaction_flow(_return, transaction);

    _return.roundNum = (uint32_t) cs::Conveyer::instance().currentRoundTable().round;
}

void APIHandler::PoolListGet(api::PoolListGetResult& _return, const int64_t offset, const int64_t const_limit) {
    if (!validatePagination(_return, *this, offset, const_limit))
        return;

    uint64_t sequence = s_blockchain.getLastSequence();
    if ((uint64_t)offset > sequence)
        return;

    _return.pools.reserve(const_limit);

    csdb::PoolHash hash;
    try {
        hash = s_blockchain.getHashBySequence(sequence - offset);
    }
    catch (...) {
        return;
    }
    if (hash.is_empty()) {
        return;
    }
    PoolListGetStable(_return, fromByteArray(hash.to_binary()), const_limit);
    _return.count = uint32_t(sequence + 1);
}

void APIHandler::PoolTransactionsGet(PoolTransactionsGetResult& _return, const PoolHash& hash, const int64_t offset, const int64_t limit) {
    const csdb::PoolHash poolHash = csdb::PoolHash::from_binary(toByteArray(hash));
    csdb::Pool pool = s_blockchain.loadBlock(poolHash);

    if (pool.is_valid())
        _return.transactions = extractTransactions(pool, limit, offset);

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::PoolInfoGet(PoolInfoGetResult& _return, const PoolHash& hash, const int64_t index) {
    csunused(index);
    const csdb::PoolHash poolHash = csdb::PoolHash::from_binary(toByteArray(hash));
    csdb::Pool pool = s_blockchain.loadBlock(poolHash);
    _return.isFound = pool.is_valid();

    if (_return.isFound)
        _return.pool = convertPool(poolHash);

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::StatsGet(api::StatsGetResult& _return) {
#ifdef MONITOR_NODE
    csstats::StatsPerPeriod stats_inst = this->stats.getStats();

    for (auto& s : stats_inst) {
        api::PeriodStats ps = {};
        ps.periodDuration = s.periodSec;
        ps.poolsCount = s.poolsCount;
        ps.transactionsCount = s.transactionsCount;
        ps.smartContractsCount = s.smartContractsCount;
        ps.transactionsSmartCount = s.transactionsSmartCount;

        for (auto& t : s.balancePerCurrency) {
            api::CumulativeAmount amount;
            amount.integral = t.second.integral;
            amount.fraction = t.second.fraction;
            ps.balancePerCurrency[t.first] = amount;
        }

        _return.stats.push_back(ps);
    }
#endif
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::SmartContractGet(api::SmartContractGetResult& _return, const general::Address& address) {
    auto smartrid = [&]() -> decltype(auto) {
        auto smart_origin = lockedReference(this->smart_origin);
        auto it = smart_origin->find(BlockChain::getAddressFromKey(address));
        return it == smart_origin->end() ? csdb::TransactionID() : it->second;
    }();
    if (!smartrid.is_valid()) {
        SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
        return;
    }
    _return.smartContract = fetch_smart_body(s_blockchain.loadTransaction(smartrid));
    const csdb::Address adrs = BlockChain::getAddressFromKey(address);
    auto locked_smart_state(lockedReference(this->smart_state));
    _return.smartContract.objectState = (*locked_smart_state)[adrs].getState().state;

    SetResponseStatus(_return.status, !_return.smartContract.address.empty() ? APIRequestStatusType::SUCCESS : APIRequestStatusType::FAILURE);
    return;
}

void APIHandler::store_block_slot(const csdb::Pool&) {
    newBlockCv_.notify_all();
}

void APIHandler::collect_all_stats_slot(const csdb::Pool& pool) {
	const ::csstats::Periods periods = ::csstats::collectionPeriods;

	static unsigned int currentCutIndex = 0;
	static auto startCutTime = stats_.first[currentCutIndex].timeStamp;
	static auto endCutTime = stats_.first[currentCutIndex + 1].timeStamp;

	auto now = std::chrono::system_clock::now();
	auto poolTime_t = atoll(pool.user_field(0).value<std::string>().c_str()) / 1000;
	auto poolTime = std::chrono::system_clock::from_time_t(poolTime_t);

	using Seconds = std::chrono::seconds;
	Seconds poolAgeSec = std::chrono::duration_cast<Seconds>(now - poolTime);

	if (startCutTime <= poolTime && poolTime < endCutTime) {
		::csstats::PeriodStats& periodStats = stats_.first[currentCutIndex];
		++periodStats.poolsCount;

		size_t transactionsCount = pool.transactions_count();
		periodStats.transactionsCount += (uint32_t)transactionsCount;

		for (size_t i = 0; i < transactionsCount; ++i) {
			const auto& transaction = pool.transaction(csdb::TransactionID(pool.hash(), i));

#ifdef MONITOR_NODE
			if (is_smart(transaction) || is_smart_state(transaction))
				++periodStats.transactionsSmartCount;
#endif

			if (is_deploy_transaction(transaction))
				++periodStats.smartContractsCount;

			Currency currency = 1;

			const auto& amount = transaction.amount();

			periodStats.balancePerCurrency[currency].integral += amount.integral();
			periodStats.balancePerCurrency[currency].fraction += amount.fraction();
		}
	}
	else if ((currentCutIndex + 1) < stats_.first.size()) {
		startCutTime = stats_.first[currentCutIndex].timeStamp;
		endCutTime = stats_.first[currentCutIndex + 1].timeStamp;
		++currentCutIndex;
	}

	auto period = (csstats::Period)poolAgeSec.count();
	for (size_t periodIndex = 0; periodIndex < periods.size(); ++periodIndex) {
		if (period < periods[periodIndex]) {
			csstats::PeriodStats& periodStats = stats_.second[periodIndex];
			periodStats.poolsCount++;

			size_t transactionsCount = pool.transactions_count();
			periodStats.transactionsCount += (uint32_t)transactionsCount;

			for (size_t i = 0; i < transactionsCount; ++i) {
				const auto& transaction = pool.transaction(csdb::TransactionID(pool.hash(), i));

				if (transaction.source() == s_blockchain.getGenesisAddress())
					continue;
#ifdef MONITOR_NODE
				if (is_smart(transaction) || is_smart_state(transaction))
					++periodStats.transactionsSmartCount;
#endif

				if (is_deploy_transaction(transaction))
					++periodStats.smartContractsCount;

				//Currency currency = currencies_indexed[transaction.currency().to_string()];
				Currency currency = 1;

				const auto& amount = transaction.amount();

				periodStats.balancePerCurrency[currency].integral += amount.integral();
				periodStats.balancePerCurrency[currency].fraction += amount.fraction();
			}
		}
	}
}
//

void APIHandler::update_smart_caches_slot(const csdb::Pool& pool) {
    if (!pool.is_valid()) {
        return;
    }
    auto locked_pending_smart_transactions = lockedReference(this->pending_smart_transactions);
    locked_pending_smart_transactions->last_pull_hash = pool.hash();
    if (locked_pending_smart_transactions->last_pull_sequence < pool.sequence()) {
        locked_pending_smart_transactions->last_pull_sequence = pool.sequence();
    }
    auto& trs = pool.transactions();
    for (auto i_tr = trs.rbegin(); i_tr != trs.rend(); ++i_tr) {
        auto& tr = *i_tr;
        if (is_smart(tr) || is_smart_state(tr)) {
            locked_pending_smart_transactions->queue.push(std::make_pair(pool.sequence(), tr));
        }
    }

    if (!locked_pending_smart_transactions->queue.empty()) {
        auto elt = std::move(locked_pending_smart_transactions->queue.front());
        auto& tr = elt.second;
        locked_pending_smart_transactions->queue.pop();
        auto address = s_blockchain.getAddressByType(tr.target(), BlockChain::AddressType::PublicKey);

        auto source_pk = s_blockchain.getAddressByType(tr.source(), BlockChain::AddressType::PublicKey);
        auto target_pk = s_blockchain.getAddressByType(tr.target(), BlockChain::AddressType::PublicKey);

        if (is_smart_state(tr)) {
            cs::SmartContractRef scr;
            scr.from_user_field(tr.user_field(cs::trx_uf::new_state::RefStart));
            csdb::TransactionID trId(scr.hash, scr.transaction);

            std::string newState;
            auto locked_smart_state(lockedReference(this->smart_state));
            (*locked_smart_state)[address].updateState([&](const SmartState& oldState) {
                newState = tr.user_field(smart_state_idx).value<std::string>();
                return SmartState{newState.empty() ? oldState.state : newState, newState.empty(), tr.id().clone(), trId.clone()};
            });

            auto execTrans = s_blockchain.loadTransaction(trId);
            if (execTrans.is_valid() && is_smart(execTrans)) {
                const auto smart = fetch_smart(execTrans);

                {
                    auto retVal = tr.user_field(cs::trx_uf::new_state::RetVal).value<std::string>();
                    ::general::Variant val;
                    if (!retVal.empty())
                        val = deserialize<::general::Variant>(std::move(retVal));

                    auto opers = lockedReference(this->smart_operations);
                    auto& op = (*opers)[trId];
                    op.state = newState.empty() ? SmartOperation::State::Failed : SmartOperation::State::Success;
                    op.stateTransaction = tr.id();

                    if (!retVal.empty()) {
                        op.hasRetval = true;
                        if (val.__isset.v_boolean || val.__isset.v_boolean_box) {
                            op.returnsBool = true;
                            op.boolResult = val.__isset.v_boolean ? val.v_boolean : val.v_boolean_box;
                        }
                    }
                }

                auto caller_pk = s_blockchain.getAddressByType(execTrans.source(), BlockChain::AddressType::PublicKey);

                if (is_smart_deploy(smart))
                    tm.checkNewDeploy(target_pk, caller_pk, smart);

                newState = tr.user_field(smart_state_idx).value<std::string>();
                if (!newState.empty()) {
                    tm.checkNewState(target_pk, caller_pk, smart, newState);
                }
            }
        }
        else {
            const auto smart = fetch_smart(tr);

            {
                auto opers = lockedReference(this->smart_operations);
                (*opers)[tr.id()];

                auto sp = lockedReference(this->smarts_pending);
                (*sp)[elt.first].push_back(tr.id());
            }

            if (is_smart_deploy(smart)) {
                {
                    if (!smart.smartContractDeploy.byteCodeObjects.empty()) {
                        auto locked_smart_origin = lockedReference(this->smart_origin);
                        (*locked_smart_origin)[address] = tr.id().clone();

                        executor_.updateDeployTrxns(address, tr.id().clone());
                    }
                }
                {
                    auto locked_deployed_by_creator = lockedReference(this->deployed_by_creator);
                    (*locked_deployed_by_creator)[source_pk].push_back(tr.id().clone());
                }
            }
        }
    }
    else {
        auto sp = lockedReference(this->smarts_pending);
        auto so = lockedReference(this->smart_operations);
        for (auto it = sp->begin(); it != sp->end(); it = sp->erase(it)) {
            if ((it->first + Consensus::MaxRoundsCancelContract) > locked_pending_smart_transactions->last_pull_sequence)
                break;

            for (auto& sm : it->second) {
                auto& oper = (*so)[sm];
                if (oper.state == SmartOperation::State::Pending)
                    oper.state = SmartOperation::State::Failed;
            }
        }
    }
}

bool APIHandler::update_smart_caches_once(const csdb::PoolHash& start, bool init) {
    auto locked_pending_smart_transactions = lockedReference(this->pending_smart_transactions);
    std::vector<csdb::PoolHash> new_blocks;
    auto curph = start;

    static bool log_to_console = true;
    size_t cnt = 0;

    if (log_to_console) {
        std::cout << "API: analizing blockchain...\n";
    }
    while (curph != locked_pending_smart_transactions->last_pull_hash) {
        ++cnt;
        new_blocks.push_back(curph);
        size_t res;
        auto p = s_blockchain.loadBlockMeta(curph, res);
        curph = p.previous_hash();
        if (log_to_console && (cnt % 1000) == 0) {
            std::cout << '\r' << WithDelimiters(cnt);
        }

        if (p.is_valid() && locked_pending_smart_transactions->last_pull_sequence < p.sequence())
            locked_pending_smart_transactions->last_pull_sequence = p.sequence();

        if (curph.is_empty()) {
            if (log_to_console) {
                std::cout << '\r' << WithDelimiters(cnt) << "... Done\n";
            }
            break;
        }
    }

    if (curph.is_empty() && !locked_pending_smart_transactions->last_pull_hash.is_empty()) {
        // Fork detected!
        cnt = 0;
        if (log_to_console) {
            std::cout << "API: fork detected, handling " << WithDelimiters(new_blocks.size()) << " hashes...\n";
        }
        auto luca = locked_pending_smart_transactions->last_pull_hash;
        while (!luca.is_empty()) {
            ++cnt;
            auto fIt = std::find(new_blocks.begin(), new_blocks.end(), luca);
            if (fIt != new_blocks.end()) {
                new_blocks.erase(fIt, new_blocks.end());
                break;
            }
            if (log_to_console && (cnt % 100) == 0) {
                std::cout << '\r' << WithDelimiters(cnt);
            }
            size_t res;
            luca = s_blockchain.loadBlockMeta(luca, res).previous_hash();
        }
        if (log_to_console) {
            std::cout << '\r' << WithDelimiters(cnt) << "... Done\n";
        }
    }

    locked_pending_smart_transactions->last_pull_hash = start;

    cnt = 0;
    if (log_to_console) {
        std::cout << "API: searching for smart states in " << WithDelimiters(new_blocks.size()) << " blocks...\n";
    }
    while (!new_blocks.empty()) {
        ++cnt;
        auto p = s_blockchain.loadBlock(new_blocks.back());
        new_blocks.pop_back();
        auto& trs = p.transactions();
        for (auto i_tr = trs.rbegin(); i_tr != trs.rend(); ++i_tr) {
            auto& tr = *i_tr;
			if (is_smart(tr) || is_smart_state(tr)) {
				locked_pending_smart_transactions->queue.push(std::make_pair(p.sequence(), tr));
			}
			/*else { // simple transactions
				auto lockRef{ lockedReference(this->trxInProgress) };
				if (auto it = lockRef->find(std::pair(tr.source(), tr.innerID())); it != lockRef->end()) {
					(it->second).second = true;
					(it->second).first.notify_all();
				}
			}*/
        }
        if (log_to_console && (cnt % 1000) == 0)
            std::cout << '\r' << WithDelimiters(cnt);
    }
    if (log_to_console) {
        std::cout << "\rDone, handled " << WithDelimiters(cnt) << " blocks...\n";
    }
    log_to_console = false;

    if (!locked_pending_smart_transactions->queue.empty()) {
        auto elt = std::move(locked_pending_smart_transactions->queue.front());
        auto& tr = elt.second;
        locked_pending_smart_transactions->queue.pop();
        auto address = s_blockchain.getAddressByType(tr.target(), BlockChain::AddressType::PublicKey);

        auto source_pk = s_blockchain.getAddressByType(tr.source(), BlockChain::AddressType::PublicKey);
        auto target_pk = s_blockchain.getAddressByType(tr.target(), BlockChain::AddressType::PublicKey);

        if (is_smart_state(tr)) {
            cs::SmartContractRef scr;
            scr.from_user_field(tr.user_field(cs::trx_uf::new_state::RefStart));
            csdb::TransactionID trId(scr.hash, scr.transaction);

            std::string newState;
            auto locked_smart_state(lockedReference(this->smart_state));
            (*locked_smart_state)[address].updateState([&](const SmartState& oldState) {
                newState = tr.user_field(smart_state_idx).value<std::string>();
                return SmartState{newState.empty() ? oldState.state : newState, newState.empty(), tr.id().clone(), trId.clone()};
            });

            auto execTrans = s_blockchain.loadTransaction(trId);

            if ((execTrans.is_valid() && is_smart(execTrans)) || 
					execTrans.amount().to_double()) { // payable
                const auto smart = fetch_smart(execTrans);

                {
                    auto retVal = tr.user_field(cs::trx_uf::new_state::RetVal).value<std::string>();
                    ::general::Variant val;
                    if (!retVal.empty())
                        val = deserialize<::general::Variant>(std::move(retVal));

                    auto opers = lockedReference(this->smart_operations);
                    auto& op = (*opers)[trId];
                    op.state = newState.empty() ? SmartOperation::State::Failed : SmartOperation::State::Success;
                    op.stateTransaction = tr.id();

                    if (!retVal.empty()) {
                        op.hasRetval = true;
                        if (val.__isset.v_boolean || val.__isset.v_boolean_box) {
                            op.returnsBool = true;
                            op.boolResult = val.__isset.v_boolean ? val.v_boolean : val.v_boolean_box;
                        }
                    }
                }

                auto caller_pk = s_blockchain.getAddressByType(execTrans.source(), BlockChain::AddressType::PublicKey);

                if (is_smart_deploy(smart))
                    tm.checkNewDeploy(target_pk, caller_pk, smart);

                newState = tr.user_field(smart_state_idx).value<std::string>();
                if (!newState.empty())
                    tm.checkNewState(target_pk, caller_pk, smart, newState);
            }
        }
        else {
            const auto smart = fetch_smart(tr);
            if (!init) {
                auto& e = [&]() -> decltype(auto) {
                    auto smart_last_trxn = lockedReference(this->smart_last_trxn);
                    return (*smart_last_trxn)[address];
                }();
                std::unique_lock<decltype(e.lock)> l(e.lock);
                e.trid_queue.push_back(tr.id().clone());
                e.new_trxn_cv.notify_all();
            }

            {
                auto opers = lockedReference(this->smart_operations);
                (*opers)[tr.id()];

                auto sp = lockedReference(this->smarts_pending);
                (*sp)[elt.first].push_back(tr.id());
            }

            if (is_smart_deploy(smart)) {
                {
                    if (!smart.smartContractDeploy.byteCodeObjects.empty()) {
                        auto locked_smart_origin = lockedReference(this->smart_origin);
                        (*locked_smart_origin)[address] = tr.id().clone();

                        executor_.updateDeployTrxns(address, tr.id().clone());
                    }
                }
                {
                    auto locked_deployed_by_creator = lockedReference(this->deployed_by_creator);
                    (*locked_deployed_by_creator)[source_pk].push_back(tr.id().clone());
                }
            }

            return true;
        }
    }
    else {
        auto sp = lockedReference(this->smarts_pending);
        auto so = lockedReference(this->smart_operations);
        for (auto it = sp->begin(); it != sp->end(); it = sp->erase(it)) {
            if ((it->first + Consensus::MaxRoundsCancelContract) > locked_pending_smart_transactions->last_pull_sequence)
                break;

            for (auto& sm : it->second) {
                auto& oper = (*so)[sm];
                if (oper.state == SmartOperation::State::Pending)
                    oper.state = SmartOperation::State::Failed;
            }
        }
    }

    return false;
}

template <typename Mapper>
size_t APIHandler::getMappedDeployerSmart(const csdb::Address& deployer, Mapper mapper, std::vector<decltype(mapper(api::SmartContract()))>& out) {
    auto locked_deployed_by_creator = lockedReference(this->deployed_by_creator);
    auto& elt = (*locked_deployed_by_creator)[deployer];
    for (auto& trid : elt) {
        auto tr = s_blockchain.loadTransaction(trid);
        auto smart = fetch_smart_body(tr);
        out.push_back(mapper(smart));
    }

    return elt.size();
}

void APIHandler::SmartContractsListGet(api::SmartContractsListGetResult& _return, const general::Address& deployer) {
    const csdb::Address addr = BlockChain::getAddressFromKey(deployer);

    _return.count = static_cast<decltype(_return.count)>(getMappedDeployerSmart(addr, [](const api::SmartContract& smart) {
        return smart;
    }, _return.smartContractsList));

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::SmartContractAddressesListGet(api::SmartContractAddressesListGetResult& _return, const general::Address& deployer) {
    const csdb::Address addr = BlockChain::getAddressFromKey(deployer);

    getMappedDeployerSmart(addr, [](const SmartContract& sc) {
        return sc.address;
    }, _return.addressesList);

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::GetLastHash(api::PoolHash& _return) {
    _return = fromByteArray(s_blockchain.getLastHash().to_binary());
    return;
}

void APIHandler::PoolListGetStable(api::PoolListGetResult& _return, const api::PoolHash& api_hash, const int64_t const_limit) {
    if (const_limit <= 0 || const_limit > 100) {
        SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
        return;
    }

    auto hash = csdb::PoolHash::from_binary(toByteArray(api_hash));
    auto limit = const_limit;

    bool limSet = false;

    while (limit && !hash.is_empty()) {
        auto cch = poolCache.find(hash);

        if (cch == poolCache.end()) {
            auto pool = s_blockchain.loadBlock(hash);
            api::Pool apiPool = convertPool(pool);
            _return.pools.push_back(apiPool);
            poolCache.insert(cch, std::make_pair(hash, apiPool));
            hash = pool.previous_hash();

            if (!limSet) {
                _return.count = uint32_t(pool.sequence() + 1);
                limSet = true;
            }
        }
        else {
            _return.pools.push_back(cch->second);
            hash = csdb::PoolHash::from_binary(toByteArray(cch->second.prevHash));

            if (!limSet) {
                _return.count = uint32_t(cch->second.poolNumber + 1);
                limSet = true;
            }
        }

        --limit;
    }
}

void APIHandler::WaitForSmartTransaction(api::TransactionId& _return, const general::Address& smart_public) {
    csdb::Address key = BlockChain::getAddressFromKey(smart_public);
    decltype(smart_last_trxn)::LockedType::iterator it;
    auto& entry = [&]() -> decltype(auto) {
        auto smart_last_trxn = lockedReference(this->smart_last_trxn);
        std::tie(it, std::ignore) = smart_last_trxn->emplace(std::piecewise_construct, std::forward_as_tuple(key), std::forward_as_tuple());
        return std::ref(it->second).get();
    }();

    {
        std::unique_lock<decltype(entry.lock)> l(entry.lock);
        ++entry.awaiter_num;
        const auto checker = [&]() {
            if (!entry.trid_queue.empty()) {
                _return = convert_transaction_id(entry.trid_queue.front());
                if (--entry.awaiter_num == 0)
                    entry.trid_queue.pop_front();
                return true;
            }
            return false;
        };
        entry.new_trxn_cv.wait(l, checker);
    }
}

void APIHandler::SmartContractsAllListGet(SmartContractsListGetResult& _return, const int64_t _offset, const int64_t _limit) {
    int64_t offset = _offset;
    int64_t limit = _limit;

    auto locked_smart_origin = lockedReference(this->smart_origin);

    _return.count = (uint32_t) locked_smart_origin->size();

    for (auto p : *locked_smart_origin) {
        if (offset) {
            --offset;
        }
        else if (limit) {
            auto trid = p.second;
            auto tr = s_blockchain.loadTransaction(trid);
            _return.smartContractsList.push_back(fetch_smart_body(tr));
            --limit;
        }
        else
            break;
    }

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void api::APIHandler::WaitForBlock(PoolHash& _return, const PoolHash& /* obsolete */) {
    std::unique_lock lk(dbLock_);
    newBlockCv_.wait(lk);
    _return = fromByteArray(s_blockchain.getLastHash().to_binary());
}

void APIHandler::TransactionsStateGet(TransactionsStateGetResult& _return, const general::Address& address, const std::vector<int64_t>& v) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    for (auto inner_id : v) {
        csdb::Transaction transactionTmp;
        BlockChain::WalletData wallData{};
        BlockChain::WalletId wallId{};
        inner_id &= 0x3fffffffffff;
        bool finish_for_idx = false;
        if (!s_blockchain.findWalletData(addr, wallData, wallId)) {
            SetResponseStatus(_return.status, APIRequestStatusType::NOT_FOUND);
            return;
        }
        auto addr_id = csdb::Address::from_wallet_id(wallId);
        if (s_blockchain.getTransaction(addr_id, inner_id, transactionTmp))  // find in blockchain
            _return.states[inner_id] = VALID;
        else {
            cs::Conveyer& conveyer = cs::Conveyer::instance();
            auto lock = conveyer.lock();
            for (decltype(auto) it : conveyer.packetQueue()) {
                const auto& transactions = it.transactions();
                for (decltype(auto) transaction : transactions) {
                    if (transaction.innerID() == inner_id) {
                        _return.states[inner_id] = INPROGRESS;
                        finish_for_idx = true;
                        break;
                    }
                }
            }
            if (!finish_for_idx) {
                decltype(auto) m_hash_tb = conveyer.transactionsPacketTable();  // find in hash table
                for (decltype(auto) it : m_hash_tb) {
                    const auto& transactions = it.second.transactions();
                    for (decltype(auto) transaction : transactions) {
                        if (transaction.innerID() == inner_id) {
                            _return.states[inner_id] = INPROGRESS;
                            finish_for_idx = true;
                            break;
                        }
                    }
                }
            }
            lock.unlock();
            if (!finish_for_idx) {                                // if hash table doesn't contain trx return true if in last 5 rounds
                if (conveyer.isMetaTransactionInvalid(inner_id))  // trx is invalid (time between del from hash table and add to blockchain)
                    _return.states[inner_id] = INVALID;
                else
                    _return.states[inner_id] = VALID;
            }
        }
    }
    _return.roundNum = (uint32_t) cs::Conveyer::instance().currentRoundTable().round;
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void api::APIHandler::SmartMethodParamsGet(SmartMethodParamsGetResult& _return, const general::Address& address, const int64_t id) {
    csdb::Transaction trx;
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    if (!s_blockchain.getTransaction(addr, id, trx)) {
        SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
        return;
    }
    _return.method = convertTransaction(trx).trxn.smartContract.method;
    _return.params = convertTransaction(trx).trxn.smartContract.params;
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::ContractAllMethodsGet(ContractAllMethodsGetResult& _return, const std::vector<general::ByteCodeObject>& byteCodeObjects) {
    executor::GetContractMethodsResult executor_ret;
    if (byteCodeObjects.empty())
        return;
    executor_.getContractMethods(executor_ret, byteCodeObjects);
    _return.code = executor_ret.status.code;
    _return.message = executor_ret.status.message;
    for (size_t Count = 0; Count < executor_ret.methods.size(); Count++) {
        _return.methods[Count].name = executor_ret.methods[Count].name;
        for (size_t SubCount = 0; SubCount < executor_ret.methods[Count].arguments.size(); SubCount++) {
            _return.methods[Count].arguments[SubCount].type = executor_ret.methods[Count].arguments[SubCount].type;
            _return.methods[Count].arguments[SubCount].name = executor_ret.methods[Count].arguments[SubCount].name;
        }
        _return.methods[Count].returnType = executor_ret.methods[Count].returnType;
    }
}

////////new
void addTokenResult(api::TokenTransfersResult& _return, const csdb::Address& token, const std::string& code, const csdb::Pool& pool, const csdb::Transaction& tr,
                    const api::SmartContractInvocation& smart, const std::pair<csdb::Address, csdb::Address>& addrPair, const BlockChain& handler) {
    api::TokenTransfer transfer;
    transfer.token = fromByteArray(token.public_key());
    transfer.code = code;
    transfer.sender = fromByteArray(addrPair.first.public_key());
    transfer.receiver = fromByteArray(addrPair.second.public_key());
    transfer.amount = TokensMaster::getAmount(smart);
    transfer.initiator = fromByteArray(handler.getAddressByType(tr.source(), BlockChain::AddressType::PublicKey).public_key());

    transfer.transaction.poolHash = fromByteArray(tr.id().pool_hash().to_binary());
    transfer.transaction.index = (uint32_t) tr.id().index();
    transfer.time = atoll(pool.user_field(0).value<std::string>().c_str());
    _return.transfers.push_back(transfer);
}

void addTokenResult(api::TokenTransactionsResult& _return, const csdb::Address& token, const std::string&, const csdb::Pool& pool, const csdb::Transaction& tr,
                    const api::SmartContractInvocation& smart, const std::pair<csdb::Address, csdb::Address>&, BlockChain& handler) {
    api::TokenTransaction trans;
    trans.token = fromByteArray(token.public_key());
    trans.transaction.poolHash = fromByteArray(tr.id().pool_hash().to_binary());
    trans.transaction.index = (uint32_t) tr.id().index();
    trans.time = atoll(pool.user_field(0).value<std::string>().c_str());
    trans.initiator = fromByteArray(handler.getAddressByType(tr.source(), BlockChain::AddressType::PublicKey).public_key());
    trans.method = smart.method;
    trans.params = smart.params;
    _return.transactions.push_back(trans);
}

void putTokenInfo(api::TokenInfo& ti, const general::Address& addr, const Token& token) {
    ti.address = addr;
    ti.code = token.symbol;
    ti.name = token.name;
    ti.totalSupply = token.totalSupply;
    ti.owner = fromByteArray(token.owner.public_key());
    ti.transfersCount = (uint32_t) token.transfersCount;
    ti.transactionsCount = (uint32_t) token.transactionsCount;
    ti.holdersCount = (uint32_t) token.realHoldersCount;
    ti.standart = (decltype(api::TokenInfo::standart))(uint32_t)(token.standart);
}

template <typename ResultType>
void tokenTransactionsInternal(ResultType& _return, APIHandler& handler, TokensMaster& tm, const general::Address& token, bool transfersOnly, bool filterByWallet, int64_t offset,
                               int64_t limit, const csdb::Address& wallet = csdb::Address()) {
    if (!validatePagination(_return, handler, offset, limit)) {
        return;
    }

    const csdb::Address addr = BlockChain::getAddressFromKey(token);
    bool tokenFound = false;
    std::string code;

    tm.applyToInternal([&addr, &tokenFound, &transfersOnly, &filterByWallet, &code, &wallet, &_return](const TokensMap& tm, const HoldersMap&) {
        auto it = tm.find(addr);
        tokenFound = !(it == tm.end());
        if (tokenFound) {
            code = it->second.symbol;
            if (transfersOnly && !filterByWallet) {
                _return.count = it->second.transfersCount;
            }
            else if (!transfersOnly) {
                _return.count = it->second.transactionsCount;
            }
            else if (transfersOnly && filterByWallet) {
                auto hIt = it->second.holders.find(wallet);
                if (hIt != it->second.holders.end()) {
                    _return.count = hIt->second.transfersCount;
                }
                else {
                    _return.count = 0;
                }
            }
        }
    });

    if (!tokenFound) {
        handler.SetResponseStatus(_return.status, APIHandlerBase::APIRequestStatusType::FAILURE);
        return;
    }

    handler.iterateOverTokenTransactions(addr, [&_return, &offset, &limit, &addr, &code, &transfersOnly, &filterByWallet, &wallet, &s_blockchain = handler.get_s_blockchain()](
                                                   const csdb::Pool& pool, const csdb::Transaction& tr) {
        auto smart = fetch_smart(tr);
        if (transfersOnly && !TokensMaster::isTransfer(smart.method, smart.params)) {
            return true;
        }

        csdb::Address addr_pk = s_blockchain.getAddressByType(tr.source(), BlockChain::AddressType::PublicKey);
        auto addrPair = TokensMaster::getTransferData(addr_pk, smart.method, smart.params);

        if (filterByWallet && addrPair.first != wallet && addrPair.second != wallet) {
            return true;
        }

        if (--offset >= 0) {
            return true;
        }

        addTokenResult(_return, addr, code, pool, tr, smart, addrPair, s_blockchain);
        return !(--limit == 0);
    });

    handler.SetResponseStatus(_return.status, APIHandlerBase::APIRequestStatusType::SUCCESS);
}

void APIHandler::iterateOverTokenTransactions(const csdb::Address& addr, const std::function<bool(const csdb::Pool&, const csdb::Transaction&)> func) {
    std::list<csdb::TransactionID> l_id;
    for (auto trIt = TransactionsIterator(s_blockchain, addr); trIt.isValid(); trIt.next()) {
        if (is_smart_state(*trIt)) {
            cs::SmartContractRef smart_ref;
            smart_ref.from_user_field(trIt->user_field(cs::trx_uf::new_state::RefStart));
            l_id.emplace_back(csdb::TransactionID(smart_ref.hash, smart_ref.transaction));
        }
        else if (is_smart(*trIt)) {
            auto it = std::find(l_id.begin(), l_id.end(), trIt->id());
            if (it != l_id.end()) {
                l_id.erase(it);
                if (!func(trIt.getPool(), *trIt)) {
                    break;
                }
            }
        }
    }
}

////////new
api::SmartContractInvocation APIHandler::getSmartContract(const csdb::Address& addr, bool& present) {
    csdb::Address abs_addr = addr;
    if (addr.is_wallet_id()) {
        abs_addr = s_blockchain.getAddressByType(addr, BlockChain::AddressType::PublicKey);
    }

    decltype(auto) locked_smart_origin = lockedReference(this->smart_origin);

    auto it = locked_smart_origin->find(abs_addr);
    if ((present = (it != locked_smart_origin->end()))) {
        return fetch_smart(s_blockchain.loadTransaction(it->second));
    }
    return api::SmartContractInvocation{};
}

std::vector<general::ByteCodeObject> APIHandler::getSmartByteCode(const csdb::Address& addr, bool& present) {
    auto invocation = getSmartContract(addr, present);
    return present ? invocation.smartContractDeploy.byteCodeObjects : std::vector<general::ByteCodeObject>{};
}

void APIHandler::SmartContractCompile(api::SmartContractCompileResult& _return, const std::string& sourceCode) {
    executor::CompileSourceCodeResult result;
    executor_.compileSourceCode(result, sourceCode);

    if (result.status.code) {
        _return.status.code = result.status.code;
        _return.status.message = result.status.message;
        return;
    }

    executor::GetContractMethodsResult methodsResult;
    if (result.byteCodeObjects.empty()) {
        return;
    }
    executor_.getContractMethods(methodsResult, result.byteCodeObjects);

    if (methodsResult.status.code) {
        _return.status.code = methodsResult.status.code;
        _return.status.message = methodsResult.status.message;
        return;
    }

    _return.ts = (api::TokenStandart)(uint32_t)TokensMaster::getTokenStandart(methodsResult.methods);
    _return.byteCodeObjects = std::move(result.byteCodeObjects);

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::SmartContractDataGet(api::SmartContractDataResult& _return, const general::Address& address) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);

    bool present = false;
    std::vector<general::ByteCodeObject> byteCode = getSmartByteCode(addr, present);
    std::string state;

    {
        auto smartStateRef = lockedReference(this->smart_state);
        auto it = smartStateRef->find(addr);

        // if (it != smartStateRef->end()) state = it->second.get_current_state().state;
        // else present = false;

        if (it != smartStateRef->end())
            state = (*smartStateRef)[addr].getState().state;
        else
            present = false;
    }

    if (!present) {
        SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
        return;
    }

    executor::GetContractMethodsResult methodsResult;
    if (byteCode.empty())
        return;
    executor_.getContractMethods(methodsResult, byteCode);

    if (methodsResult.status.code) {
        _return.status.code = methodsResult.status.code;
        _return.status.message = methodsResult.status.message;
        return;
    }

    executor::GetContractVariablesResult variablesResult;
    if (byteCode.empty())
        return;
    executor_.getContractVariables(variablesResult, byteCode, state);

    if (variablesResult.status.code) {
        _return.status.code = variablesResult.status.code;
        _return.status.message = variablesResult.status.message;
        return;
    }

    for (auto& m : methodsResult.methods) {
        api::SmartContractMethod scm;
        scm.returnType = std::move(m.returnType);
        scm.name = std::move(m.name);
        for (auto& at : m.arguments) {
            api::SmartContractMethodArgument scma;

            scma.type = at.type;
            scma.name = at.name;

            scm.arguments.push_back(scma);
        }

        _return.methods.push_back(scm);
    }

    _return.variables = variablesResult.contractVariables;
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::TokenBalancesGet(api::TokenBalancesResult& _return, const general::Address& address) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    tm.applyToInternal([&_return, &addr](const TokensMap& tokens, const HoldersMap& holders) {
        auto holderIt = holders.find(addr);
        if (holderIt != holders.end()) {
            for (const auto& tokAddr : holderIt->second) {
                auto tokenIt = tokens.find(tokAddr);
                if (tokenIt == tokens.end())
                    continue;  // This shouldn't happen

                api::TokenBalance tb;
                tb.token = fromByteArray(tokenIt->first.public_key());
                tb.code = tokenIt->second.symbol;
                tb.name = tokenIt->second.name;

                auto hi = tokenIt->second.holders.find(addr);
                if (hi != tokenIt->second.holders.end())
                    tb.balance = hi->second.balance;

                if (!TokensMaster::isZeroAmount(tb.balance))
                    _return.balances.push_back(tb);
            }
        }
    });

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::TokenTransfersGet(api::TokenTransfersResult& _return, const general::Address& token, int64_t offset, int64_t limit) {
    tokenTransactionsInternal(_return, *this, tm, token, true, false, offset, limit);
}

void APIHandler::TokenTransferGet(api::TokenTransfersResult& _return, const general::Address& token, const TransactionId& id) {
    const csdb::PoolHash poolhash = csdb::PoolHash::from_binary(toByteArray(id.poolHash));
    const csdb::TransactionID trxn_id = csdb::TransactionID(poolhash, id.index);
    const csdb::Transaction trxn = s_blockchain.loadTransaction(trxn_id);
    const csdb::Address addr = BlockChain::getAddressFromKey(token);

    std::string code{};
    tm.applyToInternal([&addr, &code](const TokensMap& tm, const HoldersMap&) {
        const auto it = tm.find(addr);
        if (it != tm.cend())
            code = it->second.symbol;
    });

    if (code.empty()) {
        SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
        return;
    }

    const auto pool = s_blockchain.loadBlock(trxn.id().pool_hash());
    const auto smart = fetch_smart(trxn);
    const auto addr_pk = s_blockchain.getAddressByType(trxn.source(), BlockChain::AddressType::PublicKey);
    const auto addrPair = TokensMaster::getTransferData(addr_pk, smart.method, smart.params);

    _return.count = 1;

    addTokenResult(_return, addr, code, pool, trxn, smart, addrPair, s_blockchain);
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

#ifdef TRANSACTIONS_INDEX
void APIHandler::TransactionsListGet(api::TransactionsGetResult& _return, int64_t offset, int64_t limit) {
    if (!validatePagination(_return, *this, offset, limit))
        return;

    _return.result = false;
    _return.total_trxns_count = (uint32_t) s_blockchain.getTransactionsCount();

    auto tPair = s_blockchain.getLastNonEmptyBlock();
    while (limit > 0 && tPair.second) {
        if (tPair.second <= offset)
            offset -= tPair.second;
        else {
            auto p = s_blockchain.loadBlock(tPair.first);
            auto it = p.transactions().rbegin() + offset;
            offset = 0;

            while (it != p.transactions().rend() && limit > 0) {
                it->set_time(p.get_time());
                _return.transactions.push_back(convertTransaction(*it));
                _return.result = true;
                ++it;
                --limit;
            }
        }

        if (limit)
            tPair = s_blockchain.getPreviousNonEmptyBlock(tPair.first);
    }

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void APIHandler::TokenTransfersListGet(api::TokenTransfersResult& _return, int64_t offset, int64_t limit) {
    if (!validatePagination(_return, *this, offset, limit))
        return;

    uint64_t totalTransfers = 0;
    std::map<csdb::Address, std::string> tokenCodes;
    std::multimap<csdb::PoolHash, csdb::Address> tokenTransPools;

    tm.applyToInternal([&totalTransfers, &tokenCodes, &tokenTransPools, this](const TokensMap& tm, const HoldersMap&) {
        for (auto& t : tm) {
            totalTransfers += t.second.transfersCount;
            tokenCodes[t.first] = t.second.symbol;
            tokenTransPools.insert(std::make_pair(s_blockchain.getLastTransaction(t.first).pool_hash(), t.first));
        }
    });

    _return.count = uint32_t(totalTransfers);

    csdb::PoolHash pooh = s_blockchain.getLastNonEmptyBlock().first;
    while (limit && !pooh.is_empty() && tokenTransPools.size()) {
        auto it = tokenTransPools.find(pooh);
        if (it != tokenTransPools.end()) {
            auto pool = s_blockchain.loadBlock(pooh);

            for (auto& t : pool.transactions()) {
                if (!is_smart(t))
                    continue;
                auto tIt = tokenCodes.find(s_blockchain.getAddressByType(t.target(), BlockChain::AddressType::PublicKey));
                if (tIt == tokenCodes.end())
                    continue;
                const auto smart = fetch_smart(t);
                if (!TokensMaster::isTransfer(smart.method, smart.params))
                    continue;
                if (--offset >= 0)
                    continue;
                csdb::Address target_pk = s_blockchain.getAddressByType(t.target(), BlockChain::AddressType::PublicKey);
                auto addrPair = TokensMaster::getTransferData(target_pk, smart.method, smart.params);
                addTokenResult(_return, target_pk, tIt->second, pool, t, smart, addrPair, s_blockchain);
                if (--limit == 0)
                    break;
            }

            do {
                const auto lPh = s_blockchain.getPreviousPoolHash(it->second, it->first);
                const auto lAddr = it->second;

                tokenTransPools.erase(it);
                if (!lPh.is_empty())
                    tokenTransPools.insert(std::make_pair(lPh, lAddr));

                it = tokenTransPools.find(pooh);
            } while (it != tokenTransPools.end());
        }

        pooh = s_blockchain.getPreviousNonEmptyBlock(pooh).first;
    }

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

#endif

void APIHandler::TokenWalletTransfersGet(api::TokenTransfersResult& _return, const general::Address& token, const general::Address& address, int64_t offset, int64_t limit) {
    const csdb::Address wallet = BlockChain::getAddressFromKey(address);
    tokenTransactionsInternal(_return, *this, tm, token, true, true, offset, limit, wallet);
}

void APIHandler::TokenTransactionsGet(api::TokenTransactionsResult& _return, const general::Address& token, int64_t offset, int64_t limit) {
    tokenTransactionsInternal(_return, *this, tm, token, false, false, offset, limit);
}

void APIHandler::TokenInfoGet(api::TokenInfoResult& _return, const general::Address& token) {
    bool found = false;

    const csdb::Address addr = BlockChain::getAddressFromKey(token);
    tm.applyToInternal([&token, &addr, &found, &_return](const TokensMap& tm, const HoldersMap&) {
        auto tIt = tm.find(addr);
        if (tIt != tm.end()) {
            found = true;
            putTokenInfo(_return.token, token, tIt->second);
        }
    });

    SetResponseStatus(_return.status, found ? APIRequestStatusType::SUCCESS : APIRequestStatusType::FAILURE);
}

template <typename MapType, typename ComparatorType, typename FuncType>
static void applyToSortedMap(const MapType& map, const ComparatorType comparator, const FuncType func) {
    std::multiset<typename MapType::const_iterator, std::function<bool(const typename MapType::const_iterator&, const typename MapType::const_iterator&)>> s(
        [comparator](const typename MapType::const_iterator& lhs, const typename MapType::const_iterator& rhs) -> bool { return comparator(*lhs, *rhs); });

    for (auto it = map.begin(); it != map.end(); ++it)
        s.insert(it);

    for (auto& elt : s) {
        if (!func(*elt))
            break;
    }
}

template <typename T, typename FieldType>
static std::function<bool(const T&, const T&)> getComparator(const FieldType field, const bool desc) {
    return [field, desc](const T& lhs, const T& rhs) { return desc ? (lhs.second.*field > rhs.second.*field) : (lhs.second.*field < rhs.second.*field); };
}

void APIHandler::TokenHoldersGet(api::TokenHoldersResult& _return, const general::Address& token, int64_t offset, int64_t limit, const TokenHoldersSortField order,
                                 const bool desc) {
    if (!validatePagination(_return, *this, offset, limit))
        return;

    bool found = false;

    using HMap = decltype(Token::holders);
    using HT = HMap::value_type;

    std::function<bool(const HT&, const HT&)> comparator;

    switch (order) {
        case TH_Balance:
            comparator = [desc](const HT& lhs, const HT& rhs) { return desc ^ (stod(lhs.second.balance) < stod(rhs.second.balance)); };
            break;
        case TH_TransfersCount:
            comparator = getComparator<HT>(&Token::HolderInfo::transfersCount, desc);
            break;
    }

    const csdb::Address addr = BlockChain::getAddressFromKey(token);
    tm.applyToInternal([&token, &addr, &found, &offset, &limit, &_return, comparator](const TokensMap& tm, const HoldersMap&) {
        auto tIt = tm.find(addr);
        if (tIt != tm.end()) {
            found = true;
            _return.count = (uint32_t) tIt->second.realHoldersCount;

            applyToSortedMap(tIt->second.holders, comparator, [&offset, &limit, &_return, &token](const HMap::value_type& t) {
                if (TokensMaster::isZeroAmount(t.second.balance))
                    return true;
                if (--offset >= 0)
                    return true;

                api::TokenHolder th;

                th.holder = fromByteArray(t.first.public_key());
                th.token = token;
                th.balance = t.second.balance;
                th.transfersCount = (uint32_t) t.second.transfersCount;

                _return.holders.push_back(th);

                if (--limit == 0)
                    return false;

                return true;
            });
        }
    });

    SetResponseStatus(_return.status, found ? APIRequestStatusType::SUCCESS : APIRequestStatusType::FAILURE);
}

void APIHandler::TokensListGet(api::TokensListResult& _return, int64_t offset, int64_t limit, const TokensListSortField order, const bool desc) {
    if (!validatePagination(_return, *this, offset, limit))
        return;

    using VT = TokensMap::value_type;
    std::function<bool(const VT&, const VT&)> comparator;

    switch (order) {
        case TL_Code:
            comparator = getComparator<VT>(&Token::symbol, desc);
            break;
        case TL_Name:
            comparator = getComparator<VT>(&Token::name, desc);
            break;
        case TL_Address:
            comparator = [desc](const VT& lhs, const VT& rhs) { return desc ^ (lhs.first < rhs.first); };
            break;
        case TL_TotalSupply:
            comparator = [desc](const VT& lhs, const VT& rhs) { return desc ^ (stod(lhs.second.totalSupply) < stod(rhs.second.totalSupply)); };
            break;
        case TL_HoldersCount:
            comparator = getComparator<VT>(&Token::realHoldersCount, desc);
            break;
        case TL_TransfersCount:
            comparator = getComparator<VT>(&Token::transfersCount, desc);
            break;
        case TL_TransactionsCount:
            comparator = getComparator<VT>(&Token::transactionsCount, desc);
            break;
    };

    tm.applyToInternal([&offset, &limit, &_return, comparator](const TokensMap& tm, const HoldersMap&) {
        _return.count = (uint32_t) tm.size();

        applyToSortedMap(tm, comparator, [&offset, &limit, &_return](const TokensMap::value_type& t) {
            if (--offset >= 0)
                return true;

            api::TokenInfo tok;
            putTokenInfo(tok, fromByteArray(t.first.public_key()), t.second);

            _return.tokens.push_back(tok);

            if (--limit == 0)
                return false;

            return true;
        });
    });

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

//////////Wallets
typedef std::list<std::pair<const cs::WalletsCache::WalletData::Address*, const cs::WalletsCache::WalletData*>> WCSortedList;
template <typename T>
void walletStep(const cs::WalletsCache::WalletData::Address* addr, const cs::WalletsCache::WalletData* wd, const uint64_t num,
                std::function<const T&(const cs::WalletsCache::WalletData&)> getter, std::function<bool(const T&, const T&)> comparator, WCSortedList& lst) {
    assert(num > 0);

    const T& val = getter(*wd);
    if (lst.size() < num || comparator(val, getter(*(lst.back().second)))) {
        // Guess why I can't use std::upper_bound in here
        // C++ is not as expressive as I've imagined it to be...
        auto it = lst.begin();
        while (it != lst.end() && !comparator(val, getter(*(it->second)))) /* <-- this looks more like Lisp, doesn't it... */
            ++it;

        lst.insert(it, std::make_pair(addr, wd));
        if (lst.size() > num)
            lst.pop_back();
    }
}

template <typename T>
void iterateOverWallets(std::function<const T&(const cs::WalletsCache::WalletData&)> getter, const uint64_t num, const bool desc, WCSortedList& lst, BlockChain& bc) {
    std::function<bool(const T&, const T&)> comparator;
    if (desc)
        comparator = std::greater<T>();
    else
        comparator = std::less<T>();

    bc.iterateOverWallets([&lst, num, getter, comparator](const cs::WalletsCache::WalletData::Address& addr, const cs::WalletsCache::WalletData& wd) {
        if (!addr.empty() && wd.balance_ >= csdb::Amount(0))
            walletStep(&addr, &wd, num, getter, comparator, lst);
        return true;
    });
}

void APIHandler::WalletsGet(WalletsGetResult& _return, int64_t _offset, int64_t _limit, int8_t _ordCol, bool _desc) {
    if (!validatePagination(_return, *this, _offset, _limit))
        return;

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);

    WCSortedList lst;
    const uint64_t num = _offset + _limit;

    if (_ordCol == 0) {  // Balance
        iterateOverWallets<csdb::Amount>([](const cs::WalletsCache::WalletData& wd) -> const csdb::Amount& { return wd.balance_; }, num, _desc, lst, s_blockchain);
    }
#ifdef MONITOR_NODE
    else if (_ordCol == 1) {  // TimeReg
        iterateOverWallets<uint64_t>([](const cs::WalletsCache::WalletData& wd) -> const uint64_t& { return wd.createTime_; }, num, _desc, lst, s_blockchain);
    }
    else {  // Tx count
        iterateOverWallets<uint64_t>([](const cs::WalletsCache::WalletData& wd) -> const uint64_t& { return wd.transNum_; }, num, _desc, lst, s_blockchain);
    }
#endif

    if (lst.size() < (uint64_t)_offset)
        return;

    auto ptr = lst.begin();
    std::advance(ptr, _offset);

    for (; ptr != lst.end(); ++ptr) {
        api::WalletInfo wi;
        const cs::Bytes addr_b((*(ptr->first)).begin(), (*(ptr->first)).end());
        wi.address = fromByteArray(addr_b);
        wi.balance.integral = ptr->second->balance_.integral();
        wi.balance.fraction = ptr->second->balance_.fraction();
#ifdef MONITOR_NODE
        wi.transactionsNumber = ptr->second->transNum_;
        wi.firstTransactionTime = ptr->second->createTime_;
#endif

        _return.wallets.push_back(wi);
    }

    _return.count = (uint32_t) s_blockchain.getWalletsCountWithBalance();
}

void APIHandler::TrustedGet(TrustedGetResult& _return, int32_t _page) {
#ifdef MONITOR_NODE
    const static uint32_t PER_PAGE = 256;
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
    _page = std::max(int32_t(0), _page);

    uint32_t offset = _page * PER_PAGE;
    uint32_t limit = PER_PAGE;
    uint32_t total = 0;

    s_blockchain.iterateOverWriters([&_return, &offset, &limit, &total](const cs::WalletsCache::WalletData::Address& addr, const cs::WalletsCache::TrustedData& wd) {
        if (addr.empty())
            return true;
        if (offset == 0) {
            if (limit > 0) {
                api::TrustedInfo wi;
                // const ::csdb::internal::byte_array addr_b(addr.begin(), addr.end());
                const cs::Bytes addr_b(addr.begin(), addr.end());
                wi.address = fromByteArray(addr_b);

                wi.timesWriter = uint32_t(wd.times);
                wi.timesTrusted = uint32_t(wd.times_trusted);
                wi.feeCollected.integral = wd.totalFee.integral();
                wi.feeCollected.fraction = wd.totalFee.fraction();

                _return.writers.push_back(wi);
                --limit;
            }
        }
        else
            --offset;

        ++total;
        return true;
    });
    _return.pages = (total / PER_PAGE) + (int)(total % PER_PAGE != 0);
#else
    ++_page;
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
#endif
}

////////new

void APIHandler::SyncStateGet(api::SyncStateResult& _return) {
    _return.lastBlock = s_blockchain.loadBlock(s_blockchain.getLastHash()).sequence();
    _return.currRound = cs::Conveyer::instance().currentRoundNumber();
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void apiexec::APIEXECHandler::GetSeed(apiexec::GetSeedResult& _return, const general::AccessID accessId) {
    const auto opt_sequence = executor_.getSequence(accessId);
    if (!opt_sequence.has_value()) {
        //_return.status.message = "AccessId isn't correct!";
        SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
        return;
    }
    const auto hash_seq = blockchain_.getHashBySequence(opt_sequence.value());
    const auto hash = ::csdb::priv::crypto::calc_hash(hash_seq.to_binary());
    std::copy(hash.begin(), hash.end(), std::inserter(_return.seed, _return.seed.end()));
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void apiexec::APIEXECHandler::SendTransaction(apiexec::SendTransactionResult& _return, const general::AccessID accessId, const api::Transaction& transaction) {
    csunused(_return);
    csunused(accessId);
    // const csdb::Address addr = BlockChain::getAddressFromKey(transaction.source);
    // BlockChain::WalletData wallData{};
    // BlockChain::WalletId wallId{};
    // if (!blockchain_.findWalletData(addr, wallData, wallId)) {
    //  SetResponseStatus(_return.status, APIRequestStatusType::NOT_FOUND);
    //  return;
    //}
    // const_cast<api::Transaction&>(transaction).id = wallData.trxTail_.empty() ? 0 : wallData.trxTail_.getLastTransactionId() + 1;
    executor_.addInnerSendTransaction(accessId, executor_.make_transaction(transaction));
}

void apiexec::APIEXECHandler::WalletIdGet(api::WalletIdGetResult& _return, const general::AccessID accessId, const general::Address& address) {
    csunused(accessId);
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    BlockChain::WalletData wallData{};
    BlockChain::WalletId wallId{};
    if (!blockchain_.findWalletData(addr, wallData, wallId)) {
        SetResponseStatus(_return.status, APIRequestStatusType::NOT_FOUND);
        return;
    }
    _return.walletId = wallId;
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void apiexec::APIEXECHandler::SmartContractGet(SmartContractGetResult& _return, const general::AccessID accessId, const general::Address& address) {
    const auto addr = BlockChain::getAddressFromKey(address);
    auto opt_transaction_id = executor_.getDeployTrxn(addr);
    if (!opt_transaction_id.has_value()) {
        SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
        return;
    }

    auto trxn = blockchain_.loadTransaction(opt_transaction_id.value());
    const auto sci = deserialize<api::SmartContractInvocation>(trxn.user_field(0).value<std::string>());
    _return.byteCodeObjects = sci.smartContractDeploy.byteCodeObjects;
    const auto opt_state = executor_.getAccessState(accessId, addr);
    if (!opt_state.has_value()) {
        SetResponseStatus(_return.status, APIRequestStatusType::FAILURE);
        return;
    }
    _return.contractState = opt_state.value();
	_return.stateCanModify = (solver_.isContractLocked(addr) && executor_.isLockSmart(address, accessId)) ? true : false;

    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}

void apiexec::APIEXECHandler::WalletBalanceGet(api::WalletBalanceGetResult& _return, const general::Address& address) {
    const csdb::Address addr = BlockChain::getAddressFromKey(address);
    BlockChain::WalletData wallData{};
    BlockChain::WalletId wallId{};
    if (!blockchain_.findWalletData(addr, wallData, wallId)) {
        SetResponseStatus(_return.status, APIRequestStatusType::NOT_FOUND);
        return;
    }
    _return.balance.integral = wallData.balance_.integral();
    _return.balance.fraction = static_cast<decltype(_return.balance.fraction)>(wallData.balance_.fraction());
    SetResponseStatus(_return.status, APIRequestStatusType::SUCCESS);
}
```
# ..\node\api\src\csconnector.cpp 
```cpp 
#include "stdafx.h"

#include <csdb/currency.hpp>
#if defined(_MSC_VER)
#pragma warning(push)
// 4245: 'return': conversion from 'int' to 'SOCKET', signed/unsigned mismatch
#pragma warning(disable : 4245)
#endif
#include <thrift/protocol/TJSONProtocol.h>
#include <thrift/transport/THttpServer.h>
#if defined(_MSC_VER)
#pragma warning(pop)
#endif  // _MSC_VER

#include "csconnector/csconnector.hpp"

namespace csconnector {

using ::apache::thrift::TProcessorFactory;

using namespace ::apache::thrift::stdcxx;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::protocol;

connector::connector(BlockChain& m_blockchain, cs::SolverCore* solver, const Config& config)
: executor_(executor::Executor::getInstance(&m_blockchain, solver, config.executor_port))
, api_handler(make_shared<api::APIHandler>(m_blockchain, *solver, executor_, config))
, apiexec_handler(make_shared<apiexec::APIEXECHandler>(m_blockchain, *solver, executor_, config))
, p_api_processor(make_shared<api::APIProcessor>(api_handler))
, p_apiexec_processor(make_shared<apiexec::APIEXECProcessor>(apiexec_handler))
#ifdef BINARY_TCP_API
, server(p_api_processor, make_shared<TServerSocket>(config.port), make_shared<TBufferedTransportFactory>(), make_shared<TBinaryProtocolFactory>())
#endif
#ifdef AJAX_IFACE
, ajax_server(p_api_processor, make_shared<TServerSocket>(config.ajax_port), make_shared<THttpServerTransportFactory>(), make_shared<TJSONProtocolFactory>())
#endif
#ifdef BINARY_TCP_EXECAPI
, exec_server(p_apiexec_processor, make_shared<TServerSocket>(config.apiexec_port), make_shared<TBufferedTransportFactory>(), make_shared<TBinaryProtocolFactory>())
#endif
{

#ifdef BINARY_TCP_EXECAPI
    exec_server_port = uint16_t(config.apiexec_port);
    cslog() << "Starting executor API on port " << config.apiexec_port;
    exec_thread = std::thread([this]() {
        try {
            exec_server.run();
        }
        catch (...) {
            cserror() << "Oh no! I'm dead :'-(";
        }
    });
#endif

#ifdef BINARY_TCP_API
    server_port = uint16_t(config.port);
#endif

#ifdef AJAX_IFACE
    ajax_server_port = uint16_t(config.ajax_port);
#endif
}

void connector::run() {

#ifdef BINARY_TCP_API
    cslog() << "Starting public API on port " << server_port;
    thread = std::thread([this]() {
        try {
            server.run();
        }
        catch (...) {
            cserror() << "Oh no! I'm dead :'-(";
        }
        });
#endif

#ifdef AJAX_IFACE
    cslog() << "Starting AJAX server on port " << ajax_server_port;
    ajax_server.setConcurrentClientLimit(AJAX_CONCURRENT_API_CLIENTS);
    ajax_thread = std::thread([this]() {
        try {
            ajax_server.run();
        }
        catch (...) {
            cserror() << "Oh no! I'm dead in AJAX :'-(";
        }
        });
#endif

    api_handler->run();
}

connector::~connector() {
#ifdef BINARY_TCP_API
    server.stop();
    if (thread.joinable()) {
        thread.join();
    }
#endif

#ifdef BINARY_TCP_EXECAPI
    exec_server.stop();
    if (exec_thread.joinable()) {
        exec_thread.join();
    }
#endif

#ifdef AJAX_IFACE
    ajax_server.stop();
    if (ajax_thread.joinable()) {
        ajax_thread.join();
    }
#endif
}

connector::ApiHandlerPtr connector::apiHandler() const {
    return api_handler;
}

connector::ApiExecHandlerPtr connector::apiExecHandler() const {
    return apiexec_handler;
}

}  // namespace csconnector
```
# ..\node\api\src\csstats.cpp 
```cpp 
#include "stdafx.h"

#include <algorithm>
#include <apihandler.hpp>
#include <cassert>
#include <client/params.hpp>
#include <csdb/currency.hpp>
#include <csstats.hpp>

namespace csstats {

template <class F>
void csstats::matchPeriod(const Periods& periods, period_t period, F func) {
    for (size_t i = 0; i < periods.size(); ++i) {
        if (period < periods[i]) {
            func(i);
        }
    }
}

StatsPerPeriod csstats::collectStats(const Periods& periods) {
    assert(std::is_sorted(std::begin(periods), std::end(periods), [](const Period& l, const Period& r) { return l < r; }));

    cstrace() << " Collecting stats: started";

    auto stats = currentStats;
    auto startTime = std::chrono::high_resolution_clock::now();
    auto blockHash = blockchain.getLastHash();

	static auto lastHash = blockHash;

    PeriodStats periodStats;
    periodStats.timeStamp = std::chrono::system_clock::now();

    {
        auto future_last_hash = blockHash;

        if (blockHash.is_empty()) {
            cserror() << "Stats: no bricks in the wall (last hash is empty)";
        }

        while (blockHash != lastHash && !blockHash.is_empty()) {
            csdb::Pool pool = blockchain.loadBlock(blockHash);
            periodStats.poolsCount++;
            std::size_t transactionsCount = pool.transactions_count();
            periodStats.transactionsCount += static_cast<uint32_t>(transactionsCount);

            for (std::size_t i = 0; i < transactionsCount; ++i) {
                const auto& transaction = pool.transaction(csdb::TransactionID(pool.hash(), i));
#ifdef MONITOR_NODE
                if (is_smart(transaction) || is_smart_state(transaction))
                    ++periodStats.transactionsSmartCount;
#endif
                if (is_deploy_transaction(transaction))
                    ++periodStats.smartContractsCount;

                Currency currency = currencies_indexed[transaction.currency().to_string()];
                const auto& amount = transaction.amount();
                periodStats.balancePerCurrency[currency].integral += amount.integral();
                periodStats.balancePerCurrency[currency].fraction += amount.fraction();
            }
            blockHash = pool.previous_hash();
        }
        lastHash = future_last_hash;
    }

    // total
    auto& total = stats[PeriodIndex::Total];
    total.poolsCount += periodStats.poolsCount;
    total.transactionsCount += periodStats.transactionsCount;
    total.smartContractsCount += periodStats.smartContractsCount;
    total.transactionsSmartCount += periodStats.transactionsSmartCount;

    for (auto& element : periodStats.balancePerCurrency) {
        total.balancePerCurrency[element.first].integral += element.second.integral;
        total.balancePerCurrency[element.first].fraction += element.second.fraction;
    }

    for (size_t i = 0; i < periods.size(); ++i) {
        assert(updateTimeSec != 0);

        std::size_t index = (periods[i] / updateTimeSec) - 1;

        try {
            auto& lastPeriodStats = statsCut.at(index);
            auto& stat = stats.at(i);

            // remove last stats
            stat.poolsCount -= lastPeriodStats.poolsCount;
            stat.smartContractsCount -= lastPeriodStats.smartContractsCount;
            stat.transactionsCount -= lastPeriodStats.transactionsCount;
            stat.transactionsSmartCount -= lastPeriodStats.transactionsSmartCount;

            for (auto& element : lastPeriodStats.balancePerCurrency) {
                stat.balancePerCurrency[element.first].integral -= element.second.integral;
                stat.balancePerCurrency[element.first].fraction -= element.second.fraction;
            }

            // add new stats
            stat.poolsCount += periodStats.poolsCount;
            stat.smartContractsCount += periodStats.smartContractsCount;
            stat.transactionsCount += periodStats.transactionsCount;
            stat.transactionsSmartCount += periodStats.transactionsSmartCount;

            for (auto& element : periodStats.balancePerCurrency) {
                stat.balancePerCurrency[element.first].integral += element.second.integral;
                stat.balancePerCurrency[element.first].fraction += element.second.fraction;
            }
        }
        catch (const std::exception& e) {
            cslog() << "STATS> " << e.what();
        }
    }

    // update cuts
    statsCut.push_front(periodStats);
    statsCut.pop_back();

    auto finishTime = std::chrono::high_resolution_clock::now();

    using Seconds = std::chrono::seconds;
    Seconds seconds = std::chrono::duration_cast<Seconds>(finishTime - startTime);

    cstrace() << "STATS> Collecting stats: finished (took " << seconds.count() << "s";
    cslog() << "STATS> Stats updated";

    return stats;
}

/*AllStats csstats::collectAllStats(const Periods& periods) {
    assert(std::is_sorted(std::begin(periods), std::end(periods), [](const Period& l, const Period& r) { return l < r; }));

    cstrace() << "STATS>  Collecting All stats: started";

    AllStats stats;
    stats.second.resize(periods.size());

    auto nowGlobal = std::chrono::system_clock::now();
    auto lastTimePoint = nowGlobal - std::chrono::seconds(collectionPeriods[PeriodIndex::Month]);

    for (auto time = nowGlobal; time > lastTimePoint; time -= std::chrono::seconds(updateTimeSec)) {
        PeriodStats cut;
        cut.timeStamp = time;

        stats.first.push_back(cut);
    }

    auto startTime = std::chrono::system_clock::now();
    auto blockHash = blockchain.getLastHash();
    unsigned int currentCutIndex = 0;
    auto startCutTime = stats.first[currentCutIndex].timeStamp;
    auto endCutTime = stats.first[currentCutIndex + 1].timeStamp;

    auto future_lastHash = blockchain.getLastHash();

    static bool log_to_console = true;
    size_t cnt = 0;
    if (log_to_console) {
        std::cout << "STATS> analizing blockchain...\n";
    }

    while (!blockHash.is_empty() && !quit) {
        const csdb::Pool pool = blockchain.loadBlock(blockHash);

        auto now = std::chrono::system_clock::now();
        auto poolTime_t = atoll(pool.user_field(0).value<std::string>().c_str()) / 1000;
        auto poolTime = std::chrono::system_clock::from_time_t(poolTime_t);

        using Seconds = std::chrono::seconds;
        Seconds poolAgeSec = std::chrono::duration_cast<Seconds>(now - poolTime);

        if (startCutTime <= poolTime && poolTime < endCutTime) {
            PeriodStats& periodStats = stats.first[currentCutIndex];
            ++periodStats.poolsCount;

            size_t transactionsCount = pool.transactions_count();
            periodStats.transactionsCount += (uint32_t)transactionsCount;

            for (size_t i = 0; i < transactionsCount; ++i) {
                const auto& transaction = pool.transaction(csdb::TransactionID(pool.hash(), i));

#ifdef MONITOR_NODE
                if (is_smart(transaction) || is_smart_state(transaction))
                    ++periodStats.transactionsSmartCount;
#endif

                if (is_deploy_transaction(transaction))
                    ++periodStats.smartContractsCount;

                Currency currency = currencies_indexed[transaction.currency().to_string()];

                const auto& amount = transaction.amount();

                periodStats.balancePerCurrency[currency].integral += amount.integral();
                periodStats.balancePerCurrency[currency].fraction += amount.fraction();
            }
        }
        else if ((currentCutIndex + 1) < stats.first.size()) {
            startCutTime = stats.first[currentCutIndex].timeStamp;
            endCutTime = stats.first[currentCutIndex + 1].timeStamp;

            ++currentCutIndex;
            continue;
        }

        matchPeriod(periods, (Period)poolAgeSec.count(), [&](size_t periodIndex) {
            PeriodStats& periodStats = stats.second[periodIndex];
            periodStats.poolsCount++;

            size_t transactionsCount = pool.transactions_count();
            periodStats.transactionsCount += (uint32_t)transactionsCount;

            for (size_t i = 0; i < transactionsCount; ++i) {
                const auto& transaction = pool.transaction(csdb::TransactionID(pool.hash(), i));

                if (transaction.source() == blockchain.getGenesisAddress())
                    continue;
#ifdef MONITOR_NODE
                if (is_smart(transaction) || is_smart_state(transaction))
                    ++periodStats.transactionsSmartCount;
#endif

                if (is_deploy_transaction(transaction))
                    ++periodStats.smartContractsCount;

                Currency currency = currencies_indexed[transaction.currency().to_string()];

                const auto& amount = transaction.amount();

                periodStats.balancePerCurrency[currency].integral += amount.integral();
                periodStats.balancePerCurrency[currency].fraction += amount.fraction();
            }
        });

        blockHash = pool.previous_hash();

        ++cnt;
        if (log_to_console && (cnt % 1000) == 0) {
            std::cout << '\r' << WithDelimiters(cnt);
        }
    }

    if (log_to_console) {
        std::cout << '\r' << WithDelimiters(cnt) << "... Done\n";
        log_to_console = false;
    }

    // lastHash = blockchain.getLastHash();
    lastHash = future_lastHash;

    auto finishTime = std::chrono::system_clock::now();
    auto milliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(finishTime - startTime);

    cstrace() << "Collecting All stats: finished (took " << milliseconds.count() << "ms)";

    return stats;
}*/

csstats::csstats(BlockChain& blockchain)
: blockchain(blockchain) {
    cstrace() << "STATS> csstats start "
              << "update interval is " << updateTimeSec << " sec";
}

void csstats::run(const ::csstats::AllStats& allStats) {
    csunused(allStats);
#ifndef STATS
    return;
#else
    ScopedLock lock(mutex);

	//lastHash = blockchain.getLastHash();

    thread = std::thread([this, allStats]() {
        cstrace() << "STATS> csstats thread started";

        currentStats = std::move(allStats.second);
        statsCut = std::move(allStats.first);

        assert(currentStats.size() == collectionPeriods.size());

        for (auto i = 0ull; i < currentStats.size(); ++i)
            currentStats[i].periodSec = collectionPeriods[i];

        while (!quit) {
            using namespace std::chrono_literals;

            if (!quit) {
                auto periods = collectionPeriods;
                periods.pop_back();

                StatsPerPeriod stats = collectStats(periods);

                for (auto& s : stats) {
                    std::stringstream ss;
                    ss << "Period " << s.periodSec << " collected ";
                    ss << s.poolsCount << " pools, " << s.transactionsCount;
                    ss << " transactions";

                    cstrace() << "STATS> " << ss.str();
#ifdef LOG_STATS_TO_FILE
                    cstrace() << "STATS> " << ss.str();

                    ss.str(std::string());

                    ss << "Blockchain size:";
                    ss << this->blockchain.getSize();

                    cstrace() << "STATS> " << ss.str();
#endif
                    for (auto& t : s.balancePerCurrency) {
                        cstrace() << "STATS> "
                                  << "'" << t.first << "' = " << std::to_string(t.second.integral) << "." << std::to_string(t.second.fraction);
                    }
                }

                {
                    ScopedLock lock(currentStatsMutex);
                    currentStats = std::move(stats);
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(updateTimeSec));
        }

        cstrace() << "STATS> csstats thread stopped";
    });

#endif
}

csstats::~csstats() {
    cstrace() << "STATS> csstats stop";

    ScopedLock lock(mutex);

    quit = true;

    if (thread.joinable()) {
        thread.join();
    }
}

StatsPerPeriod csstats::getStats() {
    ScopedLock lock(currentStatsMutex);
    return currentStats;
}
}  // namespace csstats
```
# ..\node\api\src\stdafx.cpp 
```cpp 
#include "stdafx.h"```
# ..\node\api\src\tokens.cpp 
```cpp 
#include <client/params.hpp>

#include <base58.h>

#include <cctype>
#include "apihandler.hpp"
#include "tokens.hpp"

#ifdef TOKENS_CACHE

static inline bool isStringParam(const std::string& param) {
    return param.size() >= 2 && param[0] == '"' && param.back() == '"';
}

/*static inline bool isNormalTransfer(const std::string& method,
                                    const std::vector<std::string>& params) {
  return method == "transfer" && params.size() == 2 && isStringParam(params[0]) && isStringParam(params[1]);
}*/

static inline bool isNormalTransfer(const std::string& method, const std::vector<general::Variant>& params) {
    return method == "transfer" && params.size() == 2 && params[0].__isset.v_string &&
           params[1].__isset.v_string; /*&& isStringParam(params[0].v_string) && isStringParam(params[1].v_string);*/
}

/*static inline bool isTransferFrom(const std::string& method,
                                  const std::vector<std::string>& params) {
  return method == "transferFrom" && params.size() == 3 && isStringParam(params[0]) && isStringParam(params[1]) && isStringParam(params[1]);
}*/

static inline bool isTransferFrom(const std::string& method, const std::vector<general::Variant>& params) {
    return method == "transferFrom" && params.size() == 3 && params[0].__isset.v_string && params[1].__isset.v_string &&
           params[2].__isset.v_string; /*&& isStringParam(params[0].v_string) && isStringParam(params[1].v_string) && isStringParam(params[2].v_string);*/
}

static csdb::Address tryExtractPublicKey(const std::string& str) {
    // First try to decipher
    csdb::Address result;
    std::vector<uint8_t> vc;
    bool decodeSucc = DecodeBase58(str, vc);
    if (!decodeSucc || vc.size() != cscrypto::kPublicKeySize)
        return result;

    return csdb::Address::from_public_key(vc);
}

static csdb::Address tryGetRegisterData(const std::string& method, const std::vector<general::Variant>& params) {
    if (method == "register" && params.size() == 1)
        return tryExtractPublicKey(params[0].v_string);

    return csdb::Address();
}

static inline bool isValidAmountChar(const char c) {
    return std::isdigit(c) || c == '.' || c == ',';
}

static std::string tryExtractAmount(const std::string& str) {
    if (str.size() > 256)
        return "0";

    const auto end = str.end();
    bool hasSep = false;

    uint8_t leadingZeros = 0;   // From beginning
    uint8_t trailingZeros = 0;  // After .

    bool hasNonZero = false;

    std::string result;
    for (auto cIt = str.begin(); cIt != end; ++cIt) {
        if (!isValidAmountChar(*cIt)) {
            result.clear();
            break;
        }

        if (!std::isdigit(*cIt)) {  // Found a separator
            if (hasSep) {           // double separator
                result.clear();
                break;
            }

            hasSep = true;
            hasNonZero = true;
            result.push_back('.');
        }
        else {
            if (*cIt == '0') {
                if (!hasNonZero)
                    ++leadingZeros;
                else if (hasSep)
                    ++trailingZeros;
            }
            else {
                if (!hasSep)
                    hasNonZero = true;
                else
                    trailingZeros = 0;
            }

            result.push_back(*cIt);
        }
    }

    if (result.empty())
        return "0";
    result = result.substr(leadingZeros, result.size() - leadingZeros - trailingZeros);
    if (result.empty())
        return "0";

    if (result.front() == '.')
        result.insert(result.begin(), '0');
    if (result.back() == '.')
        result.pop_back();

    return result.empty() ? "0" : result;
}

static bool javaTypesEqual(const std::string& goodType, const std::string& questionType) {
    if (goodType.size() != questionType.size())
        return false;

    for (uint32_t i = 0; i < goodType.size(); ++i) {
        if (goodType[i] != static_cast<char>(std::tolower(questionType[i])))
            return false;
    }

    return true;
}

TokenStandart TokensMaster::getTokenStandart(const std::vector<general::MethodDescription>& methods) {
    const static std::map<std::string, std::pair<std::string, std::vector<std::string>>> StandartMethods = {
        {"getName", {"java.lang.string", {}}},
        {"getSymbol", {"java.lang.string", {}}},
        {"getDecimal", {"int", {}}},
        {"setFrozen", {"boolean", {"boolean"}}},
        {"totalSupply", {"java.lang.string", {}}},
        {"balanceOf", {"java.lang.string", {"java.lang.string"}}},
        {"allowance", {"java.lang.string", {"java.lang.string", "java.lang.string"}}},
        {"transfer", {"boolean", {"java.lang.string", "java.lang.string"}}},
        {"transferFrom", {"boolean", {"java.lang.string", "java.lang.string", "java.lang.string"}}},
        {"approve", {"void", {"java.lang.string", "java.lang.string"}}},
        {"burn", {"boolean", {"java.lang.string"}}},
        {"register", {"void", {}}},
        {"buyTokens", {"boolean", {"java.lang.string"}}}};

    const static auto findPos = [](const std::string& key) { return std::distance(StandartMethods.begin(), StandartMethods.find(key)); };
    const static std::pair<size_t, size_t> extendedPositions = {findPos("register"), findPos("buyTokens")};

    std::vector<bool> gotMethods(StandartMethods.size(), false);
    for (auto& m : methods) {
        auto smIt = StandartMethods.find(m.name);

        if (smIt != StandartMethods.end()) {
            if (smIt->second.second.size() != m.arguments.size() || !javaTypesEqual(smIt->second.first, m.returnType))
                continue;

            bool argsMatch = true;
            for (uint32_t i = 0; i < m.arguments.size(); ++i) {
                if (!javaTypesEqual(smIt->second.second[i], m.arguments[i].type)) {
                    argsMatch = false;
                    break;
                }
            }

            if (argsMatch)
                gotMethods[std::distance(StandartMethods.begin(), smIt)] = true;
        }
    }

    bool canBeCredits = true;
    bool canBeCreditsExtended = true;
    for (uint8_t i = 0; i < gotMethods.size(); ++i) {
        if (!gotMethods[i]) {
            canBeCreditsExtended = false;
            if (i != extendedPositions.first && i != extendedPositions.second) {
                canBeCredits = false;
                break;
            }
        }
    }

    return canBeCreditsExtended ? TokenStandart::CreditsExtended : (canBeCredits ? TokenStandart::CreditsBasic : TokenStandart::NotAToken);
}

template <typename T>
T getVariantAs(const general::Variant&);
template <>
std::string getVariantAs(const general::Variant& var) {
    return var.v_string;
}

template <typename RetType>
void executeAndCall(api::APIHandler* p_api, const general::Address& addr, const general::Address& addr_smart, const std::vector<general::ByteCodeObject>& byteCodeObjects,
                    const std::string& state, const std::string& method, const std::vector<general::Variant>& params, const uint32_t timeout,
                    const std::function<void(const RetType&)> handler) {
    executor::ExecuteByteCodeResult result;

    if (byteCodeObjects.empty())
        return;
    p_api->getExecutor().executeByteCode(result, addr, addr_smart, byteCodeObjects, state, method, params, timeout);

    if (!result.status.code)
        handler(getVariantAs<RetType>(result.ret_val));
}

void TokensMaster::refreshTokenState(const csdb::Address& token, const std::string& newState) {
    bool present = false;
    auto byteCodeObjects = api_->getSmartByteCode(token, present);
    if (!present)
        return;

    const auto pk = token.public_key();
    general::Address addr = std::string((char*)pk.data(), pk.size());

    std::string name, symbol, totalSupply;

    if (byteCodeObjects.empty())
        return;
    csdb::Address deployer;
    {
        std::lock_guard<decltype(dataMut_)> l(dataMut_);
        deployer = tokens_[token].owner;
    }
    general::Address dpAddr = std::string((char*)deployer.public_key().data(), deployer.public_key().size());

    executeAndCall<std::string>(api_, dpAddr, addr, byteCodeObjects, newState, "getName", std::vector<general::Variant>(), 250,
                                [&name](const std::string& newName) { name = newName.substr(0, 255); });

    executeAndCall<std::string>(api_, dpAddr, addr, byteCodeObjects, newState, "getSymbol", std::vector<general::Variant>(), 250, [&symbol](const std::string& newSymb) {
        symbol.clear();

        for (uint32_t i = 0; i < newSymb.size(); ++i) {
            if (i >= 4)
                break;
            symbol.push_back((char)std::toupper(newSymb[i]));
        }
    });

    executeAndCall<std::string>(api_, dpAddr, addr, byteCodeObjects, newState, "totalSupply", std::vector<general::Variant>(), 250,
                                [&totalSupply](const std::string& newSupp) { totalSupply = tryExtractAmount(newSupp); });

    std::vector<csdb::Address> holders;

    {
        std::lock_guard<decltype(dataMut_)> l(dataMut_);
        auto& t = tokens_[token];
        t.name = name;
        t.symbol = symbol;
        t.totalSupply = totalSupply;

        holders.reserve(t.holders.size());
        for (auto& h : t.holders)
            holders.push_back(h.first);
    }

    std::vector<std::vector<general::Variant>> holderKeysParams;
    holderKeysParams.reserve(holders.size());
    for (auto& h : holders) {
        general::Variant var;
        // var.__set_v_string('"' + EncodeBase58(h.public_key()) + '"');
        auto key = h.public_key();
        var.__set_v_string(EncodeBase58(cs::Bytes(key.begin(), key.end())));
        holderKeysParams.push_back(std::vector<general::Variant>(1, var));
    }

    executor::ExecuteByteCodeMultipleResult result;
    if (byteCodeObjects.empty())
        return;

    executor::SmartContractBinary smartContractBinary;
    smartContractBinary.contractAddress = addr;
    smartContractBinary.object.byteCodeObjects = byteCodeObjects;
    smartContractBinary.object.instance = newState;
    smartContractBinary.stateCanModify = 0;

    api_->getExecutor().executeByteCodeMultiple(result, dpAddr, smartContractBinary, "balanceOf", holderKeysParams, 100);

    if (!result.status.code && (result.results.size() == holders.size())) {
        std::lock_guard<decltype(dataMut_)> l(dataMut_);
        auto& t = tokens_[token];

        for (uint32_t i = 0; i < holders.size(); ++i) {
            const auto& res = result.results[i];
            if (!res.status.code) {
                auto& oldBalance = t.holders[holders[i]].balance;
                // auto newBalance = tryExtractAmount('"' + getVariantAs<std::string>(res.ret_val) + '"');
                auto newBalance = tryExtractAmount(getVariantAs<std::string>(res.ret_val));
                if (isZeroAmount(newBalance) && !isZeroAmount(oldBalance))
                    --t.realHoldersCount;
                else if (isZeroAmount(oldBalance) && !isZeroAmount(newBalance))
                    ++t.realHoldersCount;
                oldBalance = newBalance;
            }
        }
    }
}

/* Call under data lock only */
void TokensMaster::initiateHolder(Token& token, const csdb::Address& address, const csdb::Address& holder, bool increaseTransfers /* = false*/) {
    if (increaseTransfers)
        ++token.holders[holder].transfersCount;
    else
        token.holders[holder];

    holders_[holder].insert(address);
}

TokensMaster::TokensMaster(api::APIHandler* api)
: api_(api) {
}

TokensMaster::~TokensMaster() {
    running_.store(false);

    if (tokThread_.joinable()) {
        tokCv_.notify_all();
        tokThread_.join();
    }
}

void TokensMaster::run() {
    running_.store(true);

    tokThread_ = std::thread([this]() {
        while (running_.load()) {
            std::unique_lock<std::mutex> l(cvMut_);
            while (!deployQueue_.empty()) {
                DeployTask dt = std::move(deployQueue_.front());
                deployQueue_.pop();
                l.unlock();

                executor::GetContractMethodsResult methodsResult;

                // try { api_->executor_.getOrigExecutor(); }
                // catch (...) { std::cout << "executor dosent run!" << std::endl; return; }

                if (!dt.byteCodeObjects.empty()) {
                    api_->getExecutor().getContractMethods(methodsResult, dt.byteCodeObjects);
                    if (!methodsResult.status.code) {
                        auto ts = getTokenStandart(methodsResult.methods);
                        if (ts != TokenStandart::NotAToken) {
                            Token t;
                            t.standart = ts;
                            t.owner = dt.deployer;

                            {
                                std::lock_guard<decltype(dataMut_)> lInt(dataMut_);
                                tokens_[dt.address] = t;
                            }
                        }
                    }
                }

                l.lock();
            }

            decltype(newExecutes_) executes;
            std::swap(executes, newExecutes_);
            l.unlock();

            for (auto& st : executes) {
                {
                    std::lock_guard<decltype(dataMut_)> lInt(dataMut_);
                    auto tIt = tokens_.find(st.first);
                    if (tIt == tokens_.end())
                        continue;  // Ignore if not-a-token

                    for (auto& ps : st.second.invocations) {
                        initiateHolder(tIt->second, tIt->first, ps.initiator);
                        ++tIt->second.transactionsCount;

                        if (isTransfer(ps.method, ps.params)) {
                            ++tIt->second.transfersCount;
                            auto trPair = getTransferData(ps.initiator, ps.method, ps.params);
                            if (trPair.first.is_valid())
                                initiateHolder(tIt->second, tIt->first, trPair.first, true);
                            if (trPair.second.is_valid())
                                initiateHolder(tIt->second, tIt->first, trPair.second, true);
                        }
                        else if (tIt->second.standart == TokenStandart::CreditsExtended) {
                            csdb::Address regDude = tryGetRegisterData(ps.method, ps.params);
                            if (regDude.is_valid())
                                initiateHolder(tIt->second, tIt->first, regDude);
                        }
                    }
                }

                refreshTokenState(st.first, st.second.newState);
            }

            l.lock();
            tokCv_.wait(l);
        }
    });
}

void TokensMaster::checkNewDeploy(const csdb::Address& sc, const csdb::Address& deployer, const api::SmartContractInvocation& sci) {
    DeployTask dt;
    dt.address = sc;
    dt.deployer = deployer;
    dt.byteCodeObjects = sci.smartContractDeploy.byteCodeObjects;

    TokenInvocationData tdo;

    TokenInvocationData::Params ps;
    ps.initiator = deployer;
    tdo.invocations.push_back(ps);

    {
        std::lock_guard<decltype(cvMut_)> l(cvMut_);
        /* It is important to do this under one lock */
        deployQueue_.push(dt);
    }

    tokCv_.notify_all();
}

void TokensMaster::checkNewState(const csdb::Address& sc, const csdb::Address& initiator, const api::SmartContractInvocation& sci, const std::string& newState) {
    TokenInvocationData::Params ps;
    ps.initiator = initiator;
    ps.method = sci.method;
    ps.params = sci.params;

    {
        std::lock_guard<decltype(cvMut_)> l(cvMut_);
        auto& tid = newExecutes_[sc];
        tid.newState = newState;
        tid.invocations.push_back(ps);
    }

    tokCv_.notify_all();
}

void TokensMaster::applyToInternal(const std::function<void(const TokensMap&, const HoldersMap&)> func) {
    std::lock_guard<decltype(dataMut_)> l(dataMut_);
    func(tokens_, holders_);
}

bool TokensMaster::isTransfer(const std::string& method, const std::vector<general::Variant>& params) {
    return isNormalTransfer(method, params) || isTransferFrom(method, params);
}

using AddrPair = std::pair<csdb::Address, csdb::Address>;

AddrPair TokensMaster::getTransferData(const csdb::Address& initiator, const std::string& method, const std::vector<general::Variant>& params) {
    AddrPair result;

    if (isNormalTransfer(method, params)) {
        result.first = initiator;
        result.second = tryExtractPublicKey(params[0].v_string);
    }
    else if (isTransferFrom(method, params)) {
        result.first = tryExtractPublicKey(params[0].v_string);
        result.second = tryExtractPublicKey(params[1].v_string);
    }

    return result;
}

std::string TokensMaster::getAmount(const api::SmartContractInvocation& sci) {
    if (isNormalTransfer(sci.method, sci.params))
        return tryExtractAmount(sci.params[1].v_string);
    else if (isTransferFrom(sci.method, sci.params))
        return tryExtractAmount(sci.params[2].v_string);

    return "0";
}

#else

TokensMaster::TokensMaster(api::APIHandler*) {
}
TokensMaster::~TokensMaster() {
}
void TokensMaster::run() {
}
void TokensMaster::checkNewDeploy(const csdb::Address&, const csdb::Address&, const api::SmartContractInvocation&) {
}
void TokensMaster::checkNewState(const csdb::Address&, const csdb::Address&, const api::SmartContractInvocation&, const std::string&) {
}
void TokensMaster::applyToInternal(const std::function<void(const TokensMap&, const HoldersMap&)>) {
}
bool TokensMaster::isTransfer(const std::string&, const std::vector<general::Variant>&) {
    return false;
}
std::pair<csdb::Address, csdb::Address> TokensMaster::getTransferData(const csdb::Address&, const std::string&, const std::vector<general::Variant>&) {
    return std::pair<csdb::Address, csdb::Address>();
}
std::string TokensMaster::getAmount(const api::SmartContractInvocation&) {
    return "";
}
TokenStandart TokensMaster::getTokenStandart(const std::vector<general::MethodDescription>&) {
    return TokenStandart::NotAToken;
}

/*void TokensMaster::checkNewDeploy(const csdb::Address&, const csdb::Address&, const api::SmartContractInvocation&) { }
void TokensMaster::checkNewState(const csdb::Address&, const csdb::Address&, const api::SmartContractInvocation&, const std::string&) { }
void TokensMaster::applyToInternal(const std::function<void(const TokensMap&, const HoldersMap&)>) { }
bool TokensMaster::isTransfer(const std::string&, const std::vector<general::Variant>&) { return false; }
std::pair<csdb::Address, csdb::Address> TokensMaster::getTransferData(const csdb::Address&, const std::string&, const std::vector<general::Variant>&) { return
std::pair<csdb::Address, csdb::Address>(); } std::string TokensMaster::getAmount(const api::SmartContractInvocation&) { return ""; } TokenStandart
TokensMaster::getTokenStandart(const std::vector<general::MethodDescription>& methods) { return TokenStandart::NotAToken; }
*/
#endif
```
# ..\node\api\variant_gen\variant_aux.cpp 
```cpp 
#include <general_types.h>
#include <algorithm>

namespace general {

bool operator<(const _Variant__isset& a, const _Variant__isset& b) {
    auto ta = std::tie(a.v_boolean, a.v_double, a.v_short, a.v_int, a.v_long, a.v_byte, a.v_list, a.v_map, a.v_set, a.v_string);
    decltype(ta) tb = std::tie(b.v_boolean, b.v_double, b.v_short, b.v_int, b.v_long, b.v_byte, b.v_list, b.v_map, b.v_set, b.v_string);
    return ta < tb;
}

bool Variant::operator<(const Variant& that) const {
    const Variant &a = *this, &b = that;
    if (a.__isset < b.__isset) {
        return true;
    }
    if (b.__isset < a.__isset) {
        return false;
    }
    if (a.__isset.v_boolean) {
        return a.v_boolean < b.v_boolean;
    }
    if (a.__isset.v_double) {
        return a.v_double < b.v_double;
    }
    if (a.__isset.v_short) {
        return a.v_short < b.v_short;
    }
    if (a.__isset.v_int) {
        return a.v_int < b.v_int;
    }
    if (a.__isset.v_long) {
        return a.v_long < b.v_long;
    }
    if (a.__isset.v_byte) {
        return a.v_byte < b.v_byte;
    }
    if (a.__isset.v_string) {
        return a.v_string < b.v_string;
    }
    if (a.__isset.v_list) {
        return std::lexicographical_compare(a.v_list.begin(), a.v_list.end(), b.v_list.begin(), b.v_list.end());
    }
    if (a.__isset.v_set) {
        return std::lexicographical_compare(a.v_set.begin(), a.v_set.end(), b.v_set.begin(), b.v_set.end());
    }
    if (a.__isset.v_map) {
        return std::lexicographical_compare(a.v_map.begin(), a.v_map.end(), b.v_map.begin(), b.v_map.end());
    }
    assert(false);
    return false;
}
}  // namespace general
```
# ..\node\client\include\client\config.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef CONFIG_HPP
#define CONFIG_HPP

#include <boost/asio.hpp>
#include <boost/log/utility/setup/settings.hpp>
#include <boost/program_options.hpp>
#include <string>

#include <lib/system/common.hpp>
#include <net/neighbourhood.hpp> // using Neighbourhood::MaxNeighbours constant

namespace po = boost::program_options;
namespace ip = boost::asio::ip;

typedef uint16_t NodeVersion;
const NodeVersion NODE_VERSION = 415;

const std::string DEFAULT_PATH_TO_CONFIG = "config.ini";
const std::string DEFAULT_PATH_TO_DB = "test_db";
const std::string DEFAULT_PATH_TO_KEY = "keys.dat";

const std::string DEFAULT_PATH_TO_PUBLIC_KEY = "NodePublic.txt";
const std::string DEFAULT_PATH_TO_PRIVATE_KEY = "NodePrivate.txt";

const uint32_t DEFAULT_MAX_NEIGHBOURS = Neighbourhood::MaxNeighbours;
const uint32_t DEFAULT_CONNECTION_BANDWIDTH = 1 << 19;

typedef short unsigned Port;

struct EndpointData {
    bool ipSpecified;
    short unsigned port;
    ip::address ip;

    static EndpointData fromString(const std::string&);
};

enum NodeType {
    Client,
    Router
};

enum BootstrapType {
    SignalServer,
    IpList
};

struct PoolSyncData {
    bool oneReplyBlock = true;                      // true: sendBlockRequest one pool at a time. false: equal to number of pools requested.
    bool isFastMode = false;                        // true: is silent mode synchro(sync up to the current round). false: normal mode
    uint8_t blockPoolsCount = 25;                   // max block count in one request: cannot be 0
    uint8_t requestRepeatRoundCount = 20;           // round count for repeat request : 0-never
    uint8_t neighbourPacketsCount = 10;             // packet count for connect another neighbor : 0-never
    uint16_t sequencesVerificationFrequency = 350;  // sequences received verification frequency : 0-never; 1-once per round: other- in ms;
};

struct ApiData {
    uint16_t port = 9090;
    uint16_t ajaxPort = 8081;
    uint16_t executorPort = 9080;
    uint16_t apiexecPort = 9070;
};

class Config {
public:
    Config() {
    }  // necessary for testing
    Config(const Config&) = default;
    Config(Config&&) = default;

    static Config read(po::variables_map&);

    const EndpointData& getInputEndpoint() const {
        return inputEp_;
    }
    const EndpointData& getOutputEndpoint() const {
        return outputEp_;
    }

    const EndpointData& getSignalServerEndpoint() const {
        return signalServerEp_;
    }

    BootstrapType getBootstrapType() const {
        return bType_;
    }
    NodeType getNodeType() const {
        return nType_;
    }
    const std::vector<EndpointData>& getIpList() const {
        return bList_;
    }

    const std::string& getPathToDB() const {
        return pathToDb_;
    }

    bool isGood() const {
        return good_;
    }

    bool useIPv6() const {
        return ipv6_;
    }
    bool hasTwoSockets() const {
        return twoSockets_;
    }

    uint32_t getMaxNeighbours() const {
        return maxNeighbours_;
    }
    uint64_t getConnectionBandwidth() const {
        return connectionBandwidth_;
    }

    bool isSymmetric() const {
        return symmetric_;
    }
    const EndpointData& getAddressEndpoint() const {
        return hostAddressEp_;
    }

    const boost::log::settings& getLoggerSettings() const {
        return loggerSettings_;
    }

    const PoolSyncData& getPoolSyncSettings() const {
        return poolSyncData_;
    }

    const ApiData& getApiSettings() const {
        return apiData_;
    }

    const cs::PublicKey& getMyPublicKey() const {
        return publicKey_;
    }
    const cs::PrivateKey& getMyPrivateKey() const {
        return privateKey_;
    }

    static NodeVersion getNodeVersion() {
        return NODE_VERSION;
    }

    void dumpJSONKeys(const std::string& fName) const;

private:
    static Config readFromFile(const std::string& fileName);
    void setLoggerSettings(const boost::property_tree::ptree& config);
    void readPoolSynchronizerData(const boost::property_tree::ptree& config);
    void readApiData(const boost::property_tree::ptree& config);

    bool readKeys(const std::string& pathToPk, const std::string& pathToSk, const bool encrypt);
    void showKeys(const std::string& pk58);
    
    void changePasswordOption(const std::string& pathToSk);

    template <typename T>
    bool checkAndSaveValue(const boost::property_tree::ptree& data, const std::string& block, const std::string& param, T& value);

    bool good_ = false;

    EndpointData inputEp_;

    bool twoSockets_;
    EndpointData outputEp_;

    NodeType nType_;

    bool ipv6_;
    uint32_t maxNeighbours_;
    uint64_t connectionBandwidth_;

    bool symmetric_;
    EndpointData hostAddressEp_;

    BootstrapType bType_;
    EndpointData signalServerEp_;

    std::vector<EndpointData> bList_;

    std::string pathToDb_;

    cs::PublicKey publicKey_;
    cs::PrivateKey privateKey_;

    boost::log::settings loggerSettings_;

    PoolSyncData poolSyncData_;
    ApiData apiData_;
};

#endif  // CONFIG_HPP
```
# ..\node\client\include\client\params.hpp 
```cpp 
#ifndef PARAMS_HPP
#define PARAMS_HPP

/**
 *  Please don't commit these three defines
 *  below uncommented.
 */
//#define MONITOR_NODE
//#define WEB_WALLET_NODE

#define NODE_API
#define AJAX_IFACE

#define AJAX_CONCURRENT_API_CLIENTS INT64_MAX
#define BINARY_TCP_API
#define BINARY_TCP_EXECAPI
#define DEFAULT_CURRENCY 1

#if defined(MONITOR_NODE) || defined(WEB_WALLET_NODE)
#define TRANSACTIONS_INDEX
#define TOKENS_CACHE
#endif

#ifdef MONITOR_NODE
#define STATS
#endif

// diagnostic output & compatibility checks
#if defined(_MSC_VER)

#if defined(MONITOR_NODE)

#if defined(WEB_WALLET_NODE)
#error Incompatible macros defined: MONITOR_NODE & WEB_WALLET_NODE
#endif
//#pragma message ( "*** Building monitor node" )

#elif defined(WEB_WALLET_NODE)

#if defined(MONITOR_NODE)
#error Incompatible macros defined: WEB_WALLET_NODE & MONITOR_NODE
#endif
//#pragma message ( "*** Building web wallet node" )

#else

//#pragma message ( "*** Building basic node" )

#endif

#endif  // _MSC_VER

#endif
```
# ..\node\client\include\client\stdafx.h 
```cpp 
#pragma once

#include <string>
#include <regex>
#include <stdexcept>

#include <boost/asio.hpp>
#include <boost/program_options.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/filesystem.hpp>
#include <boost/log/utility/setup/settings_parser.hpp>
#include <boost/property_tree/ini_parser.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/property_tree/xml_parser.hpp>```
# ..\node\client\src\config.cpp 
```cpp 
/* Send blaming letters to @yrtimd */
#include <iostream>
#include <regex>
#include <stdexcept>
#include <string>

#include <boost/algorithm/string.hpp>
#include <boost/asio.hpp>
#include <boost/filesystem.hpp>
#include <boost/log/utility/setup/settings_parser.hpp>
#include <boost/property_tree/ini_parser.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/property_tree/xml_parser.hpp>

#include <base58.h>

#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>

#include <cscrypto/cscrypto.hpp>
#include "config.hpp"

#ifdef _WIN32
#include <windows.h>
#include <conio.h>
#else
#include <termios.h>
#include <unistd.h>
#endif

const std::string BLOCK_NAME_PARAMS = "params";
const std::string BLOCK_NAME_SIGNAL_SERVER = "signal_server";
const std::string BLOCK_NAME_HOST_INPUT = "host_input";
const std::string BLOCK_NAME_HOST_OUTPUT = "host_output";
const std::string BLOCK_NAME_HOST_ADDRESS = "host_address";
const std::string BLOCK_NAME_POOL_SYNC = "pool_sync";
const std::string BLOCK_NAME_API = "api";

const std::string PARAM_NAME_NODE_TYPE = "node_type";
const std::string PARAM_NAME_BOOTSTRAP_TYPE = "bootstrap_type";
const std::string PARAM_NAME_HOSTS_FILENAME = "hosts_filename";
const std::string PARAM_NAME_USE_IPV6 = "ipv6";
const std::string PARAM_NAME_MAX_NEIGHBOURS = "max_neighbours";
const std::string PARAM_NAME_CONNECTION_BANDWIDTH = "connection_bandwidth";

const std::string PARAM_NAME_IP = "ip";
const std::string PARAM_NAME_PORT = "port";

const std::string PARAM_NAME_POOL_SYNC_ONE_REPLY_BLOCK = "one_reply_block";
const std::string PARAM_NAME_POOL_SYNC_FAST_MODE = "fast_mode";
const std::string PARAM_NAME_POOL_SYNC_POOLS_COUNT = "block_pools_count";
const std::string PARAM_NAME_POOL_SYNC_ROUND_COUNT = "request_repeat_round_count";
const std::string PARAM_NAME_POOL_SYNC_PACKET_COUNT = "neighbour_packets_count";
const std::string PARAM_NAME_POOL_SYNC_SEQ_VERIF_FREQ = "sequences_verification_frequency";

const std::string PARAM_NAME_API_PORT = "port";
const std::string PARAM_NAME_AJAX_PORT = "ajax_port";
const std::string PARAM_NAME_EXECUTOR_PORT = "executor_port";
const std::string PARAM_NAME_APIEXEC_PORT = "apiexec_port";

const std::string ARG_NAME_CONFIG_FILE = "config-file";
const std::string ARG_NAME_DB_PATH = "db-path";
const std::string ARG_NAME_PUBLIC_KEY_FILE = "public-key-file";
const std::string ARG_NAME_PRIVATE_KEY_FILE = "private-key-file";
const std::string ARG_NAME_ENCRYPT_KEY_FILE = "encryptkey";

const uint32_t MIN_PASSWORD_LENGTH = 3;
const uint32_t MAX_PASSWORD_LENGTH = 128;

const std::map<std::string, NodeType> NODE_TYPES_MAP = {{"client", NodeType::Client}, {"router", NodeType::Router}};
const std::map<std::string, BootstrapType> BOOTSTRAP_TYPES_MAP = {{"signal_server", BootstrapType::SignalServer}, {"list", BootstrapType::IpList}};

static EndpointData readEndpoint(const boost::property_tree::ptree& config, const std::string& propName) {
    const boost::property_tree::ptree& epTree = config.get_child(propName);

    EndpointData result;

    if (epTree.count(PARAM_NAME_IP)) {
        result.ipSpecified = true;
        result.ip = ip::make_address(epTree.get<std::string>(PARAM_NAME_IP));
    }
    else {
        result.ipSpecified = false;
    }

    result.port = epTree.get<Port>(PARAM_NAME_PORT);

    return result;
}

EndpointData EndpointData::fromString(const std::string& str) {
    static std::regex ipv4Regex("^([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})\\:([0-9]{1,5})$");
    static std::regex ipv6Regex("^\\[([0-9a-z\\:\\.]+)\\]\\:([0-9]{1,5})$");

    std::smatch match;
    EndpointData result;

    if (std::regex_match(str, match, ipv4Regex)) {
        result.ip = ip::make_address_v4(match[1]);
    }
    else if (std::regex_match(str, match, ipv6Regex)) {
        result.ip = ip::make_address_v6(match[1]);
    }
    else {
        throw std::invalid_argument(str);
    }

    result.port = static_cast<uint16_t>(std::stoul(match[2]));

    return result;
}

template <typename MapType>
typename MapType::mapped_type getFromMap(const std::string& pName, const MapType& map) {
    auto it = map.find(pName);

    if (it != map.end()) {
        return it->second;
    }

    throw boost::property_tree::ptree_bad_data("Bad param value", pName);
}

static inline std::string getArgFromCmdLine(const po::variables_map& vm, const std::string& name, const std::string& defVal) {
    return vm.count(name) ? vm[name].as<std::string>() : defVal;
}

static inline void writeFile(const std::string name, const std::string data) {
    std::ofstream file(name);
    file << data;
    file.close();
}

void Config::dumpJSONKeys(const std::string& fName) const {
    auto sk = privateKey_.access();

    auto pk58 = EncodeBase58(publicKey_.data(), publicKey_.data() + publicKey_.size());
    auto sk58 = EncodeBase58(sk.data(), sk.data() + sk.size());

    std::ofstream f(fName);
    f << "{\"key\":{\"public\":\"" << pk58 << "\",\"private\":\"" << sk58 << "\"}}";

    cscrypto::fillWithZeros(const_cast<char*>(pk58.data()), pk58.size());
    cscrypto::fillWithZeros(const_cast<char*>(sk58.data()), sk58.size());
}

Config Config::read(po::variables_map& vm) {
    Config result = readFromFile(getArgFromCmdLine(vm, ARG_NAME_CONFIG_FILE, DEFAULT_PATH_TO_CONFIG));

    result.pathToDb_ = getArgFromCmdLine(vm, ARG_NAME_DB_PATH, DEFAULT_PATH_TO_DB);

    if (result.good_)
        result.good_ = result.readKeys(getArgFromCmdLine(vm, ARG_NAME_PUBLIC_KEY_FILE, DEFAULT_PATH_TO_PUBLIC_KEY),
                                       getArgFromCmdLine(vm, ARG_NAME_PRIVATE_KEY_FILE, DEFAULT_PATH_TO_PRIVATE_KEY), vm.count(ARG_NAME_ENCRYPT_KEY_FILE));

    return result;
}

#ifndef _WIN32
int getch() {
    int ch;
    struct termios t_old, t_new;

    tcgetattr(STDIN_FILENO, &t_old);
    t_new = t_old;
    t_new.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &t_new);

    ch = getchar();

    tcsetattr(STDIN_FILENO, TCSANOW, &t_old);
    return ch;
}

static int _getch() {
    return getch();
}

static int _kbhit() {
    static const int STDIN = 0;
    static bool initialized = false;

    if (! initialized) {
        // Use termios to turn off line buffering
        termios term;
        tcgetattr(STDIN, &term);
        term.c_lflag &= ~ICANON;
        tcsetattr(STDIN, TCSANOW, &term);
        setbuf(stdin, NULL);
        initialized = true;
    }

    int bytesWaiting;
    ioctl(STDIN, FIONREAD, &bytesWaiting);
    return bytesWaiting;
}
#endif

template <typename T>
static bool readPasswordFromCin(T& mem) {
    auto ptr = mem.data();
    unsigned char ch = 0;

#ifdef _WIN32
    const char BACKSPACE = 8;
    const char RETURN = 13;

    DWORD con_mode;
    DWORD dwRead;

    HANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);

    GetConsoleMode(hIn, &con_mode);
    SetConsoleMode(hIn, con_mode & ~(ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT));

    while (ReadConsoleA(hIn, &ch, 1, &dwRead, NULL) && ch != RETURN) {
#else
    const char BACKSPACE = 127;
    const char RETURN = 10;

    while ((ch = getch()) != RETURN) {
#endif
        if (ch == BACKSPACE) {
            if (ptr != mem.data()) {
                *(ptr--) = '\0';
                std::cout << "\b \b" << std::flush;
            }
        }
        else if ((size_t)(ptr - mem.data()) < (mem.size() - 1) && ch >= 32 && ch <= 126) {
            *(ptr++) = ch;
            std::cout << '*' << std::flush;
        }
        else
            break;
    }

    *ptr = '\0';
    std::cout << std::endl;

    const auto sz = strlen(mem.data());
    if (!sz)
        return false;

    return ferror(stdin) == 0;
}

static bool encryptWithPassword(const cscrypto::PrivateKey& sk, std::vector<uint8_t>& skBytes) {
    bool pGood = false;
    cscrypto::MemGuard<char, 256> pass;

    while (!pGood) {
        std::cout << "Enter password: " << std::flush;
        if (!readPasswordFromCin(pass)) {
            return false;
        }
        const auto pLen = strlen(pass.data());

        if (pLen < MIN_PASSWORD_LENGTH) {
            std::cout << "Password is too short, minimum length is " << MIN_PASSWORD_LENGTH << std::endl;
            continue;
        }
        else if (pLen > MAX_PASSWORD_LENGTH) {
            std::cout << "Password is too long, maximum length is " << MAX_PASSWORD_LENGTH << std::endl;
            continue;
        }

        std::cout << "Confirm password: " << std::flush;
        cscrypto::MemGuard<char, 256> passConf;
        if (!readPasswordFromCin(passConf))
            return false;

        if (strcmp(pass.data(), passConf.data()) != 0) {
            std::cout << "Passwords do not match" << std::endl;
            continue;
        }

        pGood = true;
    }

    skBytes = sk.getEncrypted(pass.data(), std::strlen(pass.data()));
    return true;
}

static bool getBufFromFile(std::string& buf) {
    std::string pathToFile;
    std::fstream f;
    while (!f.is_open()) {
        std::cout << "\nEnter path to file (will be used as cipher key): " << std::flush;
        std::cin >> pathToFile;
        f.open(pathToFile, std::fstream::binary | std::fstream::in);
        if (!f.is_open()) {
            std::cout << "Can't open file " << pathToFile
                      << ", try another? (y/n): " << std::flush;
            char choice = '\0';
            std::cin >> choice;
            if (choice != 'y') {
                return false;
            }
        }
    }
    std::stringstream ss;
    ss << f.rdbuf();
    buf = ss.str();
    return true;
}

static bool encryptWithFile(const cscrypto::PrivateKey& sk, std::vector<uint8_t>& skBytes) {
    std::string buf;
    if (!getBufFromFile(buf)) {
        return false;
    }
    skBytes = sk.getEncrypted(buf.data(), buf.size());
    return true;
}

static bool usePassword() {
    char choice = '\0';
    while (choice != 'p' && choice != 'f') {
        std::cout << "\nTo use password for encrytion/decryption press \"p\", to use file press \"f\": "
                  << std::flush;
        std::cin >> choice;
        std::cout << std::endl;
    }
    if (choice == 'p') {
        return true;
    }
    return false;
}

static bool getEncryptedPrivateBytes(const cscrypto::PrivateKey& sk, std::vector<uint8_t>& skBytes) {
    if (!std::cin.good()) {
        return false;
    }
    if (usePassword()) {
        return encryptWithPassword(sk, skBytes);
    }
    return encryptWithFile(sk, skBytes);
}

void Config::showKeys(const std::string& pk58) {
    const double kTimeoutSeconds = 5;
    double secondsPassed = 0;
    std::cout << "To show your keys not encrypted press \"s\"." << std::endl;
    std::cout << "Seconds left:" << std::endl;
    std::clock_t start = std::clock();
    while (secondsPassed < kTimeoutSeconds) {
        secondsPassed = (double)(std::clock() - start) / CLOCKS_PER_SEC;
        std::cout << kTimeoutSeconds - secondsPassed << "\r";
        if (_kbhit()) {
            if (_getch() == 's') {
                std::cout << "\n\nPress any key to continue...\n" << std::endl;
                auto sk = privateKey_.access();
                std::string sk58tmp = EncodeBase58(sk.data(), sk.data() + sk.size());
                std::cout << "PublicKey: " << pk58 << " PrivateKey: " << sk58tmp << std::flush;
                cscrypto::fillWithZeros(sk58tmp.data(), sk58tmp.size());
                _getch();
                std::cout << "\r" << std::string(cscrypto::kPrivateKeySize * 5, 'x') << std::endl
                          << std::flush;
                break;
            }
        }
    }
}

void Config::changePasswordOption(const std::string& pathToSk) {
    std::cout << "To change password press \"p\".\n" << std::flush;
    std::cout << "Seconds left:" << std::endl;
    const double kTimeoutSeconds = 5;
    double secondsPassed = 0;
    std::clock_t start = std::clock();
    while (secondsPassed < kTimeoutSeconds) {
        secondsPassed = (double)(std::clock() - start) / CLOCKS_PER_SEC;
        std::cout << kTimeoutSeconds - secondsPassed << "\r";
        if (_kbhit()) {
            if (_getch() == 'p') {
                std::cout << "Encrypting the private key file with new password..." << std::endl;
                std::vector<uint8_t> skBytes;
                const bool encSucc = getEncryptedPrivateBytes(privateKey_, skBytes);
                if (encSucc) {
                    std::string sk58tmp = EncodeBase58(skBytes.data(), skBytes.data() + skBytes.size());
                    writeFile(pathToSk, sk58tmp);
                    cscrypto::fillWithZeros(const_cast<char*>(sk58tmp.data()), sk58tmp.size());
                    cslog() << "Key in " << pathToSk << " has been encrypted successfully";
                } else {
                    cslog() << "Not encrypting the private key file due to errors";
                }
                break;
            }
        }
    }
}

bool Config::readKeys(const std::string& pathToPk, const std::string& pathToSk, const bool encrypt) {
    // First read private
    std::ifstream skFile(pathToSk);
    std::string pk58;
    bool callShowKeys = false;

    if (skFile.is_open()) {
        std::string sk58;
        std::vector<uint8_t> sk;

        std::getline(skFile, sk58);
        skFile.close();
        DecodeBase58(sk58, sk);

        bool encFlag = false;
        if (sk.size() < cscrypto::kPrivateKeySize) {
            cserror() << "Bad private key file in " << pathToSk;
            return false;
        }
        else if (sk.size() > cscrypto::kPrivateKeySize) {
            encFlag = true;
            callShowKeys = true;
        }

        if (encFlag) {  // Check the encryption flag
            std::cout << "The key file seems to be encrypted" << std::endl;

            while (!privateKey_) {
                if (!std::cin.good())
                    return false;
                if (usePassword()) {
                    std::cout << "Enter password: " << std::flush;
                    cscrypto::MemGuard<char, 256> pass;
                    if (!readPasswordFromCin(pass)) {
                        return false;
                    }
                    std::cout << "Trying to open file..." << std::endl;
                    privateKey_ = cscrypto::PrivateKey::readFromEncrypted(sk, pass.data(), std::strlen(pass.data()));
                }
                else {
                    std::string buf;
                    if (!getBufFromFile(buf)) {
                        return false;
                    }
                    privateKey_ = cscrypto::PrivateKey::readFromEncrypted(sk, buf.data(), buf.size());
                }

                if (!privateKey_) {
                    std::cout << "Incorrect password (or corrupted file)" << std::endl;
                }
            }
            changePasswordOption(pathToSk);
        }
        else {
            privateKey_ = cscrypto::PrivateKey::readFromBytes(sk);

            if (!privateKey_) {
                cserror() << "Bad private key in " << pathToSk;
                return false;
            }

            cscrypto::fillWithZeros(sk.data(), sk.size());
            cscrypto::fillWithZeros(sk58.data(), sk58.size());

            if (encrypt) {
                callShowKeys = true;
                std::cout << "Encrypting the private key file..." << std::endl;
                std::vector<uint8_t> skBytes;
                const bool encSucc = getEncryptedPrivateBytes(privateKey_, skBytes);
                if (encSucc) {
                    std::string sk58tmp = EncodeBase58(skBytes.data(), skBytes.data() + skBytes.size());
                    writeFile(pathToSk, sk58tmp);
                    cscrypto::fillWithZeros(const_cast<char*>(sk58tmp.data()), sk58tmp.size());
                    cslog() << "Key in " << pathToSk << " has been encrypted successfully";
                }
                else {
                    cslog() << "Not encrypting the private key file due to errors";
                }
            }
        }

        publicKey_ = cscrypto::getMatchingPublic(privateKey_);
        pk58 = EncodeBase58(publicKey_.data(), publicKey_.data() + publicKey_.size());
    }
    else {
        // No private key detected
        for (;;) {
            std::cout << "No suitable keys were found. Type \"g\" to generate or \"q\" to quit." << std::endl;
            char flag;
            std::cin >> flag;

            if (flag == 'g') {
                std::vector<uint8_t> skBytes;
                auto ms = cscrypto::keys_derivation::generateMaterSeed();
                auto keys = cscrypto::keys_derivation::deriveKeyPair(ms, 0);
                privateKey_ = keys.second;
                publicKey_ = keys.first;

                std::cout << "\nSave this phrase to restore your keys in futute, and press any key to continue:" << std::endl;
                auto words = cscrypto::mnemonic::masterSeedToWords(ms);
                for (auto w : words) {
                    std::cout << w << " ";
                }
                std::cout << std::flush;
                _getch();
                std::cout << "\r" << std::string(ms.size() * 10, 'x') << std::endl << std::flush;

                std::cout << "Choose your private key file encryption type (enter number):" << std::endl;
                std::cout << "[1] Encrypt with password (recommended)" << std::endl;
                std::cout << "[2] No encryption" << std::endl;
                std::cout << "[q] Quit" << std::endl;

                char sChoice = '\0';
                while (sChoice != '1' && sChoice != '2' && sChoice != 'q') {
                    std::cout << "Enter choice: " << std::flush;
                    std::cin >> sChoice;
                    if (!std::cin.good())
                        return false;
                }

                if (sChoice == 'q')
                    return false;
                else if (sChoice == '1') {
                    callShowKeys = true;
                    if (!getEncryptedPrivateBytes(privateKey_, skBytes))
                        return false;
                }
                else {
                    auto sk = privateKey_.access();
                    skBytes.assign(sk.data(), sk.data() + sk.size());
                }

                pk58 = EncodeBase58(publicKey_.data(), publicKey_.data() + publicKey_.size());
                std::string sk58 = EncodeBase58(skBytes.data(), skBytes.data() + skBytes.size());

                writeFile(pathToPk, pk58);
                writeFile(pathToSk, sk58);

                // Just in case...
                cscrypto::fillWithZeros(const_cast<char*>(sk58.data()), sk58.size());
                cscrypto::fillWithZeros(const_cast<uint8_t*>(skBytes.data()), skBytes.size());

                cslog() << "Keys generated";
                break;
            }
            else if (flag == 'q')
                return false;
        }
    }

    // Okay so by now we have both public and private key fields filled up
    std::ifstream pkFile(pathToPk);
    bool pkGood = false;

    if (pkFile.is_open()) {
        std::string pkFileCont;
        std::getline(pkFile, pkFileCont);
        pkFile.close();

        pkGood = (pkFileCont == pk58);
    }

    if (!pkGood) {
        std::cout << "The PUBLIC key file not found or doesn't contain a valid key (matching the provided private key). Type \"f\" to rewrite the PUBLIC key file." << std::endl;
        char flag;
        std::cin >> flag;
        if (flag == 'f')
            writeFile(pathToPk, pk58);
        else
            return false;
    }

    if (callShowKeys) {
        showKeys(pk58);
    }

    return true;
}

Config Config::readFromFile(const std::string& fileName) {
    Config result;

    boost::property_tree::ptree config;

    try {
        auto ext = boost::filesystem::extension(fileName);
        boost::algorithm::to_lower(ext);
        if (ext == "json") {
            boost::property_tree::read_json(fileName, config);
        }
        else if (ext == "xml") {
            boost::property_tree::read_xml(fileName, config);
        }
        else {
            boost::property_tree::read_ini(fileName, config);
        }

        result.inputEp_ = readEndpoint(config, BLOCK_NAME_HOST_INPUT);

        if (config.count(BLOCK_NAME_HOST_OUTPUT)) {
            result.outputEp_ = readEndpoint(config, BLOCK_NAME_HOST_OUTPUT);

            result.twoSockets_ = true; /*(result.outputEp_.ip != result.inputEp_.ip ||
                                         result.outputEp_.port != result.inputEp_.port);*/
        }
        else {
            result.twoSockets_ = false;
        }

        const boost::property_tree::ptree& params = config.get_child(BLOCK_NAME_PARAMS);

        result.ipv6_ = !(params.count(PARAM_NAME_USE_IPV6) && params.get<std::string>(PARAM_NAME_USE_IPV6) == "false");

        result.maxNeighbours_ = params.count(PARAM_NAME_MAX_NEIGHBOURS) ? params.get<uint32_t>(PARAM_NAME_MAX_NEIGHBOURS) : DEFAULT_MAX_NEIGHBOURS;
        if (result.maxNeighbours_ > DEFAULT_MAX_NEIGHBOURS) {
            result.maxNeighbours_ = DEFAULT_MAX_NEIGHBOURS; // see neighbourhood.hpp, some containers are of static size
        }

        result.connectionBandwidth_ = params.count(PARAM_NAME_CONNECTION_BANDWIDTH) ? params.get<uint64_t>(PARAM_NAME_CONNECTION_BANDWIDTH) : DEFAULT_CONNECTION_BANDWIDTH;

        result.nType_ = getFromMap(params.get<std::string>(PARAM_NAME_NODE_TYPE), NODE_TYPES_MAP);

        if (config.count(BLOCK_NAME_HOST_ADDRESS)) {
            result.hostAddressEp_ = readEndpoint(config, BLOCK_NAME_HOST_ADDRESS);
            result.symmetric_ = false;
        }
        else {
            result.symmetric_ = true;
        }

        result.bType_ = getFromMap(params.get<std::string>(PARAM_NAME_BOOTSTRAP_TYPE), BOOTSTRAP_TYPES_MAP);

        if (result.bType_ == BootstrapType::SignalServer || result.nType_ == NodeType::Router) {
            result.signalServerEp_ = readEndpoint(config, BLOCK_NAME_SIGNAL_SERVER);
        }

        if (result.bType_ == BootstrapType::IpList) {
            const auto hostsFileName = params.get<std::string>(PARAM_NAME_HOSTS_FILENAME);

            std::string line;

            std::ifstream hostsFile;
            hostsFile.exceptions(std::ifstream::failbit);
            hostsFile.open(hostsFileName);
            hostsFile.exceptions(std::ifstream::goodbit);

            while (getline(hostsFile, line)) {
                if (!line.empty()) {
                    result.bList_.push_back(EndpointData::fromString(line));
                }
            }

            if (result.bList_.empty()) {
                throw std::length_error("No hosts specified");
            }
        }

        result.setLoggerSettings(config);
        result.readPoolSynchronizerData(config);
        result.readApiData(config);
        result.good_ = true;
    }
    catch (boost::property_tree::ini_parser_error& e) {
        cserror() << "Couldn't read config file \"" << fileName << "\": " << e.what();
        result.good_ = false;
    }
    catch (boost::property_tree::ptree_bad_data& e) {
        cserror() << e.what() << ": " << e.data<std::string>();
    }
    catch (boost::property_tree::ptree_error& e) {
        cserror() << "Errors in config file: " << e.what();
    }
    catch (std::invalid_argument& e) {
        cserror() << "Parsing error at \"" << e.what() << "\".";
    }
    catch (std::ifstream::failure& e) {
        cserror() << "Cannot open file: " << e.what();
    }
    catch (std::exception& e) {
        cserror() << e.what();
    }
    catch (...) {
        cserror() << "Errors in config file";
    }

    return result;
}

void Config::setLoggerSettings(const boost::property_tree::ptree& config) {
    boost::property_tree::ptree settings;
    auto core = config.get_child_optional("Core");
    if (core) {
        settings.add_child("Core", *core);
    }
    auto sinks = config.get_child_optional("Sinks");
    if (sinks) {
        for (const auto& val : *sinks) {
            settings.add_child(boost::property_tree::ptree::path_type("Sinks." + val.first, '/'), val.second);
        }
    }
    for (const auto& item : config) {
        if (item.first.find("Sinks.") == 0)
            settings.add_child(boost::property_tree::ptree::path_type(item.first, '/'), item.second);
    }
    std::stringstream ss;
    boost::property_tree::write_ini(ss, settings);
    loggerSettings_ = boost::log::parse_settings(ss);
}

void Config::readPoolSynchronizerData(const boost::property_tree::ptree& config) {
    const std::string& block = BLOCK_NAME_POOL_SYNC;

    if (!config.count(block)) {
        return;
    }

    const boost::property_tree::ptree& data = config.get_child(block);

    checkAndSaveValue(data, block, PARAM_NAME_POOL_SYNC_ONE_REPLY_BLOCK, poolSyncData_.oneReplyBlock);
    checkAndSaveValue(data, block, PARAM_NAME_POOL_SYNC_FAST_MODE, poolSyncData_.isFastMode);
    checkAndSaveValue(data, block, PARAM_NAME_POOL_SYNC_POOLS_COUNT, poolSyncData_.blockPoolsCount);
    checkAndSaveValue(data, block, PARAM_NAME_POOL_SYNC_ROUND_COUNT, poolSyncData_.requestRepeatRoundCount);
    checkAndSaveValue(data, block, PARAM_NAME_POOL_SYNC_PACKET_COUNT, poolSyncData_.neighbourPacketsCount);
    checkAndSaveValue(data, block, PARAM_NAME_POOL_SYNC_SEQ_VERIF_FREQ, poolSyncData_.sequencesVerificationFrequency);
}

void Config::readApiData(const boost::property_tree::ptree& config) {
    if (!config.count(BLOCK_NAME_API)) {
        return;
    }

    const boost::property_tree::ptree& data = config.get_child(BLOCK_NAME_API);

    checkAndSaveValue(data, BLOCK_NAME_API, PARAM_NAME_API_PORT, apiData_.port);
    checkAndSaveValue(data, BLOCK_NAME_API, PARAM_NAME_AJAX_PORT, apiData_.ajaxPort);
    checkAndSaveValue(data, BLOCK_NAME_API, PARAM_NAME_EXECUTOR_PORT, apiData_.executorPort);
    checkAndSaveValue(data, BLOCK_NAME_API, PARAM_NAME_APIEXEC_PORT, apiData_.apiexecPort);
}

template <typename T>
bool Config::checkAndSaveValue(const boost::property_tree::ptree& data, const std::string& block, const std::string& param, T& value) {
    if (data.count(param)) {
        const int readValue = std::is_same_v<T, bool> ? data.get<bool>(param) : data.get<int>(param);
        const auto max = cs::getMax(value);
        const auto min = cs::getMin(value);

        if (readValue > max || readValue < min) {
            std::cout << "[warning] Config.ini> Please, check the block: [" << block << "], so that param: [" << param << "],  will be: [" << cs::numeric_cast<int>(min) << ", "
                      << cs::numeric_cast<int>(max) << "]" << std::endl;
            return false;
        }

        value = cs::numeric_cast<T>(readValue);
        return true;
    }

    return false;
}
```
# ..\node\client\src\main.cpp 
```cpp 
#include "stdafx.h"

#include <iomanip>
#include <iostream>
#ifndef WIN32
#include <signal.h>
#include <unistd.h>
#else
#include <csignal>
#endif

#include <csnode/node.hpp>
#include <lib/system/logger.hpp>
#include <net/transport.hpp>

#include "config.hpp"

// diagnostic output
#if defined(_MSC_VER)
#if defined(MONITOR_NODE)
#pragma message("\n*** Monitor node has been built ***\n")
#elif defined(WEB_WALLET_NODE)
#pragma message("\n*** Web wallet node has been built ***\n")
#elif defined(SPAMMER)
#pragma message("\n*** Spammer node has been built ***\n")
#else
#pragma message("\n*** Basic node has been built ***\n")
#endif
#endif  // _MSC_VER

#ifdef BUILD_WITH_GPROF
void sigUsr1Handler(int sig) {
    std::cerr << "Exiting on SIGUSR1\n";
    auto _mcleanup = (void (*)(void))dlsym(RTLD_DEFAULT, "_mcleanup");
    if (_mcleanup == NULL) {
        std::cerr << "Unable to find gprof exit hook\n";
    }
    else {
        _mcleanup();
    }
    _exit(0);
}
#endif

const uint32_t CLOSE_TIMEOUT_SECONDS = 10;

void panic() {
    cserror() << "Couldn't continue due to critical errors. The node will be closed in " << CLOSE_TIMEOUT_SECONDS << " seconds...";
    std::this_thread::sleep_for(std::chrono::seconds(CLOSE_TIMEOUT_SECONDS));
    exit(1);
}

inline void mouseSelectionDisable() {
#if defined(WIN32) && !defined(_DEBUG)
    DWORD prevMode = 0;
    HANDLE hConsole = GetStdHandle(STD_INPUT_HANDLE);
    GetConsoleMode(hConsole, &prevMode);
    SetConsoleMode(hConsole, prevMode & static_cast<unsigned long>(~ENABLE_QUICK_EDIT_MODE));
#endif
}

#ifndef WIN32
extern "C" void sigHandler(int sig) {
    gSignalStatus = 1;
    std::cout << "+++++++++++++++++ >>> Signal received!!! <<< +++++++++++++++++++++++++" << std::endl;
    switch (sig) {
        case SIGINT:
            cswarning() << "Signal SIGINT received, exiting";
            break;
        case SIGTERM:
            cswarning() << "Signal SIGTERM received, exiting";
            break;
        case SIGHUP:
            cswarning() << "Signal SIGHUP received, exiting";
            break;
        default:
            cswarning() << "Unknown signal received!!!";
            break;
    }
}

void installSignalHandler() {
    if (SIG_ERR == signal(SIGTERM, sigHandler)) {
        // Handle error
        cserror() << "Error to set SIGTERM!";
        _exit(EXIT_FAILURE);
    }
    if (SIG_ERR == signal(SIGINT, sigHandler)) {
        cserror() << "Error to set SIGINT!";
        _exit(EXIT_FAILURE);
    }
    if (SIG_ERR == signal(SIGHUP, sigHandler)) {
        cserror() << "Error to set SIGHUP!";
        _exit(EXIT_FAILURE);
    }
}
#else
BOOL WINAPI CtrlHandler(DWORD fdwCtrlType) {
    gSignalStatus = 1;
    std::cout << "+++++++++++++++++ >>> Signal received!!! <<< +++++++++++++++++++++++++" << std::endl;
    switch (fdwCtrlType) {
            // Handle the CTRL-C signal.
        case CTRL_C_EVENT:
            cswarning() << "Ctrl-C event\n\n";
            return TRUE;

        // CTRL-CLOSE: confirm that the user wants to exit.
        case CTRL_CLOSE_EVENT:
            cswarning() << "Ctrl-Close event\n\n";
            return TRUE;

            // Pass other signals to the next handler.
        case CTRL_BREAK_EVENT:
            cswarning() << "Ctrl-Break event\n\n";
            return TRUE;

        case CTRL_LOGOFF_EVENT:
            cswarning() << "Ctrl-Logoff event\n\n";
            return FALSE;

        case CTRL_SHUTDOWN_EVENT:
            cswarning() << "Ctrl-Shutdown event\n\n";
            return FALSE;

        default:
            return FALSE;
    }
}
#endif  // !WIN32

int main(int argc, char* argv[]) {
#ifdef WIN32
    if (!SetConsoleCtrlHandler(CtrlHandler, TRUE)) {
        std::cout << "\nERROR: Could not set control handler" << std::flush;
        return 1;
    }
#else
    installSignalHandler();
#endif  // WIN32
    mouseSelectionDisable();
#if BUILD_WITH_GPROF
    signal(SIGUSR1, sigUsr1Handler);
#endif
    std::ios_base::sync_with_stdio(false);

    using namespace boost::program_options;
    options_description desc("Allowed options");
    desc.add_options()("help", "produce this message")("version", "show node version")("db-path", po::value<std::string>(), "path to DB (default: \"test_db/\")")(
        "config-file", po::value<std::string>(), "path to configuration file (default: \"config.ini\")")(
        "public-key-file", po::value<std::string>(), "path to public key file (default: \"NodePublic.txt\")")("private-key-file", po::value<std::string>(),
                                                                                                              "path to private key file (default: \"NodePrivate.txt\")")(
        "dumpkeys", po::value<std::string>(), "dump your public and private keys into a JSON file with the specified name (UNENCRYPTED!)")(
        "encryptkey", "encrypts the private key with password upon startup (if not yet encrypted)");

    variables_map vm;
    try {
        store(parse_command_line(argc, argv, desc), vm);
        notify(vm);
    }
    catch (unknown_option& e) {
        cserror() << e.what();
        cslog() << desc;
        return 1;
    }
    catch (invalid_command_line_syntax& e) {
        cserror() << e.what();
        cslog() << desc;
        return 1;
    }
    catch (...) {
        cserror() << "Couldn't parse the arguments";
        cslog() << desc;
        return 1;
    }

    if (vm.count("help")) {
        cslog() << desc;
        return 0;
    }

    if (vm.count("version")) {
        cslog() << "Node version is " << Config::getNodeVersion();
        return 0;
    }

    if (!cscrypto::cryptoInit()) {
        std::cout << "Couldn't initialize the crypto library" << std::endl;
        panic();
    }

    auto config = Config::read(vm);

    if (!config.isGood()) {
        panic();
    }

    if (vm.count("dumpkeys")) {
        auto fName = vm["dumpkeys"].as<std::string>();
        if (fName.size() > 0) {
            config.dumpJSONKeys(fName);
            cslog() << "Keys dumped to " << fName;
            return 0;
        }
    }

    logger::initialize(config.getLoggerSettings());

    Node node(config);

    if (!node.isGood()) {
        panic();
    }

    std::cout << "Running Node\n";
    node.run();

    cswarning() << "+++++++++++++>>> NODE ATTEMPT TO STOP! <<<++++++++++++++++++++++";
    node.stop();

    cswarning() << "Exiting Main Function";

    logger::cleanup();

    std::cout << "Logger cleaned" << std::endl;
    std::_Exit(EXIT_SUCCESS);
}
```
# ..\node\client\src\stdafx.cpp 
```cpp 
#include "stdafx.h"```
# ..\node\cscrypto\include\cscrypto\cryptoconstants.hpp 
```cpp 
#ifndef CSCRYPTO_CRYPTOCONSTANTS_HPP
#define CSCRYPTO_CRYPTOCONSTANTS_HPP

#include <cstddef>

namespace cscrypto {

const size_t kHashSize = 32;
const size_t kPublicKeySize = 32;
const size_t kPrivateKeySize = 64;
const size_t kSignatureSize = 64;

}  // namespace cscrypto
#endif  // CSCRYPTO_CRYPTOCONSTANTS_HPP
```
# ..\node\cscrypto\include\cscrypto\cryptotypes.hpp 
```cpp 
#ifndef CSCRYPTO_CRYPTOTYPES_HPP
#define CSCRYPTO_CRYPTOTYPES_HPP

#include "cscrypto/cryptoconstants.hpp"

#include <array>
#include <cinttypes>
#include <string_view>
#include <vector>

namespace cscrypto {

using Byte = uint8_t;

template <std::size_t size>
using ByteArray = std::array<cscrypto::Byte, size>;
using Bytes = std::vector<cscrypto::Byte>;
using BytesView = std::basic_string_view<cscrypto::Byte>;

using Hash = cscrypto::ByteArray<kHashSize>;
using PublicKey = cscrypto::ByteArray<kPublicKeySize>;
using Signature = cscrypto::ByteArray<kSignatureSize>;

}  // namespace cscrypto
#endif  // CSCRYPTO_CRYPTOTYPES_HPP
```
# ..\node\cscrypto\include\cscrypto\cscrypto.hpp 
```cpp 
/**
 *  @file   cscrypto.hpp
 *  @author Sergey Sychev
 */

#ifndef CSCRYPTO_HPP
#define CSCRYPTO_HPP

/**
 *   CS cryptography module.
 *   It was designed to have an opportunity of crypto engines substitution.
 */
#include <cscrypto/maincryptofunctions.hpp>
#include <cscrypto/mnemonic.hpp>

#endif  // CSCRYPTO_HPP
```
# ..\node\cscrypto\include\cscrypto\dictionary.hpp 
```cpp 
#ifndef CSCRYPTO_DICTIONARY_HPP
#define CSCRYPTO_DICTIONARY_HPP

#include <array>
#include <vector>

namespace cscrypto {
namespace mnemonic {

const size_t kDictionarySize = 2048;

using Dictionary = std::array<const char*, kDictionarySize>;
using DictionaryList = std::vector<const Dictionary*>;

namespace langs {

extern const Dictionary en;

const DictionaryList all { &en };

} // namespace langs
} // namespace mnemonic
} // namespace cscrypto
#endif // CSCRYPTO_DICTIONARY_HPP
```
# ..\node\cscrypto\include\cscrypto\keysderivation.hpp 
```cpp 
#ifndef CSCRYPTO_KEYS_DERIVATION_HPP
#define CSCRYPTO_KEYS_DERIVATION_HPP

#include <cscrypto/privatekey.hpp>

#include <array>
#include <cinttypes>
#include <utility>

namespace cscrypto {
namespace keys_derivation {

const size_t kMasterSeedSize = crypto_kdf_KEYBYTES;
const size_t kSeedContextSize = crypto_kdf_CONTEXTBYTES;

using KeyId = uint64_t;
using MasterSeed = MemGuard<cscrypto::Byte, kMasterSeedSize>;
using Context = std::array<const char, kSeedContextSize>;
using KeyPair = std::pair<PublicKey, PrivateKey>;

MasterSeed generateMaterSeed();

KeyPair deriveKeyPair(MasterSeed&, KeyId, const Context& ctx = {0});

void accessMasterSeed(MasterSeed&);
void lockMasterSeed(MasterSeed&);

} // namespace keys_derivation
} // namespace cscrypto
#endif // CSCRYPTO_KEYS_DERIVATION_HPP
```
# ..\node\cscrypto\include\cscrypto\maincryptofunctions.hpp 
```cpp 
#ifndef CSCRYPTO_MAINCRYPTOFUNCTIONS_HPP
#define CSCRYPTO_MAINCRYPTOFUNCTIONS_HPP

#include "cscrypto/privatekey.hpp"

namespace cscrypto {
/**
 *   @brief Does the job for the correct work of the crypto library.
 *
 *   Should be called before any other crypto function.
 *   @return true if initialization successful, false if error.
 */

bool cryptoInit();

/**
 *   @brief Calculates hash from byte array of arbitrary size.
 *
 *   @param[in]  data - hash value depends on this.
 *   @return Returns calculated hash.
 *
 *   If you need to calculate MAC (message authentication code)
 *   use two optional params (key and keySize). Two calculated
 *   hashes with the same data but different keys will not match.
 */
Hash calculateHash(const Byte* data, size_t dataSize, const Byte* key = nullptr, size_t keySize = 0);

/**
 *   @brief Generates new crypto keys appropriate to cipher or to sign data.
 */
PrivateKey generateKeyPair(PublicKey& publicKey);

/**
 *   @brief Tries to sign data and verify generated signature with given keys.
 *   @return true if keys are valid, false otherwise.
 */
bool validateKeyPair(const PublicKey& publicKey, const PrivateKey& privateKey);

/**
 *   @brief Returns public key from generated private key.
 */
PublicKey getMatchingPublic(const PrivateKey& privateKey);

/**
 *   @brief Signs data with private key and saves the result in signature.
 *   @return Returns generated signature.
 */
Signature generateSignature(const PrivateKey& privateKey, const Byte* data, size_t dataSize);

/**
 *   @brief Verifies with public key that signature of data was generated by
 *   related private key owner.
 *
 *   @return true if signature is correct, false if incorrect
 */
bool verifySignature(const Signature& signature, const PublicKey& publicKey, const Byte* data, size_t dataSize);

/**
 *   @brief Verifies with public key that signature of data was generated by
 *   related private key owner represented as pointers.
 *
 *   @return true if signature is correct, false if incorrect.
 */
bool verifySignature(const Byte* signature, const Byte* publicKey, const Byte* data, size_t dataSize);

/**
 *   @brief Fills buf_size bytes starting at buf with an unpredictable sequence of bytes.
 */
void fillBufWithRandomBytes(void* buffer, size_t size);
void fillWithZeros(void* buffer, size_t size);

}  // namespace cscrypto
#endif  // CSCRYPTO_MAINCRYPTOFUNCTIONS_HPP
```
# ..\node\cscrypto\include\cscrypto\memoryprotection.hpp 
```cpp 
#ifndef CSCRYPTO_MEMORY_PROTECTION_HPP
#define CSCRYPTO_MEMORY_PROTECTION_HPP

#include <cstddef>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4324 4244 4267 4804)  // 'crypto_generichash_blake2b_state': structure was padded due to alignment specifier,
#endif

#include <sodium.h>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

namespace cscrypto {

template <typename T, std::size_t Size>
class MemGuard {
public:
    MemGuard();
    ~MemGuard() {
        clear();
    }

    MemGuard(MemGuard&&);
    MemGuard& operator=(MemGuard&&);

    MemGuard(const MemGuard&) = delete;
    MemGuard& operator=(const MemGuard&) = delete;

    T* data() {
        return mem_;
    }
    const T* data() const {
        return mem_;
    }

    auto size() const {
        return Size;
    }

    void clear();

    operator bool() const {
        return mem_;
    }

private:
    T* mem_;
};

template <typename T, std::size_t Size>
class MemAccessGuard {
public:
    MemAccessGuard(T* mem);
    ~MemAccessGuard() {
        clear();
    }

    MemAccessGuard(MemAccessGuard&&);
    MemAccessGuard& operator=(MemAccessGuard&&);

    MemAccessGuard(const MemAccessGuard&) = delete;
    MemAccessGuard& operator=(const MemAccessGuard&) = delete;

    const T* data() const {
        return mem_;
    }
    auto size() const {
        return Size;
    }

private:
    void clear();
    T* mem_;
};

template <typename T, std::size_t Size>
MemGuard<T, Size>::MemGuard() {
    mem_ = static_cast<T*>(sodium_malloc(Size * sizeof(T)));
}

template <typename T, std::size_t Size>
void MemGuard<T, Size>::clear() {
    sodium_free(reinterpret_cast<void*>(mem_));
    mem_ = nullptr;
}

template <typename T, std::size_t Size>
MemGuard<T, Size>::MemGuard(MemGuard&& rhs) {
    mem_ = rhs.mem_;
    rhs.mem_ = nullptr;
}

template <typename T, std::size_t Size>
MemGuard<T, Size>& MemGuard<T, Size>::operator=(MemGuard&& rhs) {
    if (rhs.mem_ != mem_) {
        clear();
        mem_ = rhs.mem_;
        rhs.mem_ = nullptr;
    }
    return *this;
}

template <typename T, std::size_t Size>
MemAccessGuard<T, Size>::MemAccessGuard(T* mem)
: mem_(mem) {
    sodium_mprotect_readonly(mem_);
}

template <typename T, std::size_t Size>
void MemAccessGuard<T, Size>::clear() {
    sodium_mprotect_noaccess(mem_);
}

template <typename T, std::size_t Size>
MemAccessGuard<T, Size>::MemAccessGuard(MemAccessGuard&& rhs) {
    if (rhs.mem_ != mem_) {
        clear();
        mem_ = rhs.mem_;
        rhs.mem_ = nullptr;
    }
}

template <typename T, std::size_t Size>
MemAccessGuard<T, Size>& MemAccessGuard<T, Size>::operator=(MemAccessGuard&& rhs) {
    if (rhs.mem_ != mem_) {
        clear();
        mem_ = rhs.mem_;
        rhs.mem_ = nullptr;
    }
    return *this;
}
}  // namespace cscrypto
#endif  // CSCRYPTO_MEMORY_PROTECTION_HPP
```
# ..\node\cscrypto\include\cscrypto\mnemonic.hpp 
```cpp 
#ifndef CSCRYPTO_MNEMONIC_HPP
#define CSCRYPTO_MNEMONIC_HPP

#include <cscrypto/dictionary.hpp>
#include <cscrypto/keysderivation.hpp>

#include <functional>

namespace cscrypto {
namespace mnemonic {

namespace kd = keys_derivation;

const size_t kBitsCheckSum = kd::kMasterSeedSize / sizeof(uint32_t);
const size_t kBitsAll = kBitsCheckSum + kd::kMasterSeedSize * 8;
const size_t kBitsWord = 11;
const size_t kNumWords = kBitsAll / kBitsWord;

using WordList = std::array<const char*, kNumWords>;
using MasterSeedGuard = MemGuard<cscrypto::Byte, kBitsAll / 8>;

WordList masterSeedToWords(kd::MasterSeed&, const Dictionary& dictionary = langs::en);

kd::MasterSeed wordsToMasterSeed(const WordList&,
        const Dictionary& dictionary = langs::en,
        std::function<void(const char*)> errorHandler = nullptr);

} // namespace mnemonic
} // namespace cscrypto
#endif // CSCRYPTO_MNEMONIC_HPP
```
# ..\node\cscrypto\include\cscrypto\privatekey.hpp 
```cpp 
#ifndef CSCRYPTO_PRIVATE_KEY
#define CSCRYPTO_PRIVATE_KEY

#include "cscrypto/cryptotypes.hpp"
#include "cscrypto/memoryprotection.hpp"

namespace cscrypto {

using PrivateKeyGuard = MemAccessGuard<cscrypto::Byte, kPrivateKeySize>;

class PrivateKey {
public:
    PrivateKey();
    ~PrivateKey() {
        clear();
    }

    PrivateKey(const PrivateKey&);
    PrivateKey(PrivateKey&&);
    PrivateKey& operator=(const PrivateKey&);
    PrivateKey& operator=(PrivateKey&&);

    PrivateKeyGuard access() const;
    operator bool() const {
        return mem_;
    }

    static PrivateKey readFromBytes(const Bytes&);
    static PrivateKey readFromBytes(const MemGuard<Byte, kPrivateKeySize>&);
    static PrivateKey readFromEncrypted(const Bytes&, const char* passwd, size_t pswdLen);

    Bytes getEncrypted(const char* passwd, size_t pswdLen) const;
    static PrivateKey generateWithPair(PublicKey&);

private:
    void clear();

    void* mem_;
    uint32_t* ctr_;
};

}  // namespace cscrypto
#endif  // CSCRYPTO_PRIVATE_KEY
```
# ..\node\cscrypto\qt\include\cipherwidget.hpp 
```cpp 
#ifndef CIPHER_WIDGET_HPP
#define CIPHER_WIDGET_HPP

#include <QWidget>

namespace cscrypto {
namespace gui {

class CipherWidget : public QWidget {
    Q_OBJECT

public:
    CipherWidget(QWidget* parent = nullptr);
};

} // namespace gui
} // namespace csccrypto
#endif // CIPHER_WIDGET_HPP
```
# ..\node\cscrypto\qt\include\common.hpp 
```cpp 
#ifndef CSCRYPTO_GUI_COMMON_HPP
#define CSCRYPTO_GUI_COMMON_HPP

#include <vector>
#include <utility>

#include <cscrypto/cscrypto.hpp>

namespace cscrypto {
namespace gui {

using KeyPair = cscrypto::keys_derivation::KeyPair;

} // namespace gui
} // namespace cscrypto
#endif // CSCRYPTO_GUI_COMMON_HPP
```
# ..\node\cscrypto\qt\include\hashwidget.hpp 
```cpp 
#ifndef HASH_WIDGET_HPP
#define HASH_WIDGET_HPP

#include <QWidget>

#include <vector>
#include <cinttypes>

class QStatusBar;
class QLayout;
class QTextEdit;
class QLineEdit;
class QLabel;

namespace cscrypto {
namespace gui {

class HashWidget : public QWidget {
    Q_OBJECT

public:
    HashWidget(QStatusBar&, QWidget* parent = nullptr);

signals:
    void messageModeActivated(bool);
    void fileModeActivated(bool);
    void hmac(bool);
    void canHash(bool);

private:
    void tuneLayouts();
    void fillModeLayout(QLayout*);
    void fillSettingsLayout(QLayout*);
    void fillMiddleLayout(QLayout*);

    void activateMessageMode();
    void activateFileMode();
    void activateHmac(int);

    void loadHashingFile();

    void calculateHash();

    QStatusBar& statusBar_;
    QTextEdit* hashingMsg_;
    QLineEdit* hmacKeyLineEdit_;
    QLineEdit* genHashLineEdit_;
    QLabel* loadedFileName_;

    std::vector<uint8_t> hashingData_;
    bool fileMode_;
    bool hmacMode_;
};

} // namespace gui
} // namespace cscrypto
#endif // HASH_WIDGET_HPP
```
# ..\node\cscrypto\qt\include\keygenwidget.hpp 
```cpp 
#ifndef KEYGEN_WIDGET_HPP
#define KEYGEN_WIDGET_HPP

#include <QWidget>
#include <QString>

#include <common.hpp>

class QLayout;
class QDialog;
class QMessageBox;
class QLineEdit;
class QListWidget;
class QStatusBar;

namespace cscrypto {
namespace gui {

class KeyGenWidget : public QWidget {
    Q_OBJECT

public:
    KeyGenWidget(QStatusBar& statusBar, std::vector<KeyPair>& keys, QWidget* parent = nullptr);

signals:
    void enableKeyGen(bool);
    void enableNewSeed(bool);
    void newKeyAdded();

private:
    void tuneLayouts();
    void fillSeedLayout(QLayout*);
    void fillKeyLayout(QLayout*);
    void fillKeyListLayout(QLayout*);
    void fillMainLowLayout(QLayout*);

    void setupTypeSeedDia();
    void setSeedOnMsBox();
    void disableKeyGen();

    void fillMasterSeedFromString(const QString&);
    void handleInputSeed();
    void handlePrivKeyLine();

    void saveSeedToFile();
    void loadSeedFromFile();
    void dumpKeysToFile();

    void genNewSeed();
    QString getSeedString();
    void genKeyPair();
    void genPublicFromPrivateDialog();

    QDialog* typeSeedDialog_;
    QMessageBox* seedMsBox_;
    QLineEdit* seedLineEdit_;
    QLineEdit* privateKeyLineEdit_;
    QListWidget* keysList_;
    QStatusBar& statusBar_;

    cscrypto::keys_derivation::MasterSeed masterSeed_;
    cscrypto::keys_derivation::KeyId nextKeyId_;
    std::vector<KeyPair>& keys_;
};
} // namespace gui
} // namespace cscrypto
#endif // KEYGEN_WIDGET_HPP
```
# ..\node\cscrypto\qt\include\mainwidget.hpp 
```cpp 
#ifndef MAINWIDGET_HPP
#define MAINWIDGET_HPP

#include <QWidget>

#include <map>

#include <common.hpp>

class QTabWidget;
class QStatusBar;

namespace cscrypto {
namespace gui {

class MainWidget : public QWidget {
    Q_OBJECT

public:
    MainWidget(QWidget* parent = nullptr);

private:
    void fillTabs();
    void fillWidgets();

    QTabWidget* tabs_;
    QStatusBar* statusBar_;
    std::map<const char*, QWidget*> widgets_;
    std::vector<KeyPair> keys_;
};

} // namespace gui
} // namespace cscrypto
#endif // MAINWIDGET_HPP
```
# ..\node\cscrypto\qt\include\signwidget.hpp 
```cpp 
#ifndef SIGN_WIDGET_HPP
#define SIGN_WIDGET_HPP

#include <QWidget>

#include <string>

#include <common.hpp>

class QStatusBar;
class QLayout;
class QString;
class QListWidget;
class QLineEdit;
class QTextEdit;
class QPushButton;
class QLabel;

namespace cscrypto {
namespace gui {

class KeyGenWidget;

class SignWidget : public QWidget {
    Q_OBJECT

public:
    SignWidget(QStatusBar& statusBar,
               std::vector<KeyPair>& keys,
               const KeyGenWidget* keyGenerator,
               QWidget* parent = nullptr);

signals:
    void enableSigning(bool);
    void enableVerification(bool);
    void canSign(bool);
    void canVerify(bool);

private:
    void tuneLayouts();
    void fillModeLayout(QLayout*);
    void fillKeysLayout(QLayout*);
    void fillMiddleLayout(QLayout*);
    void fillLowLayout(QLayout*);

    void chooseSigningKey();
    void setSigningKey();
    void signMsg();
    void verifySignature();
    void addNewKey();
    void insertVerificationKey();
    void loadDataFromFile();

    void activateSignMode();
    void activateVerificationMode();
    void activateFileMode(int);

    QListWidget* keysList_;

    QStatusBar& statusBar_;
    std::vector<KeyPair>& keys_;
    QLineEdit* operatingKeyLine_;
    QTextEdit* signingMsg_;
    QLineEdit* signatureLine_;
    QPushButton* loadFileBtn_;
    std::string fileHash_;
    QLabel* fileName_;
    bool fileMode_;
};
} // namespace gui
} // namespace cscrypto
#endif // SIGN_WIDGET_HPP
```
# ..\node\cscrypto\qt\include\utils.hpp 
```cpp 
#ifndef CSCRYPTO_GUI_UTILS_HPP
#define CSCRYPTO_GUI_UTILS_HPP

#include <QStatusBar>
#include <QString>

namespace cscrypto {
namespace gui {

inline static void toStatusBar(QStatusBar& sb, const QString& msg, int timeout = 5000) {
    sb.showMessage(msg, timeout);
}

} // namespace gui
} // namespace cscrypto
#endif // CSCRYPTO_GUI_UTILS_HPP
```
# ..\node\cscrypto\qt\src\cipherwidget.cpp 
```cpp 
#include "cipherwidget.hpp"

#include <QVBoxLayout>

namespace cscrypto {
namespace gui {

CipherWidget::CipherWidget(QWidget* parent) : QWidget(parent) {
    QVBoxLayout* mainLayout = new QVBoxLayout();
    setLayout(mainLayout);
}

} // namespace gui
} // namespace cscrypto
```
# ..\node\cscrypto\qt\src\hashwidget.cpp 
```cpp 
#include "hashwidget.hpp"

#include <QVBoxLayout>
#include <QStatusBar>
#include <QRadioButton>
#include <QSpacerItem>
#include <QCheckBox>
#include <QTextEdit>
#include <QPushButton>
#include <QLabel>
#include <QLineEdit>
#include <QFileDialog>
#include <QString>

#include <utils.hpp>

#include <fstream>
#include <sstream>

#include <cscrypto/cscrypto.hpp>
#include <base58.h>

namespace cscrypto {
namespace gui {

HashWidget::HashWidget(QStatusBar& sb, QWidget* parent)
        : QWidget(parent),
          statusBar_(sb),
          fileMode_(false),
          hmacMode_(false) {
    tuneLayouts();
}

void HashWidget::tuneLayouts() {
    QVBoxLayout* mainLayout = new QVBoxLayout;
    QHBoxLayout* modeLayout = new QHBoxLayout;
    QHBoxLayout* settingsLayout = new QHBoxLayout;
    QVBoxLayout* middleLayout = new QVBoxLayout;

    fillModeLayout(modeLayout);
    fillSettingsLayout(settingsLayout);
    fillMiddleLayout(middleLayout);

    mainLayout->addLayout(modeLayout);
    mainLayout->addLayout(settingsLayout);
    mainLayout->addLayout(middleLayout);
    setLayout(mainLayout);
}

void HashWidget::fillModeLayout(QLayout* l) {
    l->addItem(new QSpacerItem(0, 0, QSizePolicy::Expanding, QSizePolicy::Minimum));
    QRadioButton* messageModeBtn = new QRadioButton(tr("Message"), this);
    QRadioButton* fileModeBtn = new QRadioButton(tr("File"), this);
    l->addWidget(messageModeBtn);
    l->addWidget(fileModeBtn);

    connect(messageModeBtn, &QRadioButton::clicked, this, &HashWidget::activateMessageMode);
    connect(fileModeBtn, &QRadioButton::clicked, this, &HashWidget::activateFileMode);
}

void HashWidget::activateMessageMode() {
    fileMode_ = false;
    emit messageModeActivated(true);
    emit fileModeActivated(false);
    toStatusBar(statusBar_, "Message mode activated. Type message to hash.");
    genHashLineEdit_->setText(tr("Calculated hash will be displayed here"));
    emit canHash(true);
}

void HashWidget::activateFileMode() {
    fileMode_ = true;
    emit fileModeActivated(true);
    emit messageModeActivated(false);
    toStatusBar(statusBar_, "File mode activated. Load file to hash.");
    genHashLineEdit_->setText(tr("Calculated hash will be displayed here"));
    emit canHash(false);
    loadedFileName_->setText(tr("No loaded file"));
}

void HashWidget::fillSettingsLayout(QLayout* l) {
    l->addItem(new QSpacerItem(0, 0, QSizePolicy::Expanding, QSizePolicy::Minimum));
    QCheckBox* hmacBtn = new QCheckBox(tr("HMAC"), this);
    l->addWidget(hmacBtn);

    connect(hmacBtn, &QCheckBox::stateChanged, this, &HashWidget::activateHmac);
}

void HashWidget::activateHmac(int status) {
    switch (status) {
        case Qt::Checked :
            hmacMode_ = true;
            emit hmac(true);
            toStatusBar(statusBar_, tr("HMAC mode activated. You may hash data with key."));
            hmacKeyLineEdit_->setEnabled(true);
            hmacKeyLineEdit_->setText(tr("Insert HMAC key..."));
            break;
        case Qt::Unchecked :
            hmacMode_ = false;
            emit hmac(false);
            toStatusBar(statusBar_, tr("HMAC mode deactivated."));
            hmacKeyLineEdit_->setEnabled(false);
            break;
        case Qt::PartiallyChecked : break;
    }
}

void HashWidget::fillMiddleLayout(QLayout* l) {
    hashingMsg_ = new QTextEdit(tr("Type message to hash..."), this);
    hashingMsg_->setEnabled(false);
    QPushButton* loadFileBtn = new QPushButton(tr("Load file"), this);
    loadFileBtn->setEnabled(false);
    loadedFileName_ = new QLabel(tr("No file loaded."), this);
    loadedFileName_->setEnabled(false);
    hmacKeyLineEdit_ = new QLineEdit(tr("Insert HMAC key..."), this);
    hmacKeyLineEdit_->setEnabled(false);
    QPushButton* genHashBtn = new QPushButton(tr("Calculate hash"), this);
    genHashBtn->setEnabled(false);
    genHashLineEdit_ = new QLineEdit(tr("Calculated hash will be displayed here"), this);
    genHashLineEdit_->setReadOnly(true);

    l->addWidget(hashingMsg_);
    l->addWidget(loadFileBtn);
    l->addWidget(loadedFileName_);
    l->addWidget(hmacKeyLineEdit_);
    l->addWidget(genHashBtn);
    l->addWidget(genHashLineEdit_);

    connect(this, &HashWidget::messageModeActivated, hashingMsg_, &QTextEdit::setEnabled);
    connect(this, &HashWidget::fileModeActivated, loadFileBtn, &QPushButton::setEnabled);
    connect(loadFileBtn, &QPushButton::clicked, this, &HashWidget::loadHashingFile);
    connect(this, &HashWidget::fileModeActivated, loadedFileName_, &QLabel::setEnabled);
    connect(this, &HashWidget::canHash, genHashBtn, &QPushButton::setEnabled);
    connect(genHashBtn, &QPushButton::clicked, this, &HashWidget::calculateHash);
}

void HashWidget::calculateHash() {
    if (!fileMode_) {
        auto s = hashingMsg_->toPlainText().toStdString();
        hashingData_.assign(s.begin(), s.end());
    }
    cscrypto::Hash hash;
    if (hmacMode_) {
        std::vector<uint8_t> hmacKey;
        auto s = hmacKeyLineEdit_->text().toStdString();
        hmacKey.assign(s.begin(), s.end());
        hash = cscrypto::calculateHash(hashingData_.data(), hashingData_.size(), hmacKey.data(), hmacKey.size());
    }
    else {
        hash = cscrypto::calculateHash(hashingData_.data(), hashingData_.size());
    }
    genHashLineEdit_->setText(QString::fromUtf8(EncodeBase58(hash.data(), hash.data() + hash.size()).c_str()));
    toStatusBar(statusBar_, tr("Hash has been calculated."));
}

void HashWidget::loadHashingFile() {
    QString fileName = QFileDialog::getOpenFileName(this, tr("Choose file to hash"));
    if (fileName.isEmpty()) {
        toStatusBar(statusBar_, tr("No file chosen!"));
        return;
    }
    std::ifstream f(fileName.toStdString());
    if (!f.is_open()) {
        toStatusBar(statusBar_, tr("Unable to open file!"));
        return;
    }
    std::stringstream ss;
    ss << f.rdbuf();
    auto s = ss.str();
    hashingData_.assign(s.begin(), s.end());
    toStatusBar(statusBar_, tr("File loaded."));
    loadedFileName_->setText(fileName);
    emit canHash(true);
}
} // namespace gui
} // namespace cscrypto```
# ..\node\cscrypto\qt\src\keygenwidget.cpp 
```cpp 
#include "keygenwidget.hpp"

#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QDialog>
#include <QFileDialog>
#include <QFile>
#include <QTextStream>
#include <QLineEdit>
#include <QSpacerItem>
#include <QListWidget>
#include <QStatusBar>
#include <QMessageBox>

#include <sstream>
#include <string>
#include <cstring>
#include <iostream>

#include <base58.h>
#include <utils.hpp>

namespace {
bool findWordInDictionary(const char* word, size_t& index) {
    using cscrypto::mnemonic::langs::en;
    bool found = false;
    for (size_t i = 0; i < en.size(); ++i) {
        if (std::strcmp(word, en[i]) == 0) {
            found = true;
            index = i;
        }
    }
    return found;
}
} // namespace

namespace cscrypto {
namespace gui {

KeyGenWidget::KeyGenWidget(QStatusBar& statusBar,
                           std::vector<KeyPair>& keys,
                           QWidget* parent)
        : QWidget(parent),
          typeSeedDialog_(new QDialog(this)),
          seedMsBox_(new QMessageBox(this)),
          statusBar_(statusBar),
          nextKeyId_(0),
          keys_(keys) {
    seedMsBox_->setWindowTitle(tr("Seed phrase"));
    setupTypeSeedDia();
    tuneLayouts();
}

void KeyGenWidget::tuneLayouts() {
    QVBoxLayout* mainLayout = new QVBoxLayout;
    QHBoxLayout* mainHLayout = new QHBoxLayout;
    QVBoxLayout* mainLeftLayout = new QVBoxLayout;
    QVBoxLayout* mainRightLayout = new QVBoxLayout;
    QHBoxLayout* mainLowLayout = new QHBoxLayout;

    QVBoxLayout* seedLayout = new QVBoxLayout;
    QVBoxLayout* keysLayout = new QVBoxLayout;
    QVBoxLayout* keyListLayout = new QVBoxLayout;

    fillKeyListLayout(keyListLayout);
    fillSeedLayout(seedLayout);
    fillKeyLayout(keysLayout);
    fillMainLowLayout(mainLowLayout);

    mainHLayout->addLayout(mainLeftLayout);
    mainHLayout->addLayout(mainRightLayout);

    mainLeftLayout->addLayout(seedLayout);
    mainLeftLayout->addLayout(keysLayout);
    mainLeftLayout->addItem(new QSpacerItem(0, 0,
                            QSizePolicy::Policy::Minimum,
                            QSizePolicy::Policy::Expanding));

    mainRightLayout->addLayout(keyListLayout);

    mainLayout->addLayout(mainHLayout);
    mainLayout->addLayout(mainLowLayout);
    setLayout(mainLayout);
}

void KeyGenWidget::fillKeyListLayout(QLayout* l) {
    QLabel* lbl = new QLabel(this);
    lbl->setText(tr("Available keys:"));
    l->addWidget(lbl);

    keysList_ = new QListWidget(this);
    l->addWidget(keysList_);
}

void KeyGenWidget::fillMainLowLayout(QLayout* l) {
    l->addItem(new QSpacerItem(0, 0, QSizePolicy::Policy::Expanding,
                               QSizePolicy::Policy::Minimum));

    QPushButton* b1 = new QPushButton(tr("Dump key"), this);
    b1->setEnabled(false);

    QPushButton* b2 = new QPushButton(tr("Dump seed"), this);
    b2->setEnabled(false);

    QPushButton* b3 = new QPushButton(tr("Show seed"), this);
    b3->setEnabled(false);

    l->addWidget(b3);
    l->addWidget(b2);
    l->addWidget(b1);

    connect(b3, &QPushButton::clicked, this, &KeyGenWidget::setSeedOnMsBox);
    connect(b3, &QPushButton::clicked, seedMsBox_, &QMessageBox::show);
    connect(this, &KeyGenWidget::enableKeyGen, b3, &QPushButton::setEnabled);

    connect(b2, &QPushButton::clicked, this, &KeyGenWidget::saveSeedToFile);
    connect(this, &KeyGenWidget::enableKeyGen, b2, &QPushButton::setEnabled);

    connect(keysList_, &QListWidget::itemClicked, b1, &QPushButton::setEnabled);
    connect(b1, &QPushButton::clicked, this, &KeyGenWidget::dumpKeysToFile);
}

void KeyGenWidget::dumpKeysToFile() {
    QString fileName = QFileDialog::getSaveFileName(this,
                                                    tr("Choose file to dump keys"), "",
                                                    tr("key file(*.json)"));
    if (fileName.isEmpty()) {
        toStatusBar(statusBar_, tr("File was not selected!"));
        return;
    }
    QFile f(fileName);
    if (!f.open(QIODevice::WriteOnly)) {
        toStatusBar(statusBar_, tr("Unable to open file!"));
        return;
    }

    auto keyPair = keys_[size_t(keysList_->currentRow())];
    QString s = "{\"key\":{\"public\":\"";
    s += QString::fromUtf8(EncodeBase58(keyPair.first.data(),
                                        keyPair.first.data() + keyPair.first.size()).c_str());
    s += "\",\"private\":\"";
    auto sk = keyPair.second.access();
    s += QString::fromUtf8(EncodeBase58(sk.data(), sk.data() + sk.size()).c_str());
    s += "\"}}";
    QTextStream out(&f);
    out << s;
    toStatusBar(statusBar_, tr("Keys have been saved to file."));
}

void KeyGenWidget::fillSeedLayout(QLayout* l) {
    QLabel* label = new QLabel(this);
    label->setText(tr("Master seed:"));
    l->addWidget(label);

    QPushButton* b1 = new QPushButton(this);
    b1->setText(tr("generate new seed"));
    l->addWidget(b1);
    connect(b1, &QPushButton::clicked, this, &KeyGenWidget::genNewSeed);

    QPushButton* b2 = new QPushButton(this);
    b2->setText(tr("load seed file"));
    l->addWidget(b2);
    connect(b2, &QPushButton::clicked, this, &KeyGenWidget::loadSeedFromFile);

    QPushButton* b3 = new QPushButton(this);
    b3->setText(tr("type seed phrase"));
    l->addWidget(b3);
    connect(b3, &QPushButton::clicked, typeSeedDialog_, &QDialog::show);

    connect(this, SIGNAL(enableNewSeed(bool)), label, SLOT(setEnabled(bool)));
    connect(this, SIGNAL(enableNewSeed(bool)), b1, SLOT(setEnabled(bool)));
    connect(this, SIGNAL(enableNewSeed(bool)), b2, SLOT(setEnabled(bool)));
    connect(this, SIGNAL(enableNewSeed(bool)), b3, SLOT(setEnabled(bool)));
}

void KeyGenWidget::setupTypeSeedDia() {
    typeSeedDialog_->setWindowTitle(tr("Seed input"));
    QVBoxLayout* mainLayout = new QVBoxLayout;

    QLabel* lbl = new QLabel(typeSeedDialog_);
    lbl->setText(tr("24 words devided with spaces:"));
    mainLayout->addWidget(lbl);

    seedLineEdit_ = new QLineEdit(typeSeedDialog_);
    mainLayout->addWidget(seedLineEdit_);
    typeSeedDialog_->setLayout(mainLayout);

    QHBoxLayout* lowLayout = new QHBoxLayout;
    mainLayout->addLayout(lowLayout);

    lowLayout->addItem(new QSpacerItem(0, 0, QSizePolicy::Policy::Expanding));
    QPushButton* b = new QPushButton(typeSeedDialog_);
    b->setText(tr("Ok"));
    lowLayout->addWidget(b);

    connect(b, SIGNAL(clicked()), typeSeedDialog_, SLOT(close()));
    connect(b, &QPushButton::clicked, this, &KeyGenWidget::handleInputSeed);
}

void KeyGenWidget::handleInputSeed() {
    fillMasterSeedFromString(seedLineEdit_->text());
}

void KeyGenWidget::fillMasterSeedFromString(const QString& s) {
    using cscrypto::mnemonic::langs::en;
    std::istringstream ss(s.toStdString());
    cscrypto::mnemonic::WordList res;
    bool allValid = true;

    for (auto it = res.begin(); it != res.end(); ++it) {
        if (!ss) {
            allValid = false;
            break;
        }
        std::string word;
        ss >> word;
        size_t index;
        if (!findWordInDictionary(word.c_str(), index)) {
            allValid = false;
            break;
        }
        *it = en[index];
    }

    if (allValid) {
        emit enableKeyGen(true);
        emit enableNewSeed(false);
        toStatusBar(statusBar_, tr("Seed phrase is correct."));
        masterSeed_ = cscrypto::mnemonic::wordsToMasterSeed(res);
    }
    else {
        toStatusBar(statusBar_, tr("Incorrect seed phrase!"));
        disableKeyGen();
    }
}

void KeyGenWidget::loadSeedFromFile() {
    QString fileName = QFileDialog::getOpenFileName(this,
                                                    tr("Choose file to load seed phrase from"), "",
                                                    tr("seed phrase (*.txt)"));
    if (fileName.isEmpty()) {
        toStatusBar(statusBar_, tr("File was not selected!"));
    }
    else {
        QFile f(fileName);
        if (!f.open(QIODevice::ReadOnly)) {
            toStatusBar(statusBar_, tr("Unable to open file!"));
            return;
        }
        QTextStream in(&f);
        fillMasterSeedFromString(in.readAll());
    }
}

void KeyGenWidget::fillKeyLayout(QLayout* l) {
    QLabel* label = new QLabel(this);
    label->setText(tr("Keys generation:"));
    label->setEnabled(false);
    l->addWidget(label);

    QPushButton* b1 = new QPushButton(this);
    b1->setText(tr("another seed"));
    b1->setEnabled(false);
    l->addWidget(b1);

    QPushButton* b2 = new QPushButton(this);
    b2->setText(tr("key pair"));
    b2->setEnabled(false);
    l->addWidget(b2);
    connect(b2, &QPushButton::clicked, this, &KeyGenWidget::genKeyPair);

    QPushButton* b3 = new QPushButton(this);
    b3->setText(tr("public from private"));
    l->addWidget(b3);
    connect(b3, &QPushButton::clicked, this, &KeyGenWidget::genPublicFromPrivateDialog);

    connect(this, SIGNAL(enableKeyGen(bool)), label, SLOT(setEnabled(bool)));
    connect(this, SIGNAL(enableKeyGen(bool)), b1, SLOT(setEnabled(bool)));
    connect(this, SIGNAL(enableKeyGen(bool)), b2, SLOT(setEnabled(bool)));

    connect(b1, &QPushButton::clicked, this, &KeyGenWidget::disableKeyGen);
}

void KeyGenWidget::genPublicFromPrivateDialog() {
    QDialog* d = new QDialog(this);
    QVBoxLayout* l = new QVBoxLayout;
    QHBoxLayout* l1 = new QHBoxLayout;

    QLabel* lbl = new QLabel(d);
    lbl->setText(tr("Insert private key:"));
    l->addWidget(lbl);

    privateKeyLineEdit_ = new QLineEdit(d);
    l->addWidget(privateKeyLineEdit_);

    l1->addItem(new QSpacerItem(0, 0,
                                QSizePolicy::Policy::Expanding,
                                QSizePolicy::Policy::Minimum));
    QPushButton* b1 = new QPushButton(d);
    b1->setText(tr("Get public"));
    l1->addWidget(b1);
    l->addLayout(l1);

    connect(b1, &QPushButton::clicked, this, &KeyGenWidget::handlePrivKeyLine);
    connect(b1, &QPushButton::clicked, d, &QDialog::close);

    d->setLayout(l);
    d->show();
}

void KeyGenWidget::handlePrivKeyLine() {
    QString privStr = privateKeyLineEdit_->text();
    std::vector<uint8_t> vecPriv;
    if (!DecodeBase58(privStr.toStdString(), vecPriv) || vecPriv.size() != cscrypto::kPrivateKeySize) {
        toStatusBar(statusBar_, tr("Incorrect private key passed!"));
        return;
    }

    KeyPair keys;
    keys.second = cscrypto::PrivateKey::readFromBytes(vecPriv);
    keys.first = cscrypto::getMatchingPublic(keys.second);
    keys_.push_back(keys);
    emit newKeyAdded();

    QString s = QString::fromUtf8(EncodeBase58(keys.first.data(),
                                               keys.first.data() + keys.first.size()).c_str());
    keysList_->addItem(s);
    toStatusBar(statusBar_, tr("Public key was generated and added to available keys!"));
}

void KeyGenWidget::genKeyPair() {
    KeyPair newPair = cscrypto::keys_derivation::deriveKeyPair(masterSeed_, nextKeyId_++);
    keys_.push_back(newPair);
    emit newKeyAdded();

    QString s = QString::fromUtf8(EncodeBase58(newPair.first.data(),
                                               newPair.first.data() + newPair.first.size()).c_str());
    keysList_->addItem(s);
    toStatusBar(statusBar_, tr("New key pair has been generated."));
}

inline QString KeyGenWidget::getSeedString() {
    QString res;
    auto words = cscrypto::mnemonic::masterSeedToWords(masterSeed_);
    for (auto w : words) {
        res += w;
        res += ' ';
    }
    return res;
}

void KeyGenWidget::saveSeedToFile() {
    QString fileName = QFileDialog::getSaveFileName(this,
                                                    tr("Choose file to save seed phrase"), "",
                                                    tr("seed phrase(*.txt)"));
    if (fileName.isEmpty()) {
        toStatusBar(statusBar_, tr("File was not selected!"));
        return;
    }
    else {
        QFile f(fileName);
        if (!f.open(QIODevice::WriteOnly)) {
            toStatusBar(statusBar_, tr("Unable to open file!"));
            return;
        }
        QTextStream out(&f);
        out << getSeedString();
        toStatusBar(statusBar_, tr("Seed saved to file."));
    }
}

void KeyGenWidget::genNewSeed() {
    masterSeed_ = cscrypto::keys_derivation::generateMaterSeed();
    emit enableNewSeed(false);
    emit enableKeyGen(true);
    toStatusBar(statusBar_, tr("New seed has been generated! Save it to restore your keys in future."));
}

inline void KeyGenWidget::setSeedOnMsBox() {
    auto s = getSeedString();
    seedMsBox_->setText(s);
}

void KeyGenWidget::disableKeyGen() {
    emit enableNewSeed(true);
    emit enableKeyGen(false);
}
} // namespace gui
} // namespace cscrypto
```
# ..\node\cscrypto\qt\src\main.cpp 
```cpp 
#include <QApplication>
#include "mainwidget.hpp"

#include <iostream>

#include <cscrypto/cscrypto.hpp>

int main(int argc, char* argv[]) {
    if (!cscrypto::cryptoInit()) {
        std::cerr << "Crypto lib init error" << std::endl;
        return -1;
    }

    QApplication app(argc, argv);
    cscrypto::gui::MainWidget w;
    w.show();
    return app.exec();
}
```
# ..\node\cscrypto\qt\src\mainwidget.cpp 
```cpp 
#include "mainwidget.hpp"

#include <QVBoxLayout>
#include <QTabWidget>
#include <QSizePolicy>
#include <QStatusBar>

#include "keygenwidget.hpp"
#include "hashwidget.hpp"
#include "signwidget.hpp"
#include "cipherwidget.hpp"

namespace cscrypto {
namespace gui {

MainWidget::MainWidget(QWidget* parent)
        : QWidget(parent),
          tabs_(new QTabWidget(this)),
          statusBar_(new QStatusBar(this)) {
    fillWidgets();
    fillTabs();

    QVBoxLayout* mainLayout = new QVBoxLayout;

    mainLayout->addWidget(tabs_);
    mainLayout->addWidget(statusBar_);

    setLayout(mainLayout);
}

void MainWidget::fillTabs() {
    tabs_->setSizePolicy(QSizePolicy(QSizePolicy::Policy::Expanding,
                                     QSizePolicy::Policy::Expanding));

    for (const auto& w : widgets_) {
        tabs_->addTab(w.second, w.first);
    }
}

void MainWidget::fillWidgets() {
    auto ptr = new KeyGenWidget(*statusBar_, keys_, tabs_);
    widgets_.insert(std::make_pair("keygen", ptr));
    widgets_.insert(std::make_pair("sign", new SignWidget(*statusBar_, keys_, ptr, tabs_)));
    widgets_.insert(std::make_pair("hash", new HashWidget(*statusBar_, tabs_)));
//	  @TODO add when ciphering implemented in cscrypto
//    widgets_.insert(std::make_pair("cipher", new CipherWidget(tabs_)));
}

} // namespace gui
} // namespace cscrypto
```
# ..\node\cscrypto\qt\src\signwidget.cpp 
```cpp 
#include "signwidget.hpp"

#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QStatusBar>
#include <QSpacerItem>
#include <QRadioButton>
#include <QPushButton>
#include <QLabel>
#include <QTextEdit>
#include <QMessageBox>
#include <QDialog>
#include <QListWidget>
#include <QLineEdit>
#include <QCheckBox>
#include <QFileDialog>

#include <utils.hpp>
#include <keygenwidget.hpp>

#include <base58.h>

#include <fstream>
#include <sstream>
#include <algorithm>

namespace cscrypto {
namespace gui {

SignWidget::SignWidget(QStatusBar& statusBar,
                       std::vector<KeyPair>& keys,
                       const KeyGenWidget* keyGenerator,
                       QWidget* parent)
        : QWidget(parent),
          keysList_(new QListWidget(this)),
          statusBar_(statusBar),
          keys_(keys),
          fileMode_(false) {
    keysList_->hide();
    connect(keyGenerator, &KeyGenWidget::newKeyAdded, this, &SignWidget::addNewKey);
    tuneLayouts();
}

void SignWidget::addNewKey() {
    if (!keys_.empty()) {
        auto keyPair = keys_.back();
        keysList_->addItem(EncodeBase58(keyPair.first.data(),
                                        keyPair.first.data() + keyPair.first.size()).c_str());
    }
}

void SignWidget::tuneLayouts() {
    QVBoxLayout* mainLayout = new QVBoxLayout;

    QHBoxLayout* modeLayout = new QHBoxLayout;
    QHBoxLayout* keysLayout = new QHBoxLayout;
    QVBoxLayout* middleLayout = new QVBoxLayout;
    QHBoxLayout* lowLayout = new QHBoxLayout;

    mainLayout->addLayout(modeLayout);
    mainLayout->addLayout(keysLayout);
    mainLayout->addLayout(middleLayout);
    mainLayout->addLayout(lowLayout);

    fillModeLayout(modeLayout);
    fillKeysLayout(keysLayout);
    fillMiddleLayout(middleLayout);
    fillLowLayout(lowLayout);

    setLayout(mainLayout);
}

void SignWidget::fillModeLayout(QLayout* l) {
    l->addItem(new QSpacerItem(0, 0, QSizePolicy::Policy::Expanding,
                               QSizePolicy::Policy::Minimum));
    QRadioButton* signBtn = new QRadioButton(tr("Sign"), this);
    l->addWidget(signBtn);
    connect(signBtn, &QRadioButton::clicked, this, &SignWidget::activateSignMode);

    QRadioButton* verBtn = new QRadioButton(tr("Verify"), this);
    l->addWidget(verBtn);
    connect(verBtn, &QRadioButton::clicked, this, &SignWidget::activateVerificationMode);
}

void SignWidget::activateSignMode() {
    operatingKeyLine_->clear();
    signatureLine_->clear();
    if (keys_.empty()) {
        toStatusBar(statusBar_, tr("Sign mode activated. No private keys! Generate first!"));
    }
    else {
        toStatusBar(statusBar_, tr("Sign mode activated."));
    }
    emit enableSigning(true);
    emit enableVerification(false);
    emit canVerify(false);
}

void SignWidget::activateVerificationMode() {
    toStatusBar(statusBar_, tr("Verification mode activated."));
    emit enableSigning(false);
    emit enableVerification(true);
    emit canSign(false);
    emit canVerify(true);
    insertVerificationKey();
}

void SignWidget::fillKeysLayout(QLayout* l) {
    QPushButton* chooseKeyBtn = new QPushButton(tr("Choose signing key"), this);
    l->addWidget(chooseKeyBtn);
    l->addItem(new QSpacerItem(0, 0, QSizePolicy::Policy::Expanding,
                               QSizePolicy::Policy::Minimum));
    QCheckBox* fileModeChekBox = new QCheckBox(tr("File mode"), this);
    l->addWidget(fileModeChekBox);
    chooseKeyBtn->setEnabled(false);
    connect(this, &SignWidget::enableSigning, chooseKeyBtn, &QPushButton::setEnabled);
    connect(chooseKeyBtn, &QPushButton::clicked, this, &SignWidget::chooseSigningKey);
    connect(fileModeChekBox, &QCheckBox::stateChanged, this, &SignWidget::activateFileMode);
}

void SignWidget::activateFileMode(int value) {
    switch (value) {
        case Qt::Unchecked :
            signingMsg_->show();
            loadFileBtn_->hide();
            fileName_->hide();
            fileMode_ = false;
            toStatusBar(statusBar_, tr("File mode deactivated. Type message to sign/verify."));
            break;
        case Qt::Checked :
            signingMsg_->hide();
            loadFileBtn_->show();
            fileName_->show();
            fileMode_ = true;
            toStatusBar(statusBar_, tr("File mode activated. Load file to sign/verify."));
            break;
        case Qt::PartiallyChecked : break;
    }
}

void SignWidget::insertVerificationKey() {
    operatingKeyLine_->setText(tr("Insert public key to verify signature..."));
    emit canVerify(true);
}

void SignWidget::chooseSigningKey() {
    if (keys_.empty()) {
        QMessageBox::critical(this, tr("Error!"), tr("No private keys detected! Generate firts!"));
        return;
    }
    QDialog* choosingKeyDialog = new QDialog(this);
    choosingKeyDialog->setWindowTitle(tr("Singing key selecting"));
    QVBoxLayout* mainLayout = new QVBoxLayout();
    QHBoxLayout* lowLayout = new QHBoxLayout();

    QLabel* lbl = new QLabel(tr("Available signing keys:"), choosingKeyDialog);
    mainLayout->addWidget(lbl);
    mainLayout->addWidget(keysList_);
    keysList_->show();

    lowLayout->addItem(new QSpacerItem(0, 0, QSizePolicy::Policy::Expanding,
                                       QSizePolicy::Policy::Minimum));
    QPushButton* ok = new QPushButton(tr("Ok"), choosingKeyDialog);
    ok->setEnabled(false);

    connect(keysList_, &QListWidget::itemClicked, ok, &QPushButton::setEnabled);
    connect(ok, &QPushButton::clicked, this, &SignWidget::setSigningKey);
    connect(ok, &QPushButton::clicked, choosingKeyDialog, &QDialog::close);

    lowLayout->addWidget(ok);
    mainLayout->addLayout(lowLayout);
    choosingKeyDialog->setLayout(mainLayout);
    choosingKeyDialog->show();
}

void SignWidget::setSigningKey() {
    operatingKeyLine_->setText(keysList_->currentItem()->text());
    toStatusBar(statusBar_, tr("New operating key has been selected."));
    emit canSign(true);
}

void SignWidget::fillMiddleLayout(QLayout* l) {
    operatingKeyLine_ = new QLineEdit(tr("Operating key will be displayed here"), this);
    operatingKeyLine_->setReadOnly(true);
    signingMsg_ = new QTextEdit(tr("Type message to sign or verify..."));
    QLabel* lbl1 = new QLabel(tr("Signature:"), this);
    signatureLine_ = new QLineEdit(this);
    loadFileBtn_ = new QPushButton(tr("Load file to sing/verify"));
    loadFileBtn_->hide();
    fileName_ = new QLabel(tr("No file loaded."), this);
    fileName_->hide();

    connect(this, &SignWidget::enableSigning, signatureLine_, &QLineEdit::setReadOnly);
    connect(this, &SignWidget::enableSigning, operatingKeyLine_, &QLineEdit::setReadOnly);
    connect(loadFileBtn_, &QPushButton::clicked, this, &SignWidget::loadDataFromFile);

    l->addWidget(operatingKeyLine_);
    l->addWidget(signingMsg_);
    l->addWidget(loadFileBtn_);
    l->addWidget(fileName_);

    l->addItem(new QSpacerItem(0,0, QSizePolicy::Policy::Minimum,
                               QSizePolicy::Policy::Expanding));
    l->addWidget(lbl1);
    l->addWidget(signatureLine_);
}

void SignWidget::loadDataFromFile() {
    QString fileName = QFileDialog::getOpenFileName(this,
                                                    tr("Choose file to sign/verify signature"));
    if (fileName.isEmpty()) {
        toStatusBar(statusBar_, tr("File was not selected!"));
        return;
    }
    std::ifstream f(fileName.toStdString());
    if (!f.is_open()) {
        toStatusBar(statusBar_, tr("Unable to open file!"));
        return;
    }
    std::stringstream ss;
    ss << f.rdbuf();
    auto data = ss.str();
    auto hash = cscrypto::calculateHash(reinterpret_cast<cscrypto::Byte*>(data.data()), data.size());
    fileHash_.resize(hash.size());
    std::copy(fileHash_.begin(), fileHash_.end(), hash.begin());
    toStatusBar(statusBar_, tr("File was loaded!"));
    fileName_->setText(fileName);
}

void SignWidget::fillLowLayout(QLayout* l) {
    QPushButton* signBtn = new QPushButton(tr("Sign"), this);
    QPushButton* verifyBtn = new QPushButton(tr("Verify"), this);
    l->addWidget(signBtn);
    l->addWidget(verifyBtn);
    signBtn->setEnabled(false);
    verifyBtn->setEnabled(false);
    connect(this, &SignWidget::canSign, signBtn, &QPushButton::setEnabled);
    connect(this, &SignWidget::canVerify, verifyBtn, &QPushButton::setEnabled);
    connect(signBtn, &QPushButton::clicked, this, &SignWidget::signMsg);
    connect(verifyBtn, &QPushButton::clicked, this, &SignWidget::verifySignature);
}

void SignWidget::signMsg() {
    std::string msg;
    if (fileMode_) {
        msg = fileHash_;
    }
    else {
        msg = signingMsg_->toPlainText().toStdString();
    }
    if (msg.empty()) {
        toStatusBar(statusBar_, tr("Signing message is empty! Type it."));
        return;
    }
    auto signature = cscrypto::generateSignature(keys_[size_t(keysList_->currentRow())].second,
                                                 reinterpret_cast<cscrypto::Byte*>(msg.data()), msg.size());
    signatureLine_->setText(QString::fromUtf8(EncodeBase58(signature.data(), signature.data() + signature.size()).c_str()));
    toStatusBar(statusBar_, tr("Message signed. New signature has been generated."));
}

void SignWidget::verifySignature() {
    auto signature = signatureLine_->text().toStdString();
    if (signature.empty()) {
        toStatusBar(statusBar_, tr("No singature to verify! Insert signature first!"));
        return;
    }
    std::string msg;
    if (fileMode_) {
        msg = fileHash_;
    }
    else {
        msg = signingMsg_->toPlainText().toStdString();
    }
    if (msg.empty()) {
        toStatusBar(statusBar_, tr("Message is empty! Nothing to verify!"));
        return;
    }
    auto key = operatingKeyLine_->text().toStdString();
    if (key.empty()) {
        toStatusBar(statusBar_, tr("No public key provided! Insert verification key firts!"));
    }
    std::vector<uint8_t> sigBytes;
    if (!DecodeBase58(signature, sigBytes) || sigBytes.size() != cscrypto::kSignatureSize) {
        toStatusBar(statusBar_, tr("Incorrect signature!"));
        return;
    }
    std::vector<uint8_t> keyBytes;
    if (!DecodeBase58(key, keyBytes) || keyBytes.size() != cscrypto::kPublicKeySize) {
        toStatusBar(statusBar_, tr("Incorrect signature!"));
        return;
    }
    if (cscrypto::verifySignature(sigBytes.data(), keyBytes.data(),
                                  reinterpret_cast<cscrypto::Byte*>(msg.data()), msg.size())) {
        toStatusBar(statusBar_, tr("Correct signature!"));
        return;
    }
    toStatusBar(statusBar_, tr("Incorrect signature!"));
}
} // namespace gui
} // namespace cscrypto
```
# ..\node\cscrypto\src\dictionary_en.cpp 
```cpp 
#include <cscrypto/dictionary.hpp>

namespace cscrypto {
namespace mnemonic {
namespace langs {

const Dictionary en = {
    {
        "abandon",
        "ability",
        "able",
        "about",
        "above",
        "absent",
        "absorb",
        "abstract",
        "absurd",
        "abuse",
        "access",
        "accident",
        "account",
        "accuse",
        "achieve",
        "acid",
        "acoustic",
        "acquire",
        "across",
        "act",
        "action",
        "actor",
        "actress",
        "actual",
        "adapt",
        "add",
        "addict",
        "address",
        "adjust",
        "admit",
        "adult",
        "advance",
        "advice",
        "aerobic",
        "affair",
        "afford",
        "afraid",
        "again",
        "age",
        "agent",
        "agree",
        "ahead",
        "aim",
        "air",
        "airport",
        "aisle",
        "alarm",
        "album",
        "alcohol",
        "alert",
        "alien",
        "all",
        "alley",
        "allow",
        "almost",
        "alone",
        "alpha",
        "already",
        "also",
        "alter",
        "always",
        "amateur",
        "amazing",
        "among",
        "amount",
        "amused",
        "analyst",
        "anchor",
        "ancient",
        "anger",
        "angle",
        "angry",
        "animal",
        "ankle",
        "announce",
        "annual",
        "another",
        "answer",
        "antenna",
        "antique",
        "anxiety",
        "any",
        "apart",
        "apology",
        "appear",
        "apple",
        "approve",
        "april",
        "arch",
        "arctic",
        "area",
        "arena",
        "argue",
        "arm",
        "armed",
        "armor",
        "army",
        "around",
        "arrange",
        "arrest",
        "arrive",
        "arrow",
        "art",
        "artefact",
        "artist",
        "artwork",
        "ask",
        "aspect",
        "assault",
        "asset",
        "assist",
        "assume",
        "asthma",
        "athlete",
        "atom",
        "attack",
        "attend",
        "attitude",
        "attract",
        "auction",
        "audit",
        "august",
        "aunt",
        "author",
        "auto",
        "autumn",
        "average",
        "avocado",
        "avoid",
        "awake",
        "aware",
        "away",
        "awesome",
        "awful",
        "awkward",
        "axis",
        "baby",
        "bachelor",
        "bacon",
        "badge",
        "bag",
        "balance",
        "balcony",
        "ball",
        "bamboo",
        "banana",
        "banner",
        "bar",
        "barely",
        "bargain",
        "barrel",
        "base",
        "basic",
        "basket",
        "battle",
        "beach",
        "bean",
        "beauty",
        "because",
        "become",
        "beef",
        "before",
        "begin",
        "behave",
        "behind",
        "believe",
        "below",
        "belt",
        "bench",
        "benefit",
        "best",
        "betray",
        "better",
        "between",
        "beyond",
        "bicycle",
        "bid",
        "bike",
        "bind",
        "biology",
        "bird",
        "birth",
        "bitter",
        "black",
        "blade",
        "blame",
        "blanket",
        "blast",
        "bleak",
        "bless",
        "blind",
        "blood",
        "blossom",
        "blouse",
        "blue",
        "blur",
        "blush",
        "board",
        "boat",
        "body",
        "boil",
        "bomb",
        "bone",
        "bonus",
        "book",
        "boost",
        "border",
        "boring",
        "borrow",
        "boss",
        "bottom",
        "bounce",
        "box",
        "boy",
        "bracket",
        "brain",
        "brand",
        "brass",
        "brave",
        "bread",
        "breeze",
        "brick",
        "bridge",
        "brief",
        "bright",
        "bring",
        "brisk",
        "broccoli",
        "broken",
        "bronze",
        "broom",
        "brother",
        "brown",
        "brush",
        "bubble",
        "buddy",
        "budget",
        "buffalo",
        "build",
        "bulb",
        "bulk",
        "bullet",
        "bundle",
        "bunker",
        "burden",
        "burger",
        "burst",
        "bus",
        "business",
        "busy",
        "butter",
        "buyer",
        "buzz",
        "cabbage",
        "cabin",
        "cable",
        "cactus",
        "cage",
        "cake",
        "call",
        "calm",
        "camera",
        "camp",
        "can",
        "canal",
        "cancel",
        "candy",
        "cannon",
        "canoe",
        "canvas",
        "canyon",
        "capable",
        "capital",
        "captain",
        "car",
        "carbon",
        "card",
        "cargo",
        "carpet",
        "carry",
        "cart",
        "case",
        "cash",
        "casino",
        "castle",
        "casual",
        "cat",
        "catalog",
        "catch",
        "category",
        "cattle",
        "caught",
        "cause",
        "caution",
        "cave",
        "ceiling",
        "celery",
        "cement",
        "census",
        "century",
        "cereal",
        "certain",
        "chair",
        "chalk",
        "champion",
        "change",
        "chaos",
        "chapter",
        "charge",
        "chase",
        "chat",
        "cheap",
        "check",
        "cheese",
        "chef",
        "cherry",
        "chest",
        "chicken",
        "chief",
        "child",
        "chimney",
        "choice",
        "choose",
        "chronic",
        "chuckle",
        "chunk",
        "churn",
        "cigar",
        "cinnamon",
        "circle",
        "citizen",
        "city",
        "civil",
        "claim",
        "clap",
        "clarify",
        "claw",
        "clay",
        "clean",
        "clerk",
        "clever",
        "click",
        "client",
        "cliff",
        "climb",
        "clinic",
        "clip",
        "clock",
        "clog",
        "close",
        "cloth",
        "cloud",
        "clown",
        "club",
        "clump",
        "cluster",
        "clutch",
        "coach",
        "coast",
        "coconut",
        "code",
        "coffee",
        "coil",
        "coin",
        "collect",
        "color",
        "column",
        "combine",
        "come",
        "comfort",
        "comic",
        "common",
        "company",
        "concert",
        "conduct",
        "confirm",
        "congress",
        "connect",
        "consider",
        "control",
        "convince",
        "cook",
        "cool",
        "copper",
        "copy",
        "coral",
        "core",
        "corn",
        "correct",
        "cost",
        "cotton",
        "couch",
        "country",
        "couple",
        "course",
        "cousin",
        "cover",
        "coyote",
        "crack",
        "cradle",
        "craft",
        "cram",
        "crane",
        "crash",
        "crater",
        "crawl",
        "crazy",
        "cream",
        "credit",
        "creek",
        "crew",
        "cricket",
        "crime",
        "crisp",
        "critic",
        "crop",
        "cross",
        "crouch",
        "crowd",
        "crucial",
        "cruel",
        "cruise",
        "crumble",
        "crunch",
        "crush",
        "cry",
        "crystal",
        "cube",
        "culture",
        "cup",
        "cupboard",
        "curious",
        "current",
        "curtain",
        "curve",
        "cushion",
        "custom",
        "cute",
        "cycle",
        "dad",
        "damage",
        "damp",
        "dance",
        "danger",
        "daring",
        "dash",
        "daughter",
        "dawn",
        "day",
        "deal",
        "debate",
        "debris",
        "decade",
        "december",
        "decide",
        "decline",
        "decorate",
        "decrease",
        "deer",
        "defense",
        "define",
        "defy",
        "degree",
        "delay",
        "deliver",
        "demand",
        "demise",
        "denial",
        "dentist",
        "deny",
        "depart",
        "depend",
        "deposit",
        "depth",
        "deputy",
        "derive",
        "describe",
        "desert",
        "design",
        "desk",
        "despair",
        "destroy",
        "detail",
        "detect",
        "develop",
        "device",
        "devote",
        "diagram",
        "dial",
        "diamond",
        "diary",
        "dice",
        "diesel",
        "diet",
        "differ",
        "digital",
        "dignity",
        "dilemma",
        "dinner",
        "dinosaur",
        "direct",
        "dirt",
        "disagree",
        "discover",
        "disease",
        "dish",
        "dismiss",
        "disorder",
        "display",
        "distance",
        "divert",
        "divide",
        "divorce",
        "dizzy",
        "doctor",
        "document",
        "dog",
        "doll",
        "dolphin",
        "domain",
        "donate",
        "donkey",
        "donor",
        "door",
        "dose",
        "double",
        "dove",
        "draft",
        "dragon",
        "drama",
        "drastic",
        "draw",
        "dream",
        "dress",
        "drift",
        "drill",
        "drink",
        "drip",
        "drive",
        "drop",
        "drum",
        "dry",
        "duck",
        "dumb",
        "dune",
        "during",
        "dust",
        "dutch",
        "duty",
        "dwarf",
        "dynamic",
        "eager",
        "eagle",
        "early",
        "earn",
        "earth",
        "easily",
        "east",
        "easy",
        "echo",
        "ecology",
        "economy",
        "edge",
        "edit",
        "educate",
        "effort",
        "egg",
        "eight",
        "either",
        "elbow",
        "elder",
        "electric",
        "elegant",
        "element",
        "elephant",
        "elevator",
        "elite",
        "else",
        "embark",
        "embody",
        "embrace",
        "emerge",
        "emotion",
        "employ",
        "empower",
        "empty",
        "enable",
        "enact",
        "end",
        "endless",
        "endorse",
        "enemy",
        "energy",
        "enforce",
        "engage",
        "engine",
        "enhance",
        "enjoy",
        "enlist",
        "enough",
        "enrich",
        "enroll",
        "ensure",
        "enter",
        "entire",
        "entry",
        "envelope",
        "episode",
        "equal",
        "equip",
        "era",
        "erase",
        "erode",
        "erosion",
        "error",
        "erupt",
        "escape",
        "essay",
        "essence",
        "estate",
        "eternal",
        "ethics",
        "evidence",
        "evil",
        "evoke",
        "evolve",
        "exact",
        "example",
        "excess",
        "exchange",
        "excite",
        "exclude",
        "excuse",
        "execute",
        "exercise",
        "exhaust",
        "exhibit",
        "exile",
        "exist",
        "exit",
        "exotic",
        "expand",
        "expect",
        "expire",
        "explain",
        "expose",
        "express",
        "extend",
        "extra",
        "eye",
        "eyebrow",
        "fabric",
        "face",
        "faculty",
        "fade",
        "faint",
        "faith",
        "fall",
        "false",
        "fame",
        "family",
        "famous",
        "fan",
        "fancy",
        "fantasy",
        "farm",
        "fashion",
        "fat",
        "fatal",
        "father",
        "fatigue",
        "fault",
        "favorite",
        "feature",
        "february",
        "federal",
        "fee",
        "feed",
        "feel",
        "female",
        "fence",
        "festival",
        "fetch",
        "fever",
        "few",
        "fiber",
        "fiction",
        "field",
        "figure",
        "file",
        "film",
        "filter",
        "final",
        "find",
        "fine",
        "finger",
        "finish",
        "fire",
        "firm",
        "first",
        "fiscal",
        "fish",
        "fit",
        "fitness",
        "fix",
        "flag",
        "flame",
        "flash",
        "flat",
        "flavor",
        "flee",
        "flight",
        "flip",
        "float",
        "flock",
        "floor",
        "flower",
        "fluid",
        "flush",
        "fly",
        "foam",
        "focus",
        "fog",
        "foil",
        "fold",
        "follow",
        "food",
        "foot",
        "force",
        "forest",
        "forget",
        "fork",
        "fortune",
        "forum",
        "forward",
        "fossil",
        "foster",
        "found",
        "fox",
        "fragile",
        "frame",
        "frequent",
        "fresh",
        "friend",
        "fringe",
        "frog",
        "front",
        "frost",
        "frown",
        "frozen",
        "fruit",
        "fuel",
        "fun",
        "funny",
        "furnace",
        "fury",
        "future",
        "gadget",
        "gain",
        "galaxy",
        "gallery",
        "game",
        "gap",
        "garage",
        "garbage",
        "garden",
        "garlic",
        "garment",
        "gas",
        "gasp",
        "gate",
        "gather",
        "gauge",
        "gaze",
        "general",
        "genius",
        "genre",
        "gentle",
        "genuine",
        "gesture",
        "ghost",
        "giant",
        "gift",
        "giggle",
        "ginger",
        "giraffe",
        "girl",
        "give",
        "glad",
        "glance",
        "glare",
        "glass",
        "glide",
        "glimpse",
        "globe",
        "gloom",
        "glory",
        "glove",
        "glow",
        "glue",
        "goat",
        "goddess",
        "gold",
        "good",
        "goose",
        "gorilla",
        "gospel",
        "gossip",
        "govern",
        "gown",
        "grab",
        "grace",
        "grain",
        "grant",
        "grape",
        "grass",
        "gravity",
        "great",
        "green",
        "grid",
        "grief",
        "grit",
        "grocery",
        "group",
        "grow",
        "grunt",
        "guard",
        "guess",
        "guide",
        "guilt",
        "guitar",
        "gun",
        "gym",
        "habit",
        "hair",
        "half",
        "hammer",
        "hamster",
        "hand",
        "happy",
        "harbor",
        "hard",
        "harsh",
        "harvest",
        "hat",
        "have",
        "hawk",
        "hazard",
        "head",
        "health",
        "heart",
        "heavy",
        "hedgehog",
        "height",
        "hello",
        "helmet",
        "help",
        "hen",
        "hero",
        "hidden",
        "high",
        "hill",
        "hint",
        "hip",
        "hire",
        "history",
        "hobby",
        "hockey",
        "hold",
        "hole",
        "holiday",
        "hollow",
        "home",
        "honey",
        "hood",
        "hope",
        "horn",
        "horror",
        "horse",
        "hospital",
        "host",
        "hotel",
        "hour",
        "hover",
        "hub",
        "huge",
        "human",
        "humble",
        "humor",
        "hundred",
        "hungry",
        "hunt",
        "hurdle",
        "hurry",
        "hurt",
        "husband",
        "hybrid",
        "ice",
        "icon",
        "idea",
        "identify",
        "idle",
        "ignore",
        "ill",
        "illegal",
        "illness",
        "image",
        "imitate",
        "immense",
        "immune",
        "impact",
        "impose",
        "improve",
        "impulse",
        "inch",
        "include",
        "income",
        "increase",
        "index",
        "indicate",
        "indoor",
        "industry",
        "infant",
        "inflict",
        "inform",
        "inhale",
        "inherit",
        "initial",
        "inject",
        "injury",
        "inmate",
        "inner",
        "innocent",
        "input",
        "inquiry",
        "insane",
        "insect",
        "inside",
        "inspire",
        "install",
        "intact",
        "interest",
        "into",
        "invest",
        "invite",
        "involve",
        "iron",
        "island",
        "isolate",
        "issue",
        "item",
        "ivory",
        "jacket",
        "jaguar",
        "jar",
        "jazz",
        "jealous",
        "jeans",
        "jelly",
        "jewel",
        "job",
        "join",
        "joke",
        "journey",
        "joy",
        "judge",
        "juice",
        "jump",
        "jungle",
        "junior",
        "junk",
        "just",
        "kangaroo",
        "keen",
        "keep",
        "ketchup",
        "key",
        "kick",
        "kid",
        "kidney",
        "kind",
        "kingdom",
        "kiss",
        "kit",
        "kitchen",
        "kite",
        "kitten",
        "kiwi",
        "knee",
        "knife",
        "knock",
        "know",
        "lab",
        "label",
        "labor",
        "ladder",
        "lady",
        "lake",
        "lamp",
        "language",
        "laptop",
        "large",
        "later",
        "latin",
        "laugh",
        "laundry",
        "lava",
        "law",
        "lawn",
        "lawsuit",
        "layer",
        "lazy",
        "leader",
        "leaf",
        "learn",
        "leave",
        "lecture",
        "left",
        "leg",
        "legal",
        "legend",
        "leisure",
        "lemon",
        "lend",
        "length",
        "lens",
        "leopard",
        "lesson",
        "letter",
        "level",
        "liar",
        "liberty",
        "library",
        "license",
        "life",
        "lift",
        "light",
        "like",
        "limb",
        "limit",
        "link",
        "lion",
        "liquid",
        "list",
        "little",
        "live",
        "lizard",
        "load",
        "loan",
        "lobster",
        "local",
        "lock",
        "logic",
        "lonely",
        "long",
        "loop",
        "lottery",
        "loud",
        "lounge",
        "love",
        "loyal",
        "lucky",
        "luggage",
        "lumber",
        "lunar",
        "lunch",
        "luxury",
        "lyrics",
        "machine",
        "mad",
        "magic",
        "magnet",
        "maid",
        "mail",
        "main",
        "major",
        "make",
        "mammal",
        "man",
        "manage",
        "mandate",
        "mango",
        "mansion",
        "manual",
        "maple",
        "marble",
        "march",
        "margin",
        "marine",
        "market",
        "marriage",
        "mask",
        "mass",
        "master",
        "match",
        "material",
        "math",
        "matrix",
        "matter",
        "maximum",
        "maze",
        "meadow",
        "mean",
        "measure",
        "meat",
        "mechanic",
        "medal",
        "media",
        "melody",
        "melt",
        "member",
        "memory",
        "mention",
        "menu",
        "mercy",
        "merge",
        "merit",
        "merry",
        "mesh",
        "message",
        "metal",
        "method",
        "middle",
        "midnight",
        "milk",
        "million",
        "mimic",
        "mind",
        "minimum",
        "minor",
        "minute",
        "miracle",
        "mirror",
        "misery",
        "miss",
        "mistake",
        "mix",
        "mixed",
        "mixture",
        "mobile",
        "model",
        "modify",
        "mom",
        "moment",
        "monitor",
        "monkey",
        "monster",
        "month",
        "moon",
        "moral",
        "more",
        "morning",
        "mosquito",
        "mother",
        "motion",
        "motor",
        "mountain",
        "mouse",
        "move",
        "movie",
        "much",
        "muffin",
        "mule",
        "multiply",
        "muscle",
        "museum",
        "mushroom",
        "music",
        "must",
        "mutual",
        "myself",
        "mystery",
        "myth",
        "naive",
        "name",
        "napkin",
        "narrow",
        "nasty",
        "nation",
        "nature",
        "near",
        "neck",
        "need",
        "negative",
        "neglect",
        "neither",
        "nephew",
        "nerve",
        "nest",
        "net",
        "network",
        "neutral",
        "never",
        "news",
        "next",
        "nice",
        "night",
        "noble",
        "noise",
        "nominee",
        "noodle",
        "normal",
        "north",
        "nose",
        "notable",
        "note",
        "nothing",
        "notice",
        "novel",
        "now",
        "nuclear",
        "number",
        "nurse",
        "nut",
        "oak",
        "obey",
        "object",
        "oblige",
        "obscure",
        "observe",
        "obtain",
        "obvious",
        "occur",
        "ocean",
        "october",
        "odor",
        "off",
        "offer",
        "office",
        "often",
        "oil",
        "okay",
        "old",
        "olive",
        "olympic",
        "omit",
        "once",
        "one",
        "onion",
        "online",
        "only",
        "open",
        "opera",
        "opinion",
        "oppose",
        "option",
        "orange",
        "orbit",
        "orchard",
        "order",
        "ordinary",
        "organ",
        "orient",
        "original",
        "orphan",
        "ostrich",
        "other",
        "outdoor",
        "outer",
        "output",
        "outside",
        "oval",
        "oven",
        "over",
        "own",
        "owner",
        "oxygen",
        "oyster",
        "ozone",
        "pact",
        "paddle",
        "page",
        "pair",
        "palace",
        "palm",
        "panda",
        "panel",
        "panic",
        "panther",
        "paper",
        "parade",
        "parent",
        "park",
        "parrot",
        "party",
        "pass",
        "patch",
        "path",
        "patient",
        "patrol",
        "pattern",
        "pause",
        "pave",
        "payment",
        "peace",
        "peanut",
        "pear",
        "peasant",
        "pelican",
        "pen",
        "penalty",
        "pencil",
        "people",
        "pepper",
        "perfect",
        "permit",
        "person",
        "pet",
        "phone",
        "photo",
        "phrase",
        "physical",
        "piano",
        "picnic",
        "picture",
        "piece",
        "pig",
        "pigeon",
        "pill",
        "pilot",
        "pink",
        "pioneer",
        "pipe",
        "pistol",
        "pitch",
        "pizza",
        "place",
        "planet",
        "plastic",
        "plate",
        "play",
        "please",
        "pledge",
        "pluck",
        "plug",
        "plunge",
        "poem",
        "poet",
        "point",
        "polar",
        "pole",
        "police",
        "pond",
        "pony",
        "pool",
        "popular",
        "portion",
        "position",
        "possible",
        "post",
        "potato",
        "pottery",
        "poverty",
        "powder",
        "power",
        "practice",
        "praise",
        "predict",
        "prefer",
        "prepare",
        "present",
        "pretty",
        "prevent",
        "price",
        "pride",
        "primary",
        "print",
        "priority",
        "prison",
        "private",
        "prize",
        "problem",
        "process",
        "produce",
        "profit",
        "program",
        "project",
        "promote",
        "proof",
        "property",
        "prosper",
        "protect",
        "proud",
        "provide",
        "public",
        "pudding",
        "pull",
        "pulp",
        "pulse",
        "pumpkin",
        "punch",
        "pupil",
        "puppy",
        "purchase",
        "purity",
        "purpose",
        "purse",
        "push",
        "put",
        "puzzle",
        "pyramid",
        "quality",
        "quantum",
        "quarter",
        "question",
        "quick",
        "quit",
        "quiz",
        "quote",
        "rabbit",
        "raccoon",
        "race",
        "rack",
        "radar",
        "radio",
        "rail",
        "rain",
        "raise",
        "rally",
        "ramp",
        "ranch",
        "random",
        "range",
        "rapid",
        "rare",
        "rate",
        "rather",
        "raven",
        "raw",
        "razor",
        "ready",
        "real",
        "reason",
        "rebel",
        "rebuild",
        "recall",
        "receive",
        "recipe",
        "record",
        "recycle",
        "reduce",
        "reflect",
        "reform",
        "refuse",
        "region",
        "regret",
        "regular",
        "reject",
        "relax",
        "release",
        "relief",
        "rely",
        "remain",
        "remember",
        "remind",
        "remove",
        "render",
        "renew",
        "rent",
        "reopen",
        "repair",
        "repeat",
        "replace",
        "report",
        "require",
        "rescue",
        "resemble",
        "resist",
        "resource",
        "response",
        "result",
        "retire",
        "retreat",
        "return",
        "reunion",
        "reveal",
        "review",
        "reward",
        "rhythm",
        "rib",
        "ribbon",
        "rice",
        "rich",
        "ride",
        "ridge",
        "rifle",
        "right",
        "rigid",
        "ring",
        "riot",
        "ripple",
        "risk",
        "ritual",
        "rival",
        "river",
        "road",
        "roast",
        "robot",
        "robust",
        "rocket",
        "romance",
        "roof",
        "rookie",
        "room",
        "rose",
        "rotate",
        "rough",
        "round",
        "route",
        "royal",
        "rubber",
        "rude",
        "rug",
        "rule",
        "run",
        "runway",
        "rural",
        "sad",
        "saddle",
        "sadness",
        "safe",
        "sail",
        "salad",
        "salmon",
        "salon",
        "salt",
        "salute",
        "same",
        "sample",
        "sand",
        "satisfy",
        "satoshi",
        "sauce",
        "sausage",
        "save",
        "say",
        "scale",
        "scan",
        "scare",
        "scatter",
        "scene",
        "scheme",
        "school",
        "science",
        "scissors",
        "scorpion",
        "scout",
        "scrap",
        "screen",
        "script",
        "scrub",
        "sea",
        "search",
        "season",
        "seat",
        "second",
        "secret",
        "section",
        "security",
        "seed",
        "seek",
        "segment",
        "select",
        "sell",
        "seminar",
        "senior",
        "sense",
        "sentence",
        "series",
        "service",
        "session",
        "settle",
        "setup",
        "seven",
        "shadow",
        "shaft",
        "shallow",
        "share",
        "shed",
        "shell",
        "sheriff",
        "shield",
        "shift",
        "shine",
        "ship",
        "shiver",
        "shock",
        "shoe",
        "shoot",
        "shop",
        "short",
        "shoulder",
        "shove",
        "shrimp",
        "shrug",
        "shuffle",
        "shy",
        "sibling",
        "sick",
        "side",
        "siege",
        "sight",
        "sign",
        "silent",
        "silk",
        "silly",
        "silver",
        "similar",
        "simple",
        "since",
        "sing",
        "siren",
        "sister",
        "situate",
        "six",
        "size",
        "skate",
        "sketch",
        "ski",
        "skill",
        "skin",
        "skirt",
        "skull",
        "slab",
        "slam",
        "sleep",
        "slender",
        "slice",
        "slide",
        "slight",
        "slim",
        "slogan",
        "slot",
        "slow",
        "slush",
        "small",
        "smart",
        "smile",
        "smoke",
        "smooth",
        "snack",
        "snake",
        "snap",
        "sniff",
        "snow",
        "soap",
        "soccer",
        "social",
        "sock",
        "soda",
        "soft",
        "solar",
        "soldier",
        "solid",
        "solution",
        "solve",
        "someone",
        "song",
        "soon",
        "sorry",
        "sort",
        "soul",
        "sound",
        "soup",
        "source",
        "south",
        "space",
        "spare",
        "spatial",
        "spawn",
        "speak",
        "special",
        "speed",
        "spell",
        "spend",
        "sphere",
        "spice",
        "spider",
        "spike",
        "spin",
        "spirit",
        "split",
        "spoil",
        "sponsor",
        "spoon",
        "sport",
        "spot",
        "spray",
        "spread",
        "spring",
        "spy",
        "square",
        "squeeze",
        "squirrel",
        "stable",
        "stadium",
        "staff",
        "stage",
        "stairs",
        "stamp",
        "stand",
        "start",
        "state",
        "stay",
        "steak",
        "steel",
        "stem",
        "step",
        "stereo",
        "stick",
        "still",
        "sting",
        "stock",
        "stomach",
        "stone",
        "stool",
        "story",
        "stove",
        "strategy",
        "street",
        "strike",
        "strong",
        "struggle",
        "student",
        "stuff",
        "stumble",
        "style",
        "subject",
        "submit",
        "subway",
        "success",
        "such",
        "sudden",
        "suffer",
        "sugar",
        "suggest",
        "suit",
        "summer",
        "sun",
        "sunny",
        "sunset",
        "super",
        "supply",
        "supreme",
        "sure",
        "surface",
        "surge",
        "surprise",
        "surround",
        "survey",
        "suspect",
        "sustain",
        "swallow",
        "swamp",
        "swap",
        "swarm",
        "swear",
        "sweet",
        "swift",
        "swim",
        "swing",
        "switch",
        "sword",
        "symbol",
        "symptom",
        "syrup",
        "system",
        "table",
        "tackle",
        "tag",
        "tail",
        "talent",
        "talk",
        "tank",
        "tape",
        "target",
        "task",
        "taste",
        "tattoo",
        "taxi",
        "teach",
        "team",
        "tell",
        "ten",
        "tenant",
        "tennis",
        "tent",
        "term",
        "test",
        "text",
        "thank",
        "that",
        "theme",
        "then",
        "theory",
        "there",
        "they",
        "thing",
        "this",
        "thought",
        "three",
        "thrive",
        "throw",
        "thumb",
        "thunder",
        "ticket",
        "tide",
        "tiger",
        "tilt",
        "timber",
        "time",
        "tiny",
        "tip",
        "tired",
        "tissue",
        "title",
        "toast",
        "tobacco",
        "today",
        "toddler",
        "toe",
        "together",
        "toilet",
        "token",
        "tomato",
        "tomorrow",
        "tone",
        "tongue",
        "tonight",
        "tool",
        "tooth",
        "top",
        "topic",
        "topple",
        "torch",
        "tornado",
        "tortoise",
        "toss",
        "total",
        "tourist",
        "toward",
        "tower",
        "town",
        "toy",
        "track",
        "trade",
        "traffic",
        "tragic",
        "train",
        "transfer",
        "trap",
        "trash",
        "travel",
        "tray",
        "treat",
        "tree",
        "trend",
        "trial",
        "tribe",
        "trick",
        "trigger",
        "trim",
        "trip",
        "trophy",
        "trouble",
        "truck",
        "true",
        "truly",
        "trumpet",
        "trust",
        "truth",
        "try",
        "tube",
        "tuition",
        "tumble",
        "tuna",
        "tunnel",
        "turkey",
        "turn",
        "turtle",
        "twelve",
        "twenty",
        "twice",
        "twin",
        "twist",
        "two",
        "type",
        "typical",
        "ugly",
        "umbrella",
        "unable",
        "unaware",
        "uncle",
        "uncover",
        "under",
        "undo",
        "unfair",
        "unfold",
        "unhappy",
        "uniform",
        "unique",
        "unit",
        "universe",
        "unknown",
        "unlock",
        "until",
        "unusual",
        "unveil",
        "update",
        "upgrade",
        "uphold",
        "upon",
        "upper",
        "upset",
        "urban",
        "urge",
        "usage",
        "use",
        "used",
        "useful",
        "useless",
        "usual",
        "utility",
        "vacant",
        "vacuum",
        "vague",
        "valid",
        "valley",
        "valve",
        "van",
        "vanish",
        "vapor",
        "various",
        "vast",
        "vault",
        "vehicle",
        "velvet",
        "vendor",
        "venture",
        "venue",
        "verb",
        "verify",
        "version",
        "very",
        "vessel",
        "veteran",
        "viable",
        "vibrant",
        "vicious",
        "victory",
        "video",
        "view",
        "village",
        "vintage",
        "violin",
        "virtual",
        "virus",
        "visa",
        "visit",
        "visual",
        "vital",
        "vivid",
        "vocal",
        "voice",
        "void",
        "volcano",
        "volume",
        "vote",
        "voyage",
        "wage",
        "wagon",
        "wait",
        "walk",
        "wall",
        "walnut",
        "want",
        "warfare",
        "warm",
        "warrior",
        "wash",
        "wasp",
        "waste",
        "water",
        "wave",
        "way",
        "wealth",
        "weapon",
        "wear",
        "weasel",
        "weather",
        "web",
        "wedding",
        "weekend",
        "weird",
        "welcome",
        "west",
        "wet",
        "whale",
        "what",
        "wheat",
        "wheel",
        "when",
        "where",
        "whip",
        "whisper",
        "wide",
        "width",
        "wife",
        "wild",
        "will",
        "win",
        "window",
        "wine",
        "wing",
        "wink",
        "winner",
        "winter",
        "wire",
        "wisdom",
        "wise",
        "wish",
        "witness",
        "wolf",
        "woman",
        "wonder",
        "wood",
        "wool",
        "word",
        "work",
        "world",
        "worry",
        "worth",
        "wrap",
        "wreck",
        "wrestle",
        "wrist",
        "write",
        "wrong",
        "yard",
        "year",
        "yellow",
        "you",
        "young",
        "youth",
        "zebra",
        "zero",
        "zone",
        "zoo"
    }
};

} // namespace lang
} // namespace mnemonic
} // namespace cscrypto
```
# ..\node\cscrypto\src\keysderivation.cpp 
```cpp 
#include <cscrypto/keysderivation.hpp>

namespace cscrypto {
namespace keys_derivation {

MasterSeed generateMaterSeed() {
    MasterSeed res;
    crypto_kdf_keygen(res.data());
    sodium_mprotect_noaccess(res.data());
    return res;
}

KeyPair deriveKeyPair(MasterSeed& seed, KeyId id, const Context& ctx) {
    MemGuard<Byte, crypto_sign_SEEDBYTES> subkey;
    sodium_mprotect_readonly(seed.data());
    crypto_kdf_derive_from_key(subkey.data(), subkey.size(), id, ctx.data(), seed.data());
    sodium_mprotect_noaccess(seed.data());
    PublicKey pk;
    MemGuard<Byte, kPrivateKeySize> sk;
    crypto_sign_seed_keypair(pk.data(), sk.data(), subkey.data());
    return std::make_pair(pk, PrivateKey::readFromBytes(sk));
}

void accessMasterSeed(MasterSeed& seed) {
    sodium_mprotect_readonly(seed.data());
}

void lockMasterSeed(MasterSeed& seed) {
    sodium_mprotect_noaccess(seed.data());
}

} // namespace keys_derivation
} // namespace cscrypto
```
# ..\node\cscrypto\src\maincryptofunctions.cpp 
```cpp 
#include "cscrypto/maincryptofunctions.hpp"

#include <cassert>

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4324 4244 4267 4804)  // 'crypto_generichash_blake2b_state': structure was padded due to alignment specifier,
                                                // convertion from uin64_t to uin32_t, convertion from size_t to uint8_t
#endif
#include <blake2.h>
#if defined(_MSC_VER)
#pragma warning(pop)
#endif

namespace cscrypto {

bool cryptoInit() {
    return sodium_init() >= 0;
}

Hash calculateHash(const Byte* data, size_t dataSize, const Byte* key, size_t keySize) {
    Hash hash;
    blake2s(hash.data(), BLAKE2S_OUTBYTES, data, dataSize, key, keySize);
    return hash;
}

PrivateKey generateKeyPair(PublicKey& publicKey) {
    PrivateKey privateKey = PrivateKey::generateWithPair(publicKey);
    return privateKey;
}

bool validateKeyPair(const PublicKey& publicKey, const PrivateKey& privateKey) {
    return publicKey == getMatchingPublic(privateKey);
}

PublicKey getMatchingPublic(const PrivateKey& privateKey) {
    PublicKey result;
    auto pkg = privateKey.access();
    crypto_sign_ed25519_sk_to_pk(result.data(), pkg.data());
    return result;
}

Signature generateSignature(const PrivateKey& privateKey, const Byte* data, size_t dataSize) {
    assert(data != nullptr);
    unsigned long long signatureLen;
    auto pkg = privateKey.access();

    Signature signature;
    crypto_sign_ed25519_detached(signature.data(), &signatureLen, data, dataSize, pkg.data());
    return signature;
}

bool verifySignature(const Signature& signature, const PublicKey& publicKey, const Byte* data, size_t dataSize) {
    assert(data != nullptr);
    return !crypto_sign_ed25519_verify_detached(signature.data(), data, dataSize, publicKey.data());
}

bool verifySignature(const Byte* signature, const Byte* publicKey, const Byte* data, size_t dataSize) {
    assert(signature != nullptr && publicKey != nullptr && data != nullptr);
    return !crypto_sign_ed25519_verify_detached(signature, data, dataSize, publicKey);
}

void fillBufWithRandomBytes(void* buffer, size_t size) {
    assert(buffer != nullptr);
    randombytes_buf(buffer, size);
}

void fillWithZeros(void* buffer, size_t size) {
    assert(buffer != nullptr);
    sodium_memzero(buffer, size);
}

}  // namespace cscrypto
```
# ..\node\cscrypto\src\mnemonic.cpp 
```cpp 
#include <cscrypto/mnemonic.hpp>
#include <cscrypto/maincryptofunctions.hpp>

#include <algorithm>
#include <cstring>

using namespace cscrypto::keys_derivation;

namespace cscrypto {
namespace mnemonic {

namespace {
inline bool getBit(const cscrypto::Byte* bits, size_t pos) {
    cscrypto::Byte byte = *(bits + pos / 8);
    return (byte & (1 << (pos % 8)));
}

inline void putBit(cscrypto::Byte* bits, size_t pos, bool bit) {
    cscrypto::Byte* byte = bits + pos / 8;
    *byte |= uint8_t(bit) << (pos % 8);
}

inline size_t getIndex(const cscrypto::Byte* bits, size_t wordNum) {
    size_t result = 0;
    size_t pos = wordNum * kBitsWord;
    size_t end = pos + kBitsWord;
    while (pos < end) {
        result |= uint8_t(getBit(bits, pos)) << (pos % kBitsWord);
        ++pos;
    }
    return result;
}

inline void putIndex(cscrypto::Byte* bits, size_t wordNum, size_t index) {
    for (size_t i = 0; i < kBitsWord; ++i) {
        if (wordNum * kBitsWord + i < kBitsAll - kBitsCheckSum) {
            auto bit = getBit(reinterpret_cast<cscrypto::Byte*>(&index), i);
            putBit(bits, wordNum * kBitsWord + i, bit);
        }
    }
}
} // namespace

WordList masterSeedToWords(MasterSeed& seed, const Dictionary& dictionary) {
    accessMasterSeed(seed);
    auto hash = cscrypto::calculateHash(seed.data(), kMasterSeedSize);
    auto sum = hash[0];

    MasterSeedGuard bits;
    std::copy(seed.data(), seed.data() + seed.size(), bits.data());
    std::copy(&sum, &sum + sizeof(sum), bits.data() + seed.size());
    lockMasterSeed(seed);

    WordList result;
    for (size_t i = 0; i < result.size(); ++i) {
        result[i] = dictionary[getIndex(bits.data(), i)];
    }
    return result;
}

MasterSeed wordsToMasterSeed(const WordList& words,
        const Dictionary& dictionary,
        std::function<void(const char*)> errorHandler) {
    MasterSeed result;
    cscrypto::fillWithZeros(result.data(), result.size());
    bool indexAdded = false;
    for (size_t i = 0; i < words.size(); ++i) {
        for (size_t j = 0; j < dictionary.size(); ++j) {
            if (std::strcmp(words[i], dictionary[j]) == 0) {
                putIndex(result.data(), i, j);
                indexAdded = true;
                break;
            }
        }
        if (!indexAdded) {
            cscrypto::fillWithZeros(result.data(), result.size());
            if (errorHandler) errorHandler("Corrupted word list");
            return result;
        }
        indexAdded = false;
    }
    lockMasterSeed(result);
    return result;
}
} // namespace mnemonic
} // namespace cscrypto
```
# ..\node\cscrypto\src\privatekey.cpp 
```cpp 
#include <memory.h>
#include <cstring>

#include "cscrypto/privatekey.hpp"

namespace cscrypto {

PrivateKey::PrivateKey()
: mem_(nullptr)
, ctr_(new uint32_t(1)) {
}

void PrivateKey::clear() {
    if (!(--(*ctr_))) {
        sodium_free(mem_);
        delete ctr_;
    }
}

PrivateKey::PrivateKey(const PrivateKey& rhs)
: mem_(rhs.mem_)
, ctr_(rhs.ctr_) {
    ++(*ctr_);
}

PrivateKey::PrivateKey(PrivateKey&& rhs)
: PrivateKey(rhs) {
}

PrivateKey& PrivateKey::operator=(const PrivateKey& rhs) {
    if (rhs.mem_ != mem_)
        clear();

    mem_ = rhs.mem_;
    ctr_ = rhs.ctr_;
    ++(*ctr_);

    return *this;
}

PrivateKey& PrivateKey::operator=(PrivateKey&& rhs) {
    return (*this = rhs);
}

PrivateKeyGuard PrivateKey::access() const {
    return PrivateKeyGuard(static_cast<Byte*>(mem_));
}

PrivateKey PrivateKey::generateWithPair(PublicKey& public_key) {
    PrivateKey result;
    result.mem_ = sodium_malloc(kPrivateKeySize);
    crypto_sign_keypair(public_key.data(), static_cast<Byte*>(result.mem_));
    sodium_mprotect_noaccess(result.mem_);
    return result;
}

static auto getKeyFromPassword(const char* passwd, size_t pswdLen) {
    MemGuard<Byte, crypto_aead_chacha20poly1305_KEYBYTES> key;
    const static std::array<Byte, crypto_pwhash_SALTBYTES> salt = {73, 68, 73, 32, 78, 65, 72, 85, 89, 32, 66, 76, 89, 65, 84, 39};

    if (crypto_pwhash(key.data(), key.size(), passwd, pswdLen, salt.data(), crypto_pwhash_OPSLIMIT_SENSITIVE, crypto_pwhash_MEMLIMIT_SENSITIVE,
                      crypto_pwhash_ALG_DEFAULT) != 0) {
        key.clear();
    }

    return key;
}

PrivateKey PrivateKey::readFromBytes(const Bytes& bytes) {
    if (bytes.size() != kPrivateKeySize)
        return PrivateKey();

    PrivateKey result;
    result.mem_ = sodium_malloc(kPrivateKeySize);
    memcpy(result.mem_, bytes.data(), kPrivateKeySize);
    sodium_mprotect_noaccess(result.mem_);
    return result;
}

PrivateKey PrivateKey::readFromBytes(const MemGuard<Byte, kPrivateKeySize>& bytes) {
    PrivateKey result;
    result.mem_ = sodium_malloc(kPrivateKeySize);
    memcpy(result.mem_, bytes.data(), kPrivateKeySize);
    sodium_mprotect_noaccess(result.mem_);
    return result;
}

PrivateKey PrivateKey::readFromEncrypted(const Bytes& bytes, const char* passwd, size_t pswdLen) {
    if (bytes.size() < crypto_aead_chacha20poly1305_NPUBBYTES)
        return PrivateKey();

    MemGuard<Byte, crypto_aead_chacha20poly1305_NPUBBYTES> nonce;
    memcpy(nonce.data(), bytes.data(), crypto_aead_chacha20poly1305_NPUBBYTES);

    // Hash the password
    auto key = getKeyFromPassword(passwd, pswdLen);

    PrivateKey result;
    result.mem_ = sodium_malloc(kPrivateKeySize);

    long long unsigned decrypted_len = 0;
    if (crypto_aead_chacha20poly1305_decrypt(static_cast<Byte*>(result.mem_), &decrypted_len, NULL, bytes.data() + crypto_aead_chacha20poly1305_NPUBBYTES,
                                             bytes.size() - crypto_aead_chacha20poly1305_NPUBBYTES, NULL, 0, nonce.data(), key.data()) != 0 ||
        decrypted_len != kPrivateKeySize) {
        return PrivateKey();
    }

    sodium_mprotect_noaccess(result.mem_);
    return result;
}

Bytes PrivateKey::getEncrypted(const char* passwd, size_t pswdLen) const {
    Bytes result;

    auto key = getKeyFromPassword(passwd, pswdLen);
    auto pk = access();

    Byte cText[kPrivateKeySize + crypto_aead_chacha20poly1305_ABYTES];
    long long unsigned cSize = 0;

    MemGuard<Byte, crypto_aead_chacha20poly1305_NPUBBYTES> nonce;
    randombytes_buf(nonce.data(), nonce.size());

    if (crypto_aead_chacha20poly1305_encrypt(cText, &cSize, pk.data(), pk.size(), NULL, 0, NULL, nonce.data(), key.data()) != 0) {
        return result;
    }

    result.resize(crypto_aead_chacha20poly1305_NPUBBYTES + cSize);

    memcpy(result.data(), nonce.data(), crypto_aead_chacha20poly1305_NPUBBYTES);

    memcpy(result.data() + crypto_aead_chacha20poly1305_NPUBBYTES, cText, cSize);

    return result;
}
}  // namespace cscrypto
```
# ..\node\csdb\benchmark\csdb_benchmark_main.cpp 
```cpp 
#include <benchmark/benchmark.h>

static void bench(benchmark::State &state)
{
  for(auto _ : state)
  {
  }
}
BENCHMARK(bench);

BENCHMARK_MAIN();
```
# ..\node\csdb\include\csdb\address.hpp 
```cpp 
/**
 * @file address.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_ADDRESS_H_INCLUDED_
#define _CREDITS_CSDB_ADDRESS_H_INCLUDED_

#include <functional>
#include <string>

#include <lib/system/common.hpp>

#include "csdb/internal/shared_data.hpp"
#include "csdb/internal/types.hpp"

namespace csdb {

namespace priv {
class obstream;
class ibstream;
}  // namespace priv

class Address {
    SHARED_DATA_CLASS_DECLARE(Address)
public:
    using WalletId = csdb::internal::WalletId;

    bool is_valid() const noexcept;
    bool is_public_key() const noexcept;
    bool is_wallet_id() const noexcept;
    ::std::string to_string() const noexcept;
    static Address from_string(const std::string &val);

    const cs::PublicKey &public_key() const noexcept;
    // returns (uint32_t)-1 if it is not WalletId
    WalletId wallet_id() const noexcept;

    static Address from_public_key(const cs::Bytes &key);
    static Address from_public_key(const cs::PublicKey &key);
    static Address from_public_key(const char *key);
    static Address from_wallet_id(WalletId id);
    std::string to_api_addr();

    bool operator==(const Address &other) const noexcept;
    inline bool operator!=(const Address &other) const noexcept;

    /**
     * @brief operator <
     *
     * Оператор предназначен для возможности сортировок контейнеров класса или
     * использования класса в качестве ключа.
     */
    bool operator<(const Address &other) const noexcept;
    size_t calcHash() const noexcept;

private:
    void put(::csdb::priv::obstream &) const;
    bool get(::csdb::priv::ibstream &);
    friend class ::csdb::priv::obstream;
    friend class ::csdb::priv::ibstream;
    friend class Storage;
};

inline bool Address::operator!=(const Address &other) const noexcept {
    return !operator==(other);
}

}  // namespace csdb

namespace std {
template <>
class hash<csdb::Address> {
public:
    size_t operator()(const csdb::Address &obj) const {
        return obj.calcHash();
    }
};
}  // namespace std

#endif // _CREDITS_CSDB_ADDRESS_H_INCLUDED_
```
# ..\node\csdb\include\csdb\amount.hpp 
```cpp 
/**
 * @file amount.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_AMOUNT_H_INCLUDED_
#define _CREDITS_CSDB_AMOUNT_H_INCLUDED_

#include <cinttypes>
#include <iostream>
#include <limits>
#include <stdexcept>
#include <string>
#include <type_traits>

#include "internal/math128ce.hpp"
#include "lib/system/common.hpp"

namespace csdb {
/** @brief Класс для хранения количества валюты.
 *
 * Класс предназначен для хранения количества произвольной суммы валюты в формате с фиксированной точкой с
 * повышенной точностью. Диапазон хранимых значений от INT32_MIN до INT32_MAX, точное количество значащих
 * цифр после запятой - 18.
 *
 * Целая часть хранится в виде числа типа INT32 со знаком. Дробная часть хранится в виде числа UINT64 без
 * знака, и интерпретируется как количество 1/10^18 долей единицы. Т.е. значение дробной части "1"
 * означает 0.000000000000000001, а для 0.1 значение дробной части равно 100000000000000000.
 *
 * Отрицательные числа кодируются в дополнительном формате, т.е. целая часть является максимальным целым
 * числом, не превышающим значения, а дробная часть является дополнением целой части до значения.
 *
 * Примеры кодирования:
 * \li 1: {1,0}
 * \li 0.1: {1,500000000000000000}
 * \li -1: {-1,0}
 * \li -1.5: {-2,500000000000000000}
 * \li -0.1: {-1,900000000000000000}
 *
 * Такой формат кодирования позволяет осуществлять операции сложения и вычитания не обращая внимания на знак.
 *
 * В классе реализованы основные арифметические операции для работы с \ref Amount как с обычным числовым типом.
 * Большинство операций реализовано в виде constexpr-операторов, что позволяет создавать константы этого типа,
 * вычисляемые на этапе компиляции. Для задания констант также можно использовать литеральный оператор с
 * суффиксом "_c".
 *
 * Примеры выражений с классом Amount:
 * \code
 * constexpr Amount a1{1};                  // a1 = 1.0;
 * const Amount a2{1.1};                    // a2 = 1.1; преобразование из double
 * constexpr Amount a3{1.1_c};              // a3 = 1.1; литерал
 * constexpr Amount a4{(1_c + 1.2_c) * 2};  // a3 = 4.4; выражение из литералов
 * constexpr Amount a4{0,1};                // a3 = 0.01; задание в виде дроби с делителем по умолчанию (100)
 * constexpr Amount a4{0,1,10};             // a3 = 0.1; задание в виде дроби с делителем 10
 * \endcode
 *
 * Настоятельно не рекомендуется использовать преобразование из double, т.к. оно может привести к потере
 * точности (значащих цифр). Кодирование double обеспечивает только 15 значащих цифр, в то время как
 * класс \ref Amount обеспечивает 9 значащих цифр в целой части и 18 в дробной. Для задания значений с
 * большим количеством значащих цифр рекомендуется использовать литеральный оператор, а при вычислениях
 * рекомендуется сначала привести значения к типу \ref Amount, а потом использовать операторы для него.
 */
class Amount;
}  // namespace csdb
template <char... s>
constexpr csdb::Amount operator"" _c();

namespace csdb {
namespace priv {
class obstream;
class ibstream;
}  // namespace priv

#pragma pack(push, 1)
class Amount {
public:
    static constexpr const uint64_t AMOUNT_MAX_FRACTION = 1000000000000000000ULL;

public:
    inline constexpr Amount() = default;
    inline constexpr Amount(int32_t value) noexcept
    : integral_(value) {
    }
    /**
     * @brief Конструтор из целой части и правильной положительной дробной части
     * @param integral Целая часть
     * @param numerator Числитель дробной части
     * @param denominator Знаменатель дробной части
     *
     * Примеры:
     * \code
     * Amount a(0,1);     // a = 0.01;
     * Amount a(0,1,10);  // a = 0.1;
     * Amount a(0,1,2);   // a = 0.5;
     * Amount a(0,1,0);   // Ошибка деления на ноль.
     * Amount a(0,3,2);   // Ошибка - числитель обязан быть меньше знаменателя.
     * \endcode
     *
     * Для конструирования \ref Amount из неправильной дроби следует использовать оператор деления:
     * \code
     * Amount a1{5_c / 2};        // a1 = 2.5;
     * int32 n = -9;
     * Amount a2{Amount(n) / 4};  // a2 = -2.25;
     * \endcode
     */
    inline constexpr Amount(int32_t integral, uint64_t numerator, uint64_t denominator = 100);
    /// \todo Переделать на inline constexpr
    Amount(double value);

private:
    inline constexpr Amount(const int32_t integral, const uint64_t fraction, std::nullptr_t) noexcept
    : integral_(integral)
    , fraction_(fraction) {
    }
    inline constexpr Amount(const internal::uint128_t& value, bool divide) noexcept;
    inline constexpr Amount(const internal::uint128_t::division64_result& value) noexcept;
    static inline constexpr uint64_t _check_fraction(const internal::uint128_t& fraction);

    // Получение значений
public:
    inline constexpr int32_t integral() const noexcept {
        return integral_;
    }
    inline constexpr uint64_t fraction() const noexcept {
        return fraction_;
    }
    inline constexpr int32_t round() const noexcept;
    inline constexpr double to_double() const noexcept;
    inline constexpr operator int32_t() const noexcept {
        return round();
    }
    inline constexpr operator double() const noexcept {
        return to_double();
    }

    // Сравнение
public:
    inline constexpr bool operator==(const Amount& other) const noexcept;
    inline constexpr bool operator!=(const Amount& other) const noexcept;
    inline constexpr bool operator<(const Amount& other) const noexcept;
    inline constexpr bool operator>(const Amount& other) const noexcept;
    inline constexpr bool operator<=(const Amount& other) const noexcept;
    inline constexpr bool operator>=(const Amount& other) const noexcept;

    // Арифметические операции
public:
    inline constexpr Amount operator-() const noexcept;

    inline constexpr Amount operator+(const Amount& other) const noexcept;
    inline constexpr Amount operator+(const int32_t other) const noexcept;
    inline Amount operator+(double other) const;

    inline constexpr Amount operator-(const Amount& other) const noexcept;
    inline constexpr Amount operator-(int32_t other) const noexcept;
    inline Amount operator-(double other) const;

    inline constexpr Amount operator*(const Amount& other) const noexcept;
    inline constexpr Amount operator*(const int32_t other) const noexcept;
    inline Amount operator*(double other) const;

    /// \todo Реализовать версию для const Amount& other
    // inline constexpr Amount operator *(const Amount& other) const;
    inline constexpr Amount operator/(const int32_t other) const;
    // inline Amount operator *(double other) const;

    inline Amount& operator+=(const Amount& other) noexcept;
    inline Amount& operator+=(int32_t other) noexcept;
    inline Amount& operator+=(double other);

    inline Amount& operator-=(const Amount& other) noexcept;
    inline Amount& operator-=(int32_t other) noexcept;
    inline Amount& operator-=(double other);

    inline Amount& operator*=(const Amount& other) noexcept;
    inline Amount& operator*=(int32_t other) noexcept;
    inline Amount& operator*=(double other);

    /// \todo Реализовать версию для const Amount& other
    // inline Amount& operator /=(const Amount& other);
    inline Amount& operator/=(int32_t other);
    // inline Amount& operator /=(double other);

    /// \todo Реализовать функцию muldiv для вычисление долей (процентов) для больших значений

    ::std::string to_string(size_t min_decimal_places = 2) const noexcept;

    // Сериализация
    cs::Bytes toBytes() const;
    static Amount fromBytes(const cs::Bytes&);
public:
    void put(priv::obstream&) const;
    bool get(priv::ibstream&);

private:
    int32_t integral_ = 0;
    uint64_t fraction_ = 0;

    // Шаблоны для constexpr литерального оператора.
private:
    template <uint64_t m, char d, char... s>
    struct amount_fraction;
    template <char d, char... s>
    struct amount_full;
    template <char... s>
    friend Amount constexpr ::operator"" _c();
};
#pragma pack(pop)

static_assert(std::is_trivially_copyable<Amount>::value, "Invalid csdb::Amount definition.");

inline constexpr Amount::Amount(int32_t integral, uint64_t numerator, uint64_t denominator)
: integral_(integral)
, fraction_(_check_fraction((internal::uint128_t::mul(numerator, AMOUNT_MAX_FRACTION) + (denominator / 2)).div(denominator).quotient_)) {
}

inline constexpr Amount::Amount(const internal::uint128_t& value, bool divide) noexcept
: Amount(((0 == value.lo_) && (0 == value.hi_)) ? internal::uint128_t::division64_result{{0, 0}, 0}
                                                : divide ? value.div(AMOUNT_MAX_FRACTION).quotient_.div(AMOUNT_MAX_FRACTION) : value.div(AMOUNT_MAX_FRACTION)) {
}

inline constexpr Amount::Amount(const internal::uint128_t::division64_result& value) noexcept
: integral_(static_cast<int32_t>(value.quotient_.lo_))
, fraction_(value.remainder_) {
}

inline constexpr uint64_t Amount::_check_fraction(const internal::uint128_t& fraction) {
    return ((0 != fraction.hi_) || (AMOUNT_MAX_FRACTION <= fraction.lo_)) ? throw std::invalid_argument("Amount::Amount(): Invalid fraction part.") : fraction.lo_;
}

inline constexpr int32_t Amount::round() const noexcept {
    return (fraction_ < (AMOUNT_MAX_FRACTION / 2ULL)) ? integral_ : (integral_ + 1);
}

inline constexpr double Amount::to_double() const noexcept {
    return static_cast<double>(integral_) + (static_cast<double>(fraction_) / static_cast<double>(AMOUNT_MAX_FRACTION));
}

inline constexpr bool Amount::operator==(const Amount& other) const noexcept {
    return (integral_ == other.integral_) && (fraction_ == other.fraction_);
}

inline constexpr bool Amount::operator!=(const Amount& other) const noexcept {
    return !this->operator==(other);
}

inline constexpr bool Amount::operator<(const Amount& other) const noexcept {
    return (integral_ < other.integral_) ? true : (integral_ > other.integral_) ? false : (fraction_ < other.fraction_);
}

inline constexpr bool Amount::operator>(const Amount& other) const noexcept {
    return (integral_ > other.integral_) ? true : (integral_ < other.integral_) ? false : (fraction_ > other.fraction_);
}

inline constexpr bool Amount::operator<=(const Amount& other) const noexcept {
    return !this->operator>(other);
}

inline constexpr bool Amount::operator>=(const Amount& other) const noexcept {
    return !this->operator<(other);
}

inline constexpr Amount Amount::operator-() const noexcept {
    return (0 == fraction_) ? Amount(-integral_) : Amount(-integral_ - 1, AMOUNT_MAX_FRACTION - fraction_, nullptr);
}

inline Amount& Amount::operator+=(const Amount& other) noexcept {
    integral_ += other.integral_;
    fraction_ += other.fraction_;
    if (fraction_ >= AMOUNT_MAX_FRACTION) {
        ++integral_;
        fraction_ -= AMOUNT_MAX_FRACTION;
    }
    return *this;
}

inline Amount& Amount::operator+=(int32_t other) noexcept {
    integral_ += other;
    return *this;
}

inline Amount& Amount::operator+=(double other) {
    return operator+=(Amount(other));
}

inline Amount& Amount::operator-=(const Amount& other) noexcept {
    integral_ -= other.integral_;
    if (other.fraction_ > fraction_) {
        --integral_;
        fraction_ += (AMOUNT_MAX_FRACTION - other.fraction_);
    }
    else {
        fraction_ -= other.fraction_;
    }
    return *this;
}

inline Amount& Amount::operator-=(int32_t other) noexcept {
    integral_ -= other;
    return *this;
}

inline Amount& Amount::operator-=(double other) {
    return operator-=(Amount(other));
}

inline constexpr Amount Amount::operator+(const Amount& other) const noexcept {
    return (AMOUNT_MAX_FRACTION < (fraction_ + other.fraction_)) ? Amount(integral_ + other.integral_ + 1, fraction_ + other.fraction_ - AMOUNT_MAX_FRACTION, nullptr)
                                                                 : Amount(integral_ + other.integral_, fraction_ + other.fraction_, nullptr);
}

inline constexpr Amount Amount::operator+(const int32_t other) const noexcept {
    return Amount(integral_ + other, fraction_, nullptr);
}

inline Amount Amount::operator+(double other) const {
    return this->operator+(Amount(other));
}

inline constexpr Amount Amount::operator-(const Amount& other) const noexcept {
    return (fraction_ < other.fraction_) ? Amount(integral_ - other.integral_ - 1, fraction_ + AMOUNT_MAX_FRACTION - other.fraction_, nullptr)
                                         : Amount(integral_ - other.integral_, fraction_ - other.fraction_, nullptr);
}

inline constexpr Amount Amount::operator-(int32_t other) const noexcept {
    return Amount(integral_ - other, fraction_, nullptr);
}

inline Amount Amount::operator-(double other) const {
    return this->operator-(Amount(other));
}

inline constexpr Amount Amount::operator*(const Amount& other) const noexcept {
    return (0 > integral_) ? this->operator-().operator*(other).operator-()
                           : (0 > other.integral_)
                                 ? this->operator*(-other).operator-()
                                 : Amount(static_cast<int32_t>(integral_ * other.integral_)) + Amount(internal::uint128_t::mul(fraction_, other.integral_), false) +
                                       Amount(internal::uint128_t::mul(other.fraction_, integral_), false) + Amount(internal::uint128_t::mul(fraction_, other.fraction_), true);
}

inline constexpr Amount Amount::operator*(const int32_t other) const noexcept {
    return (0 > other) ? this->operator*(-other).operator-() : Amount(integral_ * other) + Amount(internal::uint128_t::mul(fraction_, other), false);
}

inline Amount Amount::operator*(double other) const {
    return this->operator*(Amount(other));
}

inline Amount& Amount::operator*=(const Amount& other) noexcept {
    (*this) = this->operator*(other);
    return *this;
}

inline Amount& Amount::operator*=(int32_t other) noexcept {
    (*this) = this->operator*(other);
    return *this;
}

inline Amount& Amount::operator*=(double other) {
    return this->operator*=(Amount(other));
}

inline constexpr Amount Amount::operator/(const int32_t other) const {
    return (0 == other) ? throw std::overflow_error("Amount division by zero")
                        : (0 > other) ? this->operator/(-other).operator-()
                                      : (1 == other) ? (*this)
                                                     : (0 > integral_) ? this->operator-().operator/(other).operator-()
                                                                       : Amount(internal::uint128_t::mul(integral_, AMOUNT_MAX_FRACTION).div(other).quotient_, false) +
                                                                             Amount(0, fraction_ / other, nullptr);
}

inline Amount& Amount::operator/=(int32_t other) {
    (*this) = this->operator/(other);
    return *this;
}

template <uint64_t m, char d, char... s>
struct Amount::amount_fraction {
    static constexpr const uint64_t value = ((d - '0') * m) + amount_fraction<m / 10, s...>::value;
};

template <uint64_t m, char d>
struct Amount::amount_fraction<m, d> {
    static constexpr const uint64_t value = ((d - '0') * m);
};

template <char d, char... s>
struct Amount::amount_full {
    static constexpr const uint64_t integral = amount_full<s...>::integral + amount_full<s...>::multiplier * (d - '0');
    static constexpr const uint64_t multiplier = amount_full<s...>::multiplier * 10;
    static constexpr const uint64_t fraction = amount_full<s...>::fraction;
    static constexpr const Amount value() {
        return Amount{static_cast<int32_t>(integral), fraction, nullptr};
    }
};

template<char ...s>
struct Amount::amount_full<'.', s...>
{
  static constexpr const uint64_t integral = 0;
  static constexpr const uint64_t multiplier = 1;
  static constexpr const uint64_t fraction = amount_fraction<AMOUNT_MAX_FRACTION / 10ULL, s...>::value;
  static constexpr const Amount value() {return Amount{static_cast<int32_t>(integral), fraction, nullptr};}
};

}  // namespace csdb

inline constexpr csdb::Amount operator +(const int32_t a, const csdb::Amount& b)
{
  return b + a;
}

inline csdb::Amount operator +(double a, const csdb::Amount& b)
{
  return b + a;
}

inline constexpr csdb::Amount operator -(int32_t a, const csdb::Amount& b) noexcept
{
  return (-b) + a;
}

inline csdb::Amount operator -(double a, const csdb::Amount& b)
{
  return csdb::Amount(a) - b;
}

inline constexpr csdb::Amount operator *(const int32_t a, const csdb::Amount& b)
{
  return b * a;
}

inline csdb::Amount operator *(double a, const csdb::Amount& b)
{
  return b * a;
}

inline constexpr csdb::Amount operator "" _c (unsigned long long value)
{
  return csdb::Amount(static_cast<int32_t>(value));
}

template<char ...s>
inline constexpr csdb::Amount operator "" _c ()
{
  return csdb::Amount::amount_full<s...>::value();
}

/// \todo Реализовать вывод в строку с поддержкой ширины поля и точности.
inline ::std::ostream& operator << (::std::ostream& os, const csdb::Amount& value)
{
  return (os << value.to_string());
}
/// \todo Реализовать чтение из строки

#endif // _CREDITS_CSDB_AMOUNT_H_INCLUDED_
```
# ..\node\csdb\include\csdb\amount_commission.hpp 
```cpp 
/**
 * @file amount_commission.h
 * @author Vladimir Shilkin
 */

#ifndef _CREDITS_CSDB_AMOUNT_COMMISSION_H_INCLUDED_
#define _CREDITS_CSDB_AMOUNT_COMMISSION_H_INCLUDED_

#include <atomic>
#include <cinttypes>
#include <type_traits>

#include <boost/endian/conversion.hpp>

namespace csdb {
class AmountCommission;
}

namespace csdb {
namespace priv {
class obstream;
class ibstream;
}  // namespace priv

#pragma pack(push, 1)
class AmountCommission {
public:
    inline AmountCommission() = default;
    inline AmountCommission(const AmountCommission& other) {
        *this = other;
    }
    inline csdb::AmountCommission& operator=(const AmountCommission& other) {
        u_ = other.u_;
        return *this;
    }

    explicit AmountCommission(uint16_t value);
    explicit AmountCommission(double value);

    // Получение значений
public:
    inline double to_double() const noexcept;
    inline explicit operator double() const noexcept {
        return to_double();
    }
    inline uint16_t get_raw() {
        return u_.bits;
    }

    // Сериализация
public:
    void put(priv::obstream&) const;
    bool get(priv::ibstream&);

private:
    union {
        uint16_t bits{};  // All bits
        struct {
#ifdef BOOST_BIG_ENDIAN
            uint16_t sign : 1;   // sign
            uint16_t exp : 5;    // exponent
            uint16_t frac : 10;  // mantissa
#else
            uint16_t frac : 10;  // mantissa
            uint16_t exp : 5;    // exponent
            uint16_t sign : 1;   // sign
#endif
        } fIEEE;
    } u_;

    mutable double cachedDouble_;
    mutable std::atomic_bool cached_ = false;
};
#pragma pack(pop)

namespace pows {
constexpr double kTensPows[32] = {1e-18, 1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3,
                        1e-2,  1e-1,  1.,    1e1,   1e2,   1e3,   1e4,   1e5,   1e6,   1e7,  1e8,  1e9,  1e10, 1e11, 1e12, 1e13};
}

inline double AmountCommission::to_double() const noexcept {
    if (cached_.load(std::memory_order_relaxed)) {
        return cachedDouble_;
    }

    const double _1_1024 = 1. / 1024;
    cachedDouble_ = (u_.fIEEE.sign != 0u ? -1. : 1.) * u_.fIEEE.frac * _1_1024 * pows::kTensPows[u_.fIEEE.exp];
    cached_.store(true, std::memory_order_release);
    return cachedDouble_;
}

}  // namespace csdb

#endif  // _CREDITS_CSDB_AMOUNT_COMMISSION_H_INCLUDED_
```
# ..\node\csdb\include\csdb\csdb.hpp 
```cpp 
/**
 * @file csdb.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_H_INCLUDED_
#define _CREDITS_CSDB_H_INCLUDED_

#include "csdb/storage.hpp"

namespace csdb {
/* Набор глобальныйх функций предназначен во-первых, для совместимости с предыдущей версией csdb,
 * а во-вторых, для работы с единственным хранилищем, без создания экземпляров класса \ref ::csdb::Storage.
 *
 * Набор практически копирует набор методов \ref ::csdb::Storage, реализуюя работу с единственным
 * внутренним экземпляром объекта класса. Подробные описания функций находятся в документации к
 * классу \ref ::csdb::Storage.
 */

/**
 * @brief Инициализация внутреннего объекта хранилища
 *
 * Параметры функции эквивалентны параметрам \ref ::csdb::Storage::open. Основное отличие заключается
 * в том, что в случае, если внутренний объект \ref ::csdb::Storage уже открыт, то функция не
 * пытается открыть новое хранилище, а сразу возвращает false.
 *
 * @sa ::csdb::Storage::open
 */
bool init(const Storage::OpenOptions& options, Storage::OpenCallback callback = nullptr);

/**
 * @overload
 */
bool init(const char* path_to_bases, const Storage::OpenCallback& callback = nullptr);

/**
 * @brief Проверка, инициализирован ли внутренний объект хранилища
 * @sa ::csdb::Storage::isOpen
 */
bool isInitialized();

/**
 * @brief Закрытие внутреннего объекта хранилища
 * @sa ::csdb::Storage::close
 */
void done();

/**
 * @brief Код последней ошибки
 * @sa ::csdb::Storage::last_error()
 */
Storage::Error lastError();

/**
 * @brief Описание последней ошибки
 * @sa ::csdb::Storage::last_error_message()
 */
::std::string lastErrorMessage();

/**
 * @brief Код последней ошибки работы с драйвером базы данных
 * @sa ::csdb::Storage::db_last_error()
 */
Database::Error dbLastError();

/**
 * @brief Описание последней ошибки работы с драйвером базы данных
 * @sa ::csdb::Storage::db_last_error_message()
 */
::std::string dbLastErrorMessage();

/**
 * @brief Хранилище по умолчанию
 * @return Внутренний екземпляр объекта хранилища.
 */
Storage defaultStorage();

}  // namespace csdb

#endif // _CREDITS_CSDB_H_INCLUDED_
```
# ..\node\csdb\include\csdb\currency.hpp 
```cpp 
/**
 * @file currency.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_CURRENCY_H_INCLUDED_
#define _CREDITS_CSDB_CURRENCY_H_INCLUDED_

#include <string>
#include <vector>
#include "csdb/internal/shared_data.hpp"

namespace csdb {

namespace priv {
class obstream;
class ibstream;
}  // namespace priv

class Currency {
    SHARED_DATA_CLASS_DECLARE(Currency)
public:
    Currency(const uint8_t& id);

    bool is_valid() const noexcept;
    std::string to_string() const noexcept;

    bool operator==(const Currency& other) const noexcept;
    bool operator!=(const Currency& other) const noexcept;
    bool operator<(const Currency& other) const noexcept;

private:
    void put(::csdb::priv::obstream&) const;
    bool get(::csdb::priv::ibstream&);
    friend class ::csdb::priv::obstream;
    friend class ::csdb::priv::ibstream;
};

typedef std::vector<Currency> CurrencyList;

}  // namespace csdb

#endif  // _CREDITS_CSDB_CURRENCY_H_INCLUDED_
```
# ..\node\csdb\include\csdb\database.hpp 
```cpp 
/**
 * @file database.h
 * @author Roman Bukin, Evgeny Zalivochkin
 */

#ifndef _CREDITS_CSDB_DATABASE_H_INCLUDED_
#define _CREDITS_CSDB_DATABASE_H_INCLUDED_

#include <client/params.hpp>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "csdb/internal/types.hpp"

namespace csdb {
class Database {
public:
    enum Error {
        NoError = 0,
        NotFound = 1,
        Corruption = 2,
        NotSupported = 3,
        InvalidArgument = 4,
        IOError = 5,
        NotOpen = 6,
        UnknownError = 255,
    };

protected:
    Database();

public:
    virtual ~Database();

    virtual bool is_open() const = 0;
    virtual bool put(const cs::Bytes& key, uint32_t seq_no, const cs::Bytes& value) = 0;
    virtual bool get(const cs::Bytes& key, cs::Bytes* value = nullptr) = 0;
    virtual bool get(const uint32_t seq_no, cs::Bytes* value = nullptr) = 0;
    virtual bool remove(const cs::Bytes& key) = 0;

    using Item = std::pair<cs::Bytes, cs::Bytes>;
    using ItemList = std::vector<Item>;
    virtual bool write_batch(const ItemList& items) = 0;

#ifdef TRANSACTIONS_INDEX
    virtual bool putToTransIndex(const cs::Bytes& key, const cs::Bytes& value) = 0;
    virtual bool getFromTransIndex(const cs::Bytes& key, cs::Bytes* value) = 0;
#endif

    class Iterator {
    protected:
        Iterator();

    public:
        virtual ~Iterator();

    public:
        virtual bool is_valid() const = 0;
        virtual void seek_to_first() = 0;
        virtual void seek_to_last() = 0;
        virtual void seek(const cs::Bytes& key) = 0;
        virtual void next() = 0;
        virtual void prev() = 0;
        virtual cs::Bytes key() const = 0;
        virtual cs::Bytes value() const = 0;
    };
    using IteratorPtr = std::shared_ptr<Iterator>;
    virtual IteratorPtr new_iterator() = 0;

public:
    Error last_error() const;
    std::string last_error_message() const;

protected:
    void set_last_error(Error error = NoError, const std::string& message = std::string());
    void set_last_error(Error error, const char* message, ...);
};

}  // namespace csdb

#endif  // _CREDITS_CSDB_DATABASE_H_INCLUDED_
```
# ..\node\csdb\include\csdb\database_berkeleydb.hpp 
```cpp 
/**
 * @file database_berkeleydb.h
 * @author Evgeny Zalivochkin
 */

#ifndef _CREDITS_CSDB_DATABASE_BERKELEY_H_INCLUDED_
#define _CREDITS_CSDB_DATABASE_BERKELEY_H_INCLUDED_

#include <db_cxx.h>
#include <memory>

#include "csdb/database.hpp"

namespace berkeleydb {
class DB;
class Status;
struct Options;
}  // namespace berkeleydb

namespace csdb {

class DatabaseBerkeleyDB : public Database {
public:
    DatabaseBerkeleyDB();
    ~DatabaseBerkeleyDB() override;

public:
    bool open(const std::string& path);

private:
    bool is_open() const final;
    bool put(const cs::Bytes& key, uint32_t seq_no, const cs::Bytes& value) final;
    bool get(const cs::Bytes& key, cs::Bytes* value) final;
    bool get(const uint32_t seq_no, cs::Bytes* value) final;
    bool remove(const cs::Bytes&) final;
    bool write_batch(const ItemList&) final;
    IteratorPtr new_iterator() final;

#ifdef TRANSACTIONS_INDEX
    bool putToTransIndex(const cs::Bytes& key, const cs::Bytes& value) override final;
    bool getFromTransIndex(const cs::Bytes& key, cs::Bytes* value) override final;
#endif

private:
    class Iterator;

private:
    void set_last_error_from_berkeleydb(int status);

private:
    DbEnv env_;
    std::unique_ptr<Db> db_blocks_;
    std::unique_ptr<Db> db_seq_no_;
#ifdef TRANSACTIONS_INDEX
    std::unique_ptr<Db> db_trans_idx_;
#endif
};

}  // namespace csdb
#endif  // _CREDITS_CSDB_DATABASE_BERKELEYDB_H_INCLUDED_
```
# ..\node\csdb\include\csdb\pool.hpp 
```cpp 
/**
 * @file pool.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_POOL_H_INCLUDED_
#define _CREDITS_CSDB_POOL_H_INCLUDED_

#include <array>
#include <cinttypes>
#include <climits>
#include <string>
#include <vector>

#include <lib/system/common.hpp>

#include "csdb/address.hpp"
#include "csdb/internal/shared_data.hpp"
#include "csdb/internal/types.hpp"
#include "csdb/storage.hpp"
#include "csdb/transaction.hpp"
#include "csdb/user_field.hpp"

#include <cscrypto/cscrypto.hpp>

namespace csdb {

class Transaction;
class TransactionID;

namespace priv {
class obstream;
class ibstream;
}  // namespace priv

class PoolHash {
    SHARED_DATA_CLASS_DECLARE(PoolHash)

public:
    bool is_empty() const noexcept;
    size_t size() const noexcept;
    std::string to_string() const noexcept;

    /**
     * @brief Получение хэша из строкового представления
     * @param[in] str Строковое представление хэша
     * @return Хэш, полученный из строкового представления.
     *
     * В случае, если строковое представление неверное, возвращается пустой хэш.
     */
    static PoolHash from_string(const ::std::string& str);

    cs::Bytes to_binary() const noexcept;
    static PoolHash from_binary(cs::Bytes&& data);

    bool operator==(const PoolHash& other) const noexcept;
    inline bool operator!=(const PoolHash& other) const noexcept;

    /**
     * @brief operator <
     *
     * Оператор предназначен для возможности сортировок контейнеров класса или
     * использования класса в качестве ключа.
     */
    bool operator<(const PoolHash& other) const noexcept;

    static PoolHash calc_from_data(const cs::Bytes& data);

private:
    void put(::csdb::priv::obstream&) const;
    bool get(::csdb::priv::ibstream&);
    friend class ::csdb::priv::obstream;
    friend class ::csdb::priv::ibstream;
    friend class Storage;
};

class Pool {
    SHARED_DATA_CLASS_DECLARE(Pool)
public:
    using Transactions = std::vector<csdb::Transaction>;
    class NewWalletInfo {
    public:
        using WalletId = csdb::internal::WalletId;

        enum AddressType
        {
            AddressIsSource,
            AddressIsTarget
        };

        struct AddressId {
            size_t trxInd_ : sizeof(size_t) * CHAR_BIT - 1;
            size_t addressType_ : 1;

            bool operator==(const AddressId& rh) const {
                return trxInd_ == rh.trxInd_ && addressType_ == rh.addressType_;
            }
            bool operator!=(const AddressId& rh) const {
                return !operator==(rh);
            }
        };

    public:
        NewWalletInfo()
        : addressId_()
        , walletId_() {
        }
        NewWalletInfo(AddressId addressId, csdb::internal::WalletId walletId)
        : addressId_(addressId)
        , walletId_(walletId) {
        }
        void put(::csdb::priv::obstream&) const;
        bool get(::csdb::priv::ibstream&);

        bool operator==(const NewWalletInfo& rh) const {
            return addressId_ == rh.addressId_ && walletId_ == rh.walletId_;
        }
        bool operator!=(const NewWalletInfo& rh) const {
            return !operator==(rh);
        }

    public:
        AddressId addressId_;
        WalletId walletId_;
    };

    struct SmartSignature {
        cs::PublicKey smartKey;
        cs::Sequence smartConsensusPool;
        cs::BlockSignatures signatures;
    };

    using NewWallets = std::vector<NewWalletInfo>;

public:
    Pool(PoolHash previous_hash, cs::Sequence sequence, const Storage& storage = Storage());

    static Pool from_binary(cs::Bytes&& data);
    static Pool meta_from_binary(cs::Bytes&& data, size_t& cnt);
    static Pool load(const PoolHash& hash, Storage storage = Storage());

    // static Pool from_byte_stream(const char* data, size_t size);
    char* to_byte_stream(uint32_t&);
    cs::Bytes to_byte_stream_for_sig();

    Pool meta_from_byte_stream(const char*, size_t);
    static Pool from_lz4_byte_stream(size_t);

    bool is_valid() const noexcept;
    bool is_read_only() const noexcept;
    uint8_t version() const noexcept;
    PoolHash previous_hash() const noexcept;
    cs::Sequence sequence() const noexcept;
    Storage storage() const noexcept;
    size_t transactions_count() const noexcept;
    const cs::PublicKey& writer_public_key() const noexcept;
    const std::vector<cs::PublicKey>& confidants() const noexcept;
    const std::vector<cs::Signature>& signatures() const noexcept;
    const ::std::vector<SmartSignature>& smartSignatures() const noexcept;
    const csdb::Amount& roundCost() const noexcept;
    const std::vector<cs::Signature>& roundConfirmations() const noexcept;
    size_t hashingLength() const noexcept;

    void set_version(uint8_t version) noexcept;
    void set_previous_hash(PoolHash previous_hash) noexcept;
    void set_sequence(cs::Sequence sequence) noexcept;
    void set_storage(const Storage& storage) noexcept;
    void set_confidants(const std::vector<cs::PublicKey>& confidants) noexcept;
    void set_signatures(std::vector<cs::Signature>& blockSignatures) noexcept;
    void add_smart_signature(const SmartSignature& smartSignature) noexcept;
    void add_real_trusted(const uint64_t trustedMask) noexcept;
    void add_confirmation_mask(const uint64_t confMask) noexcept;
    void add_number_trusted(const uint8_t trustedMask) noexcept;
    void add_number_confirmations(const uint8_t confMask) noexcept;
    void setRoundCost(const csdb::Amount& roundCost) noexcept;
    void add_round_confirmations(const std::vector<cs::Signature>& confirmations) noexcept;

    Transactions& transactions();
    const Transactions& transactions() const;

    NewWallets* newWallets() noexcept;
    const NewWallets& newWallets() const noexcept;
    bool getWalletAddress(const NewWalletInfo& info, csdb::Address& wallAddress) const;
    uint64_t realTrusted() const noexcept;
    uint64_t roundConfirmationMask() const noexcept;
    uint8_t numberConfirmations() const noexcept;
    uint8_t numberTrusted() const noexcept;
    /**
     * @brief Добавляет транзакцию в пул.
     * @param[in] transaction Транзакция для добавления
     * @return true, если транзакция была успешно добавлена. false, если транзакция не прошла
     * проверку.
     *
     * Добаление возможно только во вновь создаваемый пул (т.е. если \ref is_read_only возвращает false).
     *
     * Перед добавлением транзакция проходит проверку на валидность по базе данных, указанной для
     * пула, и по ранее добавленным транзакциям. Если база данных не задана, или она была закрыта,
     * проверка считается неуспешной.
     */
    bool add_transaction(Transaction transaction
#ifdef CSDB_UNIT_TEST
                         ,
                         bool skip_check
#endif
    );

    /**
     * @brief Закончить формирование пула.
     * @return true, если для пула успешно сформировано бинарное представление.
     *
     * Для вновь создаваемого пула (т.е. если \ref is_read_only возвращает false) метод формирует
     * его бинарное представлени, вычисляет хэш и переводит пул в состояние read-only. После этого
     * для пула становятся доступными функции \ref hash, \ref save и \ref to_binary.
     *
     * Для read-only пулов функция не делает ничего и просто возвращает true.
     */
    bool compose();

    /**
     * @brief Хеш пула
     * @return Хеш пула, если пул находится в режиме read-only, и пустой хеш в противном
     *         случае.
     */
    PoolHash hash() const noexcept;
    void recount() noexcept;

    uint64_t get_time() const noexcept;

    /**
     * @brief Бинарное представление пула
     * @return Бинарное представление пула, если пул находится в режиме read-only, и пустой
     *         массив в противном случае.
     */
    cs::Bytes to_binary() const noexcept;

    /**
     * @brief Сохранение пула в хранилище.
     * @param[in] storage Хранилище, в котором нужно сохранить пул.
     * @return  true, если сохранение прошло успешно.
     *
     * Функция работает только для сформированных пулов (т.е. находящихся в режиме read-only).
     *
     * Если переданное хранилище не доступно (не открыто), то функция пытается сохранить пул в том
     * хранилище, которое было передано ему при создании. Если и это хранилище недоступно, функци
     * пытается использовать хранилище по умолчанию. Если ни одно из перечисленных хранилищ не доступно,
     * возвращается false.
     *
     * Функция не проверяет, есть ли уже пул с таким же хэшем в хранилище, т.к. вероятность совпадения
     * хешей у двух разных пулов практически нулевая.
     *
     * Если сохранение прошло успешно, то хранилище, в которое произошло сохранение, становится хранилищем
     * для данного экземпляра объекта (поэтому метод не константный).
     */
    bool save(Storage storage = Storage());

    /**
     * @brief Добавляет дополнительное произвольное поле к пулу
     * @param[in] id    Идентификатор дополнительного поля
     * @param[in] field Значение дополнительного поля
     * @return true, если поле добавлено, false в противном случае
     *
     * Поле добавляется только для пулов, не находящихся в режим Read-Only
     * (\ref is_read_only возвращает false).
     *
     * Если поле с таким идентификатором было добавлено ранее, они замещается новым.
     */
    bool add_user_field(user_field_id_t id, const UserField& field) noexcept;

    /**
     * @brief Возвращает дополнительное поле.
     * @param[in] id  Идентификатор дополнительного поля
     * @return  Значение дополнительного поля. Если поля с таким идентификатором нет в списке
     *          дополнительных полей, возвращается невалидный объект
     *          (\ref UserField::is_valid == false).
     */
    UserField user_field(user_field_id_t id) const noexcept;

    /**
     * @brief Список идентификаторов дополнительных полей
     * @return  Список идентификаторов дополнительных полей
     */
    ::std::set<user_field_id_t> user_field_ids() const noexcept;

    /// \deprecated Функция будет исключена в последующих версиях.
    Transaction transaction(size_t index) const;

    /**
     * @brief Получить транзакцию по идентификатору
     * @param[in] id Идентификатор транзакции
     * @return Возвращает объект транзакции. Если транзакции не существует в данном пуле, возвращается
     *         невалидный объект (\ref ::csdb::Transaction::is_valid() == false).
     */
    Transaction transaction(TransactionID id) const;

    /**
     * @brief Получить последнюю транзакцию по адресу источника
     * @param[in] source Адрес источника
     * @return Возвращает объект транзакции. Если транзакции не существует в данном пуле, возвращается
     *         невалидный объект (\ref ::csdb::Transaction::is_valid() == false).
     */
    Transaction get_last_by_source(const Address& source) const noexcept;

    /**
     * @brief Получить последнюю транзакцию по адресу назначения
     * @param[in] source Адрес назначения
     * @return Возвращает объект транзакции. Если транзакции не существует в данном пуле, возвращается
     *         невалидный объект (\ref ::csdb::Transaction::is_valid() == false).
     */
    Transaction get_last_by_target(const Address& target) const noexcept;

    friend class Storage;
};

inline bool PoolHash::operator !=(const PoolHash &other) const noexcept
{
  return !operator ==(other);
}
}  // namespace csdb

#endif // _CREDITS_CSDB_POOL_H_INCLUDED_
```
# ..\node\csdb\include\csdb\storage.hpp 
```cpp 
/**
 * @file storage.h
 * @author Roman Bukin, Evgeny Zalivochkin
 */

#ifndef _CREDITS_CSDB_STORAGE_H_INCLUDED_
#define _CREDITS_CSDB_STORAGE_H_INCLUDED_

#include <functional>
#include <memory>
#include <string>
#include <vector>

#include "csdb/database.hpp"
#include "csdb/transaction.hpp"

#include <lib/system/common.hpp>
#include <lib/system/signals.hpp>

namespace csdb {

class Pool;
class PoolHash;
class Address;
class Wallet;
class Transaction;
class TransactionID;

/** @brief The read block signal, caller may assign test_failed to true if block is logically corrupted */
using ReadBlockSignal = cs::Signal<void(const csdb::Pool& block, bool* test_failed)>;

/**
 * @brief Объект хранилища.
 *
 * Объект хранилища является классом, через который осуществляется дальнейшая работа с данными
 * в хранилище (чтение, запись и т.п.). Объект по сути является "разделяемым указателем" (shared_ptr),
 * поэтому может свододно копироваться, однако фактически копии ссылаются на один и то же экземпляр,
 * и изменения, произведённые в одном из экземпляров, отразятся во всех копиях.
 *
 * Для работы с физическим хранилищем используется интерфейсный класс \ref ::csdb::Database.
 *
 * В данный момент имеется единственная реализация интерфейса \ref ::csdb::Database -
 * \ref ::csdb::DatabaseLevelDB. Она же используется при открытии объекта \ref ::csdb::Storage.
 *
 * При создании объект \ref ::csdb::Storage имеет статус "не открытого", вызовы любых методов получени
 * или записи данных порождают ошибку ::csdb::Storage::NotOpen. Для работы с объектом \ref ::csdb::Storage
 * необходимо вызывать функцию \ref ::csdb::Storage::open или создать объект с помощью функции
 * ::csdb::Storage::get.
 */
class Storage final {
private:
    class priv;

    bool write_queue_search(const PoolHash& hash, Pool& res_pool) const;
    bool write_queue_pop(Pool& res_pool);

public:
    using WeakPtr = ::std::weak_ptr<priv>;

    enum Error {
        NoError = 0,
        NotOpen = 1,
        DatabaseError = 2,
        ChainError = 3,
        DataIntegrityError = 4,
        UserCancelled = 5,
        InvalidParameter = 6,
        UnknownError = 255,
    };

public:
    Error last_error() const;
    std::string last_error_message() const;
    Database::Error db_last_error() const;
    std::string db_last_error_message() const;

public:
    Storage();
    ~Storage();

public:
    Storage(const Storage&) = default;
    Storage(Storage&&) = default;
    Storage& operator=(const Storage&) = default;
    Storage& operator=(Storage&&) = default;

    explicit Storage(WeakPtr ptr) noexcept;
    WeakPtr weak_ptr() const noexcept;

public:
    struct OpenOptions {
        /// Экземпляр драйвера базы данных
        ::std::shared_ptr<Database> db;
    };

    struct OpenProgress {
        uint64_t poolsProcessed;
    };

    /**
     * @brief Callback для операции открытия
     * @return true, если операцию необходимо прервать.
     */
    typedef ::std::function<bool(const OpenProgress&)> OpenCallback;

    /**
     * @brief Открывает хранилище по набору параметров.
     * @param opt       Набор параметров для открытия. Член стурктуры \ref OpenOptions::db должен
     *                  указывать на уже открытую базу.
     * @param callback  Функция обратного вызова для процедуры открытия
     * @return          true, если открытие и анализ прошли успешно. В противном случае false.
     *
     * В случае неудачи информацию об ошибке можно получить с помошью методов \ref last_error,
     * \ref last_error_message, \ref db_last_error() и \ref db_last_error_message()
     */
    bool open(const OpenOptions& opt, OpenCallback callback = nullptr);

    /**
     * @brief Открывает хранилище по пути к хранилищу
     * @param path_to_base  Путь к базе данных (слеш в конце необязателен)
     * @param callback      Функция обратного вызова для процедуры открытия
     * @return              true, если открытие и анализ прошли успешно. В противном случае false.
     * @overload
     *
     * Метод пытается открыть существующее (или создать новое) хранилище с драйвером базы
     * данных, определённым для текущей платформы. Если указанный путь не существует, метод пытается
     * создать указанный путь. Если передан пустой путь, то используется путь по умолчанию для
     * текущей платформы.
     *
     * В случае неудачи информацию об ошибке можно получить с помошью методов \ref last_error,
     * \ref last_error_message, \ref db_last_error() и \ref db_last_error_message()
     */
    bool open(const ::std::string& path_to_base = ::std::string{}, OpenCallback callback = nullptr);

    /**
     * @brief Создание хранилища по набору параметров.
     *
     * Создаёт объект хранилища и пытается его открыть. См. \ref open(const OpenOptions &opt, OpenCallback callback);
     */
    static inline Storage get(const OpenOptions& opt, OpenCallback callback = nullptr);

    /**
     * @brief Создание хранилища по пути к хранилищу.
     *
     * Создаёт объект хранилища и пытается его открыть.
     * См. \ref open(const ::std::string& path_to_base, OpenCallback callback);
     */
    static inline Storage get(const ::std::string& path_to_base = ::std::string{}, OpenCallback callback = nullptr);

    /**
     * @brief Проверяет, открыто ли хранилище.
     * @return true, если хранилище открыто и с ним можно работать. Иначе false.
     */
    bool isOpen() const;

    /**
     * @brief Закрывает хранилище
     *
     * После вызова этого метода обращение к любым методам получения или записи данных приводят
     * к ошибке \ref NotOpen.
     */
    void close();

    /**
     * @brief Хэш последнего блока
     * @return Хэш последнего блока
     *
     * Хеш последнего блока возвращается корректно только в том случае, если блоки,
     * помещённые в хранилище (в том числе и после открытия), образуют корректную
     * связанную цепочку.
     *
     * Если хранилище пустое, или не содержит законченной цепочки, возвращается пустой хэш.
     */
    PoolHash last_hash() const noexcept;
    void set_last_hash(const PoolHash&) noexcept;
    void set_size(const size_t) noexcept;

    /**
     * @brief Записавает пул в хранилище
     * @param[in] pool Пул для записи в хранилище.
     * @return true, если пул успешно записан.
     *
     * \sa ::csdb::Pool::save
     */
    bool pool_save(Pool pool);

    /**
     * @brief Загружает пул из хранилища
     * @param[in] hash Хэш пула, который надо загрузить.
     * @return Загруженный пул. Если пул не найден или данные из хранилища не могут быть
     *         интерпретированы, как пул, возвращается невалидный пул.
     *         (\ref ::csdb::Pool::is_valid() == false).
     *
     * \sa ::csdb::Pool::load
     */
    Pool pool_load(const PoolHash& hash) const;
    Pool pool_load(const cs::Sequence sequence) const;
    Pool pool_load_meta(const PoolHash& hash, size_t& cnt) const;

    Pool pool_remove_last();

    /**
     * @brief Получение транзакции по идентификатору.
     * @param[in] id Идентификатор транзакции
     * @return Объект транзакции. Если тразакции с таким идентификаторм отсутствует в хранилище,
     *         возвращается невалидный объект (\ref ::csdb::Transaction::is_valid() == false).
     */
    Transaction transaction(const TransactionID& id) const;

    /**
     * @brief Получить последнюю транзакцию по адресу источника
     * @param[in] source Адрес источника
     * @return Объект транзакции. Если транзакции не существует в данном пуле, возвращается
     *         невалидный объект (\ref ::csdb::Transaction::is_valid() == false).
     */
    Transaction get_last_by_source(Address source) const noexcept;

    /**
     * @brief Получить последнюю транзакцию по адресу назначения
     * @param[in] source Адрес назначения
     * @return Объект транзакции. Если транзакции не существует в данном пуле, возвращается
     *         невалидный объект (\ref ::csdb::Transaction::is_valid() == false).
     */
    Transaction get_last_by_target(Address target) const noexcept;

    // And now for something completely different
    PoolHash get_previous_transaction_block(const Address&, const PoolHash&);
    void set_previous_transaction_block(const Address&, const PoolHash& currTransBlock, const PoolHash& prevTransBlock);

    /**
     * @brief size возвращает количество пулов в хранилище
     * @return количество блоков в хранилище
     *
     * \deprecated Функция будет удалена в последующих версиях.
     */
    size_t size() const noexcept;

    /**
     * @brief wallet получить кошелек для указанного адреса
     * Кошелек содержит все данные для расчета баланса и проведению транзакций для
     * указанного адреса
     * @param addr адрес кошелька
     * @return кошелек
     */
    Wallet wallet(const Address& addr) const;

    /**
     * @brief transactions получить список транзакций для указанного адреса
     * @param addr адрес кошелька
     * @param limit маскимальное число транзакций в списке
     * @param offset идентификатор транзакции после которой начинать формирование списка
     * @return список транзакций
     *
     * \deprecated Функция будет удалена в последующих версиях.
     */
    std::vector<Transaction> transactions(const Address& addr, size_t limit = 100, const TransactionID& offset = TransactionID()) const;

    /**
     * @brief get_from_blockchain возвращает true, если транзакция с addr и innerId есть в blockchain
     * @param addr       адрес кошелька (input)
     * @param InnerId    id транзакции (input)
     * @Transaction trx  полученная транзакция (output)
     * @return содержит ли blockchain транзакцию
     *
     * \параметр addr должен точно совпадать с полем source у транзакции в блокчейне (если addr - id, source должен быть также id)
     * \используется для входного параметра addr в виде id кошелька
     */
    bool get_from_blockchain(const Address& addr /*input*/, const int64_t& innerId /*input*/, Transaction& trx /*output*/) const;

public signals:
    const ReadBlockSignal& readBlockEvent() const;

private:
  static cs::Bytes get_trans_index_key(const Address&, const PoolHash&);
  Pool pool_load_internal(const PoolHash& hash, const bool metaOnly, size_t& trxCnt) const;

  ::std::shared_ptr<priv> d;
};

inline Storage Storage::get(const OpenOptions &opt, OpenCallback callback)
{
  Storage s;
  s.open(opt, callback);
  return s;
}

inline Storage Storage::get(const std::string& path_to_base, OpenCallback callback)
{
  Storage s;
  s.open(path_to_base, callback);
  return s;
}

}  // namespace csdb

#endif // _CREDITS_CSDB_STORAGE_H_INCLUDED_
```
# ..\node\csdb\include\csdb\transaction.hpp 
```cpp 
/**
 * @file transaction.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_TRANSACTION_H_INCLUDED_
#define _CREDITS_CSDB_TRANSACTION_H_INCLUDED_

#include <set>

#include "csdb/user_field.hpp"

#include "csdb/internal/shared_data.hpp"
#include "csdb/internal/types.hpp"

#include "lib/system/common.hpp"

namespace csdb {

namespace priv {
class obstream;
class ibstream;
}  // namespace priv

class Address;
class Amount;
class AmountCommission;
class Currency;
class PoolHash;
class Pool;

/**
 * @brief Уникальный идетификатор транзакции в базе
 *
 * Класс позволяет однозначно идентифицировать транзакцию в базе. Транзакция получает этот
 * идентификатор только после того, как она была помещена в пул, и пул был записан в базу.
 *
 * Конкретретное содержимое этого класса не специфицируется. Для получения идентификатора
 * используется метод \ref Transaction::id, а также предоставляются методы преобразования
 * в строку (\ref TransactionID::to_string) и получения из строки (\ref TransactionID::from_string).
 *
 * Конкретный формат строки также не специфицируется, однако класс гарантирует, что любая
 * строка, полученная с помощью метода \ref TransactionID::to_string, будет преобразована
 * к валидному идентификатору с помощью метода \ref TransactionID::from_string.
 *
 * Единственное специфицируемая часть содержимого класса - это возможность получить
 * \ref PoolHash для пула, в который помещена транзакция.
 */
class TransactionID {
    SHARED_DATA_CLASS_DECLARE(TransactionID)
public:
    /// \deprecated Конструктор будет удалён в следующих версиях.
    TransactionID(PoolHash poolHash, cs::Sequence index);

    bool is_valid() const noexcept;
    PoolHash pool_hash() const noexcept;

    /// \deprecated Метод будет удалён в следующих версиях.
    cs::Sequence index() const noexcept;

    std::string to_string() const noexcept;
    cs::Bytes to_byte_stream() const noexcept;

    /**
     * @brief Получение идентификатора транзакции из строкового представления
     * @param[in] str Строковое представление идентификатора транзакции
     * @return Идентификатор транзакции, полученный из строкового представления
     *
     * В случае, если строковое представление не может быть декодировано как
     * идетификатор транзакции, возвращаемый идентификатор невалидны
     * (\ref is_valid() возвращает false)
     */
    static TransactionID from_string(const ::std::string& str);

    bool operator==(const TransactionID& other) const noexcept;
    bool operator!=(const TransactionID& other) const noexcept;
    bool operator<(const TransactionID& other) const noexcept;

private:
    void put(::csdb::priv::obstream&) const;
    bool get(::csdb::priv::ibstream&);
    friend class ::csdb::priv::obstream;
    friend class ::csdb::priv::ibstream;
    friend class Transaction;
    friend class Pool;
    friend class Storage;
};

class Transaction {
    SHARED_DATA_CLASS_DECLARE(Transaction)

public:
    Transaction(int64_t innerID, Address source, Address target, Currency currency, Amount amount, AmountCommission max_fee, AmountCommission counted_fee,
                const cs::Signature& signature);

    bool is_valid() const noexcept;
    bool is_read_only() const noexcept;

    TransactionID id() const noexcept;
    int64_t innerID() const noexcept;
    Address source() const noexcept;
    Address target() const noexcept;
    Currency currency() const noexcept;
    Amount amount() const noexcept;
    AmountCommission max_fee() const noexcept;
    AmountCommission counted_fee() const noexcept;
    const cs::Signature& signature() const noexcept;

    void set_innerID(int64_t innerID);
    void set_source(Address source);
    void set_target(Address target);
    void set_currency(Currency currency);
    void set_amount(Amount amount);
    void set_max_fee(AmountCommission max_fee);
    void set_counted_fee(AmountCommission counted_fee);
    void set_counted_fee_unsafe(AmountCommission counted_fee);
    void set_signature(const cs::Signature& signature);

    cs::Bytes to_binary();
    static Transaction from_binary(const cs::Bytes& data);

    static Transaction from_byte_stream(const char* data, size_t m_size);
    std::vector<uint8_t> to_byte_stream() const;
    std::vector<uint8_t> to_byte_stream_for_sig() const;

    bool verify_signature(const cs::PublicKey& public_key) const;

    /**
     * @brief Добавляет дополнительное произвольное поле к транзакции
     * @param[in] id    Идентификатор дополнительного поля
     * @param[in] field Значение дополнительного поля
     * @return true, если поле добавлено, false в противном случае
     *
     * Поле добавляется только для транзакций, не находящихся в режим Read-Only
     * (\ref is_read_only возвращает false).
     *
     * Если поле с таким идентификатором было добавлено ранее, они замещается новым.
     */
    bool add_user_field(user_field_id_t id, UserField field) noexcept;

    /**
     * @brief Возвращает дополнительное поле.
     * @param[in] id  Идентификатор дополнительного поля
     * @return  Значение дополнительного поля. Если поля с таким идентификатором нет в списке
     *          дополнительных полей, возвращается невалидный объект
     *          (\ref UserField::is_valid == false).
     */
    UserField user_field(user_field_id_t id) const noexcept;

    /**
     * @brief Список идентификаторов дополнительных полей
     * @return  Список идентификаторов дополнительных полей
     */
    ::std::set<user_field_id_t> user_field_ids() const noexcept;

    void set_time(const uint64_t);
    uint64_t get_time() const;

private:
  void put(::csdb::priv::obstream&) const;
  bool get(::csdb::priv::ibstream&);
  friend class ::csdb::priv::obstream;
  friend class ::csdb::priv::ibstream;
  friend class Pool;
};

}  // namespace csdb

#endif // _CREDITS_CSDB_TRANSACTION_H_INCLUDED_
```
# ..\node\csdb\include\csdb\user_field.hpp 
```cpp 
/**
 * @file user_field.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_USER_FIELD_H_INCLUDED_
#define _CREDITS_CSDB_USER_FIELD_H_INCLUDED_

#include <cinttypes>
#include <string>
#include <type_traits>
#include <vector>

#include "csdb/amount.hpp"
#include "csdb/internal/shared_data.hpp"

namespace csdb {

namespace priv {
class obstream;
class ibstream;
}  // namespace priv

/**
 * Тип идентификатора поля. Тип знаковый. Предполагается, что "стандартные" идентификатор,
 * перечеисленные ниже, отрицательные. "Пользовательские" идентификаторы положительные.
 *
 * Тип дополнительного поля никак не связан с его идентификатором, т.е. дополнительное поле
 * с конкретным идентификатором может быть любого типа, однако в одном объекте не могут
 * быть два поля с одинаковым идетификатором и разными типами (добавление поля с тем
 * же идентификатором замещает предыдущее добавленное значение).
 */
using user_field_id_t = int32_t;

/**
 * @brief Строковый комментарий
 */
constexpr const user_field_id_t UFID_COMMENT = (-1);

/**
 * @brief Класс для хранения значения дополнительного поля.
 *
 * Класс предназначен для храниения типизированного значения дополнительного поля. В настоящий
 * момент поддерживаются три типа значения:
 * - произвольное целое число (::std::is_integral<T>::value == true)
 * - строка (произвольные бинарные данные с длиной, ::std::string)
 * - \ref ::csdb::Amount
 *
 * В классе имеет набор конструкторов для конструирования объекта класса из любого из
 * перечисленных типов, а также шаблон \ref value, позволяющий получать значение поля соответстующего
 * типа. Если тип поля не соответствует запрашиваемому тип, возвращается значени типа по
 * умолчанию (пустая строка для строк, 0 для остальных).
 *
 * Дополнительные поля используются в классах \ref Transaction и \ref Pool.
 */
class UserField {
    SHARED_DATA_CLASS_DECLARE(UserField)
public:
    enum Type : char {
        Unknown = 0,
        Integer = 1,
        String = 2,
        Amount = 3
    };

    template <typename T, typename = typename ::std::enable_if<::std::is_integral<T>::value>::type>
    UserField(T value);
    template <typename T, typename = typename ::std::enable_if<!::std::is_integral<T>::value>::type>
    UserField(const T& value);

    UserField(const char* value);

    bool is_valid() const noexcept;
    Type type() const noexcept;

    template <typename T>
    typename ::std::enable_if<!::std::is_integral<T>::value, T>::type value() const noexcept;

    template <typename T>
    typename ::std::enable_if<::std::is_integral<T>::value, T>::type value() const noexcept;

    bool operator==(const UserField& other) const noexcept;
    inline bool operator!=(const UserField& other) const noexcept;

private:
    void put(::csdb::priv::obstream&) const;
    void put_for_sig(::csdb::priv::obstream&) const;
    bool get(::csdb::priv::ibstream&);
    friend class ::csdb::priv::obstream;
    friend class ::csdb::priv::ibstream;
};

inline bool UserField::operator !=(const UserField& other) const noexcept
{
  return !operator ==(other);
}

template<>
UserField::UserField(uint64_t value);

template<typename T, typename>
inline UserField::UserField(T value) :
  UserField(static_cast<uint64_t>(value))
{}

template<>
inline UserField::UserField(bool value) :
  UserField(static_cast<uint64_t>(value ? 1 : 0))
{}

template<>
uint64_t UserField::value<uint64_t>() const noexcept;

template<>
inline bool UserField::value<bool>() const noexcept
{
  return (0 != value<uint64_t>());
}

template<typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type
inline UserField::value() const noexcept
{
  return static_cast<T>(value<uint64_t>());
}

}  // namespace csdb

#endif // _CREDITS_CSDB_USER_FIELD_H_INCLUDED_
```
# ..\node\csdb\include\csdb\wallet.hpp 
```cpp 
/**
 * @file wallet.h
 * @author Roman Bukin
 */

#ifndef _CREDITS_CSDB_WALLET_H_INCLUDED_
#define _CREDITS_CSDB_WALLET_H_INCLUDED_

#include "csdb/currency.hpp"
#include "csdb/internal/shared_data.hpp"
#include "csdb/storage.hpp"

namespace csdb {

class Address;
class Amount;
class Storage;

class Wallet {
    SHARED_DATA_CLASS_DECLARE(Wallet)

public:
    static Wallet get(Address address, Storage storage = Storage());

    bool is_valid() const noexcept;
    Address address() const noexcept;

    CurrencyList currencies() const noexcept;
    Amount amount(Currency currency) const noexcept;
};

}  // namespace csdb

#endif  // _CREDITS_CSDB_WALLET_H_INCLUDED_
```
# ..\node\csdb\include\csdb\internal\endian.hpp 
```cpp 
/**
 * @file endian.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_INTERNAL_ENDIAN_H_INCLUDED_
#define _CREDITS_CSDB_INTERNAL_ENDIAN_H_INCLUDED_

#include <cinttypes>
#include <cstddef>
#include <type_traits>

namespace csdb {
namespace internal {

template <typename T, size_t size>
struct _reverse_byte_order_helper {
    static inline T constexpr value(T v);
};

template <typename T>
T inline constexpr reverse_byte_order(T value) {
    return _reverse_byte_order_helper<T, sizeof(T)>::value(value);
}

#if defined(CSDB_PLATFORM_IS_LITTLE_ENDIAN)

template <typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type inline constexpr to_little_endian(T value) {
    return value;
}

template <typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type inline constexpr from_little_endian(T value) {
    return value;
}

template <typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type inline constexpr to_big_endian(T value) {
    return reverse_byte_order(value);
}

template <typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type inline constexpr from_big_endian(T value) {
    return reverse_byte_order(value);
}

#elif defined(CSDB_PLATFORM_IS_BIG_ENDIAN)

template <typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type inline constexpr to_little_endian(T value) {
    return reverse_byte_order(value);
}

template <typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type inline constexpr from_little_endian(T value) {
    return reverse_byte_order(value);
}

template <typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type inline constexpr to_big_endian(T value) {
    return value;
}

template <typename T>
typename ::std::enable_if<::std::is_integral<T>::value, T>::type inline constexpr from_big_endian(T value) {
    return value;
}

#else
#error Configuration error - platform endian is not defined!
#endif

template <typename T, size_t size>
inline T constexpr _reverse_byte_order_helper<T, size>::value(T v) {
    static_assert((1 < size) && (sizeof(T) >= size), "Invalid usage.");
    return (v & 0xFF) << ((size - 1) * 8) | _reverse_byte_order_helper<T, size - 1>::value(v >> 8);
}

template <typename T>
struct _reverse_byte_order_helper<T, 1> {
    static inline T constexpr value(T v) {
        return v;
    }
};

}  // namespace internal
}  // namespace csdb

#endif  // _CREDITS_CSDB_INTERNAL_ENDIAN_H_INCLUDED_
```
# ..\node\csdb\include\csdb\internal\math128ce.hpp 
```cpp 
/**
 * @file math128ce.h
 * @author Evgeny V. Zalivochkin
 * @brief Небольшой набор constexpr-функций и классов для работы со 128-битной арифметикой.
 */

#ifndef _CREDITS_CSDB_INTERNAL_MATH128CE_H_INCLUDED_
#define _CREDITS_CSDB_INTERNAL_MATH128CE_H_INCLUDED_

#include <cinttypes>
#include <stdexcept>
#include <type_traits>

namespace csdb {
namespace internal {

#pragma pack(push, 1)
struct uint128_t {
    uint64_t lo_ = 0;
    uint64_t hi_ = 0;

    constexpr inline uint128_t() noexcept {
    }
    constexpr inline uint128_t(const uint64_t lo) noexcept
    : lo_(lo) {
    }
    constexpr inline uint128_t(const uint64_t lo, const uint64_t hi) noexcept
    : lo_(lo)
    , hi_(hi) {
    }

    constexpr inline uint128_t operator+(const uint64_t summand) const noexcept;
    constexpr inline uint128_t operator+(const uint128_t& summand) const noexcept;

    // Умножение
public:
    static constexpr inline uint128_t mul(uint64_t a, uint64_t b);

private:
    static constexpr inline uint128_t mul1(const uint64_t a, const uint64_t b, const uint64_t c, const uint64_t d);
    static constexpr inline uint128_t mul2(const uint64_t ac, const uint64_t ad, const uint64_t bc, const uint64_t bd);

    // Деление
public:
    struct division64_result;
    constexpr inline division64_result div(const uint64_t divisor) const;

private:
    constexpr inline division64_result div1(const division64_result& previous, const uint64_t divisor, const size_t shift) const;
    constexpr inline division64_result div2(const division64_result& previous, const uint64_t divisor, const size_t shift) const;
    constexpr inline division64_result div3(const division64_result& previous, const uint64_t divisor, const uint64_t bit, const uint64_t dividend) const;
};

struct uint128_t::division64_result {
    uint128_t quotient_;
    uint64_t remainder_;
};
#pragma pack(pop)

}  // namespace internal
}  // namespace csdb

constexpr inline csdb::internal::uint128_t csdb::internal::uint128_t::operator+(const uint64_t summand) const noexcept {
    return ((0xFFFFFFFFFFFFFFFFULL - lo_) < summand) ? uint128_t(lo_ - (0xFFFFFFFFFFFFFFFFULL - summand + 1), hi_ + 1) : csdb::internal::uint128_t(lo_ + summand, hi_);
}

constexpr inline csdb::internal::uint128_t csdb::internal::uint128_t::operator+(const uint128_t& summand) const noexcept {
    return ((0xFFFFFFFFFFFFFFFFULL - lo_) < summand.lo_) ? uint128_t(lo_ - (0xFFFFFFFFFFFFFFFFULL - summand.lo_ + 1), hi_ + summand.hi_ + 1)
                                                         : csdb::internal::uint128_t(lo_ + summand.lo_, hi_ + summand.hi_);
}

constexpr inline csdb::internal::uint128_t csdb::internal::uint128_t::mul(uint64_t a, uint64_t b) {
    return mul1(a >> 32, a & 0xFFFFFFFFUL, b >> 32, b & 0xFFFFFFFFUL);
}

constexpr inline csdb::internal::uint128_t csdb::internal::uint128_t::mul1(const uint64_t a, const uint64_t b, const uint64_t c, const uint64_t d) {
    return mul2(a * c, a * d, b * c, b * d);
}

constexpr inline csdb::internal::uint128_t csdb::internal::uint128_t::mul2(const uint64_t ac, const uint64_t ad, const uint64_t bc, const uint64_t bd) {
    return uint128_t(bd, ac + (ad >> 32) + (bc >> 32)) + (ad << 32) + (bc << 32);
}

constexpr inline csdb::internal::uint128_t::division64_result csdb::internal::uint128_t::div(const uint64_t divisor) const {
    return (0ULL == divisor) ? throw std::overflow_error("Division by zero")
                             : (1ULL == divisor) ? division64_result{*this, 0} : div1(division64_result{{0, hi_ / divisor}, hi_ % divisor}, divisor, 63);
}

constexpr inline csdb::internal::uint128_t::division64_result csdb::internal::uint128_t::div1(const division64_result& previous, const uint64_t divisor, const size_t shift) const {
    return (0 == shift) ? div2(previous, divisor, shift) : div1(div2(previous, divisor, shift), divisor, shift - 1);
}

constexpr inline csdb::internal::uint128_t::division64_result csdb::internal::uint128_t::div2(const division64_result& previous, const uint64_t divisor, const size_t shift) const {
    return div3(previous, divisor, 1ULL << shift, (previous.remainder_ << 1) + ((lo_ >> shift) & 0x1));
}

constexpr inline csdb::internal::uint128_t::division64_result csdb::internal::uint128_t::div3(const division64_result& previous, const uint64_t divisor, const uint64_t bit,
                                                                                              const uint64_t dividend) const {
    return (0 == (0x8000000000000000ULL & previous.remainder_))
               ? division64_result{{previous.quotient_.lo_ + ((dividend < divisor) ? 0 : bit), previous.quotient_.hi_}, dividend % divisor}
               : division64_result{{previous.quotient_.lo_ + bit, previous.quotient_.hi_}, 0xFFFFFFFFFFFFFFFF - divisor + dividend + 1};
}

static_assert(std::is_trivially_copyable<csdb::internal::uint128_t>::value, "Invalid csdb::internal::uint128_t definition.");
static_assert(sizeof(csdb::internal::uint128_t) == 16, "Invalid size of csdb::internal::uint128_t.");

#endif // _CREDITS_CSDB_INTERNAL_MATH128CE_H_INCLUDED_
```
# ..\node\csdb\include\csdb\internal\shared_data.hpp 
```cpp 
/**
 * @file shared_data.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_SHARED_DATA_H_INCLUDED
#define _CREDITS_CSDB_SHARED_DATA_H_INCLUDED

#include <atomic>
#include <type_traits>

namespace csdb {
namespace internal {

template <class T>
class shared_data_ptr {
public:
    shared_data_ptr(const shared_data_ptr<T>& o) noexcept;
    shared_data_ptr(shared_data_ptr<T>&&) noexcept;
    explicit shared_data_ptr(T* data) noexcept;
    ~shared_data_ptr();

public:
    inline const T& operator*() const {
        return *d;
    }
    inline const T* operator->() const {
        return d;
    }
    inline T& operator*() {
        detach();
        return *d;
    }
    inline T* operator->() {
        detach();
        return d;
    }
    inline operator T*() {
        detach();
        return d;
    }
    inline operator const T*() const {
        return d;
    }
    inline T* data() {
        detach();
        return d;
    }
    inline const T* data() const {
        return d;
    }
    inline const T* constData() const {
        return d;
    }

    inline bool operator==(const shared_data_ptr<T>& other) const {
        return d == other.d;
    }
    inline bool operator!=(const shared_data_ptr<T>& other) const {
        return d != other.d;
    }

    shared_data_ptr<T>& operator=(const shared_data_ptr<T>&) noexcept;
    shared_data_ptr<T>& operator=(shared_data_ptr<T>&&) noexcept;

private:
    inline void detach();

private:
    T* d = nullptr;
};

static_assert((sizeof(shared_data_ptr<int>) == sizeof(void*)), "Invalid csdb::shared_data_ptr definition.");

}  // namespace internal
}  // namespace csdb

#ifdef CSDB_UNIT_TEST
#define UNIT_TEST_METHODS_DECLARE    \
public:                              \
    bool copy_semantic_used() const; \
    bool move_semantic_used() const;
#else
#define UNIT_TEST_METHODS_DECLARE
#endif

#define SHARED_DATA_CLASS_DECLARE(class_name)          \
public:                                                \
    class_name();                                      \
    class_name(const class_name&) noexcept;            \
    class_name(class_name&&) noexcept;                 \
    class_name& operator=(const class_name&) noexcept; \
    class_name& operator=(class_name&&) noexcept;      \
    ~class_name();                                     \
    class_name clone() const;                          \
    UNIT_TEST_METHODS_DECLARE                          \
private:                                               \
    class priv;                                        \
    class_name(priv* source);                          \
    ::csdb::internal::shared_data_ptr<priv> d;

#endif  // _CREDITS_CSDB_SHARED_DATA_H_INCLUDED
```
# ..\node\csdb\include\csdb\internal\shared_data_ptr_implementation.hpp 
```cpp 
/**
 * @file shared_data_ptr_implementation.h
 * @author Evgeny V. Zalivochkin
 */

#ifndef _CREDITS_CSDB_SHARED_DATA_PTR_IMPLEMENTATION_H_INCLUDED_
#define _CREDITS_CSDB_SHARED_DATA_PTR_IMPLEMENTATION_H_INCLUDED_

#include "shared_data.hpp"

#include <utility>

namespace csdb {
namespace internal {

class shared_data {
public:
    inline shared_data()
    : ref(0) {
    }
    inline shared_data(const shared_data &)
    : ref(0) {
    }

private:
    shared_data(shared_data &&) = delete;
    shared_data &operator=(const shared_data &) = delete;
    shared_data &operator=(shared_data &&) = delete;

public:
    mutable std::atomic<std::size_t> ref;
#ifdef CSDB_UNIT_TEST
    bool copy_semantic_used_ = false;
    bool move_semantic_used_ = false;
#endif
};

template <class T>
inline shared_data_ptr<T>::shared_data_ptr(const shared_data_ptr<T> &o) noexcept
: d(o.d) {
    if (d) {
        if (1 < (++d->ref)) {
#ifdef CSDB_UNIT_TEST
            d->copy_semantic_used_ = true;
#endif
        }
    }
}

template <class T>
inline shared_data_ptr<T>::shared_data_ptr(shared_data_ptr<T> &&o) noexcept
: d(o.d) {
    o.d = nullptr;
#ifdef CSDB_UNIT_TEST
    d->move_semantic_used_ = true;
#endif
}

template <class T>
inline shared_data_ptr<T>::shared_data_ptr(T *data) noexcept
: d(data) {
    if (d) {
        if (1 < (++d->ref)) {
#ifdef CSDB_UNIT_TEST
            d->copy_semantic_used_ = true;
#endif
        }
    }
}

template <class T>
inline shared_data_ptr<T>::~shared_data_ptr() {
    if (d && (0 == (--d->ref))) {
        delete d;
    }
}

template <class T>
inline shared_data_ptr<T> &shared_data_ptr<T>::operator=(const shared_data_ptr<T> &o) noexcept {
    if (&o == this) {
        return *this;
    }

    if (o.d != d) {
        if (o.d) {
            if (1 < (++o.d->ref)) {
#ifdef CSDB_UNIT_TEST
                o.d->copy_semantic_used_ = true;
#endif
            }
        }
        T *old = d;
        d = o.d;
        if (old && (0 == (--old->ref))) {
            delete old;
        }
    }
    return *this;
}

template <class T>
inline shared_data_ptr<T> &shared_data_ptr<T>::operator=(shared_data_ptr<T> &&o) noexcept {
    std::swap(d, o.d);
#ifdef CSDB_UNIT_TEST
    d->move_semantic_used_ = true;
#endif
    return *this;
}

template <class T>
inline void shared_data_ptr<T>::detach() {
    if (d && (d->ref != 1)) {
        T *x = new T(*d);
        ++x->ref;
        if (0 == (--d->ref)) {
            delete d;
        }
        d = x;
    }
}

}  // namespace internal
}  // namespace csdb

#ifdef CSDB_UNIT_TEST
#define UNIT_TEST_METHODS_IMPLEMENTATION(class_name) \
    bool class_name::copy_semantic_used() const {    \
        return d->copy_semantic_used_;               \
    }                                                \
    bool class_name::move_semantic_used() const {    \
        return d->move_semantic_used_;               \
    }
#else
#define UNIT_TEST_METHODS_IMPLEMENTATION(class_name)
#endif

#define SHARED_DATA_CLASS_IMPLEMENTATION(class_name)                                                          \
    template class ::csdb::internal::shared_data_ptr<class_name::priv>;                                       \
    class_name::class_name()                                                                                  \
    : d(new class_name::priv) {                                                                               \
        static_assert(std::is_base_of<::csdb::internal::shared_data, class_name::priv>::value,                \
                      "class `" #class_name "::priv` must be derived from `::csdb::internal::shared_data`."); \
    }                                                                                                         \
    class_name::class_name(const class_name &o) noexcept                                                      \
    : d(o.d) {                                                                                                \
    }                                                                                                         \
    class_name::class_name(class_name &&o) noexcept                                                           \
    : d(std::move(o.d)) {                                                                                     \
    }                                                                                                         \
    class_name &class_name::operator=(const class_name &o) noexcept {                                         \
        if (&o != this) {                                                                                     \
            d = o.d;                                                                                          \
        }                                                                                                     \
        return *this;                                                                                         \
    }                                                                                                         \
    class_name &class_name::operator=(class_name &&o) noexcept {                                              \
        d = std::move(o.d);                                                                                   \
        return *this;                                                                                         \
    }                                                                                                         \
    class_name::class_name(priv *source)                                                                      \
    : d(source) {                                                                                             \
    }                                                                                                         \
    class_name::~class_name() {                                                                               \
    }                                                                                                         \
    class_name class_name::clone() const {                                                                    \
        return class_name(new priv(d->clone()));                                                              \
    }                                                                                                         \
    UNIT_TEST_METHODS_IMPLEMENTATION(class_name)

#define DEFAULT_PRIV_CLONE() \
    priv clone() const {     \
        return priv(*this);  \
    }

#endif  // _CREDITS_CSDB_SHARED_DATA_PTR_IMPLEMENTATION_H_INCLUDED_
```
# ..\node\csdb\include\csdb\internal\sorted_array_set.hpp 
```cpp 
#ifndef SORTED_ARRAY_SET_H
#define SORTED_ARRAY_SET_H

#include <algorithm>
#include <cassert>
#include <cinttypes>
#include <cstring>

namespace csdb {
namespace internal {

class sorted_array_set {
public:
    using Byte = uint8_t;
    using SizeType = size_t;

    sorted_array_set() = default;

    sorted_array_set(const Byte* elements, SizeType elementsCount, SizeType elementSize)
    : elements{elements}
    , elementsCount{elementsCount}
    , elementSize{elementSize} {
        assert(elements != nullptr);
        assert(elementsCount > 0);
        assert(elementSize > 0);
    }

    // Copy semantics might be unclear to the user, thus disallow copy and assign for now
    sorted_array_set(const sorted_array_set&) = delete;
    sorted_array_set& operator=(const sorted_array_set&) = delete;

    sorted_array_set(sorted_array_set&&) = default;
    sorted_array_set& operator=(sorted_array_set&&) = default;

    template <class T>
    sorted_array_set(const T* elements, SizeType elementsCount, SizeType elementSize = sizeof(T))
    : sorted_array_set(reinterpret_cast<const Byte*>(elements), elementsCount, elementSize) {
    }

    template <class T>
    bool contains(const T* element) const {
        assert(element != nullptr);

        const Byte* ptr = reinterpret_cast<const Byte*>(element);
        const size_t index = getIndex(ptr);
        return index != size();
    }

    template <class T>
    size_t getIndex(const T* element) const {
        assert(element != nullptr);

        const Byte* ptr = reinterpret_cast<const Byte*>(element);
        const size_t index = find(ptr);
        return index;
    }

    const Byte* operator[](size_t index) const {
        return &elements[index * elementSize];
    }

    size_t size() const {
        return elementsCount;
    }

    template <size_t E, class T>
    static void sort(T* ptr, SizeType elementsCount) {
        static constexpr size_t elementSize = E;

        struct Element {
            Byte data[elementSize];
        };

        Element* elements = reinterpret_cast<Element*>(ptr);
        Comparator comparator(elementSize);

        std::sort(elements, elements + elementsCount, [&](const Element& l, const Element& r) {
            const Byte& a = reinterpret_cast<const Byte&>(l);
            const Byte& b = reinterpret_cast<const Byte&>(r);
            return comparator(a, b);
        });
    }

    template <size_t E, class T>
    static bool isSorted(const T* ptr, SizeType elementsCount) {
        static constexpr size_t elementSize = E;

        struct Element {
            Byte data[elementSize];
        };

        const Element* elements = reinterpret_cast<const Element*>(ptr);
        Comparator comparator(elementSize);

        auto sorted = std::is_sorted(elements, elements + elementsCount, [&](const Element& l, const Element& r) {
            const Byte& a = reinterpret_cast<const Byte&>(l);
            const Byte& b = reinterpret_cast<const Byte&>(r);
            return comparator(a, b);
        });

        return sorted;
    }

private:
    struct Comparator {
        bool operator()(const Byte& l, const Byte& r) const {
            auto res = std::lexicographical_compare(&l, &l + elementSize, &r, &r + elementSize);
            return res;
        }

        Comparator(SizeType elementSize)
        : elementSize{elementSize} {
        }

        SizeType elementSize;
    };

    template <class I, class T, class P>
    I lower_bound(I first, I last, const T& val, const P& pred) const {
        using namespace std;

        I it;
        typename iterator_traits<I>::difference_type count, step;
        count = distance(first, last) / elementSize;

        while (count > 0) {
            it = first;
            step = count / 2;
            advance(it, step * elementSize);

            if (pred(*it, val)) {
                it += elementSize;
                first = it;
                count -= step + 1;
            }
            else {
                count = step;
            }
        }

        return first;
    }

    size_t find(const Byte* element) const {
        const SizeType length = elementsCount * elementSize;

        auto it = lower_bound(elements, elements + length, *element, Comparator(elementSize));

        if (it != (elements + length)) {
            if (memcmp(it, element, elementSize) == 0)
                return std::distance(elements, it) / elementSize;
        }

        return size();
    }

    const Byte* elements = nullptr;
    SizeType elementsCount = 0;
    SizeType elementSize = 0;
};

//
// Templated version
// (Easier to use, but no performance gain)
//

template <size_t N>
class sorted_array_set_t {
public:
    using Byte = uint8_t;
    using SizeType = size_t;

    static constexpr SizeType elementSize = N;

    sorted_array_set_t() = default;

    sorted_array_set_t(const Byte* elements, SizeType elementsCount)
    : elements{reinterpret_cast<const element_adaptor*>(elements)}
    , elementsCount{elementsCount} {
        assert(elements != nullptr);
        assert(elementsCount > 0);
    }

    // Copy semantics might be unclear to the user, thus disallow copy and assign for now
    sorted_array_set_t(const sorted_array_set_t&) = delete;
    sorted_array_set_t& operator=(const sorted_array_set_t&) = delete;

    sorted_array_set_t(sorted_array_set_t&&) = default;
    sorted_array_set_t& operator=(sorted_array_set_t&&) = default;

    template <class T>
    sorted_array_set_t(const T* elements, SizeType elementsCount)
    : sorted_array_set_t(reinterpret_cast<const Byte*>(elements), elementsCount) {
    }

    template <class T>
    bool contains(const T* element) const {
        assert(element != nullptr);

        const element_adaptor* ptr = reinterpret_cast<const element_adaptor*>(element);
        const size_t index = getIndex(ptr);
        return index != size();
    }

    template <class T>
    size_t getIndex(const T* element) const {
        assert(element != nullptr);

        const element_adaptor* ptr = reinterpret_cast<const element_adaptor*>(element);
        const size_t index = find(ptr);
        return index;
    }

    const Byte* operator[](size_t index) const {
        const Byte* element = reinterpret_cast<const Byte*>(&elements[index]);
        return element;
    }

    size_t size() const {
        return elementsCount;
    }

    template <class T>
    static void sort(T* ptr, SizeType elementsCount) {
        element_adaptor* elements = reinterpret_cast<element_adaptor*>(ptr);

        std::sort(elements, elements + elementsCount, Comparator());
    }

    template <class T>
    static bool isSorted(T* ptr, SizeType elementsCount) {
        element_adaptor* elements = reinterpret_cast<element_adaptor*>(ptr);

        auto sorted = std::is_sorted(elements, elements + elementsCount, Comparator());
        return sorted;
    }

private:
    struct element_adaptor {
        Byte data[elementSize];
    };

    struct Comparator {
        bool operator()(const element_adaptor& l, const element_adaptor& r) const {
            const Byte& a = reinterpret_cast<const Byte&>(l.data);
            const Byte& b = reinterpret_cast<const Byte&>(r.data);

            auto res = std::lexicographical_compare(&a, &a + elementSize, &b, &b + elementSize);
            return res;
        }
    };

    size_t find(const element_adaptor* element) const {
        auto end = elements + elementsCount;
        auto it = std::lower_bound(elements, end, *element, Comparator());

        if (it != end) {
            if (memcmp(it, element, elementSize) == 0)
                return std::distance(elements, it);
        }

        return size();
    }

    const element_adaptor* elements = nullptr;
    SizeType elementsCount = 0;
};

}  // namespace internal
}  // namespace csdb

#endif  // SORTED_ARRAY_SET_H
```
# ..\node\csdb\include\csdb\internal\types.hpp 
```cpp 
/**
 * @file types.h
 * @author Roman Bukin
 */

#ifndef _CREDITS_CSDB_TYPES_H_INCLUDED_
#define _CREDITS_CSDB_TYPES_H_INCLUDED_

#include <cinttypes>
#include <string>
#include <vector>

#include <lib/system/common.hpp>

namespace csdb {
namespace internal {

using WalletId = uint32_t;

}  // namespace internal
}  // namespace csdb

#endif  // _CREDITS_CSDB_TYPES_H_INCLUDED_
```
# ..\node\csdb\include\csdb\internal\utils.hpp 
```cpp 
/**
 * @file utils.h
 * @author Roman Bukin
 */

#ifndef _CREDITS_CSDB_UTILS_H_INCLUDED_
#define _CREDITS_CSDB_UTILS_H_INCLUDED_

#include "csdb/internal/types.hpp"

namespace csdb {
namespace internal {

template <typename Iterator>
cs::Bytes from_hex(Iterator beg, Iterator end) {
    auto digit_from_hex = [](char val, uint8_t &result) {
        val = static_cast<char>(toupper(val));

        if ((val >= '0') && (val <= '9'))
            result = static_cast<uint8_t>(val - '0');
        else if ((val >= 'A') && (val <= 'F'))
            result = static_cast<uint8_t>(val - 'A' + 10);
        else
            return false;

        return true;
    };

    cs::Bytes res;
    res.reserve(std::distance(beg, end) / 2);
    for (Iterator it = beg;;) {
        uint8_t hi, lo;

        if (it == end || !digit_from_hex(*it++, hi))
            break;

        if (it == end || !digit_from_hex(*it++, lo))
            break;

        res.push_back(static_cast<uint8_t>((hi << 4) | lo));
    }
    return res;
}

template <typename Iterator>
std::string to_hex(Iterator beg, Iterator end) {
    auto digit_to_hex = [](uint8_t val) { return static_cast<char>((val < 10) ? (val + '0') : (val - 10 + 'A')); };

    std::string res;
    res.reserve(std::distance(beg, end) * 2);
    for (Iterator it = beg; it != end; it++) {
        res.push_back(digit_to_hex((*it >> 4) & 0x0F));
        res.push_back(digit_to_hex(*it & 0x0F));
    }
    return res;
}

inline cs::Bytes from_hex(const std::string &val) {
    return from_hex(val.begin(), val.end());
}

inline std::string to_hex(const cs::Bytes &val) {
    return to_hex(val.begin(), val.end());
}

/**
 * @brief Добавляет оконечный разделитель к пути
 * @param Путь к папке
 * @return Путь к папке с добавленым оконечным разделителем
 *
 * Функция не проверят реального существования папки и просто добавляет
 * оконечный разделитель (в зависимости от платформы) в случае его отсутствия.
 *
 * Если оконечный разделитель уже присутствует, путь возвращается без изменений.
 */
std::string path_add_separator(const std::string &path);

/**
 * @brief Путь к папке для хранения данных приложения.
 * @return Путь к папке для хранения данных приложения.
 *
 * Функция возвращает специфичный для платформы путь для хранения данных приложения.
 * Если папки не существует, папака создаётся.
 *
 * Возвращаемый путь всегда завершается разделителем (слешем)
 */
std::string app_data_path();

/**
 * @brief Размер файла
 * @param[in] name Имя файла
 * @return Размер файла в байтах, или static_cast<size_t>(-1), если файл не существует или является папкой.
 */
size_t file_size(const std::string &name);

/**
 * @brief exists_file функция проверяет существование файла
 * @param path путь до проверяемого файла
 * @return true - файл существует
 */
inline bool file_exists(const std::string &path) {
    return (static_cast<uint64_t>(-1) != file_size(path));
}

/**
 * @brief remove_file функция удаляет файл
 * @param path путь до файла
 * @return true - файл удален
 */
bool file_remove(const std::string &path);

/**
 * @brief exists_dir функция проверяет существование директории
 * @param path путь до проверяемой директории
 * @return true - директория существует
 */
bool dir_exists(const std::string &path);

/**
 * @brief make_dir функция создает директорию
 * Для успешного создания директории необходимо,
 * что-бы родительская директория для создаваемой существовала.
 * Например, для успешного создания директории /home/user/.appdata/storage,
 * необходимо что-бы уже существовала директория /home/user/.appdata
 * @param path путь до создаваемой директории
 * @return true - директория создана
 */
bool dir_make(const std::string &path);

/**
 * @brief remove_dir удалить деркторию
 * Для успешного удалениия директории, она должна быть пуста.
 * @param path путь до удаляемой директории
 * @return true - дерктория удалена
 */
bool dir_remove(const std::string &path);

/**
 * @brief make_path функция создает полный путь до указанной директории
 * В процессе создания пути будут созданы все промежуточные директории
 * @param path путь до создаваемой директории
 * @return true - директория полностью создан
 */
bool path_make(const std::string &path);

/**
 * @brief remove_path функция удаляет директорию по указанному пути
 * со всем содержимым (будут удалены все файлы и директории)
 * @param path путь до удаляемой директории
 * @return true - директория полностью удалена
 */
bool path_remove(const std::string &path);

/**
 * @brief Объём папки
 * @param[in] path Путь к папке (оконочный разделитель не обязателен)
 * @return Суммарный размер всех файлов в папке, включая вложенные папки.
 *
 * Если указанный путь является файлом, возвращается размер файла. Если ни папка, ни файл
 * с таким имененм не существуют, возвращается static_cast<size_t>(-1).
 */
size_t path_size(const std::string &path);

}  // namespace internal
}  // namespace csdb

#endif // _CREDITS_CSDB_UTILS_H_INCLUDED_
```
# ..\node\csdb\src\address.cpp 
```cpp 
#include "csdb/address.hpp"
#include <array>
#include <boost/functional/hash.hpp>
#include "binary_streams.hpp"
#include "csdb/internal/shared_data_ptr_implementation.hpp"
#include "csdb/internal/types.hpp"
#include "csdb/internal/utils.hpp"

#include <lib/system/logger.hpp>

#include "priv_crypto.hpp"

namespace csdb {

class Address::priv : public ::csdb::internal::shared_data {
    union {
        cs::PublicKey public_key;
        WalletId wallet_id;
    } data_{};

    bool is_wallet_id_ = false;

    DEFAULT_PRIV_CLONE()

    friend class ::csdb::Address;
};
SHARED_DATA_CLASS_IMPLEMENTATION(Address)

bool Address::is_valid() const noexcept {
    return is_public_key() || is_wallet_id();
}

bool Address::is_public_key() const noexcept {
    return !d->is_wallet_id_;
}

bool Address::is_wallet_id() const noexcept {
    return d->is_wallet_id_;
}

bool Address::operator==(const Address& other) const noexcept {
    if (d == other.d) {
        return true;
    }

    if (is_public_key() != other.is_public_key()) {
        return false;
    }

    if (is_public_key()) {
        return d->data_.public_key == other.d->data_.public_key;
    }
    return d->data_.wallet_id == other.d->data_.wallet_id;
}

bool Address::operator<(const Address& other) const noexcept {
    if (d == other.d) {
        return false;
    }

    if (d->is_wallet_id_ && other.d->is_wallet_id_) {
        return d->data_.wallet_id < other.d->data_.wallet_id;
    }
    if (!d->is_wallet_id_ && !other.d->is_wallet_id_) {
        return d->data_.public_key < other.d->data_.public_key;
    }
    if (d->is_wallet_id_ && !other.d->is_wallet_id_) {
        return d->data_.public_key < other.d->data_.public_key;
    }
    if (!d->is_wallet_id_ && other.d->is_wallet_id_) {
        return d->data_.public_key < other.d->data_.public_key;
    }
    return false;
}

size_t Address::calcHash() const noexcept {
    if (is_public_key()) {
        return boost::hash_value(d->data_.public_key);
    }
    return boost::hash_value(d->data_.wallet_id);
}

::std::string Address::to_string() const noexcept {
    if (is_public_key()) {
        return internal::to_hex(cs::Bytes(d->data_.public_key.begin(), d->data_.public_key.end()));
    }
    if (is_wallet_id()) {
        return std::to_string(wallet_id());
    }
    return std::string();
}

Address Address::from_string(const ::std::string& val) {
    Address res;

    if (val.size() == 2 * ::csdb::priv::crypto::public_key_size) {
        const cs::Bytes data = ::csdb::internal::from_hex(val);
        if (::csdb::priv::crypto::public_key_size == data.size()) {
            memcpy(res.d->data_.public_key.data(), data.data(), ::csdb::priv::crypto::public_key_size);
            res.d->is_wallet_id_ = false;
        }
    }
    else {
        try {
            if (!val.empty()) {
                WalletId id = static_cast<WalletId>(std::stol(val));
                res = from_wallet_id(id);
                res.d->is_wallet_id_ = true;
            }
        }
        catch (...) {
            cserror() << "Address from string exception occured, check address to string convertion";
        }
    }

    return res;
}

const cs::PublicKey& Address::public_key() const noexcept {
    return d->data_.public_key;
}

Address::WalletId Address::wallet_id() const noexcept {
    if (is_wallet_id()) {
        return d->data_.wallet_id;
    }
    return static_cast<Address::WalletId>(-1);
}

Address Address::from_public_key(const cs::Bytes& key) {
    Address res;

    if (::csdb::priv::crypto::public_key_size == key.size()) {
        std::copy(key.begin(), key.end(), res.d->data_.public_key.data());
        res.d->is_wallet_id_ = false;
    }

    return res;
}

Address Address::from_public_key(const cs::PublicKey& key) {
    Address res;
    res.d->data_.public_key = key;
    res.d->is_wallet_id_ = false;

    return res;
}

Address Address::from_public_key(const char* key) {
    Address res;
    std::copy(key, key + ::csdb::priv::crypto::public_key_size, res.d->data_.public_key.begin());
    res.d->is_wallet_id_ = false;
    return res;
}

std::string Address::to_api_addr() {
    return std::string(d->data_.public_key.begin(), d->data_.public_key.end());
}

Address Address::from_wallet_id(WalletId id) {
    Address res;
    res.d->data_.wallet_id = id;
    res.d->is_wallet_id_ = true;
    return res;
}

void Address::put(::csdb::priv::obstream& os) const {
    if (is_public_key()) {
        os.put(d->data_.public_key);
    }
    else {
        os.put(d->data_.wallet_id);
    }
}

bool Address::get(::csdb::priv::ibstream& is) {
    if (is.size() == ::csdb::priv::crypto::public_key_size) {
        bool ok = is.get(d->data_.public_key);
        return ok;
    }
    return is.get(d->data_.wallet_id);
}

}  // namespace csdb
```
# ..\node\csdb\src\amount.cpp 
```cpp 
#include "csdb/amount.hpp"

#include <algorithm>
#include <cstdio>

#ifndef _MSC_VER
#define sprintf_s sprintf
#endif

#include "binary_streams.hpp"

namespace {
template <typename T, typename U>
T constexpr gen_pow(T base, U exponent) {
    return exponent == 0 ? 1 : base * gen_pow(base, exponent - 1);
}
}  // anonymous namespace

namespace csdb {
Amount::Amount(double value) {
    if ((value < static_cast<double>(std::numeric_limits<int32_t>::min())) || (value > static_cast<double>(std::numeric_limits<int32_t>::max()))) {
        throw std::overflow_error("Amount::Amount(double) overflow)");
    }

    integral_ = static_cast<int32_t>(value);
    if (value < 0.0) {
        --integral_;
    }

    double frac = value - static_cast<double>(integral_);
    constexpr uint64_t digits = std::numeric_limits<double>::digits10;
    constexpr uint64_t factor = gen_pow(static_cast<uint64_t>(10), digits);
    constexpr uint64_t multiplier = AMOUNT_MAX_FRACTION / factor;
    frac *= factor;

    fraction_ = static_cast<uint64_t>(frac + 0.5) * multiplier;
    if (fraction_ >= AMOUNT_MAX_FRACTION) {
        fraction_ -= AMOUNT_MAX_FRACTION;
        ++integral_;
    }
}

::std::string Amount::to_string(size_t min_decimal_places) const noexcept {
    char buf[64];
    char* end;
    if ((0 > integral_) && (0 != fraction_)) {
        end = sprintf_s(buf, "-%d.%018" PRIu64, (-1) - integral_, AMOUNT_MAX_FRACTION - fraction_) + buf - 1;
    }
    else {
        end = sprintf_s(buf, "%d.%018" PRIu64, integral_, fraction_) + buf - 1;
    }

    for (min_decimal_places = 18 - ::std::min<size_t>(min_decimal_places, 18); (min_decimal_places != 0u) && ('0' == (*end)); --min_decimal_places, --end) {
    }

    if ('.' == *end) {
        --end;
    }
    end[1] = '\0';

    return buf;
}

cs::Bytes Amount::toBytes() const {
    ::csdb::priv::obstream os;
    put(os);
    return os.buffer();
}

Amount Amount::fromBytes(const cs::Bytes& serializedAmount) {
    ::csdb::priv::ibstream is(serializedAmount.data(), serializedAmount.size());
    Amount res;
    if (!res.get(is)) {
        return Amount();
    }
    return res;
}

void Amount::put(priv::obstream& os) const {
    os.put(integral_);
    os.put(fraction_);
}

bool Amount::get(priv::ibstream& is) {
    return is.get(integral_) && is.get(fraction_);
}

}  // namespace csdb
```
# ..\node\csdb\src\amount_commission.cpp 
```cpp 
#include <cmath>

#include <csdb/amount_commission.hpp>

#include "binary_streams.hpp"

namespace csdb {

AmountCommission::AmountCommission(uint16_t value) {
    u_.bits = value;
}

AmountCommission::AmountCommission(double value) {
    u_.fIEEE.sign = value < 0. ? 1 : 0;
    value = std::fabs(value);
    double expf = value == 0. ? 0. : std::log10(value);
    int expi = expf >= 0. ? expf + 0.5 : expf - 0.5;
    value /= std::pow(10, expi);
    if (value >= 1.) {
        value *= 0.1;
        ++expi;
    }
    u_.fIEEE.exp = expi + 18;
    u_.fIEEE.frac = lround(value * 1024);
}

void AmountCommission::put(priv::obstream& os) const {
    os.put(u_.bits);
}

bool AmountCommission::get(priv::ibstream& is) {
    cached_.store(false, std::memory_order_relaxed);
    return is.get(u_.bits);
}

}  // namespace csdb
```
# ..\node\csdb\src\balance.cpp 
```cpp 
#include "csdb/balance.h"

#include "csdb/internal/shared_data_ptr_implementation.h"

namespace csdb {

class Balance::priv : public ::csdb::internal::shared_data
{
  DEFAULT_PRIV_CLONE()
};
SHARED_DATA_CLASS_IMPLEMENTATION(Balance)

} // namespace csdb
```
# ..\node\csdb\src\binary_streams.cpp 
```cpp 
#include "binary_streams.hpp"
#include <cstring>
#include "integral_encdec.hpp"

namespace csdb {
namespace priv {

void obstream::put(const void *buf, size_t size) {
    auto data = static_cast<const uint8_t *>(buf);
    buffer_.insert(buffer_.end(), data, data + size);
}

void obstream::put(const std::string &value) {
    put(static_cast<uint32_t>(value.size()));
    buffer_.insert(buffer_.end(), value.begin(), value.end());
}

void obstream::put(const cs::Bytes &value) {
    put(value.size());
    buffer_.insert(buffer_.end(), value.begin(), value.end());
}

bool ibstream::get(void *buf, size_t size) {
    if (size > size_) {
        return false;
    }

    auto src = static_cast<const uint8_t *>(data_);
    std::memmove(buf, src, size);
    size_ -= size;
    data_ = static_cast<const void *>(src + size);
    return true;
}

bool ibstream::get(std::string &value) {
    uint32_t size;
    if (!get(size)) {
        return false;
    }
    if (size > size_) {
        return false;
    }

    auto data = static_cast<const char *>(data_);
    value.assign(data, size);
    size_ -= size;
    data_ = static_cast<const void *>(data + size);
    return true;
}

bool ibstream::get(cs::Bytes &value) {
    size_t size;
    if (!get(size)) {
        return false;
    }
    if (size > size_) {
        return false;
    }

    const auto data = static_cast<const uint8_t *>(data_);
    value.assign(data, data + size);
    size_ -= size;
    data_ = static_cast<const void *>(data + size);
    return true;
}

}  // namespace priv
}  // namespace csdb
```
# ..\node\csdb\src\binary_streams.hpp 
```cpp 
/**
 * @file binary_streams.h
 * @author Evgeny V. Zalivochkin
 */

#pragma once
#ifndef _CREDITS_CSDB_PRIVATE_BINARY_STREAMS_H_H_INCLUDED_
#define _CREDITS_CSDB_PRIVATE_BINARY_STREAMS_H_H_INCLUDED_

#include <cinttypes>
#include <cstring>
#include <map>
#include <string>
#include <type_traits>
#include <utility>
#include "csdb/internal/types.hpp"

#include "integral_encdec.hpp"

#include <lib/system/common.hpp>

namespace csdb {
namespace priv {

class obstream {
public:
    void put(const void* buf, size_t size);
    void put(const std::string& value);
    void put(const cs::Bytes& value);

    template <typename T>
    typename std::enable_if<std::is_integral<T>::value || std::is_enum<T>::value, void>::type put(T value);

    template <typename T>
    decltype(std::declval<T>().put(std::declval<obstream&>())) put(const T& value);

    template <typename T>
    decltype(std::declval<T>().put(std::declval<obstream&>())) put_for_sig(const T& value);

    template <class K, class T, class C, class A>
    void put(const ::std::map<K, T, C, A>& value);

    template <std::size_t Size>
    void put(const cs::ByteArray<Size>& value);

    template <class K, class T, class C, class A>
    void put_smart(const ::std::map<K, T, C, A>& value);

    inline const cs::Bytes& buffer() const {
        return buffer_;
    }

private:
    cs::Bytes buffer_;
};

class ibstream {
public:
    ibstream(const void* data, size_t size)
    : data_(data)
    , size_(size) {
    }
    template <typename T>
    explicit inline ibstream(const T& d)
    : data_(d.data())
    , size_(d.size()) {
    }

public:
    bool get(void* buf, size_t size);
    bool get(std::string& value);
    bool get(cs::Bytes& value);

    template <typename T>
    typename std::enable_if<std::is_integral<T>::value || std::is_enum<T>::value, bool>::type get(T& value);

    template <typename T>
    decltype(std::declval<T>().get(std::declval<ibstream&>())) get(T& value);

    template <class K, class T, class C, class A>
    bool get(::std::map<K, T, C, A>& value);

    template <std::size_t Size>
    bool get(::cs::ByteArray<Size>& value);

    inline size_t size() const noexcept {
        return size_;
    }

    inline bool empty() const noexcept {
        return (0 == size_);
    }

private:
    const void* data_;
    size_t size_;
};

}  // namespace priv
}  // namespace csdb

namespace csdb {
namespace priv {

template <typename T>
typename std::enable_if<std::is_integral<T>::value || std::is_enum<T>::value, void>::type inline obstream::put(T value) {
    buffer_.insert(buffer_.end(), reinterpret_cast<uint8_t*>(&value), reinterpret_cast<uint8_t*>(&value) + sizeof(value));
}

template <typename T>
decltype(std::declval<T>().put(std::declval<obstream&>())) inline obstream::put(const T& value) {
    value.put(*this);
}

template <typename T>
decltype(std::declval<T>().put(std::declval<obstream&>())) inline obstream::put_for_sig(const T& value) {
    value.put_for_sig(*this);
}

template <class K, class T, class C, class A>
void obstream::put(const ::std::map<K, T, C, A>& value) {
    put((uint8_t)value.size());
    for (const auto& it : value) {
        put(it.first);
        put(it.second);
    }
}

template <std::size_t Size>
void obstream::put(const cs::ByteArray<Size>& value) {
    buffer_.insert(buffer_.end(), value.begin(), value.end());
}

template <class K, class T, class C, class A>
void obstream::put_smart(const ::std::map<K, T, C, A>& value) {
    put(static_cast<uint8_t>(value.size()));
    for (const auto& it : value) {
        put_for_sig(it.second);
    }
}

template <typename T>
typename std::enable_if<std::is_integral<T>::value || std::is_enum<T>::value, bool>::type inline ibstream::get(T& value) {
    if (size_ >= sizeof(T)) {
        value = *(reinterpret_cast<const T*>(data_));
        data_ = static_cast<const uint8_t*>(data_) + sizeof(T);
        size_ -= sizeof(T);
        return true;
    }
    return false;
}

template <typename T>
decltype(std::declval<T>().get(std::declval<ibstream&>())) inline ibstream::get(T& value) {
    return value.get(*this);
}

template <class K, class T, class C, class A>
bool ibstream::get(::std::map<K, T, C, A>& value) {
    value.clear();

    uint8_t size;
    if (!get(size)) {
        return false;
    }

    for (size_t i = 0; i < size; ++i) {
        K key;
        if (!get(key)) {
            return false;
        }
        T val;
        if (!get(val)) {
            return false;
        }
        value.emplace(key, val);
    }

    return true;
}

template <std::size_t Size>
bool ibstream::get(::cs::ByteArray<Size>& value) {
    if (Size > size_) {
        return false;
    }

    auto data = static_cast<const cs::Byte*>(data_);
    std::memmove(value.data(), data, Size);
    size_ -= Size;
    data_ = static_cast<const void*>(data + Size);

    return true;
}

}  // namespace priv
}  // namespace csdb

#endif  // _CREDITS_CSDB_PRIVATE_BINARY_STREAMS_H_H_INCLUDED_
```
# ..\node\csdb\src\csdb.cpp 
```cpp 
﻿#include "csdb/csdb.hpp"

namespace csdb {

namespace {
::csdb::Storage instance;
}  // namespace

bool init(const Storage::OpenOptions& options, Storage::OpenCallback callback) {
    if (instance.isOpen()) {
        return false;
    }
    instance = ::csdb::Storage::get(options, std::move(callback));
    return instance.isOpen();
}

bool init(const char* path_to_bases, Storage::OpenCallback callback) {
    if (instance.isOpen()) {
        return false;
    }
    instance = ::csdb::Storage::get(path_to_bases, std::move(callback));
    return instance.isOpen();
}

bool isInitialized() {
    return instance.isOpen();
}

void done() {
    instance.close();
}

Storage::Error lastError() {
    return instance.last_error();
}

::std::string lastErrorMessage() {
    return instance.last_error_message();
}

Database::Error dbLastError() {
    return instance.db_last_error();
}

::std::string dbLastErrorMessage() {
    return instance.last_error_message();
}

Storage defaultStorage() {
    return instance;
}

}  // namespace csdb
```
# ..\node\csdb\src\currency.cpp 
```cpp 
#include "csdb/currency.hpp"
#include "binary_streams.hpp"
#include "csdb/internal/shared_data_ptr_implementation.hpp"

namespace csdb {

class Currency::priv : public ::csdb::internal::shared_data {
public:
    uint8_t id = 0;
    DEFAULT_PRIV_CLONE()
};
SHARED_DATA_CLASS_IMPLEMENTATION(Currency)

Currency::Currency(const uint8_t &id)
: Currency() {
    d->id = id;
}

bool Currency::is_valid() const noexcept {
    return d != nullptr;
}

std::string Currency::to_string() const noexcept {
    return std::to_string(d->id);
}

bool Currency::operator==(const Currency &other) const noexcept {
    return d->id == other.d->id;
}

bool Currency::operator!=(const Currency &other) const noexcept {
    return !operator==(other);
}

bool Currency::operator<(const Currency &other) const noexcept {
    return d->id < other.d->id;
}

void Currency::put(::csdb::priv::obstream &os) const {
    os.put(d->id);
}

bool Currency::get(::csdb::priv::ibstream &is) {
    return is.get(d->id);
}

}  // namespace csdb
```
# ..\node\csdb\src\database.cpp 
```cpp 
#include "csdb/database.hpp"

#include <cstdarg>
#include <cstdio>
#include <map>

namespace {
struct last_error_struct {
    ::csdb::Database::Error last_error_ = ::csdb::Database::NoError;
    std::string last_error_message_;
};
last_error_struct& last_error_map(const ::csdb::Database* p) {
    static thread_local ::std::map<const ::csdb::Database*, last_error_struct> last_errors_;
    return last_errors_[p];
}
}  // namespace

namespace csdb {
Database::Database() {
    last_error_map(this) = last_error_struct();
}

Database::~Database() = default;

Database::Iterator::Iterator() = default;

Database::Iterator::~Iterator() = default;

Database::Error Database::last_error() const {
    return last_error_map(this).last_error_;
}

std::string Database::last_error_message() const {
    const last_error_struct& les = last_error_map(this);
    if (!les.last_error_message_.empty()) {
        return les.last_error_message_;
    }
    switch (les.last_error_) {
        case NoError:
            return "No error";
        case NotFound:
            return "Database is not found";
        case Corruption:
            return "Database is corrupted";
        case NotSupported:
            return "Database is not supported";
        case InvalidArgument:
            return "Invalis argument passed";
        case IOError:
            return "I/O error";
        case NotOpen:
            return "Database is not open";
        default:
            return "Unknown error";
    }
}

void Database::set_last_error(Error error, const std::string& message) {
    last_error_struct& les = last_error_map(this);
    les.last_error_ = error;
    les.last_error_message_ = message;
}

void Database::set_last_error(Error error, const char* message, ...) {
    last_error_struct& les = last_error_map(this);
    les.last_error_ = error;
    if (nullptr != message) {
        va_list args1;
        va_start(args1, message);
        va_list args2;
        va_copy(args2, args1);
        les.last_error_message_.resize(std::vsnprintf(NULL, 0, message, args1) + 1);
        va_end(args1);
        std::vsnprintf(&(les.last_error_message_[0]), les.last_error_message_.size(), message, args2);
        va_end(args2);
        les.last_error_message_.resize(les.last_error_message_.size() - 1);
    }
    else {
        les.last_error_message_.clear();
    }
}

}  // namespace csdb
```
# ..\node\csdb\src\database_berkeleydb.cpp 
```cpp 
#include <db_cxx.h>
#include <cassert>
#include <cstdlib>
#include <exception>

#include <boost/filesystem.hpp>

#include "csdb/database_berkeleydb.hpp"
#include "csdb/pool.hpp"

#include "priv_crypto.hpp"

#include <lib/system/scopeguard.hpp>

namespace csdb {

namespace {
template <typename T>
struct Dbt_copy : public Dbt {
    explicit Dbt_copy(const T &t)
    : t_copy(t) {
        init();
    }

    Dbt_copy() {
        init();
    }

    void init() {
        set_data(&t_copy);
        set_size(sizeof(T));
        set_ulen(sizeof(T));
        set_flags(DB_DBT_USERMEM);
    }

    explicit operator T() {
        return t_copy;
    }

private:
    T t_copy;
};

template <>
struct Dbt_copy<cs::Bytes> : public Dbt {
    explicit Dbt_copy(const cs::Bytes &data) {
        set_data(const_cast<unsigned char *>(data.data()));
        set_size(static_cast<uint32_t>(data.size()));
        set_ulen(static_cast<uint32_t>(data.size()));
        set_flags(DB_DBT_USERMEM);
    }
};

struct Dbt_safe : public Dbt {
    Dbt_safe() {
        set_data(nullptr);
        set_flags(DB_DBT_MALLOC);
    }
    ~Dbt_safe() {
        void *buf = get_data();
        if (buf != nullptr) {
            free(buf);
        }
    }
};
}  // namespace

DatabaseBerkeleyDB::DatabaseBerkeleyDB()
: env_(static_cast<uint32_t>(0))
, db_blocks_(nullptr)
, db_seq_no_(nullptr) {
}

DatabaseBerkeleyDB::~DatabaseBerkeleyDB() {
    std::cout << "Attempt db_blocks_ to close...\n" << std::flush;
    db_blocks_->close(0);
    std::cout << "DB db_blocks_ was closed.\n" << std::flush;
    std::cout << "Attempt db_seq_no_ to close...\n" << std::flush;
    db_seq_no_->close(0);
    std::cout << "DB db_seq_no_ was closed.\n" << std::flush;
#ifdef TRANSACTIONS_INDEX
    db_trans_idx_->close(0);
#endif
    env_.close(0);
}

void DatabaseBerkeleyDB::set_last_error_from_berkeleydb(int status) {
    Error err = UnknownError;
    if (status == 0) {
        err = NoError;
    }
    else if (status == ENOENT) {
        err = NotFound;
    }
    if (NoError == err) {
        set_last_error(err);
    }
    else {
        set_last_error(err, "LevelDB error: %d", status);
    }
}

bool DatabaseBerkeleyDB::open(const std::string &path) {
    boost::filesystem::path direc(path);
    if (boost::filesystem::exists(direc)) {
        if (!boost::filesystem::is_directory(direc)) {
            return false;
        }
    }
    else {
        if (!boost::filesystem::create_directories(direc)) {
            return false;
        }
    }

    db_blocks_.reset(nullptr);
    db_seq_no_.reset(nullptr);

    env_.log_set_config(DB_LOG_AUTO_REMOVE, 1);

    uint32_t db_env_open_flags = DB_CREATE | DB_INIT_MPOOL | DB_THREAD | DB_RECOVER | DB_INIT_TXN | DB_INIT_LOCK;
    int status = env_.open(path.c_str(), db_env_open_flags, 0);
    status = status ? status : env_.set_flags(DB_TXN_NOSYNC, 1);

    env_.txn_checkpoint(1024 * 1024, 0, 0);

    DbTxn *txn;
    status = status ? status : env_.txn_begin(nullptr, &txn, DB_READ_UNCOMMITTED);
    auto txn_create_status = status;

    auto g = cs::scopeGuard([&]() {
        if (txn_create_status) {
            return;
        }
        if (status) {
            txn->abort();
        }
        else {
            txn->commit(0);
        }
    });

#ifdef TRANSACTIONS_INDEX
    auto db_trans_idx = new Db(&env_, 0);
#endif

    if (!status) {
        decltype(db_blocks_) db_blocks(new Db(&env_, 0));
        status = db_blocks->open(txn, "blockchain.db", NULL, DB_RECNO, DB_CREATE | DB_READ_UNCOMMITTED, 0);
        db_blocks_.swap(db_blocks);
    }
    if (!status) {
        decltype(db_seq_no_) db_seq_no(new Db(&env_, 0));
        status = db_seq_no->open(txn, "sequence.db", NULL, DB_HASH, DB_CREATE | DB_READ_UNCOMMITTED, 0);
        db_seq_no_.swap(db_seq_no);
    }

    if (status) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

#ifdef TRANSACTIONS_INDEX
    status = db_trans_idx->open(NULL, "index.db", NULL, DB_BTREE, DB_CREATE, 0);
    if (status) {
        set_last_error_from_berkeleydb(status);
        return false;
    }
    db_trans_idx_.reset(db_trans_idx);
#endif

    set_last_error();
    return true;
}

bool DatabaseBerkeleyDB::is_open() const {
    return static_cast<bool>(db_blocks_);
}

bool DatabaseBerkeleyDB::put(const cs::Bytes &key, uint32_t seq_no, const cs::Bytes &value) {
    if (!db_blocks_) {
        set_last_error(NotOpen);
        return false;
    }

    DbTxn *tid;
    int status = env_.txn_begin(nullptr, &tid, DB_READ_UNCOMMITTED);
    int txn_create_status = status;
    auto g = cs::scopeGuard([&]() {
        if (txn_create_status) {
            return;
        }
        if (status) {
            tid->abort();
        }
        else {
            tid->commit(0);
        }
    });
    Dbt_copy<uint32_t> db_seq_no(seq_no + 1);
    if (!status) {
        Dbt_copy<cs::Bytes> db_value(value);
        status = db_blocks_->put(tid, &db_seq_no, &db_value, 0);
    }
    if (!status) {
        Dbt_copy<cs::Bytes> db_key(key);
        status = db_seq_no_->put(tid, &db_key, &db_seq_no, 0);
    }

    if (!status) {
        set_last_error();
        return true;
    }
    else {
        set_last_error_from_berkeleydb(status);
        return false;
    }
}

bool DatabaseBerkeleyDB::get(const cs::Bytes &key, cs::Bytes *value) {
    if (!db_blocks_) {
        set_last_error(NotOpen);
        return false;
    }

    Dbt_copy<cs::Bytes> db_key(key);
    if (value == nullptr) {
        return db_seq_no_->exists(nullptr, &db_key, 0) == 0;
    }

    Dbt_copy<uint32_t> db_seq_no;
    int status = db_seq_no_->get(nullptr, &db_key, &db_seq_no, DB_READ_UNCOMMITTED);
    if (status) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

    Dbt_safe db_value;

    status = db_blocks_->get(nullptr, &db_seq_no, &db_value, DB_READ_UNCOMMITTED);
    if (status) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

    auto begin = static_cast<uint8_t *>(db_value.get_data());
    value->assign(begin, begin + db_value.get_size());
    set_last_error();
    return true;
}

bool DatabaseBerkeleyDB::get(const uint32_t seq_no, cs::Bytes *value) {
    if (!db_blocks_) {
        set_last_error(NotOpen);
        return false;
    }

    if (value == nullptr) {
        return false;
    }

    Dbt_safe db_value;
    Dbt_copy<uint32_t> db_seq_no(seq_no);

    int status = db_blocks_->get(nullptr, &db_seq_no, &db_value, 0);
    if (status != 0) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

    auto begin = static_cast<uint8_t *>(db_value.get_data());
    value->assign(begin, begin + db_value.get_size());
    set_last_error();
    return true;
}

bool DatabaseBerkeleyDB::remove(const cs::Bytes &key) {
    if (!db_blocks_) {
        set_last_error(NotOpen);
        return false;
    }

    Dbt_copy<cs::Bytes> db_key(key);
    Dbt_copy<uint32_t> db_seq_no;
    int status = db_seq_no_->get(nullptr, &db_key, &db_seq_no, 0);
    if (status != 0) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

    status = db_seq_no_->del(nullptr, &db_key, 0);
    if (status != 0) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

    status = db_blocks_->del(nullptr, &db_seq_no, 0);
    if (status != 0) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

    set_last_error();
    return true;
}

bool DatabaseBerkeleyDB::write_batch(const ItemList &) {
    assert(false);

    if (!db_blocks_) {
        set_last_error(NotOpen);
        return false;
    }

    set_last_error();
    return true;
}

class DatabaseBerkeleyDB::Iterator final : public Database::Iterator {
public:
    explicit Iterator(Dbc *it)
    : it_(it)
    , valid_(false) {
        if (it != nullptr) {
            valid_ = true;
        }
    }
    ~Iterator() final {
        if (it_ != nullptr) {
            it_->close();
        }
    }
    bool is_valid() const final {
        return valid_;
    }

    void seek_to_first() final {
        if (it_ == nullptr) {
            return;
        }

        Dbt key;
        Dbt_safe value;

        int ret = it_->get(&key, &value, DB_FIRST);
        if (ret == 0) {
            set_value(value);
            valid_ = true;
        }
        else {
            valid_ = false;
        }
    }

    void seek_to_last() final {
        assert(false);
    }

    void seek(const cs::Bytes &) final {
        assert(false);
    }

    void next() override final {
        if (it_ == nullptr) {
            return;
        }

        Dbt key;
        Dbt_safe value;

        int ret = it_->get(&key, &value, DB_NEXT);
        if (ret == 0) {
            set_value(value);
            valid_ = true;
        }
        else {
            valid_ = false;
        }
    }

    void prev() final {
        assert(false);
    }

    cs::Bytes key() const final {
        return cs::Bytes{};
    }

    cs::Bytes value() const final {
        if (valid_) {
            return value_;
        }
        return cs::Bytes{};
    }

private:
    void set_value(const Dbt &value) {
        auto begin = static_cast<uint8_t *>(value.get_data());
        value_.assign(begin, begin + value.get_size());
    }

    Dbc *it_;
    bool valid_;
    cs::Bytes value_;
};

DatabaseBerkeleyDB::IteratorPtr DatabaseBerkeleyDB::new_iterator() {
    if (!db_blocks_) {
        set_last_error(NotOpen);
        return nullptr;
    }

    Dbc *cursorp;
    db_blocks_->cursor(nullptr, &cursorp, 0);

    return Database::IteratorPtr(new DatabaseBerkeleyDB::Iterator(cursorp));
}

#ifdef TRANSACTIONS_INDEX
bool DatabaseBerkeleyDB::putToTransIndex(const cs::Bytes &key, const cs::Bytes &value) {
    if (!db_trans_idx_) {
        set_last_error(NotOpen);
        return false;
    }

    Dbt_copy<cs::Bytes> db_key(key);
    Dbt_copy<cs::Bytes> db_value(value);

    int status = db_trans_idx_->put(nullptr, &db_key, &db_value, 0);
    if (status) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

    set_last_error();
    return true;
}

bool DatabaseBerkeleyDB::getFromTransIndex(const cs::Bytes &key, cs::Bytes *value) {
    if (!db_trans_idx_) {
        set_last_error(NotOpen);
        return false;
    }

    Dbt_copy<cs::Bytes> db_key(key);
    Dbt_safe db_value;

    int status = db_trans_idx_->get(nullptr, &db_key, &db_value, 0);
    if (status) {
        set_last_error_from_berkeleydb(status);
        return false;
    }

    auto begin = reinterpret_cast<uint8_t *>(db_value.get_data());
    value->assign(begin, begin + db_value.get_size());
    set_last_error();
    return true;
}
#endif

}  // namespace csdb
```
# ..\node\csdb\src\integral_encdec.cpp 
```cpp 
#include "integral_encdec.hpp"

#include <cstring>
#ifdef _MSC_VER
#include <intrin.h>
#endif

#include "csdb/internal/endian.hpp"

namespace csdb {
namespace priv {

template <>
std::size_t encode(void *buf, bool value) {
    *(static_cast<uint8_t *>(buf)) = value ? '\x01' : '\x00';
    return sizeof(uint8_t);
}

template <>
std::size_t encode(void *buf, uint64_t value) {
    value = ::csdb::internal::to_little_endian(value);

    uint64_t copy = (value & 0x8000000000000000) != 0u ? ~value : value;
#ifdef _MSC_VER
    unsigned long bits;
    _BitScanReverse64(&bits, copy);
    bits += 2;
#else
    uint64_t bits = (__builtin_clzl(copy) ^ 63) + 2;
#endif
    if (bits < 7) {
        bits = 7;
    }

    uint8_t bytes = 8;
    uint8_t first = (uint8_t)'\xFF';
    if (57 > bits) {
        bytes = static_cast<uint8_t>((bits - 1) / 7);
        first = static_cast<char>((value << (bytes + 1u)) | ((1u << bytes) - 1u));
        value >>= (7 - bytes);
    }
    auto buffer = static_cast<uint8_t *>(buf);
    *(buffer++) = first;
    if (0 < bytes) {
        memcpy(buffer, &value, bytes);
    }
    return bytes + sizeof(uint8_t);
}

template <>
std::size_t decode(const void *buf, std::size_t size, bool &value) {
    if (sizeof(uint8_t) > size) {
        return 0;
    }
    value = ('\0' != (*static_cast<const uint8_t *>(buf)));
    return sizeof(uint8_t);
}

template <>
std::size_t decode(const void *buf, std::size_t size, uint64_t &value) {
    if (sizeof(uint8_t) > size) {
        return 0;
    }
    auto d = static_cast<const char *>(buf);
    auto first = static_cast<uint8_t>(*d);
    uint8_t bytes = 0;
    for (uint8_t mask = first; 0 != (mask & 0x1u); ++bytes, mask >>= 1) {
    }
    if ((bytes + 1u) > size) {
        return 0;
    }

    uint64_t val = 0;
    if (bytes > 0) {
        memcpy(&val, d + 1, bytes);
    }
    if (8 > bytes) {
        val <<= (7 - bytes);
        val |= (first >> (bytes + 1u));
        if (0u != (d[bytes] & 0x80)) {
            val |= static_cast<uint64_t>(-1) << ((bytes + 1u) * 7);
        }
    }
    value = ::csdb::internal::from_little_endian(val);
    return bytes + 1;
}

}  // namespace priv
}  // namespace csdb
```
# ..\node\csdb\src\integral_encdec.hpp 
```cpp 
/**
 * @file encdec.h
 * @author Evgeny V. Zalivochkin
 *
 * Файл содержит функции для компактного кодирования целочисленных типов. Максимальный
 * размер кодируемого типа - 8 байт.
 */

#pragma once
#ifndef _CREDITS_CSDB_PRIVATE_INTEGRAL_ENCDEC_H_INCLUDED_
#define _CREDITS_CSDB_PRIVATE_INTEGRAL_ENCDEC_H_INCLUDED_

#include <cinttypes>
#include <type_traits>

namespace csdb {
namespace priv {
enum
{
    MAX_INTEGRAL_ENCODED_SIZE = sizeof(uint64_t) + 1,
};

/**
 * @brief Компактное кодирование переменной целочисленного типа.
 * @param[out]  buf   Буфер, в которые поместить закодированное значени. Буфер должен
 *                    иметь размер не менее \ref MAX_INTEGRAL_ENCODED_SIZE.
 * @param[in]   value Значение, которое закодировать. Допустимы целые типы размером не
 *                    больше, чем sizeof(uint64) байт.
 * @return  Количество байт, записанное в буфер.
 */
template <typename T>
typename std::enable_if<(std::is_integral<T>::value || std::is_enum<T>::value) && (sizeof(T) <= sizeof(uint64_t)), std::size_t>::type encode(void *buf, T value) {
    return encode<uint64_t>(buf, static_cast<uint64_t>(value));
}

/**
 * @brief Декодирование целочисленного типа.
 * @param[in]   buf   Буфер, в котором лежат данный для декодирования.
 * @param[in]   size  Размер данных в буфере.
 * @param[out]  value Переменная целочисленного типа, куда поместить резальтат
 *                    декодирования. Допустимы целые типы размером не больше, чем
 *                    sizeof(uint64) байт.
 * @return  Количество байт, прочитынных из \ref buf. 0, если закодированные данные
 *          содержат ошибку или данных недостаточно для полного декодирования.
 */
template <typename T>
typename std::enable_if<(std::is_integral<T>::value || std::is_enum<T>::value) && (sizeof(T) <= sizeof(uint64_t)), std::size_t>::type decode(const void *buf, std::size_t size,
                                                                                                                                             T &value) {
    uint64_t v;
    std::size_t res = decode<uint64_t>(buf, size, v);
    if (0 != res) {
        value = static_cast<T>(v);
    }
    return res;
}

template<>
std::size_t encode(void *buf, bool value);

template<>
std::size_t encode(void *buf, uint64_t value);

template<>
std::size_t decode(const void *buf, std::size_t size, bool& value);

template<>
std::size_t decode(const void *buf, std::size_t size, uint64_t& value);

}  // namespace priv
}  // namespace csdb

#endif // _CREDITS_CSDB_PRIVATE_INTEGRAL_ENCDEC_H_INCLUDED_
```
# ..\node\csdb\src\pool.cpp 
```cpp 
#include "csdb/pool.hpp"

#include <algorithm>
#include <iomanip>
#include <map>
#include <sstream>
#include <utility>

#include <lz4.h>

#ifdef _MSC_VER
#include <intrin.h>
#else
#include <x86intrin.h>
#endif

#include "csdb/csdb.hpp"

#include "binary_streams.hpp"
#include "csdb/internal/shared_data_ptr_implementation.hpp"
#include "csdb/internal/utils.hpp"
#include "priv_crypto.hpp"
#include "transaction_p.hpp"

namespace csdb {

class PoolHash::priv : public ::csdb::internal::shared_data {
public:
    cs::Bytes value;
    DEFAULT_PRIV_CLONE();
};
SHARED_DATA_CLASS_IMPLEMENTATION(PoolHash)

bool PoolHash::is_empty() const noexcept {
    return d->value.empty();
}

size_t PoolHash::size() const noexcept {
    return d->value.size();
}

std::string PoolHash::to_string() const noexcept {
    return internal::to_hex(d->value);
}

cs::Bytes PoolHash::to_binary() const noexcept {
    return d->value;
}

PoolHash PoolHash::from_binary(cs::Bytes&& data) {
    const size_t sz = data.size();
    PoolHash res;
    if ((0 == sz) || (::csdb::priv::crypto::hash_size == sz)) {
        res.d->value = std::move(data);
    }
    return res;
}

bool PoolHash::operator==(const PoolHash& other) const noexcept {
    return (d == other.d) || (d->value == other.d->value);
}

bool PoolHash::operator<(const PoolHash& other) const noexcept {
    return (d != other.d) && (d->value < other.d->value);
}

PoolHash PoolHash::from_string(const ::std::string& str) {
    const cs::Bytes hash = ::csdb::internal::from_hex(str);
    const size_t sz = hash.size();
    PoolHash res;
    if ((0 == sz) || (::csdb::priv::crypto::hash_size == sz)) {
        res.d->value = hash;
    }
    return res;
}

PoolHash PoolHash::calc_from_data(const cs::Bytes& data) {
    PoolHash res;
    res.d->value = ::csdb::priv::crypto::calc_hash(data);
    return res;
}

void PoolHash::put(::csdb::priv::obstream& os) const {
    size_t size = d->value.size();
    os.put(static_cast<uint8_t>(size));
    if (!d->value.empty()) {
        os.put((const void*)d->value.data(), size);
    }
}

bool PoolHash::get(::csdb::priv::ibstream& is) {
    uint8_t size;
    if (!is.get(size)) {
        return false;
    }
    if (size == 0) {
        d->value.clear();
        return true;
    }
    if (size != cscrypto::kHashSize || is.size() < cscrypto::kHashSize) {
        return false;
    }
    if (d->value.size() != cscrypto::kHashSize) {
        d->value.resize(cscrypto::kHashSize);
    }
    return is.get(d->value.data(), cscrypto::kHashSize);
}

class Pool::priv : public ::csdb::internal::shared_data {
    priv()
    : ::csdb::internal::shared_data() {
    }

    priv(PoolHash previous_hash, cs::Sequence sequence, ::csdb::Storage::WeakPtr storage)
    : is_valid_(true)
    , previous_hash_(std::move(previous_hash))
    , sequence_(sequence)
    , storage_(std::move(storage)) {
    }

    void put(::csdb::priv::obstream& os, bool doHash) const {
        os.put(version_);
        os.put(previous_hash_);
        os.put(sequence_);

        os.put(user_fields_);
        os.put(roundCost_);

        os.put(static_cast<uint32_t>(transactions_.size()));
        for (const auto& it : transactions_) {
            os.put(it);
        }

        os.put(static_cast<uint32_t>(newWallets_.size()));
        for (const auto& wall : newWallets_) {
            os.put(wall);
        }

        os.put(numberTrusted_);
        os.put(realTrusted_);

        // TODO: ensure confidants.size() <= numTrusted_
        for (const auto& it : confidants_) {
            os.put(it);
        }

        os.put(numberConfirmations_);
        os.put(roundConfirmationMask_);
        for (const auto& it : roundConfirmations_) {
            os.put(it);
        }

        if (doHash) {
            return;
        }
        const_cast<size_t&>(hashingLength_) = os.buffer().size();
        os.put(hashingLength_);

        for (const auto& it : signatures_) {
            os.put(it);
        }

        os.put(static_cast<uint8_t>(smartSignatures_.size()));
        for (const auto& it : smartSignatures_) {
            os.put(it.smartKey);
            os.put(it.smartConsensusPool);
            os.put(static_cast<uint8_t>(it.signatures.size()));
            for (const auto& itt : it.signatures) {
                os.put(itt.first);
                os.put(itt.second);
            }
        }
    }

    void put_for_sig(::csdb::priv::obstream& os) const {
        // not used now
        os.put(static_cast<uint8_t>(0));  // version
        os.put(previous_hash_);
        os.put(sequence_);

        os.put(user_fields_);
        os.put(roundCost_);

        os.put(static_cast<uint32_t>(transactions_.size()));
        for (const auto& it : transactions_) {
            os.put(it);
        }

        os.put(static_cast<uint32_t>(newWallets_.size()));
        for (const auto& wall : newWallets_) {
            os.put(wall);
        }

        os.put(static_cast<uint8_t>(confidants_.size()));
        for (const auto& it : confidants_) {
            os.put(it);
        }

        os.put(realTrusted_);
    }

    bool get_meta(::csdb::priv::ibstream& is, size_t& cnt) {
        if (!is.get(version_)) {
            csmeta(cswarning) << "get version is failed";
            return false;
        }

        if (!is.get(previous_hash_)) {
            csmeta(cswarning) << "get previous hash is failed";
            return false;
        }

        if (!is.get(sequence_)) {
            csmeta(cswarning) << "get sequence is failed";
            return false;
        }

        if (!is.get(user_fields_)) {
            csmeta(cswarning) << "get user fields is failed";
            return false;
        }

        if (!is.get(roundCost_)) {
            csmeta(cswarning) << "get round cost is failed";
            return false;
        }

        if (!is.get(transactionsCount_)) {
            csmeta(cswarning) << "get cnt is failed";
            return false;
        }
        cnt = transactionsCount_;
        is_valid_ = true;

        return true;
    }

    void updateHash() {
        const auto begin = binary_representation_.data();
        const auto end = begin + hashingLength_;
        hash_ = PoolHash::calc_from_data(cs::Bytes(begin, end));
    }

    void updateHash(const cs::Bytes& data) {
        hash_ = PoolHash::calc_from_data(data);
    }

    bool getTransactions(::csdb::priv::ibstream& is, size_t cnt) {
        transactions_.clear();
        transactions_.reserve(cnt);
        for (size_t i = 0; i < cnt; ++i) {
            Transaction tran;
            if (!is.get(tran)) {
                return false;
            }
            transactions_.emplace_back(tran);
        }
        return true;
    }

    bool getConfidants(::csdb::priv::ibstream& is) {
        confidants_.clear();
        confidants_.reserve(numberTrusted_);
        for (uint8_t i = 0; i < numberTrusted_; ++i) {
            cs::PublicKey conf;
            if (!is.get(conf)) {
                return false;
            }
            confidants_.emplace_back(conf);
        }
        return true;
    }

    bool getSignatures(::csdb::priv::ibstream& is) {
#ifdef _MSC_VER
        uint8_t cnt = (uint8_t)__popcnt64(realTrusted_);
#else
        uint8_t cnt = __builtin_popcountl(realTrusted_);
#endif

        signatures_.clear();
        signatures_.reserve(static_cast<size_t>(cnt));
        for (uint8_t i = 0; i < cnt; ++i) {
            cs::Signature sig;
            if (!is.get(sig)) {
                return false;
            }

            signatures_.push_back(sig);
        }
        return true;
    }

    bool getTrustedConfirmation(::csdb::priv::ibstream& is) {
        if (!is.get(numberConfirmations_)) {
            return false;
        }

        if (!is.get(roundConfirmationMask_)) {
            return false;
        }

#ifdef _MSC_VER
        uint8_t cnt = (uint8_t)__popcnt64(roundConfirmationMask_);
#else
        uint8_t cnt = __builtin_popcountl(roundConfirmationMask_);
#endif

        roundConfirmations_.clear();
        roundConfirmations_.reserve(static_cast<size_t>(cnt));
        for (size_t i = 0; i < cnt; ++i) {
            cs::Signature sig;

            if (!is.get(sig)) {
                return false;
            }

            roundConfirmations_.push_back(sig);
        }
        return true;
    }

    bool getSmartSignatures(::csdb::priv::ibstream& is) {
        uint8_t cnt = 0;
        if (!is.get(cnt)) {
            return false;
        }

        smartSignatures_.clear();
        smartSignatures_.reserve(cnt);

        for (uint8_t smarts = 0; smarts < cnt; ++smarts) {
            SmartSignature sSig;
            sSig.smartConsensusPool = 0;
            sSig.smartKey.fill(0);
            sSig.signatures.clear();

            if (!is.get(sSig.smartKey)) {
                return false;
            }

            if (!is.get(sSig.smartConsensusPool)) {
                return false;
            }

            uint8_t confCount = 0;
            if (!is.get(confCount)) {
                return false;
            }
            for (uint8_t i = 0; i < confCount; i++) {
                cs::Byte b;
                cs::Signature sig;
                if (!is.get(b)) {
                    return false;
                }
                if (!is.get(sig)) {
                    return false;
                }
                sSig.signatures.emplace_back(std::make_pair(b, sig));
            }

            smartSignatures_.emplace_back(sSig);
        }
        return true;
    }

    bool getNewWallets(::csdb::priv::ibstream& is) {
        uint32_t cnt = 0;
        if (!is.get(cnt)) {
            return false;
        }

        newWallets_.clear();
        newWallets_.reserve(cnt);
        for (uint32_t i = 0; i < cnt; ++i) {
            NewWalletInfo wall;
            if (!is.get(wall)) {
                return false;
            }
            newWallets_.emplace_back(wall);
        }
        return true;
    }

    bool get(::csdb::priv::ibstream& is) {
        size_t cnt;

        if (!get_meta(is, cnt)) {
            csmeta(cswarning) << "get meta is failed";
            return false;
        }

        if (!getTransactions(is, cnt)) {
            csmeta(cswarning) << "get transactions is failed";
            return false;
        }

        if (!getNewWallets(is)) {
            csmeta(cswarning) << "get new wallets is failed";
            return false;
        }

        if (!is.get(numberTrusted_)) {
            csmeta(cswarning) << "get number trusted is failed";
            return false;
        }

        if (!is.get(realTrusted_)) {
            csmeta(cswarning) << "get real trusted is failed";
            return false;
        }

        if (!getConfidants(is)) {
            csmeta(cswarning) << "get confidants is failed";
            return false;
        }

        if (!getTrustedConfirmation(is)) {
            csmeta(cswarning) << "get confirmations is failed";
            return false;
        }

        if (!is.get(hashingLength_)) {
            csmeta(cswarning) << "get hashing length is failed";
            return false;
        }

        if (!getSignatures(is)) {
            csmeta(cswarning) << "get signatures is failed";
            return false;
        }

        if (!getSmartSignatures(is)) {
            csmeta(cswarning) << "get smart signatures is failed";
            return false;
        }
        is_valid_ = true;
        if (is.size() > 0) {
            cserror() << "Pool::get(): inconsistent binary pool";
        }
        return true;
    }

    void compose() {
        if (!is_valid_) {
            binary_representation_.clear();
            hash_ = PoolHash();
            return;
        }

        update_binary_representation();
        update_transactions();
    }

    void update_binary_representation() {
        ::csdb::priv::obstream os;
        put(os, false);
        update_binary_representation(std::move(const_cast<cs::Bytes&>(os.buffer())));
    }

    void update_binary_representation(cs::Bytes&& bytes) {
        binary_representation_ = std::move(bytes);
    }

    void update_transactions() {
        read_only_ = true;

        updateHash();

        for (size_t idx = 0; idx < transactions_.size(); ++idx) {
            transactions_[idx].d->_update_id(hash_, idx);
        }
    }

    Storage get_storage(Storage candidate) {
        if (candidate.isOpen()) {
            return candidate;
        }

        candidate = Storage(storage_);
        if (candidate.isOpen()) {
            return candidate;
        }

        return ::csdb::defaultStorage();
    }

    priv clone() const {
        priv result;

        result.is_valid_ = is_valid_;
        result.version_ = version_;
        result.read_only_ = read_only_;
        result.hash_ = hash_.clone();
        result.previous_hash_ = previous_hash_.clone();
        result.sequence_ = sequence_;
        result.confidants_ = confidants_;
        result.hashingLength_ = hashingLength_;
        result.roundCost_ = roundCost_;

        result.transactions_.reserve(transactions_.size());
        for (auto& t : transactions_) {
            result.transactions_.push_back(t.clone());
        }

        result.transactionsCount_ = transactionsCount_;
        result.newWallets_ = newWallets_;

        for (auto& uf : user_fields_) {
            result.user_fields_[uf.first] = uf.second.clone();
        }

        result.signatures_ = signatures_;
        result.smartSignatures_ = smartSignatures_;
        result.roundConfirmations_ = roundConfirmations_;
        result.realTrusted_ = realTrusted_;
        result.roundConfirmationMask_ = roundConfirmationMask_;
        result.binary_representation_ = binary_representation_;
        result.numberTrusted_ = numberTrusted_;
        result.numberConfirmations_ = numberConfirmations_;

        result.storage_ = storage_;

        return result;
    }

    bool is_valid_ = false;
    bool read_only_ = false;
    uint8_t version_ = 0;
    PoolHash hash_;
    PoolHash previous_hash_;
    cs::Sequence sequence_{};
    std::vector<cs::PublicKey> confidants_;
    ::std::vector<Transaction> transactions_;
    uint32_t transactionsCount_ = 0;
    NewWallets newWallets_;
    ::std::map<::csdb::user_field_id_t, ::csdb::UserField> user_fields_;
    uint8_t numberTrusted_ = 0;
    uint64_t realTrusted_ = 0;
    uint8_t numberConfirmations_ = 0;
    uint64_t roundConfirmationMask_ = 0;
    size_t hashingLength_ = 0;
    csdb::Amount roundCost_;
    std::vector<cs::Signature> signatures_;
    std::vector<cs::Signature> roundConfirmations_;
    ::std::vector<csdb::Pool::SmartSignature> smartSignatures_;
    cs::Bytes binary_representation_;
    ::csdb::Storage::WeakPtr storage_;

    static cs::PublicKey zero_writer_public_key_;
    friend class Pool;
};
SHARED_DATA_CLASS_IMPLEMENTATION(Pool)

/*static*/
cs::PublicKey csdb::Pool::priv::zero_writer_public_key_;

Pool::Pool(PoolHash previous_hash, cs::Sequence sequence, const Storage& storage)
: d(new priv(std::move(previous_hash), sequence, storage.weak_ptr())) {
}

bool Pool::is_valid() const noexcept {
    return d->is_valid_;
}

bool Pool::is_read_only() const noexcept {
    return d->read_only_;
}

uint8_t Pool::version() const noexcept {
    return d->version_;
}

PoolHash Pool::hash() const noexcept {
    if (d->hash_.is_empty()) {
        const_cast<Pool*>(this)->d->updateHash();
    }

    return d->hash_;
}

PoolHash Pool::previous_hash() const noexcept {
    return d->previous_hash_;
}

size_t Pool::hashingLength() const noexcept {
    return d->hashingLength_;
}

Storage Pool::storage() const noexcept {
    return Storage(d->storage_);
}

Transaction Pool::transaction(size_t index) const {
    return (d->transactions_.size() > index) ? d->transactions_[index] : Transaction{};
}

uint8_t Pool::numberTrusted() const noexcept {
    return d->numberTrusted_;
}

uint64_t Pool::realTrusted() const noexcept {
    return d->realTrusted_;
}

uint64_t Pool::roundConfirmationMask() const noexcept {
    return d->roundConfirmationMask_;
}

uint8_t Pool::numberConfirmations() const noexcept {
    return d->numberConfirmations_;
}

const std::vector<cs::Signature>& Pool::roundConfirmations() const noexcept {
    return d->roundConfirmations_;
}

Transaction Pool::transaction(TransactionID id) const {
    if ((!d->is_valid_) || (!d->read_only_) || (!id.is_valid()) || (id.pool_hash() != d->hash_) || (d->transactions_.size() <= id.d->index_)) {
        return Transaction{};
    }
    return d->transactions_[id.d->index_];
}

Transaction Pool::get_last_by_source(const Address& source) const noexcept {
    const auto data = d.constData();

    if ((!data->is_valid_)) {
        return Transaction{};
    }

    auto it_rend = data->transactions_.rend();
    for (auto it = data->transactions_.rbegin(); it != it_rend; ++it) {
        const auto& t = *it;

        if (t.source() == source) {
            return t;
        }
    }

    return Transaction{};
}

Transaction Pool::get_last_by_target(const Address& target) const noexcept {
    const auto data = d.constData();

    if ((!data->is_valid_)) {
        return Transaction{};
    }

    auto it_rend = data->transactions_.rend();
    for (auto it = data->transactions_.rbegin(); it != it_rend; ++it) {
        const auto t = *it;

        if (t.target() == target) {
            return t;
        }
    }

    return Transaction{};
}

bool Pool::add_transaction(Transaction transaction
#ifdef CSDB_UNIT_TEST
                           ,
                           bool skip_check
#endif
) {
    if (d.constData()->read_only_) {
        return false;
    }

    if (!transaction.is_valid()) {
        return false;
    }

#ifdef CSDB_UNIT_TEST
    if (!skip_check) {
#endif
        /// \todo Add transaction checking.
#ifdef CSDB_UNIT_TEST
    }
#endif

    d->transactions_.push_back(Transaction(new Transaction::priv(*(transaction.d.constData()))));
    ++d->transactionsCount_;
    return true;
}

size_t Pool::transactions_count() const noexcept {
    // return d->transactionsCount_; // bad work
    return d->transactions_.size();
}

void Pool::recount() noexcept {
    d->transactionsCount_ = static_cast<uint32_t>(d->transactions_.size());
}

cs::Sequence Pool::sequence() const noexcept {
    return d->sequence_;
}

const cs::PublicKey& Pool::writer_public_key() const noexcept {
    if (d->confidants_.size() == 0) {
        if (d->sequence_ > 0) {
            cserror() << "The pool #" << d->sequence_ << " doesn't contain the confidants";
        }
        return csdb::Pool::priv::zero_writer_public_key_;
    }
    size_t index = 0;
    auto mask = cs::Utils::bitsToMask(d->numberTrusted_, d->realTrusted_);
    for (const auto& it : mask) {
        if (it != 255) {
            break;
        }
        ++index;
    }
    return d->confidants_.at(index);
}

// const cs::Signature& Pool::signature() const noexcept {
//  return d->signature_;
//}

const std::vector<cs::PublicKey>& Pool::confidants() const noexcept {
    return d->confidants_;
}

const std::vector<cs::Signature>& Pool::signatures() const noexcept {
    return d->signatures_;
}

const ::std::vector<csdb::Pool::SmartSignature>& Pool::smartSignatures() const noexcept {
    return d->smartSignatures_;
}

const csdb::Amount& Pool::roundCost() const noexcept {
    return d->roundCost_;
}

void Pool::set_version(uint8_t version) noexcept {
    if (d.constData()->read_only_) {
        return;
    }

    priv* data = d.data();
    data->is_valid_ = true;
    data->version_ = version;
}

void Pool::set_sequence(cs::Sequence seq) noexcept {
    if (d.constData()->read_only_) {
        return;
    }

    priv* data = d.data();
    data->is_valid_ = true;
    data->sequence_ = seq;
}

void Pool::setRoundCost(const csdb::Amount& roundCost) noexcept {
    if (d.constData()->read_only_) {
        return;
    }

    priv* data = d.data();
    data->is_valid_ = true;
    data->roundCost_ = roundCost;
}

void Pool::set_previous_hash(PoolHash previous_hash) noexcept {
    if (d.constData()->read_only_) {
        return;
    }

    priv* data = d.data();
    data->is_valid_ = true;
    data->previous_hash_ = std::move(previous_hash);
}

void Pool::set_confidants(const std::vector<cs::PublicKey>& confidants) noexcept {
    if (d.constData()->read_only_) {
        return;
    }

    priv* data = d.data();
    data->is_valid_ = true;
    data->confidants_ = confidants;
}

void Pool::set_signatures(std::vector<cs::Signature>& blockSignatures) noexcept {
    if (d.constData()->read_only_) {
        csmeta(cswarning) << "Set signatures is failed. Data is read only!";
        return;
    }

    priv* data = d.data();
    data->is_valid_ = true;
    data->signatures_ = std::move(blockSignatures);
}

void Pool::add_smart_signature(const csdb::Pool::SmartSignature& smartSignature) noexcept {
    priv* data = d.data();
    data->is_valid_ = true;
    data->smartSignatures_.emplace_back(smartSignature);
}

void Pool::add_round_confirmations(const std::vector<cs::Signature>& confirmations) noexcept {
    priv* data = d.data();
    data->is_valid_ = true;
    data->roundConfirmations_ = std::move(confirmations);
}

void Pool::add_real_trusted(const uint64_t trustedMask) noexcept {
    priv* data = d.data();
    data->is_valid_ = true;
    data->realTrusted_ = trustedMask;
}

void Pool::add_confirmation_mask(const uint64_t confMask) noexcept {
    priv* data = d.data();
    data->is_valid_ = true;
    data->roundConfirmationMask_ = confMask;
}

void Pool::add_number_trusted(const uint8_t trustedNumber) noexcept {
    priv* data = d.data();
    data->is_valid_ = true;
    data->numberTrusted_ = trustedNumber;
}

void Pool::add_number_confirmations(const uint8_t confNumber) noexcept {
    priv* data = d.data();
    data->is_valid_ = true;
    data->numberConfirmations_ = confNumber;
}

void Pool::set_storage(const Storage& storage) noexcept {
    // We can set up storage even if Pool is read-only
    priv* data = d.data();
    data->is_valid_ = true;
    data->storage_ = storage.weak_ptr();
}

Pool::Transactions& Pool::transactions() {
    return d->transactions_;
}

const Pool::Transactions& Pool::transactions() const {
    return d->transactions_;
}

Pool::NewWallets* Pool::newWallets() noexcept {
    if (d.constData()->read_only_) {
        return nullptr;
    }
    return &d->newWallets_;
}

const Pool::NewWallets& Pool::newWallets() const noexcept {
    return d->newWallets_;
}

bool Pool::add_user_field(user_field_id_t id, const UserField& field) noexcept {
    if (d.constData()->read_only_ || (!field.is_valid())) {
        return false;
    }

    priv* data = d.data();
    data->is_valid_ = true;
    data->user_fields_[id] = field;

    return true;
}

UserField Pool::user_field(user_field_id_t id) const noexcept {
    const priv* data = d.constData();
    auto it = data->user_fields_.find(id);
    return (data->user_fields_.end() == it) ? UserField{} : it->second;
}

::std::set<user_field_id_t> Pool::user_field_ids() const noexcept {
    ::std::set<user_field_id_t> res;
    const priv* data = d.constData();
    for (const auto& it : data->user_fields_) {
        res.insert(it.first);
    }
    return res;
}

bool Pool::compose() {
    if (d.constData()->read_only_) {
        return true;
    }

    d->compose();

    return d.constData()->is_valid_;
}

cs::Bytes Pool::to_binary() const noexcept {
    return d->binary_representation_;
}

uint64_t Pool::get_time() const noexcept {
    return atoll(user_field(0).value<std::string>().c_str());
}

Pool Pool::from_binary(cs::Bytes&& data) {
    std::unique_ptr<priv> p{new priv()};
    ::csdb::priv::ibstream is(data.data(), data.size());
    if (!p->get(is)) {
        return Pool();
    }
    p->update_binary_representation(std::move(data));
    p->update_transactions();
    return Pool(p.release());
}

Pool Pool::meta_from_binary(cs::Bytes&& data, size_t& cnt) {
    std::unique_ptr<priv> p(new priv());
    ::csdb::priv::ibstream is(data.data(), data.size());

    if (!p->get_meta(is, cnt)) {
        return Pool();
    }

    p->update_binary_representation(std::move(data));
    return Pool(p.release());
}

Pool Pool::meta_from_byte_stream(const char* data, size_t size) {
    std::unique_ptr<priv> p(new priv());
    ::csdb::priv::ibstream is(data, size);

    size_t t;
    if (!p->get_meta(is, t)) {
        return Pool();
    }

    return Pool(p.release());
}

Pool Pool::from_lz4_byte_stream(size_t uncompressedSize) {
    std::unique_ptr<priv> p(new priv());
    p->binary_representation_.resize(uncompressedSize);

    ::csdb::priv::ibstream is(p->binary_representation_.data(), p->binary_representation_.size());

    if (!p->get(is)) {
        return Pool();
    }

    p->updateHash();

    return Pool(p.release());
}

char* Pool::to_byte_stream(uint32_t& size) {
    if (d->binary_representation_.empty()) {
        d->update_binary_representation();
    }

    size = static_cast<uint32_t>(d->binary_representation_.size());
    return reinterpret_cast<char*>(d->binary_representation_.data());
}

bool Pool::save(Storage storage) {
    if ((!d.constData()->is_valid_)) {
        return false;
    }

    Storage s = d->get_storage(std::move(storage));
    if (!s.isOpen()) {
        return false;
    }

    if (d->hash_.is_empty()) {
        d->updateHash();
    }

    if (s.pool_save(*this)) {
        d->storage_ = s.weak_ptr();
        return true;
    }

    return false;
}

cs::Bytes Pool::to_byte_stream_for_sig() {
    ::csdb::priv::obstream os;
    d->put(os, true);
    cs::Bytes result = std::move(const_cast<std::vector<uint8_t>&>(os.buffer()));
    return result;
}

Pool Pool::load(const PoolHash& hash, Storage storage) {
    if (!storage.isOpen()) {
        storage = ::csdb::defaultStorage();
    }

    Pool res = storage.pool_load(hash);
    if (res.is_valid()) {
        res.set_storage(storage);
    }
    return res;
}

bool Pool::getWalletAddress(const NewWalletInfo& info, csdb::Address& wallAddress) const {
    const csdb::Pool::Transactions& transactions = this->transactions();
    const auto& conf = this->confidants();
    size_t max_new_wallets_size = transactions.size() + conf.size();

    size_t idx = info.addressId_.trxInd_;
    if (idx >= max_new_wallets_size) {
        return false;
    }
    if (idx < transactions.size()) {
        csdb::Transaction trx = transactions[idx];
        const bool isSource = (info.addressId_.addressType_ == NewWalletInfo::AddressType::AddressIsSource);
        wallAddress = (isSource) ? trx.source() : trx.target();
        return true;
    }

    wallAddress = csdb::Address::from_public_key(this->confidants()[idx - transactions.size()]);
    return true;
}

void Pool::NewWalletInfo::put(::csdb::priv::obstream& os) const {
    union {
        Pool::NewWalletInfo::AddressId address_id;
        size_t asSizeType;
    } addresIdConverter{};

    addresIdConverter.address_id = addressId_;
    os.put(addresIdConverter.asSizeType);
    os.put(walletId_);
}

bool Pool::NewWalletInfo::get(::csdb::priv::ibstream& is) {
    size_t address_id;
    if (!is.get(address_id)) {
        return false;
    }
    auto id = reinterpret_cast<size_t*>(&addressId_);
    *id = address_id;
    return is.get(walletId_);
}

}  // namespace csdb
```
# ..\node\csdb\src\priv_crypto.cpp 
```cpp 
#include "priv_crypto.hpp"

#ifdef CSDB_UNIT_TEST
#include <functional>
#endif

namespace csdb {
namespace priv {

cs::Bytes crypto::calc_hash(const cs::Bytes &buffer) noexcept {
#ifndef CSDB_UNIT_TEST
    cscrypto::Hash result = cscrypto::calculateHash(buffer.data(), buffer.size());
    return cs::Bytes(result.begin(), result.end());
#else
    const size_t result = std::hash<std::string>()(std::string(buffer.begin(), buffer.end()));
    return cs::Bytes(reinterpret_cast<const uint8_t *>(&result), reinterpret_cast<const uint8_t *>(&result) + hash_size);
#endif
}

}  // namespace priv
}  // namespace csdb
```
# ..\node\csdb\src\priv_crypto.hpp 
```cpp 
/**
 * @file priv_crypto.h
 * @author Roman Bukin
 */

#ifndef _CREDITS_CSDB_PRIVATE_CRYPTO_H_H_INCLUDED_
#define _CREDITS_CSDB_PRIVATE_CRYPTO_H_H_INCLUDED_

#include <cinttypes>
#include "csdb/internal/types.hpp"

#ifndef CSDB_UNIT_TEST
#include "cscrypto/cscrypto.hpp"
#endif

namespace csdb {
namespace priv {

struct crypto {
#ifndef CSDB_UNIT_TEST
    static const size_t hash_size = cscrypto::kHashSize;
    static const size_t public_key_size = cscrypto::kPublicKeySize;
#else
    static const size_t hash_size = sizeof(size_t);
    static const size_t public_key_size = 20;
#endif
    static cs::Bytes calc_hash(const cs::Bytes &buffer) noexcept;
};

}  // namespace priv
}  // namespace csdb

#endif  // _CREDITS_CSDB_PRIVATE_CRYPTO_H_H_INCLUDED_
```
# ..\node\csdb\src\storage.cpp 
```cpp 
#include "csdb/storage.hpp"

#include <algorithm>
#include <cassert>
#include <condition_variable>
#include <cstdarg>
#include <deque>
#include <mutex>
#include <sstream>
#include <stdexcept>
#include <thread>

#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>

#include "binary_streams.hpp"
#include "csdb/address.hpp"
#include "csdb/database.hpp"
#include "csdb/database_berkeleydb.hpp"
#include "csdb/internal/shared_data_ptr_implementation.hpp"
#include "csdb/internal/utils.hpp"
#include "csdb/pool.hpp"
#include "csdb/wallet.hpp"

namespace {
struct last_error_struct {
    ::csdb::Storage::Error last_error_ = ::csdb::Storage::NoError;
    std::string last_error_message_;
};

last_error_struct& last_error_map(const void* p) {
    static thread_local ::std::map<const void*, last_error_struct> last_errors_;
    return last_errors_[p];
}
}  // namespace

namespace csdb {

namespace {

struct head_info_t {
    size_t len_;     // Количество блоков в цепочке
    PoolHash next_;  // хеш следующего пула, или пустая строка для первого пула
                     // в цепочее (нет родителя, начало цепочки).
};
using heads_t = std::map<PoolHash, head_info_t>;
using tails_t = std::map<PoolHash, PoolHash>;

void update_heads_and_tails(heads_t& heads, tails_t& tails, const PoolHash& cur_hash, const PoolHash& prev_hash) {
    auto ith = heads.find(prev_hash);
    auto itt = tails.find(cur_hash);
    bool eith = (heads.end() != ith);
    bool eitt = (tails.end() != itt);
    if (eith && eitt) {
        // Склеиваем две подцепочки.
        assert(1 == heads.count(itt->second));
        head_info_t& ith1 = heads[itt->second];
        ith1.next_ = ith->second.next_;
        ith1.len_ += (1 + ith->second.len_);
        if (!ith->second.next_.is_empty()) {
            /// \todo Проверить, почему выпадает assert!
            // assert(1 == tails.count(ith->second.next_));
            tails[ith->second.next_] = itt->second;
        }
        heads.erase(ith);
        // Мы, возможно, уже изменили tails - поэтому нельзя удалять по итератору!
        tails.erase(cur_hash);
    }
    else if (eith && (!eitt)) {
        // Добавляем в начало цепочки.
        if (!ith->second.next_.is_empty()) {
            /// \todo Проверить, почему выпадает assert!
            // assert(1 == tails.count(ith->second.next_));
            tails[ith->second.next_] = cur_hash;
        }
        assert(0 == heads.count(cur_hash));
        heads.emplace(cur_hash, head_info_t{ith->second.len_ + 1, ith->second.next_});
        heads.erase(prev_hash);
    }
    else if ((!eith) && eitt) {
        // Добавляем в конец цепочки.
        assert(1 == heads.count(itt->second));
        head_info_t& ith1 = heads[itt->second];
        ith1.next_ = prev_hash;
        ++ith1.len_;
        if (!prev_hash.is_empty()) {
            // assert не нужен, т.е. наличие такого "хвоста" говорит о пересекающихся или зацикленных
            // цепочках (т.е. уже была цепочка, имеющая этот же хвост).
            // TODO: Доделать детектирование таких цепочек (после создания unit-тестов)
            // assert(0 == tails.count(prev_hash));
            tails.emplace(prev_hash, itt->second);
        }
        tails.erase(cur_hash);
    }
    else {
        // Ни с чем не пересекаемся! Просто подвешиваем.
        assert(0 == heads.count(cur_hash));
        heads.emplace(cur_hash, head_info_t{1, prev_hash});
        if (!prev_hash.is_empty()) {
            // см. TODO к пердыдущей ветке.
            // assert(0 == tails.count(prev_hash));
            tails.emplace(prev_hash, cur_hash);
        }
    }
}

}  // namespace

class Storage::priv {
public:
    priv() {
        last_error_map(this) = last_error_struct();
    }

    ~priv() {
        if (write_thread.joinable()) {
            quit = true;
            write_cond_var.notify_one();
            write_thread.join();
        }
    }

private:
    bool rescan(Storage::OpenCallback callback);
    void write_routine();

    std::shared_ptr<Database> db = nullptr;
    PoolHash last_hash;     // Хеш последнего пула
    size_t count_pool = 0;  // Количество пулов транзакций в хранилище (первоночально заполняется в check)

    void set_last_error(Storage::Error error = Storage::NoError, const ::std::string& message = ::std::string());
    void set_last_error(Storage::Error error, const char* message, ...);

    std::thread write_thread;
    bool quit = false;

    std::mutex data_lock;

    std::deque<Pool> write_queue;
    std::mutex write_lock;
    std::condition_variable write_cond_var;

private signals:
    ReadBlockSignal read_block_event;

    // TODO: Добавить кеш для хранения последних вычитанных пулов транзакций

    friend class ::csdb::Storage;
};

void Storage::priv::set_last_error(Storage::Error error, const ::std::string& message) {
    last_error_struct& les = last_error_map(this);
    les.last_error_ = error;
    les.last_error_message_ = message;
}

void Storage::priv::set_last_error(Storage::Error error, const char* message, ...) {
    last_error_struct& les = last_error_map(this);
    les.last_error_ = error;

    if (nullptr != message) {
        va_list args1;
        va_start(args1, message);
        va_list args2;
        va_copy(args2, args1);
        les.last_error_message_.resize(std::vsnprintf(NULL, 0, message, args1) + 1);
        va_end(args1);
        std::vsnprintf(&(les.last_error_message_[0]), les.last_error_message_.size(), message, args2);
        va_end(args2);
        les.last_error_message_.resize(les.last_error_message_.size() - 1);
    }
    else {
        les.last_error_message_.clear();
    }

    if (error != Storage::Error::NoError) {
        if (!les.last_error_message_.empty()) {
            cserror() << "Storage> error #" << static_cast<int>(error) << ": " << les.last_error_message_;
        }
        else {
            cserror() << "Storage> error #" << static_cast<int>(error);
        }
    }
}

bool Storage::priv::rescan(Storage::OpenCallback callback) {
    last_hash = {};
    count_pool = 0;

    heads_t heads;
    tails_t tails;

    Database::IteratorPtr it = db->new_iterator();
    assert(it);

    Storage::OpenProgress progress{0};
    for (it->seek_to_first(); it->is_valid(); it->next()) {
        cs::Bytes v = it->value();

        Pool p = Pool::from_binary(std::move(v));
        if (!p.is_valid()) {
            set_last_error(Storage::DataIntegrityError, "Data integrity error: Corrupted pool for key'.");
            return false;
        }

        bool test_failed = false;

        emit read_block_event(p, &test_failed);

        if (test_failed) {
            set_last_error(Storage::DataIntegrityError, "Data integrity error: client reported violation of logic in pool %d", p.sequence());
            return false;
        }

        update_heads_and_tails(heads, tails, p.hash(), p.previous_hash());
        count_pool++;
        progress.poolsProcessed++;

        if (callback != nullptr) {
            if (callback(progress)) {
                set_last_error(Storage::UserCancelled);
                return false;
            }
        }
    }

    // Посмотрим, сколько у нас завершённых цепочек.
    if ([this, &heads]() -> bool {
            for (const auto it : heads) {
                if (!it.second.next_.is_empty())
                    continue;

                if (!last_hash.is_empty())
                    return false;

                last_hash = it.first;
            }
            return true;
        }()) {
        set_last_error();
        return true;
    }

    std::stringstream ss;
    ss << "More than one chains or orphan chains. List follows:" << std::endl;
    for (auto ith = heads.begin(); ith != heads.end(); ++ith) {
        ss << "  " << ith->first.to_string() << " (length = " << ith->second.len_ << "): ";
        if (ith->second.next_.is_empty()) {
            ss << "Normal";
        }
        else {
            ss << "Orphan";
        }
        ss << std::endl;
    }
    ss << std::ends;
    set_last_error(Storage::ChainError, ss.str());

    return false;
}

void Storage::priv::write_routine() {
    std::unique_lock<std::mutex> lock(write_lock);
    while (!quit) {
        write_cond_var.wait(lock);
        while (!write_queue.empty()) {
            Pool& pool = write_queue.front();
            if (!pool.is_read_only()) {
                if (!pool.compose()) {
                    set_last_error(Storage::DataIntegrityError, "Pool passed to storage is not composed and failed to compose now");
                }
            }
            const PoolHash hash = pool.hash();

            db->put(hash.to_binary(), static_cast<uint32_t>(pool.sequence()), pool.to_binary());

            write_queue.pop_front();
        }
    }
}

Storage::Storage()
: d(::std::make_shared<priv>()) {
}

Storage::~Storage() {
}

Storage::Storage(WeakPtr ptr) noexcept
: d(ptr.lock()) {
    if (!d) {
        d = ::std::make_shared<priv>();
    }
}

Storage::WeakPtr Storage::weak_ptr() const noexcept {
    return d;
}

Storage::Error Storage::last_error() const {
    return last_error_map(d.get()).last_error_;
}

::std::string Storage::last_error_message() const {
    const last_error_struct& les = last_error_map(d.get());
    if (!les.last_error_message_.empty()) {
        return les.last_error_message_;
    }
    switch (les.last_error_) {
        case NoError:
            return "No error";
        case NotOpen:
            return "Storage is not open";
        case DatabaseError:
            return "Database error: " + db_last_error_message();
        case ChainError:
            return "Chain integrity error";
        case DataIntegrityError:
            return "Data integrity error";
        case UserCancelled:
            return "Operation cancalled by user";
        case InvalidParameter:
            return "Invalid parameter passed to method.";
        default:
            return "Unknown error";
    }
}

Database::Error Storage::db_last_error() const {
    if (d->db) {
        return d->db->last_error();
    }
    return Database::NotOpen;
}

::std::string Storage::db_last_error_message() const {
    if (d->db) {
        return d->db->last_error_message();
    }
    return ::std::string{"Database not specified"};
}

bool Storage::open(const OpenOptions& opt, OpenCallback callback) {
    if (!opt.db) {
        d->set_last_error(DatabaseError, "No valid database driver specified.");
        return false;
    }

    d->db = opt.db;

    if (!d->db->is_open()) {
        d->set_last_error(DatabaseError, "Error open database: %s", d->db->last_error_message().c_str());
        return false;
    }

    if (!d->rescan(callback)) {
        d->db.reset();
        return false;
    }

    d->set_last_error();
    return true;
}

bool Storage::open(const ::std::string& path_to_base, OpenCallback callback) {
    ::std::string path{path_to_base};
    if (path.empty()) {
        path = ::csdb::internal::app_data_path() + "/CREDITS";
    }

    auto db{::std::make_shared<::csdb::DatabaseBerkeleyDB>()};
    db->open(path);

    d->write_thread = std::thread(&Storage::priv::write_routine, d.get());

    return open(OpenOptions{db}, callback);
}

void Storage::close() {
    d->db.reset();
    d->set_last_error();
}

bool Storage::isOpen() const {
    return ((d->db) && (d->db->is_open()));
}

PoolHash Storage::last_hash() const noexcept {
    std::unique_lock<std::mutex> lock(d->data_lock);
    return d->last_hash;
}

size_t Storage::size() const noexcept {
    std::unique_lock<std::mutex> lock(d->data_lock);
    return d->count_pool;
}

bool Storage::pool_save(Pool pool) {
    if (!isOpen()) {
        d->set_last_error(NotOpen);
        return false;
    }

    if (!pool.is_valid()) {
        d->set_last_error(InvalidParameter, "%s: Invalid pool passed", funcName());
        return false;
    }

    const PoolHash hash = pool.hash();

    if (d->db->get(hash.to_binary())) {
        d->set_last_error(InvalidParameter, "%s: Pool already pressent [hash: %s]", funcName(), hash.to_string().c_str());
        return false;
    }
    /*
      {
        std::unique_lock<std::mutex> lock(d->write_lock);
        d->write_queue.push_back(pool);
        d->write_cond_var.notify_one();
      }
    */
    d->db->put(hash.to_binary(), static_cast<uint32_t>(pool.sequence()), pool.to_binary());

    {
        std::unique_lock<std::mutex> lock(d->data_lock);
        ++d->count_pool;
        if (d->last_hash == pool.previous_hash()) {
            d->last_hash = hash;
        }
    }

    d->set_last_error();
    return true;
}

Pool Storage::pool_load_internal(const PoolHash& hash, const bool metaOnly, size_t& trxCnt) const {
    if (!isOpen()) {
        d->set_last_error(NotOpen);
        return Pool{};
    }

    if (hash.is_empty()) {
        d->set_last_error(InvalidParameter, "%s: Empty hash passed", funcName());
        return Pool{};
    }

    Pool res;
    bool needParseData = true;
    cs::Bytes data;

    if (!d->db->get(hash.to_binary(), &data)) {
        {
            std::unique_lock<std::mutex> lock2(d->write_lock);
            for (auto& poolToWrite : d->write_queue) {
                if (poolToWrite.hash() == hash) {
                    res = poolToWrite;
                    needParseData = false;
                    trxCnt = res.transactions().size();
                    break;
                }
            }
        }

        if (needParseData && !d->db->get(hash.to_binary(), &data)) {
            d->set_last_error(DatabaseError);
            return Pool{};
        }
    }

    if (needParseData) {
        if (metaOnly) {
            res = Pool::meta_from_binary(std::move(data), trxCnt);
        }
        else {
            res = Pool::from_binary(std::move(data));
        }
    }

    if (!res.is_valid()) {
        d->set_last_error(DataIntegrityError, "%s: Error decoding pool [hash: %s]", funcName(), hash.to_string().c_str());
        return Pool{};
    }
    else {
        d->set_last_error();
    }

    return res;
}

bool Storage::write_queue_search(const PoolHash& hash, Pool& res_pool) const {
    std::unique_lock<std::mutex> lock(d->write_lock, std::defer_lock);

    if (!d->write_queue.empty() && lock.try_lock()) {
        auto pos = std::find_if(d->write_queue.begin(), d->write_queue.end(), [&](Pool& pool) { return hash == pool.hash(); });

        if (pos != d->write_queue.cend()) {
            res_pool = *pos;
            return true;
        }
    }
    return false;
}

bool Storage::write_queue_pop(Pool& res_pool) {
    std::unique_lock<std::mutex> lock(d->write_lock);

    if (!d->write_queue.empty()) {
        res_pool = d->write_queue.back();
        d->write_queue.pop_back();
        return true;
    }
    return false;
}

Pool Storage::pool_load(const PoolHash& hash) const {
    size_t size;
    return pool_load_internal(hash, false, size);
}

Pool Storage::pool_load(const cs::Sequence sequence) const {
    if (!isOpen()) {
        d->set_last_error(NotOpen);
        return Pool{};
    }

    Pool res;
    bool needParseData = true;
    cs::Bytes data;

    if (!d->db->get(static_cast<uint32_t>(sequence), &data)) {
        {
            std::unique_lock<std::mutex> lock2(d->write_lock);
            for (auto& poolToWrite : d->write_queue) {
                if (poolToWrite.sequence() == sequence) {
                    res = poolToWrite;
                    needParseData = false;
                    break;
                }
            }
        }

        if (needParseData && !d->db->get(static_cast<uint32_t>(sequence), &data)) {
            d->set_last_error(DatabaseError);
            return Pool{};
        }
    }

    if (needParseData) {
        res = Pool::from_binary(std::move(data));
    }

    if (!res.is_valid()) {
        d->set_last_error(DataIntegrityError);
    }
    else {
        d->set_last_error();
    }

    return res;
}

Pool Storage::pool_load_meta(const PoolHash& hash, size_t& cnt) const {
    if (!isOpen()) {
        d->set_last_error(NotOpen);
        return Pool{};
    }

    if (hash.is_empty()) {
        d->set_last_error(InvalidParameter, "%s: Empty hash passed", funcName());
        return Pool{};
    }

    Pool res{};
    bool found = write_queue_search(hash, res);
    if (found) {
        return res;
    }

    cs::Bytes data;
    if (!d->db->get(hash.to_binary(), &data)) {
        d->set_last_error(DatabaseError);
        return Pool{};
    }

    res = Pool::meta_from_binary(std::move(data), cnt);
    if (!res.is_valid()) {
        d->set_last_error(DataIntegrityError, "%s: Error decoding pool [hash: %s]", funcName(), hash.to_string().c_str());
    }
    else {
        d->set_last_error();
    }

    return res;
}

Pool Storage::pool_remove_last() {
    if (!isOpen()) {
        d->set_last_error(NotOpen);
        return Pool{};
    }

    Pool res{};
    bool found = write_queue_pop(res);

    if (found) {
        d->last_hash = res.previous_hash();
        return res;
    }

    if (last_hash().is_empty()) {
        d->set_last_error(InvalidParameter, "%s: Empty hash passed", funcName());
        return Pool{};
    }

    cs::Bytes data;
    if (!d->db->get(last_hash().to_binary(), &data)) {
        d->set_last_error(DatabaseError);
        return Pool{};
    }

    res = Pool::from_binary(std::move(data));
    if (!res.is_valid()) {
        d->set_last_error(DataIntegrityError, "%s: Error decoding pool [hash: %s]", funcName(), last_hash().to_string().c_str());
    }
    else {
        d->set_last_error();
    }

    d->db->remove(last_hash().to_binary());

    --d->count_pool;
    d->last_hash = res.previous_hash();

    return res;
}

Wallet Storage::wallet(const Address& addr) const {
    return Wallet::get(addr);
}

bool Storage::get_from_blockchain(const Address& addr /*input*/, const int64_t& innerId /*input*/, Transaction& trx /*output*/) const {
    Pool curPool;
    cs::Sequence curIdx = cs::numeric_cast<cs::Sequence>(innerId);
    bool is_in_blockchain = false;

    auto nextIt = [this, &curPool, &curIdx]() -> bool {
        if (curPool.is_valid()) {
            if (curIdx) {
                curIdx--;
                return true;
            }
            else {
                do {
                    curPool = pool_load(curPool.previous_hash());
                } while (curPool.is_valid() && !(curPool.transactions_count()));
                if (curPool.is_valid()) {
                    curIdx = static_cast<cs::Sequence>(curPool.transactions_count() - 1);
                    return true;
                }
            }
        }
        else {
            curPool = pool_load(last_hash());
            while (curPool.is_valid() && !(curPool.transactions_count())) {
                curPool = pool_load(curPool.previous_hash());
            }
            if (curPool.is_valid()) {
                curIdx = static_cast<cs::Sequence>(curPool.transactions_count() - 1);
                return true;
            }
        }
        return false;
    };

    do {
        const Transaction trx_curr = curPool.transaction(curIdx);
        if (trx_curr.source() == addr && trx_curr.innerID() == innerId) {
            is_in_blockchain = true;
            trx = trx_curr;
            break;
        }
    } while (nextIt());

    return is_in_blockchain;
}

const ReadBlockSignal& Storage::readBlockEvent() const {
    return d->read_block_event;
}

std::vector<Transaction> Storage::transactions(const Address& addr, size_t limit, const TransactionID& offset) const {
    std::vector<Transaction> res;
    res.reserve(limit);

    Pool curPool;
    cs::Sequence curIdx = 0;

    auto seekIt = [this, &curPool, &curIdx](const TransactionID& id) -> bool {
        if (id.is_valid()) {
            curPool = pool_load(id.pool_hash());
            if (curPool.is_valid() && id.index() < curPool.transactions_count()) {
                curIdx = id.index();
                return true;
            }
        }
        return false;
    };

    auto nextIt = [this, &curPool, &curIdx]() -> bool {
        if (curPool.is_valid()) {
            if (curIdx) {
                curIdx--;
                return true;
            }
            else {
                do {
                    curPool = pool_load(curPool.previous_hash());
                } while (curPool.is_valid() && !(curPool.transactions_count()));
                if (curPool.is_valid()) {
                    curIdx = static_cast<cs::Sequence>(curPool.transactions_count() - 1);
                    return true;
                }
            }
        }
        else {
            curPool = pool_load(last_hash());
            while (curPool.is_valid() && !(curPool.transactions_count())) {
                curPool = pool_load(curPool.previous_hash());
            }
            if (curPool.is_valid()) {
                curIdx = static_cast<cs::Sequence>(curPool.transactions_count() - 1);
                return true;
            }
        }
        return false;
    };

    if (offset.is_valid())
        if (!seekIt(offset))
            return res;

    while (res.size() < limit && nextIt()) {
        const Transaction t = curPool.transaction(curIdx);
        if ((t.source() == addr) || (t.target() == addr))
            res.push_back(t);
    }

    return res;
}

Transaction Storage::transaction(const TransactionID& id) const {
    if (!id.is_valid()) {
        d->set_last_error(InvalidParameter, "%s: Transaction id is not valid", __func__);
        return Transaction{};
    }

    return pool_load(id.pool_hash()).transaction(id);
}

Transaction Storage::get_last_by_source(Address source) const noexcept {
    Pool curr = pool_load(last_hash());

    while (curr.is_valid()) {
        const auto& t = curr.get_last_by_source(source);
        if (t.is_valid())
            return t;

        curr = pool_load(curr.previous_hash());
    }

    return Transaction{};
}

Transaction Storage::get_last_by_target(Address target) const noexcept {
    Pool curr = pool_load(last_hash());

    while (curr.is_valid()) {
        const auto& t = curr.get_last_by_target(target);
        if (t.is_valid()) {
            return t;
        }

        curr = pool_load(curr.previous_hash());
    }

    return Transaction{};
}

#ifdef TRANSACTIONS_INDEX
cs::Bytes Storage::get_trans_index_key(const Address& addr, const PoolHash& ph) {
    ::csdb::priv::obstream os;
    addr.put(os);
    ph.put(os);
    return os.buffer();
}

PoolHash Storage::get_previous_transaction_block(const Address& addr, const PoolHash& ph) {
    PoolHash result;

    const auto key = get_trans_index_key(addr, ph);
    cs::Bytes data;

    if (d->db->getFromTransIndex(key, &data)) {
        ::csdb::priv::ibstream is(data.data(), data.size());
        result.get(is);
    }

    return result;
}

void Storage::set_previous_transaction_block(const Address& addr, const PoolHash& currTransBlock, const PoolHash& prevTransBlock) {
  const auto key = get_trans_index_key(addr, currTransBlock);

  ::csdb::priv::obstream os;
  prevTransBlock.put(os);

  d->db->putToTransIndex(key, os.buffer());
}

#endif

}  // namespace csdb
```
# ..\node\csdb\src\transaction.cpp 
```cpp 
#include "csdb/transaction.hpp"
#include "transaction_p.hpp"

#include <cinttypes>
#include <iomanip>
#include <iterator>
#include <sstream>

#include <cscrypto/cscrypto.hpp>
#include "binary_streams.hpp"
#include "csdb/address.hpp"
#include "csdb/amount.hpp"
#include "csdb/currency.hpp"
#include "csdb/internal/types.hpp"
#include "csdb/pool.hpp"

#include "priv_crypto.hpp"

namespace csdb {

SHARED_DATA_CLASS_IMPLEMENTATION(TransactionID)

TransactionID::TransactionID(PoolHash poolHash, cs::Sequence index)
: d(new priv(poolHash, index)) {
}

bool TransactionID::is_valid() const noexcept {
    return !d->pool_hash_.is_empty();
}

PoolHash TransactionID::pool_hash() const noexcept {
    return d->pool_hash_;
}

cs::Sequence TransactionID::index() const noexcept {
    return d->index_;
}

std::string TransactionID::to_string() const noexcept {
    std::ostringstream os;
    os << d->pool_hash_.to_string() << ':' << std::hex << std::setfill('0') << std::setw(8) << d->index_;
    return os.str();
}

TransactionID TransactionID::from_string(const ::std::string& str) {
    TransactionID res;
    auto pos = str.find(':');
    if (::std::string::npos != pos) {
        PoolHash ph = PoolHash::from_string(::std::string(str, 0, pos));
        if (!ph.is_empty()) {
            const char* start = str.c_str() + pos + 1;
            if ('\0' != (*start)) {
                char* end = nullptr;
                uintmax_t idx = strtoumax(start, &end, 10);
                if ((end != start) && ('\0' == (*end))) {
                    res.d->pool_hash_ = ph;
                    res.d->index_ = static_cast<cs::Sequence>(idx);
                }
            }
        }
    }
    return res;
}

bool TransactionID::operator==(const TransactionID& other) const noexcept {
    return pool_hash() == other.pool_hash() && index() == other.index();
}

bool TransactionID::operator!=(const TransactionID& other) const noexcept {
    return !operator==(other);
}

bool TransactionID::operator<(const TransactionID& other) const noexcept {
    if (pool_hash() == other.pool_hash())
        return index() < other.index();
    else
        return pool_hash() < other.pool_hash();
}

void TransactionID::put(::csdb::priv::obstream& os) const {
    os.put(d->pool_hash_);
    os.put(d->index_);
}

bool TransactionID::get(::csdb::priv::ibstream& is) {
    return is.get(d->pool_hash_) && is.get(d->index_);
}

SHARED_DATA_CLASS_IMPLEMENTATION(Transaction)

Transaction::Transaction(int64_t innerID, Address source, Address target, Currency currency, Amount amount, AmountCommission max_fee, AmountCommission counted_fee,
                         const cs::Signature& signature)
: d(new priv(innerID, source, target, currency, amount, max_fee, counted_fee, signature)) {
}

bool Transaction::is_valid() const noexcept {
    const priv* data = d.constData();
    return data->source_.is_valid() && data->target_.is_valid() && data->currency_.is_valid() && (data->amount_ >= 0_c);
    // moved to Trusted1StageState:
    //&& (data->source_ != data->target_ || data->user_fields_.size() == 3); // user_fields_count == 3 from the smartcontracts.hpp
}

bool Transaction::is_read_only() const noexcept {
    return d->read_only_;
}

TransactionID Transaction::id() const noexcept {
    return d->id_;
}

int64_t Transaction::innerID() const noexcept {
    return d->innerID_;
}

Address Transaction::source() const noexcept {
    return d->source_;
}

Address Transaction::target() const noexcept {
    return d->target_;
}

Currency Transaction::currency() const noexcept {
    return d->currency_;
}

Amount Transaction::amount() const noexcept {
    return d->amount_;
}

AmountCommission Transaction::max_fee() const noexcept {
    return d->max_fee_;
}

AmountCommission Transaction::counted_fee() const noexcept {
    return d->counted_fee_;
}

const cs::Signature& Transaction::signature() const noexcept {
    return d->signature_;
}

void Transaction::set_innerID(int64_t innerID) {
    if (!d.constData()->read_only_) {
        d->innerID_ = innerID;
    }
}

void Transaction::set_source(Address source) {
    if (!d.constData()->read_only_) {
        d->source_ = source;
    }
}

void Transaction::set_target(Address target) {
    if (!d.constData()->read_only_) {
        d->target_ = target;
    }
}

void Transaction::set_currency(Currency currency) {
    if (!d.constData()->read_only_) {
        d->currency_ = currency;
    }
}

void Transaction::set_amount(Amount amount) {
    if (!d.constData()->read_only_) {
        d->amount_ = amount;
    }
}

void Transaction::set_max_fee(AmountCommission max_fee) {
    if (!d.constData()->read_only_) {
        d->max_fee_ = max_fee;
    }
}

void Transaction::set_counted_fee(AmountCommission counted_fee) {
    if (!d.constData()->read_only_) {
        d->counted_fee_ = counted_fee;
    }
}

void Transaction::set_counted_fee_unsafe(AmountCommission counted_fee) {
    if (!d.constData()->read_only_) {
        auto& constPrivShared = const_cast<const decltype(d)&>(d);
        const priv* constPrivPtr = constPrivShared.data();
        priv* privPtr = const_cast<priv*>(constPrivPtr);
        privPtr->counted_fee_ = counted_fee;
    }
}

void Transaction::set_signature(const cs::Signature& signature) {
    if (!d.constData()->read_only_) {
        d->signature_ = signature;
    }
}

bool Transaction::add_user_field(user_field_id_t id, UserField field) noexcept {
    if (d.constData()->read_only_ || (!field.is_valid())) {
        return false;
    }
    d->user_fields_[id] = field;
    return true;
}

UserField Transaction::user_field(user_field_id_t id) const noexcept {
    const priv* data = d.constData();
    auto it = data->user_fields_.find(id);
    return (data->user_fields_.end() == it) ? UserField{} : it->second;
}

::std::set<user_field_id_t> Transaction::user_field_ids() const noexcept {
    ::std::set<user_field_id_t> res;
    const priv* data = d.constData();
    for (const auto& it : data->user_fields_) {
        res.insert(it.first);
    }
    return res;
}

cs::Bytes Transaction::to_binary() {
    if (!is_valid()) {
        return cs::Bytes();
    }
    ::csdb::priv::obstream os;
    put(os);
    return os.buffer();
}

Transaction Transaction::from_binary(const cs::Bytes& data) {
    Transaction t;
    ::csdb::priv::ibstream is(data.data(), data.size());
    if (!t.get(is)) {
        return Transaction();
    }
    else {
        return t;
    }
}

Transaction Transaction::from_byte_stream(const char* data, size_t m_size) {
    Transaction t;
    ::csdb::priv::ibstream is(data, m_size);
    if (!t.get(is)) {
        return Transaction();
    }
    else {
        return t;
    }
}

std::vector<uint8_t> Transaction::to_byte_stream() const {
    ::csdb::priv::obstream os;
    put(os);
    return os.buffer();
}

bool Transaction::verify_signature(const cs::PublicKey& public_key) const {
    const auto byteStream = to_byte_stream_for_sig();
    return cscrypto::verifySignature(signature().data(), public_key.data(), byteStream.data(), byteStream.size());
}

std::vector<uint8_t> Transaction::to_byte_stream_for_sig() const {
    ::csdb::priv::obstream os;
    const priv* data = d.constData();
    uint8_t innerID[6];
    {
        auto ptr = reinterpret_cast<const uint8_t*>(&data->innerID_);
        std::copy(ptr, ptr + sizeof(innerID), innerID);  // only for little endian machines
    }
    innerID[5] |= ((data->source_.is_wallet_id() << 7) | (data->target_.is_wallet_id()) << 6);
    os.put(*reinterpret_cast<uint16_t*>(innerID));
    os.put(*reinterpret_cast<uint32_t*>(innerID + sizeof(uint16_t)));
    if (data->source_.is_wallet_id()) {
        os.put(data->source_.wallet_id());
    }
    else {
        os.put(data->source_.public_key());
    }
    if (data->target_.is_wallet_id()) {
        os.put(data->target_.wallet_id());
    }
    else {
        os.put(data->target_.public_key());
    }
    os.put(data->amount_);
    os.put(data->max_fee_);
    os.put(data->currency_);

    decltype(data->user_fields_) custom_user_fields(data->user_fields_.lower_bound(0), data->user_fields_.end());
    if (custom_user_fields.size()) {
        os.put_smart(custom_user_fields);
        auto buf = os.buffer();
        return buf;
    }
    else {
        uint8_t num_user_fields = 0;
        os.put(num_user_fields);
        return os.buffer();
    }
}

void Transaction::put(::csdb::priv::obstream& os) const {
    const priv* data = d.constData();
    uint8_t innerID[6];
    {
        auto ptr = reinterpret_cast<const uint8_t*>(&data->innerID_);
        std::copy(ptr, ptr + sizeof(innerID), innerID);  // only for little endian machines
    }
    innerID[5] |= ((data->source_.is_wallet_id() << 7) | (data->target_.is_wallet_id()) << 6);
    os.put(*reinterpret_cast<uint16_t*>(innerID));
    os.put(*reinterpret_cast<uint32_t*>(innerID + sizeof(uint16_t)));
    if (data->source_.is_wallet_id()) {
        os.put(data->source_.wallet_id());
    }
    else {
        os.put(data->source_.public_key());
    }
    if (data->target_.is_wallet_id()) {
        os.put(data->target_.wallet_id());
    }
    else {
        os.put(data->target_.public_key());
    }
    os.put(data->amount_);
    os.put(data->max_fee_);
    os.put(data->currency_);

    os.put(data->user_fields_);

    os.put(data->signature_);
    os.put(data->counted_fee_);
}

bool Transaction::get(::csdb::priv::ibstream& is) {
    priv* data = d.data();
    bool res;

    {
        uint16_t lo = 0;
        uint32_t hi = 0;
        res = is.get(lo) && is.get(hi);

        if (!res) {
            return res;
        }

        data->innerID_ = (((uint64_t)hi & 0x3fffffff) << 16) | lo;

        if (hi & 0x80000000) {
            internal::WalletId id;
            res = is.get(id);

            if (!res) {
                return res;
            }

            data->source_ = Address::from_wallet_id(id);
        }
        else {
            cs::PublicKey key;
            res = is.get(key);

            if (!res) {
                return res;
            }

            data->source_ = Address::from_public_key(key);
        }

        if (hi & 0x40000000) {
            internal::WalletId id;
            res = is.get(id);

            if (!res) {
                return res;
            }

            data->target_ = Address::from_wallet_id(id);
        }
        else {
            cs::PublicKey key;
            res = is.get(key);

            if (!res) {
                return res;
            }

            data->target_ = Address::from_public_key(key);
        }
    }

    res = is.get(data->amount_);

    if (!res) {
        return res;
    }

    res = is.get(data->max_fee_);

    if (!res) {
        return res;
    }

    uint8_t parse;
    res = is.get(parse);

    if (!res) {
        return res;
    }

    data->currency_ = parse;

    res = is.get(data->user_fields_);
    if (!res) {
        return res;
    }

    return is.get(data->signature_) && is.get(data->counted_fee_);
}

void Transaction::set_time(const uint64_t ts) {
    d->time_ = ts;
}

uint64_t Transaction::get_time() const {
    return d->time_;
}

}  // namespace csdb
```
# ..\node\csdb\src\transaction_p.hpp 
```cpp 
/**
 * @file transaction_p.h
 * @author Evgeny V. Zalivochkin
 */

#pragma once
#ifndef _CREDITS_CSDB_TRANSACTION_PRIVATE_H_INCLUDED_
#define _CREDITS_CSDB_TRANSACTION_PRIVATE_H_INCLUDED_

#include "csdb/transaction.hpp"

#include <map>

#include "csdb/internal/shared_data_ptr_implementation.hpp"

#include "csdb/address.hpp"
#include "csdb/amount.hpp"
#include "csdb/amount_commission.hpp"
#include "csdb/currency.hpp"
#include "csdb/pool.hpp"

namespace csdb {

class TransactionID::priv : public ::csdb::internal::shared_data {
    inline priv()
    : index_(0) {
    }

    inline priv(PoolHash pool_hash, cs::Sequence index)
    : pool_hash_(pool_hash)
    , index_(index) {
    }

    inline void _update(PoolHash pool_hash, cs::Sequence index) {
        pool_hash_ = pool_hash;
        index_ = index;
    }

    priv clone() const {
        priv result;
        result.pool_hash_ = pool_hash_.clone();
        result.index_ = index_;
        return result;
    }

    PoolHash pool_hash_;
    cs::Sequence index_ = 0;
    friend class TransactionID;
    friend class Transaction;
    friend class Pool;
};

class Transaction::priv : public ::csdb::internal::shared_data {
    inline priv()
    : read_only_(false)
    , innerID_(0)
    , amount_(0_c)
    , signature_() {
        signature_.fill(0);
    }

    inline priv(const priv& other)
    : ::csdb::internal::shared_data()
    , read_only_(other.read_only_)
    , id_(other.id_)
    , innerID_(other.innerID_)
    , source_(other.source_)
    , target_(other.target_)
    , currency_(other.currency_)
    , amount_(other.amount_)
    , max_fee_(other.max_fee_)
    , counted_fee_(other.counted_fee_)
    , signature_(other.signature_)
    , user_fields_(other.user_fields_)
    , time_(other.time_) {
    }

    inline priv(int64_t innerID, Address source, Address target, Currency currency, Amount amount, AmountCommission max_fee, AmountCommission counted_fee, cs::Signature signature)
    : read_only_(false)
    , innerID_(innerID)
    , source_(source)
    , target_(target)
    , currency_(currency)
    , amount_(amount)
    , max_fee_(max_fee)
    , counted_fee_(counted_fee)
    , signature_(signature) {
    }

    inline void _update_id(PoolHash pool_hash, cs::Sequence index) {
        id_.d->_update(pool_hash, index);
        read_only_ = true;
    }

    priv clone() const {
        priv result;
        result.read_only_ = read_only_;
        result.id_ = id_.clone();
        result.innerID_ = innerID_;

        result.source_ = source_.clone();
        result.target_ = target_.clone();
        result.currency_ = currency_.clone();
        result.amount_ = amount_;
        result.max_fee_ = max_fee_;
        result.counted_fee_ = counted_fee_;
        result.signature_ = signature_;

        for (auto& uf : user_fields_)
            result.user_fields_[uf.first] = uf.second.clone();

        result.time_ = time_;

        return result;
    }

    bool read_only_;
    TransactionID id_;
    int64_t innerID_;
    Address source_;
    Address target_;
    Currency currency_;
    Amount amount_;
    AmountCommission max_fee_;
    AmountCommission counted_fee_;
    cs::Signature signature_;
    ::std::map<::csdb::user_field_id_t, ::csdb::UserField> user_fields_;

    uint64_t time_{};  // optional, not set automatically

    friend class Transaction;
    friend class Pool;
    friend class ::csdb::internal::shared_data_ptr<priv>;
};

}  // namespace csdb

#endif  // _CREDITS_CSDB_TRANSACTION_PRIVATE_H_INCLUDED_
```
# ..\node\csdb\src\user_field.cpp 
```cpp 
#include "csdb/user_field.hpp"

#include "binary_streams.hpp"
#include "csdb/internal/shared_data_ptr_implementation.hpp"

namespace csdb {

class UserField::priv : public ::csdb::internal::shared_data {
    inline priv()
    : type_(UserField::Unknown)
    , i_value_(0) {
    }

    inline priv(uint64_t value)
    : type_(UserField::Integer)
    , i_value_(value) {
    }

    inline priv(const ::std::string& value)
    : type_(UserField::String)
    , i_value_(0)
    , s_value_(value) {
    }

    inline priv(const ::csdb::Amount& value)
    : type_(UserField::Amount)
    , i_value_(0)
    , a_value_(value) {
    }

    inline void put(::csdb::priv::obstream& os) const {
        switch (type_) {
            case UserField::Integer:
                os.put(type_);
                os.put(i_value_);
                break;

            case UserField::String:
                os.put(type_);
                os.put(s_value_);
                break;

            case UserField::Amount:
                os.put(type_);
                os.put(a_value_);
                break;

            default:
                break;
        }
    }

    inline void put_for_sig(::csdb::priv::obstream& os) const {
        switch (type_) {
            case UserField::Integer:
                os.put(i_value_);
                break;

            case UserField::String:
                os.put(s_value_);
                break;

            case UserField::Amount:
                os.put(a_value_);
                break;

            default:
                break;
        }
    }

    inline bool get(::csdb::priv::ibstream& is) {
        UserField::Type type;
        if (!is.get(type)) {
            return false;
        }
        switch (type) {
            case UserField::Integer:
                if (!is.get(i_value_)) {
                    return false;
                }
                break;

            case UserField::String:
                if (!is.get(s_value_)) {
                    return false;
                }
                break;

            case UserField::Amount:
                if (!is.get(a_value_)) {
                    return false;
                }
                break;

            default:
                return false;
        }
        type_ = type;
        return true;
    }

    inline bool is_equal(const priv* other) const {
        if (type_ != other->type_) {
            return false;
        }

        switch (type_) {
            case UserField::Integer:
                return (i_value_ == other->i_value_);
            case UserField::String:
                return (s_value_ == other->s_value_);
            case UserField::Amount:
                return (a_value_ == other->a_value_);
            default:
                return true;
        }
    }

    DEFAULT_PRIV_CLONE()

    UserField::Type type_;
    uint64_t i_value_;
    ::std::string s_value_;
    ::csdb::Amount a_value_;
    friend class UserField;
};
SHARED_DATA_CLASS_IMPLEMENTATION(UserField)

template <>
UserField::UserField(uint64_t value)
: d(new priv(value)) {
}

template <>
UserField::UserField(const ::std::string& value)
: d(new priv(value)) {
}

template <>
UserField::UserField(const ::csdb::Amount& value)
: d(new priv(value)) {
}

UserField::UserField(const char* value)
: d(new priv(::std::string(value))) {
}

bool UserField::is_valid() const noexcept {
    return (Unknown != d->type_);
}

UserField::Type UserField::type() const noexcept {
    return d->type_;
}

template <>
uint64_t UserField::value<uint64_t>() const noexcept {
    const priv* data = d.constData();
    return (Integer == data->type_) ? data->i_value_ : 0;
}

template <>
::std::string UserField::value<::std::string>() const noexcept {
    const priv* data = d.constData();
    return (String == data->type_) ? data->s_value_ : ::std::string{};
}

template <>
::csdb::Amount UserField::value<::csdb::Amount>() const noexcept {
    const priv* data = d.constData();
    return (Amount == data->type_) ? data->a_value_ : 0_c;
}

bool UserField::operator==(const UserField& other) const noexcept {
    return d->is_equal(other.d);
}

void UserField::put(::csdb::priv::obstream& os) const {
    d->put(os);
}

void UserField::put_for_sig(::csdb::priv::obstream& os) const {
    d->put_for_sig(os);
}

bool UserField::get(::csdb::priv::ibstream& is) {
    return d->get(is);
}

}  // namespace csdb
```
# ..\node\csdb\src\utils.cpp 
```cpp 
#include "csdb/internal/utils.hpp"
#include <deque>

#ifdef _MSC_VER
#include <Shlobj.h>
#include <direct.h>
#else
#include <dirent.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

namespace csdb {
namespace internal {

namespace {

struct Node {
    enum Type {
        File,
        Dir
    };

    Type type;
    std::string name;
};
using NodeList = std::deque<Node>;

NodeList children(const std::string &path) {
    NodeList res;

#if defined(_MSC_VER)
    WIN32_FIND_DATAA d;
    HANDLE h = ::FindFirstFileA((path + "\\*.*").c_str(), &d);
    if (h != INVALID_HANDLE_VALUE) {
        do {
            const std::string name{d.cFileName};
            if ((0 != (d.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) && ((name == ".") || (name == ".."))) {
                continue;
            }
            res.push_back({(0 != (d.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) ? Node::Dir : Node::File, name});
        } while (::FindNextFileA(h, &d));

        ::FindClose(h);
    }
#else
    DIR *d = opendir(path.c_str());
    if (d) {
        struct dirent *entry;
        while ((entry = readdir(d)) != NULL) {
            const std::string name{entry->d_name};
            if (entry->d_type == DT_DIR && (name == "." || name == ".."))
                continue;
            res.push_back({((entry->d_type == DT_DIR) ? Node::Dir : Node::File), name});
        }
        closedir(d);
    }
#endif

    return res;
}

}  // namespace

std::string path_add_separator(const std::string &path) {
    if (path.empty())
        return path;

#ifdef _MSC_VER
    static const char sep = '\\';
#else
    static const char sep = '/';
#endif

    const char end = path[path.size() - 1];
    return ((end != '\\') && (end != '/')) ? (path + sep) : path;
}

std::string app_data_path() {
#ifdef _MSC_VER
    char temp_char[MAX_PATH];
    HRESULT hresult = ::SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT | KF_FLAG_CREATE, temp_char);
    if (hresult == S_OK && temp_char[0])
        return path_add_separator(std::string(temp_char));
#else
    const std::string res = path_add_separator(std::string(getenv("HOME"))) + ".appdata/";
    if (path_make(res))
        return res;
#endif
    return std::string();
}

bool dir_exists(const std::string &path) {
#ifdef _MSC_VER
    const DWORD attr = ::GetFileAttributesA(path.c_str());
    return (INVALID_FILE_ATTRIBUTES != attr) && (0 != (attr & FILE_ATTRIBUTE_DIRECTORY));
#else
    struct stat buf;
    return (stat(path.c_str(), &buf) == 0) && ((buf.st_mode & S_IFMT) == S_IFDIR);
#endif
}

size_t file_size(const std::string &name) {
#ifdef _MSC_VER
    WIN32_FILE_ATTRIBUTE_DATA fad;
    if ((!::GetFileAttributesExA(name.c_str(), GetFileExInfoStandard, &fad)) || (INVALID_FILE_ATTRIBUTES == fad.dwFileAttributes) ||
        (0 != (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))) {
        return static_cast<size_t>(-1);
    }
    return ((static_cast<size_t>(fad.nFileSizeHigh) << 32) | static_cast<size_t>(fad.nFileSizeLow));
#else
    struct stat buf;
    if ((0 != stat(name.c_str(), &buf)) || (S_IFDIR == (buf.st_mode & S_IFMT))) {
        return static_cast<size_t>(-1);
    }
    return static_cast<size_t>(buf.st_size);
#endif
}

bool dir_make(const std::string &path) {
    if (dir_exists(path))
        return true;

#ifdef _MSC_VER
    return _mkdir(path.c_str()) == 0;
#else
    return mkdir(path.c_str(), 0755) == 0;
#endif
}

bool dir_remove(const std::string &path) {
    if (!dir_exists(path))
        return true;

#ifdef _MSC_VER
    return _rmdir(path.c_str()) == 0;
#else
    return rmdir(path.c_str()) == 0;
#endif
}

bool path_make(const std::string &path) {
    if (dir_make(path))
        return true;

    switch (errno) {
        case ENOENT: {
            std::string::size_type pos = path.find_last_of('/');
            if (pos == std::string::npos)
#if defined(_MSC_VER)
                pos = path.find_last_of('\\');
            if (pos == std::string::npos)
#endif
                return false;
            if (!path_make(path.substr(0, pos)))
                return false;
        }
            return dir_make(path);

        case EEXIST:
            return dir_exists(path);

        default:
            return false;
    }
}

bool path_remove(const std::string &path) {
    if (dir_remove(path))
        return true;

    const NodeList nodes = children(path);
    for (const auto &it : nodes) {
        const std::string cur = path_add_separator(path) + it.name;
        switch (it.type) {
            case Node::Dir:
                if (!path_remove(cur))
                    return false;
                break;

            case Node::File:
                if (!file_remove(cur))
                    return false;
        }
    }

    return dir_remove(path);
}

size_t path_size(const std::string &path) {
    if (!dir_exists(path)) {
        return file_size(path);
    }

    size_t total = 0;
    ::std::string path_sep = path_add_separator(path);
    for (const auto &it : children(path)) {
        size_t subtotal = path_size(path_sep + it.name);
        if (static_cast<size_t>(-1) != subtotal) {
            total += subtotal;
        }
    }

    return total;
}

bool file_remove(const std::string &path) {
#ifdef _MSC_VER
    return _unlink(path.c_str()) == 0;
#else
    return unlink(path.c_str()) == 0;
#endif
}

}  // namespace internal
}  // namespace csdb
```
# ..\node\csdb\src\wallet.cpp 
```cpp 
#include "csdb/wallet.hpp"
#include <map>

#include "csdb/address.hpp"
#include "csdb/amount.hpp"
#include "csdb/csdb.hpp"
#include "csdb/internal/shared_data_ptr_implementation.hpp"
#include "csdb/pool.hpp"

namespace csdb {

class Wallet::priv : public ::csdb::internal::shared_data {
    priv() = default;

    explicit priv(Address address)
    : address_(address) {
    }

    Address address_;
    std::map<Currency, Amount> amounts_;

    priv clone() const {
        priv result;

        result.address_ = address_.clone();

        for (auto &am : amounts_)
            result.amounts_[am.first.clone()] = am.second;

        return result;
    }

    friend class Wallet;
};
SHARED_DATA_CLASS_IMPLEMENTATION(Wallet)

bool Wallet::is_valid() const noexcept {
    return d->address_.is_valid();
}

Address Wallet::address() const noexcept {
    return d->address_;
}

CurrencyList Wallet::currencies() const noexcept {
    CurrencyList res;
    res.reserve(d->amounts_.size());

    for (const auto &it : d->amounts_) {
        res.push_back(it.first);
    }

    return res;
}

Amount Wallet::amount(Currency currency) const noexcept {
    const auto it = d->amounts_.find(currency);
    return (it != d->amounts_.end()) ? it->second : 0_c;
}

Wallet Wallet::get(Address address, Storage storage) {
    if (!storage.isOpen()) {
        storage = csdb::defaultStorage();
        if (!storage.isOpen()) {
            return Wallet{};
        }
    }
    priv *d = new priv(address);

    for (Pool pool = Pool::load(storage.last_hash(), storage); pool.is_valid(); pool = Pool::load(pool.previous_hash(), storage)) {
        for (size_t i = 0; i < pool.transactions_count(); ++i) {
            const Transaction t = pool.transaction(i);
            const Currency currency = t.currency();
            if (t.source() == address) {
                d->amounts_[currency] -= t.amount();
            }
            if (t.target() == address) {
                d->amounts_[currency] += t.amount();
            }
        }
    }

    return Wallet(d);
}

}  // namespace csdb
```
# ..\node\csdb\unittests\csdb_unit_tests_address.cpp 
```cpp 
#include "csdb/address.h"

#include <gtest/gtest.h>

#include "priv_crypto.h"

class AddressTest : public ::testing::Test
{
};

::std::ostream& operator <<(::std::ostream& os, const ::csdb::Address& value)
{
  os << value.to_string();
  return os;
}

using namespace csdb;

TEST_F(AddressTest, EmptyAddress)
{
  Address a;
  EXPECT_FALSE(a.is_valid());
  EXPECT_TRUE(a.to_string().empty());
}

TEST_F(AddressTest, FromValidString)
{
  EXPECT_TRUE(Address::from_string("0000000000000000000000000000000000000000").is_valid());
  Address a1 = Address::from_string("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
  Address a2 = Address::from_string("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
  Address a3 = Address::from_string("aAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaa");
  EXPECT_TRUE(a1.is_valid());
  EXPECT_TRUE(a2.is_valid());
  EXPECT_TRUE(a3.is_valid());
  EXPECT_EQ(a1, a2);
  EXPECT_EQ(a1, a3);
  EXPECT_EQ(a2, a3);
}

TEST_F(AddressTest, FromInvalidString)
{
  EXPECT_FALSE(Address::from_string("00000000000000000000000000000000000000").is_valid());
  EXPECT_FALSE(Address::from_string("000000000000000000000000000000000000000000").is_valid());
  EXPECT_FALSE(Address::from_string("000000000000000000000000000000000000000z").is_valid());
  EXPECT_FALSE(Address::from_string("z000000000000000000000000000000000000000").is_valid());
}

TEST_F(AddressTest, FromValidPublicKey)
{
  ::csdb::internal::byte_array key1(::csdb::priv::crypto::public_key_size);
  ::csdb::internal::byte_array key2(::csdb::priv::crypto::public_key_size);

  for (size_t i = 0; i < ::csdb::priv::crypto::public_key_size; ++i) {
    key1[i] = 0;
    key2[i] = static_cast<::csdb::internal::byte_array::value_type>(i);
  }

  Address a1 = Address::from_public_key(key1);
  Address a2 = Address::from_public_key(key1);
  Address a3 = Address::from_public_key(key2);
  Address a4 = Address::from_public_key(key2);
  EXPECT_TRUE(a1.is_valid());
  EXPECT_TRUE(a2.is_valid());
  EXPECT_TRUE(a3.is_valid());
  EXPECT_TRUE(a4.is_valid());
  EXPECT_EQ(a1, a2);
  EXPECT_EQ(a3, a4);
  EXPECT_NE(a1, a3);
  EXPECT_NE(a2, a4);
  EXPECT_EQ(a1.public_key(), key1);
  EXPECT_EQ(a2.public_key(), key1);
  EXPECT_EQ(a3.public_key(), key2);
  EXPECT_EQ(a4.public_key(), key2);
}

TEST_F(AddressTest, FromInvalidPublicKey)
{
  EXPECT_FALSE(Address::from_public_key({1,2,3}).is_valid());
  EXPECT_FALSE(Address::from_public_key(
                 ::csdb::internal::byte_array(::csdb::priv::crypto::public_key_size - 1)).is_valid());
  EXPECT_FALSE(Address::from_public_key(
                 ::csdb::internal::byte_array(::csdb::priv::crypto::public_key_size + 1)).is_valid());
}
```
# ..\node\csdb\unittests\csdb_unit_tests_amount.cpp 
```cpp 
#include "csdb/amount.h"
#include "binary_streams.h"
#include <gtest/gtest.h>

class AmountTest : public ::testing::Test
{
};

using namespace csdb;

TEST_F(AmountTest, SimpleConstructors)
{
  constexpr Amount a;
  EXPECT_EQ(a.integral(), 0);
  EXPECT_EQ(a.fraction(), 0);
  EXPECT_EQ(a.round(), 0);
  EXPECT_EQ(a.to_double(), 0.0);

  constexpr Amount b(1);
  EXPECT_EQ(b.integral(), 1);
  EXPECT_EQ(b.fraction(), 0);
  EXPECT_EQ(b.round(), 1);
  EXPECT_EQ(b.to_double(), 1.0);

  constexpr Amount c(-1);
  EXPECT_EQ(c.integral(), -1);
  EXPECT_EQ(c.fraction(), 0);
  EXPECT_EQ(c.round(), -1);
  EXPECT_EQ(c.to_double(), -1.0);
}

TEST_F(AmountTest, FractionConstructors)
{
  EXPECT_THROW(Amount(1, 1, 1), std::invalid_argument);
  EXPECT_THROW(Amount(1, 5, 2), std::invalid_argument);
  EXPECT_THROW(Amount(1, 5, 5), std::invalid_argument);
  EXPECT_THROW(Amount(1, 100, 5), std::invalid_argument);
  EXPECT_THROW(Amount(1, 101, 5), std::invalid_argument);

  constexpr Amount a1(1, 2);
  EXPECT_EQ(a1.integral(), 1);
  EXPECT_EQ(a1.fraction(), 20000000000000000ULL);
  EXPECT_EQ(a1.round(), 1);
  EXPECT_EQ(a1.to_double(), 1.02);

  constexpr Amount a2(1, 5, 1000);
  EXPECT_EQ(a2.integral(), 1);
  EXPECT_EQ(a2.fraction(), 5000000000000000ULL);
  EXPECT_EQ(a2.round(), 1);
  EXPECT_EQ(a2.to_double(), 1.005);

  constexpr Amount a3(-1, 4, 10);
  EXPECT_EQ(a3.integral(), -1);
  EXPECT_EQ(a3.fraction(), 400000000000000000ULL);
  EXPECT_EQ(a3.round(), -1);
  EXPECT_EQ(a3.to_double(), -0.6);

  constexpr Amount a4(-1, 5, 10);
  EXPECT_EQ(a4.integral(), -1);
  EXPECT_EQ(a4.fraction(), 500000000000000000ULL);
  EXPECT_EQ(a4.round(), 0);
  EXPECT_EQ(a4.to_double(), -0.5);

  constexpr Amount a5(0, 123456789, 1000000000);
  EXPECT_EQ(a5.integral(), 0);
  EXPECT_EQ(a5.fraction(), 123456789000000000ULL);
  EXPECT_EQ(a5.round(), 0);
  EXPECT_EQ(a5.to_double(), 0.123456789);
}

TEST_F(AmountTest, Serialization)
{
  ::csdb::priv::obstream o;
  o.put(Amount(5));
  o.put(Amount(-5));
  o.put(Amount(5, 20));
  o.put(Amount(-5, 20));
  o.put(Amount(5, 40, 10000));
  o.put(Amount(-5, 40, 10000));

  ::csdb::priv::ibstream i(o.buffer());
  Amount a;
  EXPECT_TRUE(i.get(a));
  EXPECT_EQ(a, Amount(5));
  EXPECT_TRUE(i.get(a));
  EXPECT_EQ(a, Amount(-5));
  EXPECT_TRUE(i.get(a));
  EXPECT_EQ(a, Amount(5, 20));
  EXPECT_TRUE(i.get(a));
  EXPECT_EQ(a, Amount(-5, 20));
  EXPECT_TRUE(i.get(a));
  EXPECT_EQ(a, Amount(5, 40, 10000));
  EXPECT_TRUE(i.get(a));
  EXPECT_EQ(a, Amount(-5, 40, 10000));
}

TEST_F(AmountTest, LiteralOperator)
{
  EXPECT_EQ(Amount(5), 5_c);
  EXPECT_EQ(Amount(5, 2), 5.02_c);
  EXPECT_EQ(Amount(5, 20), 5.20_c);
  EXPECT_EQ(Amount(5, 2, 1000), 5.002_c);
  EXPECT_EQ(Amount(55, 2, 1000), 55.002_c);
  EXPECT_EQ(Amount(0, 123456789, 1000000000), 0.123456789_c);
}

TEST_F(AmountTest, Comparison)
{
  EXPECT_TRUE(1_c < 2_c);
  EXPECT_FALSE(2_c < 1_c);
  EXPECT_TRUE(1.1_c < 1.2_c);
  EXPECT_FALSE(1.2_c < 1.1_c);
  EXPECT_TRUE(1.01_c < 1.1_c);
  EXPECT_FALSE(1.1_c < 1.01_c);
  EXPECT_FALSE(5_c < 5_c);

  EXPECT_TRUE(2_c > 1_c);
  EXPECT_FALSE(1_c > 2_c);
  EXPECT_TRUE(1.2_c > 1.1_c);
  EXPECT_FALSE(1.1_c > 1.2_c);
  EXPECT_TRUE(1.1_c > 1.01_c);
  EXPECT_FALSE(1.01_c > 1.1_c);
  EXPECT_FALSE(5_c > 5_c);

  EXPECT_TRUE(1_c <= 2_c);
  EXPECT_FALSE(2_c <= 1_c);
  EXPECT_TRUE(1.1_c <= 1.2_c);
  EXPECT_FALSE(1.2_c <= 1.1_c);
  EXPECT_TRUE(1.01_c <= 1.1_c);
  EXPECT_FALSE(1.1_c <= 1.01_c);
  EXPECT_TRUE(5_c <= 5_c);

  EXPECT_TRUE(2_c >= 1_c);
  EXPECT_FALSE(1_c >= 2_c);
  EXPECT_TRUE(1.2_c >= 1.1_c);
  EXPECT_FALSE(1.1_c >= 1.2_c);
  EXPECT_TRUE(1.1_c >= 1.01_c);
  EXPECT_FALSE(1.01_c >= 1.1_c);
  EXPECT_TRUE(5_c >= 5_c);
}

TEST_F(AmountTest, UnaryMinus)
{
  {
    constexpr const Amount a = -0_c;
    EXPECT_EQ(a.integral(), 0);
    EXPECT_EQ(a.fraction(), 0ULL);
  }

  {
    constexpr const Amount a = -1_c;
    EXPECT_EQ(a.integral(), -1);
    EXPECT_EQ(a.fraction(), 0ULL);
    constexpr const Amount b = -a;
    EXPECT_EQ(b.integral(), 1);
    EXPECT_EQ(b.fraction(), 0ULL);
  }

  {
    constexpr const Amount a = -0.4_c;
    EXPECT_EQ(a.integral(), -1);
    EXPECT_EQ(a.fraction(), 600000000000000000ULL);
    constexpr const Amount b = -a;
    EXPECT_EQ(b.integral(), 0);
    EXPECT_EQ(b.fraction(), 400000000000000000ULL);
  }

  {
    constexpr const Amount a = -2.05_c;
    EXPECT_EQ(a.integral(), -3);
    EXPECT_EQ(a.fraction(), 950000000000000000ULL);
    constexpr const Amount b = -a;
    EXPECT_EQ(b.integral(), 2);
    EXPECT_EQ(b.fraction(), 50000000000000000ULL);
  }
}

TEST_F(AmountTest, CounstructFromDouble)
{
  {
    const Amount a{1.0};
    EXPECT_EQ(a.integral(), 1);
    EXPECT_EQ(a.fraction(), 0ULL);
  }

  {
    const Amount a{-1.0};
    EXPECT_EQ(a.integral(), -1);
    EXPECT_EQ(a.fraction(), 0ULL);
  }

  {
    const Amount a{1.1};
    EXPECT_EQ(a.integral(), 1);
    EXPECT_EQ(a.fraction(), 100000000000000000ULL);
  }

  {
    const Amount a{-1.1};
    EXPECT_EQ(a.integral(), -2);
    EXPECT_EQ(a.fraction(), 900000000000000000ULL);
  }

  EXPECT_THROW(Amount(static_cast<double>(std::numeric_limits<int32_t>::max()) + 1), std::overflow_error);
  EXPECT_THROW(Amount(static_cast<double>(std::numeric_limits<int32_t>::min()) - 1), std::overflow_error);
}

TEST_F(AmountTest, AssignmentPlus)
{
  {
    Amount a = 1_c;
    a += 1_c;
    EXPECT_EQ(a, 2_c);
  }

  {
    Amount a = 1.1_c;
    a += 1.1_c;
    EXPECT_EQ(a, 2.2_c);
  }

  {
    Amount a = 1.6_c;
    a += 1.7_c;
    EXPECT_EQ(a, 3.3_c);
  }

  {
    Amount a = 1.6_c;
    a += -1.7_c;
    EXPECT_EQ(a, -0.1_c);
  }

  {
    Amount a = 1.1_c;
    a += 10;
    EXPECT_EQ(a, 11.1_c);
  }

  {
    Amount a = 1.1_c;
    a += (-10);
    EXPECT_EQ(a, -8.9_c);
  }

  {
    Amount a = 1.1_c;
    a += 1.1;
    EXPECT_EQ(a, 2.2_c);
  }

  {
    Amount a = 1.6_c;
    a += 1.7;
    EXPECT_EQ(a, 3.3_c);
  }

  {
    Amount a = 1.6_c;
    a += -1.7;
    EXPECT_EQ(a, -0.1_c);
  }
}

TEST_F(AmountTest, AssignmentMinus)
{
  {
    Amount a = 2_c;
    a -= 1_c;
    EXPECT_EQ(a, 1_c);
  }

  {
    Amount a = 2.2_c;
    a -= 1.1_c;
    EXPECT_EQ(a, 1.1_c);
  }

  {
    Amount a = 1.6_c;
    a -= 1.7_c;
    EXPECT_EQ(a, -0.1_c);
  }

  {
    Amount a = 1.6_c;
    a -= -1.7_c;
    EXPECT_EQ(a, 3.3_c);
  }

  {
    Amount a = 11.1_c;
    a -= 10;
    EXPECT_EQ(a, 1.1_c);
  }

  {
    Amount a = 1.1_c;
    a -= (-10);
    EXPECT_EQ(a, 11.1_c);
  }

  {
    Amount a = 2.2_c;
    a -= 1.1;
    EXPECT_EQ(a, 1.1_c);
  }

  {
    Amount a = 1.6_c;
    a -= 1.7;
    EXPECT_EQ(a, -0.1_c);
  }

  {
    Amount a = 1.6_c;
    a -= -1.7;
    EXPECT_EQ(a, 3.3_c);
  }
}

TEST_F(AmountTest, Plus)
{
  EXPECT_EQ(1_c + 1_c, 2_c);
  EXPECT_EQ(1.1_c + 1.1_c, 2.2_c);
  EXPECT_EQ(1.5_c + 2.5_c, 4_c);
  EXPECT_EQ(1.6_c + 2.6_c, 4.2_c);
  EXPECT_EQ(2.6_c + (-1.6_c), 1_c);

  EXPECT_EQ(1_c + 1, 2_c);
  EXPECT_EQ(2_c + (-1), 1_c);
  EXPECT_EQ((-1_c) + 2, 1_c);
  EXPECT_EQ((-0.5_c) + 1, 0.5_c);

  EXPECT_EQ(1_c + 1.0, 2_c);
  EXPECT_EQ(1.1_c + 1.1, 2.2_c);
  EXPECT_EQ(1.5_c + 2.5, 4_c);
  EXPECT_EQ(1.6_c + 2.6, 4.2_c);
  EXPECT_EQ(2.6_c + (-1.6), 1_c);

  EXPECT_EQ(1 + 1_c , 2_c);
  EXPECT_EQ((-1) + 2_c, 1_c);
  EXPECT_EQ(2 + (-1_c), 1_c);
  EXPECT_EQ(1 + (-0.5_c), 0.5_c);

  EXPECT_EQ(1.0 + 1_c, 2_c);
  EXPECT_EQ(1.1 + 1.1_c, 2.2_c);
  EXPECT_EQ(2.5 + 1.5_c, 4_c);
  EXPECT_EQ(2.6 + 1.6_c, 4.2_c);
  EXPECT_EQ((-1.6) + 2.6_c, 1_c);
}

TEST_F(AmountTest, Minus)
{
  EXPECT_EQ(2_c - 1_c, 1_c);
  EXPECT_EQ(2.2_c - 1.1_c, 1.1_c);
  EXPECT_EQ(1.5_c - 2.5_c, -1_c);
  EXPECT_EQ(1.3_c - 2.6_c, -1.3_c);
  EXPECT_EQ(2.6_c - (-1.6_c), 4.2_c);

  EXPECT_EQ(2_c - 1, 1_c);
  EXPECT_EQ(1_c - (-1), 2_c);
  EXPECT_EQ(1_c - 2, -1_c);
  EXPECT_EQ((-1_c) - 2, -3_c);
  EXPECT_EQ(0.5_c - 1, -0.5_c);
  EXPECT_EQ(0.2_c - 1, -0.8_c);

  EXPECT_EQ(2_c - 1.0, 1_c);
  EXPECT_EQ(2.2_c - 1.1, 1.1_c);
  EXPECT_EQ(1.5_c - 2.5, -1_c);
  EXPECT_EQ(1.3_c - 2.6, -1.3_c);
  EXPECT_EQ(2.6_c - (-1.6), 4.2_c);

  EXPECT_EQ(2 - 1_c, 1_c);
  EXPECT_EQ(1 - (-1_c), 2_c);
  EXPECT_EQ(1 - 2_c, -1_c);
  EXPECT_EQ((-1) - 2_c, -3_c);
  EXPECT_EQ(1 - 1.5_c, -0.5_c);
  EXPECT_EQ(1 - 1.2_c, -0.2_c);

  EXPECT_EQ(2.0 - 1.0_c, 1_c);
  EXPECT_EQ(2.2 - 1.1_c, 1.1_c);
  EXPECT_EQ(1.5 - 2.5_c, -1_c);
  EXPECT_EQ(1.3 - 2.6_c, -1.3_c);
  EXPECT_EQ(2.6 - (-1.6_c), 4.2_c);
}

TEST_F(AmountTest, Multiply)
{
  EXPECT_EQ(1_c * 1, 1_c);
  EXPECT_EQ(2_c * 2, 4_c);
  EXPECT_EQ((-2_c) * 2, -4_c);
  EXPECT_EQ(2_c * (-2), -4_c);
  EXPECT_EQ(-2_c * (-2), 4_c);
  EXPECT_EQ(1.2_c * 2, 2.4_c);
  EXPECT_EQ(1.8_c * 2, 3.6_c);
  EXPECT_EQ((-1.8_c) * 2, -3.6_c);
  EXPECT_EQ(1.8_c * (-2), -3.6_c);
  EXPECT_EQ((-1.8_c) * (-2), 3.6_c);
  EXPECT_EQ((-0.5_c) * 10, -5_c);

  EXPECT_EQ(1_c * 1_c, 1_c);
  EXPECT_EQ(2_c * 2_c, 4_c);
  EXPECT_EQ((-2_c) * 2_c, -4_c);
  EXPECT_EQ(2_c * (-2_c), -4_c);
  EXPECT_EQ(-2_c * (-2_c), 4_c);
  EXPECT_EQ(1.1_c * 1.1_c, 1.21_c);
  EXPECT_EQ(0.1_c * 0.1_c, 0.01_c);
  EXPECT_EQ(1.23_c * 1.89_c, 2.3247_c);
  EXPECT_EQ(0.123456789_c * 0.987654321_c, 0.121932631112635269_c);
  EXPECT_EQ((-1.23_c) * 1.89_c, -2.3247_c);
  EXPECT_EQ(1.23_c * (-1.89_c), -2.3247_c);
  EXPECT_EQ((-1.23_c) * (-1.89_c), 2.3247_c);

  EXPECT_EQ(1_c * 1.0, 1_c);
  EXPECT_EQ(2_c * 2.0, 4_c);
  EXPECT_EQ((-2_c) * 2.0, -4_c);
  EXPECT_EQ(2_c * (-2.0), -4_c);
  EXPECT_EQ(-2_c * (-2.0), 4_c);
  EXPECT_EQ(1.1_c * 1.1, 1.21_c);
  EXPECT_EQ(0.1_c * 0.1, 0.01_c);
  EXPECT_EQ(1.23_c * 1.89, 2.3247_c);
  EXPECT_EQ(0.123456789_c * 0.987654321, 0.121932631112635269_c);
  EXPECT_EQ((-1.23_c) * 1.89, -2.3247_c);
  EXPECT_EQ(1.23_c * (-1.89), -2.3247_c);
  EXPECT_EQ((-1.23_c) * (-1.89), 2.3247_c);

  EXPECT_EQ(2 * 1.8_c , 3.6_c);
  EXPECT_EQ(2 * (-1.8_c), -3.6_c);
  EXPECT_EQ((-2) * 1.8_c, -3.6_c);
  EXPECT_EQ((-2) * (-1.8_c), 3.6_c);
  EXPECT_EQ(10 * (-0.5_c), -5_c);

  EXPECT_EQ(0.1 * 0.1_c, 0.01_c);
  EXPECT_EQ(1.23 * 1.89_c, 2.3247_c);
  EXPECT_EQ(0.123456789 * 0.987654321_c, 0.121932631112635269_c);
  EXPECT_EQ((-1.23) * 1.89_c, -2.3247_c);
  EXPECT_EQ(1.23 * (-1.89_c), -2.3247_c);
  EXPECT_EQ((-1.23) * (-1.89_c), 2.3247_c);
}

TEST_F(AmountTest, AssignmentMultiply)
{
  {
    Amount a = 1.1_c;
    a *= 2;
    EXPECT_EQ(a, 2.2_c);
  }

  {
    Amount a = 0.123456789_c;
    a *= 0.987654321_c;
    EXPECT_EQ(a, 0.121932631112635269_c);
  }

  {
    Amount a = 0.123456789_c;
    a *= -0.987654321_c;
    EXPECT_EQ(a, -0.121932631112635269_c);
  }
}

TEST_F(AmountTest, Division)
{
  EXPECT_THROW(Amount(1) / 0, std::overflow_error);

  EXPECT_EQ(1.23_c / 1, 1.23_c);
  EXPECT_EQ(1.23_c / (-1), -1.23_c);
  EXPECT_EQ((-1.23_c) / (-1), 1.23_c);

  EXPECT_EQ(10_c / 2, 5_c);
  EXPECT_EQ(3.2_c / 2, 1.6_c);
  EXPECT_EQ(10_c / 3, 3.333333333333333333_c);
  EXPECT_EQ(12345.6789_c * 99 / 100, 12222.222111_c);

  {
    constexpr const Amount a{12345678.1234567891234_c};
    constexpr const Amount p1(a * 17 / 100);
    constexpr const Amount p2(a * 83 / 100);
    EXPECT_EQ(p1 + p2, a);
  }
}

TEST_F(AmountTest, AssignmentDivision)
{
  {
    Amount a = 1.1_c;
    EXPECT_THROW(a /= 0, std::overflow_error);
  }

  {
    Amount a = 1.1_c;
    a /= 1;
    EXPECT_EQ(a, 1.1_c);
  }

  {
    Amount a = 1.1_c;
    a /= 2;
    EXPECT_EQ(a, 0.55_c);
  }
}

TEST_F(AmountTest, ToString)
{
  EXPECT_EQ((0_c).to_string(), "0.00");
  EXPECT_EQ((0_c).to_string(0), "0");
  EXPECT_EQ((0_c).to_string(18), "0.000000000000000000");

  EXPECT_EQ((1_c).to_string(), "1.00");
  EXPECT_EQ((1_c).to_string(0), "1");
  EXPECT_EQ((1_c).to_string(18), "1.000000000000000000");
  EXPECT_EQ((1.1_c).to_string(), "1.10");
  EXPECT_EQ((1.01_c).to_string(), "1.01");
  EXPECT_EQ((1.001_c).to_string(), "1.001");
  EXPECT_EQ((1.0001_c).to_string(), "1.0001");
  EXPECT_EQ((1.00001_c).to_string(), "1.00001");

  EXPECT_EQ((-1_c).to_string(), "-1.00");
  EXPECT_EQ((-1_c).to_string(0), "-1");
  EXPECT_EQ((-1_c).to_string(18), "-1.000000000000000000");
  EXPECT_EQ((-1.1_c).to_string(), "-1.10");
  EXPECT_EQ((-1.01_c).to_string(), "-1.01");
  EXPECT_EQ((-1.001_c).to_string(), "-1.001");
  EXPECT_EQ((-1.0001_c).to_string(), "-1.0001");
  EXPECT_EQ((-1.00001_c).to_string(), "-1.00001");

  EXPECT_EQ((1234567891_c).to_string(), "1234567891.00");
  EXPECT_EQ((1234567891_c).to_string(0), "1234567891");
  EXPECT_EQ((-1234567891_c).to_string(), "-1234567891.00");
  EXPECT_EQ((-1234567891_c).to_string(0), "-1234567891");

  EXPECT_EQ((1234567891.12345678912345678_c).to_string(), "1234567891.12345678912345678");
  EXPECT_EQ((1234567891.12345678912345678_c).to_string(0), "1234567891.12345678912345678");
  EXPECT_EQ((-1234567891.12345678912345678_c).to_string(), "-1234567891.12345678912345678");
  EXPECT_EQ((-1234567891.12345678912345678_c).to_string(0), "-1234567891.12345678912345678");
}
```
# ..\node\csdb\unittests\csdb_unit_tests_binary_streams.cpp 
```cpp 
#include "binary_streams.h"
#include <limits>
#include <gtest/gtest.h>

using namespace ::csdb::priv;

class BinaryStreams : public ::testing::Test
{
protected:
  struct Test
  {
    int i;
    bool b;
    std::string s;
    inline void put(obstream& os) const
    {
      os.put(i);
      os.put(b);
      os.put(s);
    }

    inline bool get(ibstream& is)
    {
      return is.get(i)
          && is.get(b)
          && is.get(s);
    }

    bool operator ==(const Test& other) const
    {
      return (i == other.i)
          && (b == other.b)
          && (s == other.s);
    }
  };
};

inline ::csdb::internal::byte_array from_string(const std::string &src)
{
  return ::csdb::internal::byte_array(src.begin(), src.end());
}

#define string_literal(s) std::string(s, sizeof(s) - 1)
#define TEST_BS_INT(name, type, value, encoded) \
  TEST_F(BinaryStreams, name) \
  { \
    obstream o; \
    type v1 = value; \
    o.put(v1); \
    const ::csdb::internal::byte_array &s = o.buffer(); \
    EXPECT_EQ(s, from_string(string_literal(encoded))); \
    ibstream i(s); \
    type v2; \
    EXPECT_TRUE(i.get(v2)); \
    EXPECT_TRUE(i.empty()); \
    EXPECT_EQ(v1, v2); \
    ::csdb::internal::byte_array s1 = s; \
    EXPECT_FALSE(s1.empty()); \
    s1.resize(s1.size() - 1); \
    ibstream i1(s1); \
    type v3; \
    EXPECT_FALSE(i1.get(v3)); \
  }

TEST_BS_INT(BoolTrue, bool, true, "\x01")
TEST_BS_INT(BoolFalse, bool, false, "\x00")

// int8_t
TEST_BS_INT(int8_t_0, int8_t, 0, "\x00")
TEST_BS_INT(int8_t_1p, int8_t, 1, "\x02")
TEST_BS_INT(int8_t_1m, int8_t, -1, "\xFE")
TEST_BS_INT(int8_t_min, int8_t, std::numeric_limits<int8_t>::min(), "\x01\xFE")
TEST_BS_INT(int8_t_min_half, int8_t, std::numeric_limits<int8_t>::min() / 2, "\x80")
TEST_BS_INT(int8_t_max, int8_t, std::numeric_limits<int8_t>::max(), "\xFD\x01")

// uint8_t
TEST_BS_INT(uint8_t_0, uint8_t, 0, "\x00")
TEST_BS_INT(uint8_t_1p, uint8_t, 1, "\x02")
TEST_BS_INT(uint8_t_max, uint8_t, std::numeric_limits<uint8_t>::max(), "\xFD\x03")

// int16_t
TEST_BS_INT(int16_t_0, int16_t, 0, "\x00")
TEST_BS_INT(int16_t_1p, int16_t, 1, "\x02")
TEST_BS_INT(int16_t_1m, int16_t, -1, "\xFE")
TEST_BS_INT(int16_t_min, int16_t, std::numeric_limits<int16_t>::min(), "\x03\x00\xFC")
TEST_BS_INT(int16_t_min_d4, int16_t, std::numeric_limits<int16_t>::min() / 4, "\x01\x80")
TEST_BS_INT(int16_t_max, int16_t, std::numeric_limits<int16_t>::max(), "\xFB\xFF\x03")

// uint16_t
TEST_BS_INT(uint16_t_0, uint16_t, 0, "\x00")
TEST_BS_INT(uint16_t_1p, uint16_t, 1, "\x02")
TEST_BS_INT(uint16_t_max, uint16_t, std::numeric_limits<uint16_t>::max(), "\xFB\xFF\x07")

// int32_t
TEST_BS_INT(int32_t_0, int32_t, 0, "\x00")
TEST_BS_INT(int32_t_1p, int32_t, 1, "\x02")
TEST_BS_INT(int32_t_1m, int32_t, -1, "\xFE")
TEST_BS_INT(int32_t_min, int32_t, std::numeric_limits<int32_t>::min(), "\x0F\x00\x00\x00\xF0")
TEST_BS_INT(int32_t_min_d16, int32_t, std::numeric_limits<int32_t>::min() / 16, "\x07\x00\x00\x80")
TEST_BS_INT(int32_t_max, int32_t, std::numeric_limits<int32_t>::max(), "\xEF\xFF\xFF\xFF\x0F")

// uint32_t
TEST_BS_INT(uint32_t_0, uint32_t, 0, "\x00")
TEST_BS_INT(uint32_t_1p, uint32_t, 1, "\x02")
TEST_BS_INT(uint32_t_max, uint32_t, std::numeric_limits<uint32_t>::max(), "\xEF\xFF\xFF\xFF\x1F")

// int64_t
TEST_BS_INT(int64_t_0, int64_t, 0, "\x00")
TEST_BS_INT(int64_t_1p, int64_t, 1, "\x02")
TEST_BS_INT(int64_t_1m, int64_t, -1, "\xFE")
TEST_BS_INT(int64_t_min, int64_t, std::numeric_limits<int64_t>::min(), "\xFF\x00\x00\x00\x00\x00\x00\x00\x80")
TEST_BS_INT(int64_t_min_d128, int64_t, std::numeric_limits<int64_t>::min() / 128, "\xFF\x00\x00\x00\x00\x00\x00\x00\xFF")
TEST_BS_INT(int64_t_min_d256, int64_t, std::numeric_limits<int64_t>::min() / 256, "\x7F\x00\x00\x00\x00\x00\x00\x80")
TEST_BS_INT(int64_t_max, int64_t, std::numeric_limits<int64_t>::max(), "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F")

// uint64_t
TEST_BS_INT(uint64_t_0, uint64_t, 0, "\x00")
TEST_BS_INT(uint64_t_1p, uint64_t, 1, "\x02")
// std::numeric_limits<uint64_t>::max() то же самое, что (-1), так добавим дополнительный тест
TEST_BS_INT(uint64_t_max, uint64_t, std::numeric_limits<uint64_t>::max(), "\xFE")
TEST_BS_INT(uint64_t_max_1m, uint64_t, std::numeric_limits<uint64_t>::max() >> 2, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x3F")

#define TEST_BS_STRING(name, value, encoded) \
  TEST_F(BinaryStreams, String##name) \
  { \
    obstream o; \
    std::string v1 = value; \
    o.put(v1); \
    const ::csdb::internal::byte_array &s = o.buffer(); \
    EXPECT_EQ(s, from_string(string_literal(encoded))); \
    ibstream i(s); \
    std::string v2; \
    EXPECT_TRUE(i.get(v2)); \
    EXPECT_EQ(v1, v2); \
  }

TEST_BS_STRING(Empty, std::string(), "\x00")
TEST_BS_STRING(Simple, string_literal("Test string"), "\x16Test string")
TEST_BS_STRING(WithZero, string_literal("Test\0string"), "\x16Test\0string")

TEST_F(BinaryStreams, ManyValues)
{
  bool b1 = true;
  long l1 = 1000;
  std::string s1("Test string");
  int i1 = 20;

  obstream o;
  o.put(b1);
  o.put(l1);
  o.put(s1);
  o.put(i1);

  const ::csdb::internal::byte_array &s = o.buffer();
  EXPECT_EQ(s, from_string(string_literal("\x01\xA1\x0F\x16Test string\x28")));

  bool b2;
  long l2;
  std::string s2;
  int i2;

  ibstream i(s);
  EXPECT_TRUE(i.get(b2));
  EXPECT_TRUE(i.get(l2));
  EXPECT_TRUE(i.get(s2));
  EXPECT_TRUE(i.get(i2));

  EXPECT_EQ(b1, b2);
  EXPECT_EQ(l1, l2);
  EXPECT_EQ(s1, s2);
  EXPECT_EQ(i1, i2);
}

TEST_F(BinaryStreams, Enum)
{
  enum Enum {One, Two, Three};
  Enum v1 = Two;

  obstream o;
  o.put(v1);

  Enum v2 = One;
  ibstream i(o.buffer());
  EXPECT_TRUE(i.get(v2));
  EXPECT_TRUE(i.empty());
  EXPECT_EQ(v1, v2);
}

TEST_F(BinaryStreams, Struct1)
{
  Test v1{2, true, "Test string"};
  obstream o;
  o.put(v1);

  const ::csdb::internal::byte_array &s = o.buffer();
  EXPECT_EQ(s, from_string(string_literal("\x04\x01\x16Test string")));

  Test v2;
  ibstream i(s);
  EXPECT_TRUE(i.get(v2));
  EXPECT_TRUE(i.empty());
  EXPECT_EQ(v1, v2);
}

TEST_F(BinaryStreams, Struct2)
{
  Test v1{100, false, string_literal("Test\0string")};
  obstream o;
  o.put(v1);

  const ::csdb::internal::byte_array &s = o.buffer();
  EXPECT_EQ(s, from_string(string_literal("\x91\x01\x00\x16Test\x00string")));

  Test v2;
  ibstream i(s);
  EXPECT_TRUE(i.get(v2));
  EXPECT_TRUE(i.empty());
  EXPECT_EQ(v1, v2);
}

TEST_F(BinaryStreams, MapEmpty)
{
  ::std::map<int, ::std::string> v1;
  obstream o;
  o.put(v1);

  const ::csdb::internal::byte_array &s = o.buffer();
  EXPECT_EQ(s, from_string(string_literal("\0")));

  ::std::map<int, ::std::string> v2;
  ibstream i(s);
  EXPECT_TRUE(i.get(v2));
  EXPECT_TRUE(i.empty());
  EXPECT_EQ(v1, v2);
}

TEST_F(BinaryStreams, MapFilled)
{
  ::std::map<int, ::std::string> v1;
  v1.emplace(1, "Key1");
  v1.emplace(2, "Key2");
  v1.emplace(3, "Key3");
  obstream o;
  o.put(v1);

  const ::csdb::internal::byte_array &s = o.buffer();
  EXPECT_EQ(s, from_string(string_literal("\x06\x02\x08Key1\x04\x08Key2\x06\x08Key3")));

  ::std::map<int, ::std::string> v2;
  ibstream i(s);
  EXPECT_TRUE(i.get(v2));
  EXPECT_TRUE(i.empty());
  EXPECT_EQ(v1, v2);
}
```
# ..\node\csdb\unittests\csdb_unit_tests_database.cpp 
```cpp 
#include "csdb/database.h"

#include <gtest/gtest.h>

#include "csdb/internal/utils.h"

class DatabaseTest : public ::testing::Test
{
protected:
  class DatabaseImpl : public ::csdb::Database
  {
  private:
    bool is_open() const override final {return false;}
    bool put(const byte_array&, const byte_array&) override final {return false;}
    bool get(const byte_array&, byte_array*) override final {return false;}
    bool remove(const byte_array&) override final {return false;}
    bool write_batch(const ItemList&) override final {return false;}
    IteratorPtr new_iterator() override final {return IteratorPtr{nullptr};}

  public:
    using ::csdb::Database::set_last_error;
  };
};

TEST_F(DatabaseTest, LastError)
{
  DatabaseImpl db;
  EXPECT_EQ(db.last_error(), ::csdb::Database::NoError);
  EXPECT_FALSE(db.last_error_message().empty());

  db.set_last_error(::csdb::Database::NotFound);
  EXPECT_EQ(db.last_error(), ::csdb::Database::NotFound);
  EXPECT_FALSE(db.last_error_message().empty());

  db.set_last_error(::csdb::Database::Corruption, nullptr);
  EXPECT_EQ(db.last_error(), ::csdb::Database::Corruption);
  EXPECT_FALSE(db.last_error_message().empty());

  db.set_last_error(::csdb::Database::NotSupported, std::string("Test"));
  EXPECT_EQ(db.last_error(), ::csdb::Database::NotSupported);
  EXPECT_EQ(db.last_error_message(), "Test");

  db.set_last_error(::csdb::Database::InvalidArgument, "Test");
  EXPECT_EQ(db.last_error(), ::csdb::Database::InvalidArgument);
  EXPECT_EQ(db.last_error_message(), "Test");

  db.set_last_error(::csdb::Database::IOError, "%s%04u", "Test", 100);
  EXPECT_EQ(db.last_error(), ::csdb::Database::IOError);
  EXPECT_EQ(db.last_error_message(), "Test0100");

  db.set_last_error();
  EXPECT_EQ(db.last_error(), ::csdb::Database::NoError);
  EXPECT_FALSE(db.last_error_message().empty());
}
```
# ..\node\csdb\unittests\csdb_unit_tests_database_leveldb.cpp 
```cpp 
#include "csdb/database_leveldb.h"

#include <memory>
#include <algorithm>

#include <gtest/gtest.h>

#include "leveldb/db.h"
#include "leveldb/env.h"
#include "csdb/internal/utils.h"

class DatabaseLeveDBTest : public ::testing::Test
{
protected:
  void SetUp() override final
  {
    leveldb::Env *env = leveldb::Env::Default();
    EXPECT_TRUE(env->GetTestDirectory(&path_to_db_).ok());
    path_to_db_ += database_name_;

    if(env->FileExists(path_to_db_)) {
      EXPECT_TRUE(leveldb::DestroyDB(path_to_db_, leveldb::Options()).ok());
    }

    ::csdb::DatabaseLevelDB* db{new ::csdb::DatabaseLevelDB};
    ASSERT_TRUE(db->open(path_to_db_));
    db_.reset(db);
  }

  void TearDown() override final
  {
    db_.reset(nullptr);
    EXPECT_TRUE(leveldb::Env::Default()->FileExists(path_to_db_));
    EXPECT_TRUE(leveldb::DestroyDB(path_to_db_, leveldb::Options()).ok());
  }

protected:
  std::unique_ptr<::csdb::Database> db_;
  std::string path_to_db_;
  static constexpr const char* database_name_ = "/csdb_leveldb_unittests";
};

class DatabaseLeveDBTestNotOpen : public ::testing::Test
{
};

TEST_F(DatabaseLeveDBTestNotOpen, FailedCreation)
{
  std::unique_ptr<::csdb::DatabaseLevelDB> db{new ::csdb::DatabaseLevelDB};
  EXPECT_FALSE(db->open("/dev/null"));
  EXPECT_EQ(db->last_error(), ::csdb::Database::IOError);
}

TEST_F(DatabaseLeveDBTest, Create)
{
  EXPECT_TRUE(db_->is_open());
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
}

TEST_F(DatabaseLeveDBTestNotOpen, FailedGetPut)
{
  std::unique_ptr<::csdb::Database> db{new ::csdb::DatabaseLevelDB};
  EXPECT_FALSE(db->put({1,1,1}, {2,2,2}));
  EXPECT_EQ(db->last_error(), ::csdb::Database::NotOpen);

  EXPECT_FALSE(db->get({1,1,1}));
  EXPECT_EQ(db->last_error(), ::csdb::Database::NotOpen);

  ::csdb::internal::byte_array result;
  EXPECT_FALSE(db->get({1,1,1}, &result));
  EXPECT_EQ(db->last_error(), ::csdb::Database::NotOpen);
}

TEST_F(DatabaseLeveDBTest, GetPut)
{
  EXPECT_TRUE(db_->is_open());
  EXPECT_TRUE(db_->put({1,1,1}, {2,2,2}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->put({2,2,2}, {3,3,3}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->put({4,4,4}, {5,5,5}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->put({0,0,0}, {0xFF,0xFF,0xFF}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);

  EXPECT_TRUE(db_->get({0,0,0}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->get({1,1,1}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->get({2,2,2}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->get({4,4,4}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);

  EXPECT_FALSE(db_->get({3,3,3}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NotFound);

  ::csdb::internal::byte_array result;
  EXPECT_TRUE(db_->get({0,0,0}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({0xFF,0xFF,0xFF}));
  EXPECT_TRUE(db_->get({1,1,1}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({2,2,2}));
  EXPECT_TRUE(db_->get({2,2,2}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({3,3,3}));
  EXPECT_TRUE(db_->get({4,4,4}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({5,5,5}));

  EXPECT_FALSE(db_->get({3,3,3}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NotFound);
}

TEST_F(DatabaseLeveDBTestNotOpen, FailedRemove)
{
  std::unique_ptr<::csdb::Database> db{new ::csdb::DatabaseLevelDB};
  EXPECT_FALSE(db->remove({1,1,1}));
  EXPECT_EQ(db->last_error(), ::csdb::Database::NotOpen);
}

TEST_F(DatabaseLeveDBTest, Remove)
{
  EXPECT_TRUE(db_->is_open());
  EXPECT_TRUE(db_->put({1,1,1}, {2,2,2}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->put({2,2,2}, {3,3,3}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->put({4,4,4}, {5,5,5}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->put({0,0,0}, {0xFF,0xFF,0xFF}));

  EXPECT_TRUE(db_->remove({2,2,2}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->remove({3,3,3}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->remove({4,4,4}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);

  ::csdb::internal::byte_array result;
  EXPECT_TRUE(db_->get({0,0,0}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({0xFF,0xFF,0xFF}));
  EXPECT_TRUE(db_->get({1,1,1}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({2,2,2}));

  EXPECT_FALSE(db_->get({2,2,2}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NotFound);
  EXPECT_FALSE(db_->get({3,3,3}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NotFound);
  EXPECT_FALSE(db_->get({3,3,3}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NotFound);
}

TEST_F(DatabaseLeveDBTest, WriteBatch)
{
  EXPECT_TRUE(db_->is_open());
  EXPECT_TRUE(db_->write_batch({}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->write_batch({{{0,0,0}, {0xFF,0xFF,0xFF}}}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_TRUE(db_->write_batch({{{1,1,1}, {2,2,2}}, {{2,2,2}, {3,3,3}}, {{4,4,4}, {5,5,5}}}));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);

  ::csdb::internal::byte_array result;
  EXPECT_TRUE(db_->get({0,0,0}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({0xFF,0xFF,0xFF}));
  EXPECT_TRUE(db_->get({1,1,1}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({2,2,2}));
  EXPECT_TRUE(db_->get({2,2,2}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({3,3,3}));
  EXPECT_TRUE(db_->get({4,4,4}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);
  EXPECT_EQ(result, ::csdb::internal::byte_array({5,5,5}));

  EXPECT_FALSE(db_->get({3,3,3}, &result));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NotFound);
}

TEST_F(DatabaseLeveDBTestNotOpen, FailedWriteBatch)
{
  std::unique_ptr<::csdb::Database> db{new ::csdb::DatabaseLevelDB};
  EXPECT_FALSE(db->write_batch({{{0,0,0}, {0xFF,0xFF,0xFF}}}));
  EXPECT_EQ(db->last_error(), ::csdb::Database::NotOpen);
}

TEST_F(DatabaseLeveDBTest, Iterator)
{
  EXPECT_TRUE(db_->is_open());
  ::csdb::Database::ItemList list{{{3,3,3}, {4,4,4}}, {{4,4,4}, {5,5,5}}, {{2,2,2}, {3,3,3}},
                                  {{0,0,0}, {1,1,1}}, {{1,1,1}, {2,2,2}}};
  EXPECT_TRUE(db_->write_batch(list));
  EXPECT_EQ(db_->last_error(), ::csdb::Database::NoError);

  auto db_it = db_->new_iterator();
  EXPECT_TRUE(db_it);
  EXPECT_FALSE(db_it->is_valid());

  std::sort(list.begin(), list.end());

  // Forward
  auto it = list.begin();
  db_it->seek_to_first();
  for (; it != list.end(); ++it, db_it->next()) {
    EXPECT_TRUE(db_it->is_valid());
    EXPECT_EQ(it->first, db_it->key());
    EXPECT_EQ(it->second, db_it->value());
  }

  // Reverse
  it = list.end() - 1;
  db_it->seek_to_last();
  while(true) {
    EXPECT_TRUE(db_it->is_valid());
    EXPECT_EQ(it->first, db_it->key());
    EXPECT_EQ(it->second, db_it->value());
    if (list.begin() == it) {
      break;
    }
    --it;
    db_it->prev();
  };

  // Forward from center
  it = list.begin() + (list.size() / 2);
  db_it->seek(it->first);
  for (; it != list.end(); ++it, db_it->next()) {
    EXPECT_TRUE(db_it->is_valid());
    EXPECT_EQ(it->first, db_it->key());
    EXPECT_EQ(it->second, db_it->value());
  }

  // Reverse from center
  it = list.begin() + (list.size() / 2);
  db_it->seek(it->first);
  while(true) {
    EXPECT_TRUE(db_it->is_valid());
    EXPECT_EQ(it->first, db_it->key());
    EXPECT_EQ(it->second, db_it->value());
    if (list.begin() == it) {
      break;
    }
    --it;
    db_it->prev();
  };
}

TEST_F(DatabaseLeveDBTestNotOpen, FailedIterator)
{
  std::unique_ptr<::csdb::Database> db{new ::csdb::DatabaseLevelDB};
  EXPECT_FALSE(db->new_iterator());
  EXPECT_EQ(db->last_error(), ::csdb::Database::NotOpen);
}
```
# ..\node\csdb\unittests\csdb_unit_tests_endian.cpp 
```cpp 
#include "csdb/internal/endian.h"

#include <cstring>

#include <gtest/gtest.h>

namespace {
  typedef ::testing::Types<
    int8_t, uint8_t,
    int16_t, uint16_t,
    int32_t, uint32_t,
    int64_t, uint64_t,
    intmax_t, uintmax_t
  > TypesForTest;
}

template <typename T>
class EndianTest : public ::testing::Test
{
protected:
  void SetUp() override
  {
    uint8_t buf_l[sizeof(Type)];
    uint8_t buf_b[sizeof(Type)];
    platform_endian_ = 0;
    for (uint8_t i = 0; i < sizeof(Type); ++i) {
      buf_l[sizeof(Type) - i - 1] = buf_b[i] = (i + 1);
      platform_endian_ = static_cast<Type>((platform_endian_ * 256) + (i + 1));
    }
    memcpy(&little_endian_, buf_l, sizeof(Type));
    memcpy(&big_endian_, buf_b, sizeof(Type));
  }

  typedef T Type;
  Type little_endian_;
  Type big_endian_;
  Type platform_endian_;
};

TYPED_TEST_CASE(EndianTest, TypesForTest);

TYPED_TEST(EndianTest, ReverseByteOrder)
{
  EXPECT_EQ(this->little_endian_, ::csdb::internal::reverse_byte_order(this->big_endian_));
  EXPECT_EQ(this->big_endian_, ::csdb::internal::reverse_byte_order(this->little_endian_));
}

TYPED_TEST(EndianTest, EndianConvertes)
{
  EXPECT_EQ(this->little_endian_, ::csdb::internal::to_little_endian(this->platform_endian_));
  EXPECT_EQ(this->platform_endian_, ::csdb::internal::from_little_endian(this->little_endian_));

  EXPECT_EQ(this->big_endian_, ::csdb::internal::to_big_endian(this->platform_endian_));
  EXPECT_EQ(this->platform_endian_, ::csdb::internal::from_big_endian(this->big_endian_));
}
```
# ..\node\csdb\unittests\csdb_unit_tests_environment.cpp 
```cpp 
#include "csdb_unit_tests_environment.h"

namespace csdb {

bool operator ==(const Transaction& a, const Transaction& b)
{
  if (!((a.source() == b.source())
        && (a.target() == b.target())
        && (a.currency() == b.currency())
        && (a.amount() == b.amount())
        && (a.balance() == b.balance()))) {
    return false;
  }

  auto ids = a.user_field_ids();
  if (ids != b.user_field_ids()) {
    return false;
  }

  for (auto id : ids) {
    if (a.user_field(id) != b.user_field(id)) {
      return false;
    }
  }

  return true;
}

bool operator ==(const Pool& a, const Pool& b)
{
  if (a.is_valid() != b.is_valid()) {
    return false;
  }

  if (!a.is_valid()) {
    return true;
  }

  if ((a.is_read_only() != b.is_read_only())
      || (a.sequence() != b.sequence())
      || (a.previous_hash() != b.previous_hash())
      || (a.transactions_count() != b.transactions_count())
      ) {
    return false;
  }

  if (a.is_read_only()) {
    if (a.hash() != b.hash()) {
      return false;
    }
  }

  for (size_t i = 0; i < a.transactions_count(); ++i) {
    if (a.transaction(i) != b.transaction(i)) {
      return false;
    }
  }

  auto ids = a.user_field_ids();
  if (ids != b.user_field_ids()) {
    return false;
  }

  for (auto id : ids) {
    if (a.user_field(id) != b.user_field(id)) {
      return false;
    }
  }

  return true;
}

} // namespace csdb

::std::ostream& operator <<(::std::ostream& os, const ::csdb::UserField& value)
{
  os << "{";
  switch (value.type()) {
  case ::csdb::UserField::Integer:
    os << "Integer: " << value.value<int>();
    break;

  case ::csdb::UserField::String:
    os << "String: \"" << value.value<::std::string>() << "\"";
    break;

  case ::csdb::UserField::Amount:
    os << "Amount: " << value.value<::csdb::Amount>();
    break;

  default:
    os << "<invalid>";
    break;
  }
  os << "}";
  return os;
}
```
# ..\node\csdb\unittests\csdb_unit_tests_environment.h 
```cpp 
/**
  * @file csdb_unit_tests_environment.h
  * @author Evgeny V. Zalivochkin
  */

#pragma once
#ifndef _CREDITS_CSDB_UNIT_TESTS_ENVIRONMENT_H_INCLUDED_
#define _CREDITS_CSDB_UNIT_TESTS_ENVIRONMENT_H_INCLUDED_

#include <iostream>

#include "csdb/address.h"
#include "csdb/amount.h"
#include "csdb/currency.h"
#include "csdb/transaction.h"
#include "csdb/pool.h"
#include "csdb/user_field.h"

#include <gtest/gtest.h>

namespace csdb {

bool operator ==(const Transaction& a, const Transaction& b);

inline bool operator !=(const Transaction& a, const Transaction& b)
{
  return !(a == b);
}

bool operator ==(const Pool& a, const Pool& b);

inline bool operator !=(const Pool& a, const Pool& b)
{
  return !(a == b);
}

} // namespace csdb

::std::ostream& operator <<(::std::ostream& os, const ::csdb::UserField& value);

#endif // _CREDITS_CSDB_UNIT_TESTS_ENVIRONMENT_H_INCLUDED_
```
# ..\node\csdb\unittests\csdb_unit_tests_integral_encdec.cpp 
```cpp 
#include "integral_encdec.h"

#include <limits>

#include <gtest/gtest.h>

class IntegralEncDec : public ::testing::Test
{
};

#define string_literal(s) std::string(s, sizeof(s) - 1)
#define TEST_ENCDEC(name, type, value, encoded) \
  TEST_F(IntegralEncDec, name) \
  { \
    char buf[::csdb::priv::MAX_INTEGRAL_ENCODED_SIZE];\
    type v1 = value, v2; \
    std::size_t size = ::csdb::priv::encode(buf, v1); \
    EXPECT_EQ(std::string(buf, size), string_literal(encoded)); \
    EXPECT_EQ(::csdb::priv::decode(buf, size, v2), size); \
    EXPECT_EQ(v1, v2); \
    EXPECT_EQ(::csdb::priv::decode(buf, size - 1, v2), 0); \
  }

TEST_ENCDEC(BoolTrue, bool, true, "\x01")
TEST_ENCDEC(BoolFalse, bool, false, "\x00")

// int8_t
TEST_ENCDEC(int8_t_0, int8_t, 0, "\x00")
TEST_ENCDEC(int8_t_1p, int8_t, 1, "\x02")
TEST_ENCDEC(int8_t_1m, int8_t, -1, "\xFE")
TEST_ENCDEC(int8_t_min, int8_t, std::numeric_limits<int8_t>::min(), "\x01\xFE")
TEST_ENCDEC(int8_t_min_half, int8_t, std::numeric_limits<int8_t>::min() / 2, "\x80")
TEST_ENCDEC(int8_t_max, int8_t, std::numeric_limits<int8_t>::max(), "\xFD\x01")

// uint8_t
TEST_ENCDEC(uint8_t_0, uint8_t, 0, "\x00")
TEST_ENCDEC(uint8_t_1p, uint8_t, 1, "\x02")
TEST_ENCDEC(uint8_t_max, uint8_t, std::numeric_limits<uint8_t>::max(), "\xFD\x03")

// int16_t
TEST_ENCDEC(int16_t_0, int16_t, 0, "\x00")
TEST_ENCDEC(int16_t_1p, int16_t, 1, "\x02")
TEST_ENCDEC(int16_t_1m, int16_t, -1, "\xFE")
TEST_ENCDEC(int16_t_min, int16_t, std::numeric_limits<int16_t>::min(), "\x03\x00\xFC")
TEST_ENCDEC(int16_t_min_d4, int16_t, std::numeric_limits<int16_t>::min() / 4, "\x01\x80")
TEST_ENCDEC(int16_t_max, int16_t, std::numeric_limits<int16_t>::max(), "\xFB\xFF\x03")

// uint16_t
TEST_ENCDEC(uint16_t_0, uint16_t, 0, "\x00")
TEST_ENCDEC(uint16_t_1p, uint16_t, 1, "\x02")
TEST_ENCDEC(uint16_t_max, uint16_t, std::numeric_limits<uint16_t>::max(), "\xFB\xFF\x07")

// int32_t
TEST_ENCDEC(int32_t_0, int32_t, 0, "\x00")
TEST_ENCDEC(int32_t_1p, int32_t, 1, "\x02")
TEST_ENCDEC(int32_t_1m, int32_t, -1, "\xFE")
TEST_ENCDEC(int32_t_min, int32_t, std::numeric_limits<int32_t>::min(), "\x0F\x00\x00\x00\xF0")
TEST_ENCDEC(int32_t_min_d16, int32_t, std::numeric_limits<int32_t>::min() / 16, "\x07\x00\x00\x80")
TEST_ENCDEC(int32_t_max, int32_t, std::numeric_limits<int32_t>::max(), "\xEF\xFF\xFF\xFF\x0F")

// uint32_t
TEST_ENCDEC(uint32_t_0, uint32_t, 0, "\x00")
TEST_ENCDEC(uint32_t_1p, uint32_t, 1, "\x02")
TEST_ENCDEC(uint32_t_max, uint32_t, std::numeric_limits<uint32_t>::max(), "\xEF\xFF\xFF\xFF\x1F")

// int64_t
TEST_ENCDEC(int64_t_0, int64_t, 0, "\x00")
TEST_ENCDEC(int64_t_1p, int64_t, 1, "\x02")
TEST_ENCDEC(int64_t_1m, int64_t, -1, "\xFE")
TEST_ENCDEC(int64_t_min, int64_t, std::numeric_limits<int64_t>::min(), "\xFF\x00\x00\x00\x00\x00\x00\x00\x80")
TEST_ENCDEC(int64_t_min_d128, int64_t, std::numeric_limits<int64_t>::min() / 128, "\xFF\x00\x00\x00\x00\x00\x00\x00\xFF")
TEST_ENCDEC(int64_t_min_d256, int64_t, std::numeric_limits<int64_t>::min() / 256, "\x7F\x00\x00\x00\x00\x00\x00\x80")
TEST_ENCDEC(int64_t_max, int64_t, std::numeric_limits<int64_t>::max(), "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F")

// uint64_t
TEST_ENCDEC(uint64_t_0, uint64_t, 0, "\x00")
TEST_ENCDEC(uint64_t_1p, uint64_t, 1, "\x02")
// std::numeric_limits<uint64_t>::max() то же самое, что (-1), так добавим дополнительный тест
TEST_ENCDEC(uint64_t_max, uint64_t, std::numeric_limits<uint64_t>::max(), "\xFE")
TEST_ENCDEC(uint64_t_max_1m, uint64_t, std::numeric_limits<uint64_t>::max() >> 2, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x3F")

// enum
TEST_F(IntegralEncDec, Enum)
{
  char buf[::csdb::priv::MAX_INTEGRAL_ENCODED_SIZE];
  enum Enum {One, Two, Three};
  Enum v1 = Two, v2;
  std::size_t size = ::csdb::priv::encode(buf, v1);
  EXPECT_EQ(::csdb::priv::decode(buf, size, v2), size);
  EXPECT_EQ(v1, v2);
  EXPECT_EQ(::csdb::priv::decode(buf, size - 1, v2), 0);
}
```
# ..\node\csdb\unittests\csdb_unit_tests_main.cpp 
```cpp 
#include "csdb/csdb.h"

#include <clocale>

#include "leveldb/env.h"

#include <gtest/gtest.h>

int main(int argc, char** argv)
{
#if defined(__MINGW32__)
    std::setlocale(LC_ALL, "Russian");
#elif defined(_WIN32)
    std::setlocale(LC_ALL, "ru-RU");
#else
    std::setlocale(LC_ALL, "ru_RU.UTF-8");
#endif

    ::testing::InitGoogleTest(&argc, argv);

    return RUN_ALL_TESTS();
}

TEST(Init, Done)
{
  std::string path_to_tests;
  leveldb::Env *env = leveldb::Env::Default();
  EXPECT_TRUE(env->GetTestDirectory(&path_to_tests).ok());
  path_to_tests += "/csdb_unittests";
  if (!env->FileExists(path_to_tests)) {
    EXPECT_TRUE(env->CreateDir(path_to_tests).ok());
  }

  EXPECT_FALSE(::csdb::isInitialized());
  EXPECT_EQ(::csdb::lastError(), ::csdb::Storage::NoError);
  EXPECT_EQ(::csdb::dbLastError(), ::csdb::Database::NotOpen);
  EXPECT_FALSE(::csdb::lastErrorMessage().empty());
  EXPECT_FALSE(::csdb::dbLastErrorMessage().empty());

  EXPECT_FALSE(::csdb::init("/dev/null"));
  EXPECT_FALSE(::csdb::isInitialized());
  EXPECT_EQ(::csdb::lastError(), ::csdb::Storage::DatabaseError);
  EXPECT_EQ(::csdb::dbLastError(), ::csdb::Database::IOError);

  EXPECT_TRUE(::csdb::init(path_to_tests.c_str()));
  EXPECT_TRUE(::csdb::isInitialized());
  EXPECT_EQ(::csdb::lastError(), ::csdb::Storage::NoError);
  EXPECT_EQ(::csdb::dbLastError(), ::csdb::Database::NoError);

  EXPECT_FALSE(::csdb::init(path_to_tests.c_str()));
  EXPECT_TRUE(::csdb::isInitialized());
  EXPECT_EQ(::csdb::lastError(), ::csdb::Storage::NoError);
  EXPECT_EQ(::csdb::dbLastError(), ::csdb::Database::NoError);

  csdb::done();
  EXPECT_FALSE(::csdb::isInitialized());
  EXPECT_EQ(::csdb::lastError(), ::csdb::Storage::NoError);
  EXPECT_EQ(::csdb::dbLastError(), ::csdb::Database::NotOpen);
}

```
# ..\node\csdb\unittests\csdb_unit_tests_math128ce.cpp 
```cpp 
#include "csdb/internal/math128ce.h"

#include <gtest/gtest.h>

using namespace csdb::internal;

class Math128CETest : public ::testing::Test
{
};

TEST_F(Math128CETest, uint128_t_constructors)
{
  constexpr uint128_t n1;
  EXPECT_EQ(n1.lo_, 0ULL);
  EXPECT_EQ(n1.hi_, 0ULL);

  constexpr uint128_t n2(1);
  EXPECT_EQ(n2.lo_, 1ULL);
  EXPECT_EQ(n2.hi_, 0ULL);

  constexpr uint128_t n3(1,1);
  EXPECT_EQ(n3.lo_, 1ULL);
  EXPECT_EQ(n3.hi_, 1ULL);
}

TEST_F(Math128CETest, uint128_t_addition64)
{
  constexpr uint128_t n1 = uint128_t() + 1;
  EXPECT_EQ(n1.lo_, 1ULL);
  EXPECT_EQ(n1.hi_, 0ULL);

  constexpr uint128_t n2 = uint128_t(1) + 1;
  EXPECT_EQ(n2.lo_, 2ULL);
  EXPECT_EQ(n2.hi_, 0ULL);

  constexpr uint128_t n3 = uint128_t(1,10) + 10;
  EXPECT_EQ(n3.lo_, 11ULL);
  EXPECT_EQ(n3.hi_, 10ULL);

  constexpr uint128_t n4 = uint128_t(0xFFFFFFFFFFFFFFFFULL, 2) + 1;
  EXPECT_EQ(n4.lo_, 0ULL);
  EXPECT_EQ(n4.hi_, 3ULL);

  constexpr uint128_t n5 = uint128_t(10, 5) + 0xFFFFFFFFFFFFFFFFULL;
  EXPECT_EQ(n5.lo_, 9ULL);
  EXPECT_EQ(n5.hi_, 6ULL);

  constexpr uint128_t n6 = uint128_t(0xF, 5) + 0xFFFFFFFFFFFFFFF0ULL;
  EXPECT_EQ(n6.lo_, 0xFFFFFFFFFFFFFFFFULL);
  EXPECT_EQ(n6.hi_, 5ULL);

  constexpr uint128_t n7 = uint128_t(0x11, 5) + 0xFFFFFFFFFFFFFFF0ULL;
  EXPECT_EQ(n7.lo_, 1ULL);
  EXPECT_EQ(n7.hi_, 6ULL);
}

TEST_F(Math128CETest, uint128_t_addition128)
{
  constexpr uint128_t n1 = uint128_t() + uint128_t(1,1);
  EXPECT_EQ(n1.lo_, 1ULL);
  EXPECT_EQ(n1.hi_, 1ULL);

  constexpr uint128_t n2 = uint128_t(1) + uint128_t(1,2);
  EXPECT_EQ(n2.lo_, 2ULL);
  EXPECT_EQ(n2.hi_, 2ULL);

  constexpr uint128_t n3 = uint128_t(1,10) + uint128_t(10,3);
  EXPECT_EQ(n3.lo_, 11ULL);
  EXPECT_EQ(n3.hi_, 13ULL);

  constexpr uint128_t n4 = uint128_t(0xFFFFFFFFFFFFFFFFULL, 2) + uint128_t(1, 4);
  EXPECT_EQ(n4.lo_, 0ULL);
  EXPECT_EQ(n4.hi_, 7ULL);

  constexpr uint128_t n5 = uint128_t(10, 5) + uint128_t(0xFFFFFFFFFFFFFFFFULL, 5);
  EXPECT_EQ(n5.lo_, 9ULL);
  EXPECT_EQ(n5.hi_, 11ULL);

  constexpr uint128_t n6 = uint128_t(0xF, 5) + uint128_t(0xFFFFFFFFFFFFFFF0ULL, 6);
  EXPECT_EQ(n6.lo_, 0xFFFFFFFFFFFFFFFFULL);
  EXPECT_EQ(n6.hi_, 11ULL);

  constexpr uint128_t n7 = uint128_t(0x11, 5) + uint128_t(0xFFFFFFFFFFFFFFF0ULL, 7);
  EXPECT_EQ(n7.lo_, 1ULL);
  EXPECT_EQ(n7.hi_, 13ULL);
}

TEST_F(Math128CETest, uint128_t_multiplication)
{
  constexpr uint128_t n1 = uint128_t::mul(1, 1);
  EXPECT_EQ(n1.lo_, 1ULL);
  EXPECT_EQ(n1.hi_, 0ULL);

  constexpr uint128_t n2 = uint128_t::mul(0x100000000ULL, 0x100000000ULL);
  EXPECT_EQ(n2.lo_, 0ULL);
  EXPECT_EQ(n2.hi_, 1ULL);

  constexpr uint128_t n3 = uint128_t::mul(0x1000000000ULL, 0x1000000000ULL);
  EXPECT_EQ(n3.lo_, 0ULL);
  EXPECT_EQ(n3.hi_, 0x100ULL);

  constexpr uint128_t n4 = uint128_t::mul(0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL);
  EXPECT_EQ(n4.lo_, 1ULL);
  EXPECT_EQ(n4.hi_, 0xFFFFFFFFFFFFFFFEULL);

  constexpr uint128_t n5 = uint128_t::mul(17446744073709551615ULL, 7446744073709551615ULL);
  EXPECT_EQ(n5.lo_, 6541590728541208577ULL);
  EXPECT_EQ(n5.hi_, 7043055268576579053ULL);

  constexpr uint128_t n6 = uint128_t::mul(12446744073709551615ULL, 10438186666892946874ULL);
  EXPECT_EQ(9852383995793206715ULL - (0xFFFFFFFFFFFFFFFF - n6.lo_ + 1), 6541590728541208577ULL );
  EXPECT_EQ(n6.hi_ + 1, 7043055268576579053ULL);
}

TEST_F(Math128CETest, uint128_t_division64)
{
  constexpr auto n1 = uint128_t(1, 1).div(1);
  EXPECT_EQ(n1.quotient_.lo_, 1ULL);
  EXPECT_EQ(n1.quotient_.hi_, 1ULL);
  EXPECT_EQ(n1.remainder_, 0ULL);

  constexpr auto n2 = uint128_t(3, 0).div(2);
  EXPECT_EQ(n2.quotient_.lo_, 1ULL);
  EXPECT_EQ(n2.quotient_.hi_, 0ULL);
  EXPECT_EQ(n2.remainder_, 1ULL);

  constexpr auto n3 = uint128_t(4, 0).div(2);
  EXPECT_EQ(n3.quotient_.lo_, 2ULL);
  EXPECT_EQ(n3.quotient_.hi_, 0ULL);
  EXPECT_EQ(n3.remainder_, 0ULL);

  constexpr auto n4 = uint128_t(1, 1).div(2);
  EXPECT_EQ(n4.quotient_.lo_, 0x8000000000000000ULL);
  EXPECT_EQ(n4.quotient_.hi_, 0ULL);
  EXPECT_EQ(n4.remainder_, 1ULL);

  constexpr auto n5 = uint128_t(8, 0).div(7);
  EXPECT_EQ(n5.quotient_.lo_, 1);
  EXPECT_EQ(n5.quotient_.hi_, 0ULL);
  EXPECT_EQ(n5.remainder_, 1);

  constexpr auto n6 = uint128_t((123456789ULL * 987654321ULL) + 10ULL, 0).div(123456789);
  EXPECT_EQ(n6.quotient_.lo_, 987654321);
  EXPECT_EQ(n6.quotient_.hi_, 0ULL);
  EXPECT_EQ(n6.remainder_, 10ULL);

  constexpr auto n7 = uint128_t((123456789ULL * 987654321ULL) + 10ULL, 0).div(987654321);
  EXPECT_EQ(n7.quotient_.lo_, 123456789);
  EXPECT_EQ(n7.quotient_.hi_, 0ULL);
  EXPECT_EQ(n7.remainder_, 10ULL);

  constexpr auto n8 = uint128_t(0, 0xFFFFFFFFULL).div(0xFFFFFFFFFFFFFFFFULL);
  EXPECT_EQ(n8.quotient_.lo_, 0xFFFFFFFFULL);
  EXPECT_EQ(n8.quotient_.hi_, 0ULL);
  EXPECT_EQ(n8.remainder_, 0xFFFFFFFFULL);

  constexpr auto n9 = uint128_t::mul(17446744073709551615ULL, 7446744073709551615ULL).div(12446744073709551615ULL);
  EXPECT_EQ(n9.quotient_.lo_, 10438186666892946874ULL);
  EXPECT_EQ(n9.quotient_.hi_, 0ULL);
  EXPECT_EQ(n9.remainder_, 9852383995793206715ULL);

  constexpr auto n10 = uint128_t::mul(1, 1000000000000000000ULL).div(2);
  EXPECT_EQ(n10.quotient_.lo_, 500000000000000000ULL);
  EXPECT_EQ(n10.quotient_.hi_, 0ULL);

  constexpr auto n11 = uint128_t::mul(1, 1000000000000000000ULL).div(3);
  EXPECT_EQ(n11.quotient_.lo_, 333333333333333333ULL);
  EXPECT_EQ(n11.quotient_.hi_, 0ULL);

  constexpr auto n12 = (uint128_t::mul(2, 1000000000000000000ULL) + 1).div(3);
  EXPECT_EQ(n12.quotient_.lo_, 666666666666666667ULL);
  EXPECT_EQ(n12.quotient_.hi_, 0ULL);

  constexpr auto n13 = (uint128_t::mul(3, 1000000000000000000ULL) + (700 / 2)).div(700);
  EXPECT_EQ(n13.quotient_.lo_, 4285714285714286ULL);
  EXPECT_EQ(n13.quotient_.hi_, 0ULL);
}
```
# ..\node\csdb\unittests\csdb_unit_tests_pool.cpp 
```cpp 
#include "csdb/pool.h"

#include <iostream>
#include <set>
#include <map>
#include <stdexcept>

#include <gtest/gtest.h>

#include "csdb_unit_tests_environment.h"

#include "csdb/internal/utils.h"
#include "priv_crypto.h"

class PoolHashTest : public ::testing::Test
{
};

class PoolTest : public ::testing::Test
{
protected:
  PoolTest() :
    path_to_tests_(::csdb::internal::app_data_path() + "csdb_unittests_pool")
  {
  }

  void TearDown() override
  {
    ASSERT_TRUE(::csdb::internal::path_remove(path_to_tests_));
  }

  ::std::string path_to_tests_;
  ::csdb::Address addr1 = ::csdb::Address::from_string("0000000000000000000000000000000000000000");
  ::csdb::Address addr2 = ::csdb::Address::from_string("0000000000000000000000000000000000000001");
  ::csdb::Address addr3 = ::csdb::Address::from_string("0000000000000000000000000000000000000002");
};

::std::ostream& operator <<(::std::ostream& os, const ::csdb::PoolHash& value)
{
  os << value.to_string();
  return os;
}

using namespace csdb;

TEST_F(PoolHashTest, EmptyHash)
{
  PoolHash h;
  EXPECT_TRUE(h.is_empty());
  EXPECT_EQ(h.size(), static_cast<size_t>(0));
  EXPECT_TRUE(h.to_string().empty());
}

TEST_F(PoolHashTest, HashFromData)
{
  {
    PoolHash h = PoolHash::calc_from_data({1,2,3});
    EXPECT_FALSE(h.is_empty());
    EXPECT_EQ(h.size(), ::csdb::priv::crypto::hash_size);
    EXPECT_FALSE(h.to_string().empty());
  }

  {
    PoolHash h = PoolHash::calc_from_data({});
    EXPECT_FALSE(h.is_empty());
    EXPECT_EQ(h.size(), ::csdb::priv::crypto::hash_size);
    EXPECT_FALSE(h.to_string().empty());
  }
}

TEST_F(PoolHashTest, Compare)
{
  PoolHash h1 = PoolHash::calc_from_data({1,2,3});
  PoolHash h2 = PoolHash::calc_from_data({1,2,3});
  PoolHash h3 = PoolHash::calc_from_data({1,2,3,4});
  PoolHash h4;
  EXPECT_EQ(h1, h2);
  EXPECT_NE(h1, h3);
  EXPECT_NE(h1, h4);
  EXPECT_NE(h2, h3);
  EXPECT_NE(h2, h4);
  EXPECT_NE(h3, h4);
}

TEST_F(PoolHashTest, StdSet)
{
  ::std::set<PoolHash> hs;
  EXPECT_TRUE(hs.insert(PoolHash::calc_from_data({1,2,3})).second);
  EXPECT_FALSE(hs.insert(PoolHash::calc_from_data({1,2,3})).second);
  EXPECT_TRUE(hs.insert(PoolHash::calc_from_data({1,2,4})).second);
  EXPECT_TRUE(hs.insert(PoolHash{}).second);
  EXPECT_FALSE(hs.insert(PoolHash{}).second);

  EXPECT_EQ(hs.size(), static_cast<size_t>(3));
  EXPECT_EQ(hs.count(PoolHash::calc_from_data({1,2,3})), static_cast<size_t>(1));
  EXPECT_EQ(hs.count(PoolHash::calc_from_data({1,2,4})), static_cast<size_t>(1));
  EXPECT_EQ(hs.count(PoolHash::calc_from_data({1,4,2})), static_cast<size_t>(0));
  EXPECT_EQ(hs.count(PoolHash{}), static_cast<size_t>(1));

  EXPECT_EQ(hs.erase(PoolHash::calc_from_data({1,2,3})), static_cast<size_t>(1));
  EXPECT_EQ(hs.erase(PoolHash::calc_from_data({1,2,3})), static_cast<size_t>(0));
  EXPECT_EQ(hs.size(), static_cast<size_t>(2));
  EXPECT_EQ(hs.count(PoolHash::calc_from_data({1,2,3})), static_cast<size_t>(0));
  EXPECT_EQ(hs.count(PoolHash::calc_from_data({1,2,4})), static_cast<size_t>(1));
  EXPECT_EQ(hs.count(PoolHash::calc_from_data({1,4,2})), static_cast<size_t>(0));
  EXPECT_EQ(hs.count(PoolHash{}), static_cast<size_t>(1));
}

TEST_F(PoolHashTest, StdMap)
{
  ::std::map<PoolHash, ::internal::byte_array> hm;
  EXPECT_TRUE(hm.emplace(PoolHash::calc_from_data({1,2,3}), internal::byte_array{1,2,3}).second);
  EXPECT_FALSE(hm.emplace(PoolHash::calc_from_data({1,2,3}), internal::byte_array{1,3,2}).second);
  EXPECT_TRUE(hm.emplace(PoolHash::calc_from_data({1,3,2}), internal::byte_array{1,3,2}).second);
  EXPECT_TRUE(hm.emplace(PoolHash{}, internal::byte_array{}).second);

  EXPECT_EQ(hm.size(), static_cast<size_t>(3));
  EXPECT_EQ(hm.at(PoolHash::calc_from_data({1,2,3})), (internal::byte_array{1,2,3}));
  EXPECT_EQ(hm.at(PoolHash::calc_from_data({1,3,2})), (internal::byte_array{1,3,2}));
  EXPECT_THROW(hm.at(PoolHash::calc_from_data({1,2,4})), ::std::out_of_range);
  EXPECT_EQ(hm.at(PoolHash{}), (internal::byte_array{}));

  EXPECT_EQ(hm.erase(PoolHash::calc_from_data({1,2,3})), static_cast<size_t>(1));
  EXPECT_EQ(hm.erase(PoolHash::calc_from_data({1,2,3})), static_cast<size_t>(0));
  EXPECT_EQ(hm.size(), static_cast<size_t>(2));
  EXPECT_THROW(hm.at(PoolHash::calc_from_data({1,2,3})), ::std::out_of_range);
  EXPECT_EQ(hm.at(PoolHash::calc_from_data({1,3,2})), (internal::byte_array{1,3,2}));
  EXPECT_THROW(hm.at(PoolHash::calc_from_data({1,2,4})), std::out_of_range);
  EXPECT_EQ(hm.at(PoolHash{}), (internal::byte_array{}));
}

TEST_F(PoolHashTest, FromValidString)
{
  {
    PoolHash h1;
    EXPECT_TRUE(h1.to_string().empty());
    PoolHash h2 = PoolHash::from_string(h1.to_string());
    EXPECT_TRUE(h1.is_empty());
    EXPECT_TRUE(h2.is_empty());
    EXPECT_EQ(h1, h2);
  }

  {
    PoolHash h1 = PoolHash::calc_from_data({1,2,3});
    PoolHash h2 = PoolHash::from_string(h1.to_string());
    PoolHash h3 = PoolHash::calc_from_data({1,3,2});
    PoolHash h4 = PoolHash::from_string(h3.to_string());
    EXPECT_FALSE(h1.is_empty());
    EXPECT_FALSE(h2.is_empty());
    EXPECT_FALSE(h3.is_empty());
    EXPECT_FALSE(h4.is_empty());
    EXPECT_EQ(h1, h2);
    EXPECT_EQ(h3, h4);
    EXPECT_NE(h1, h3);
    EXPECT_NE(h2, h4);
  }
}

TEST_F(PoolHashTest, FromValidBinary)
{
  {
    PoolHash h1;
    EXPECT_TRUE(h1.to_binary().empty());
    PoolHash h2 = PoolHash::from_binary(h1.to_binary());
    EXPECT_TRUE(h1.is_empty());
    EXPECT_TRUE(h2.is_empty());
    EXPECT_EQ(h1, h2);
  }

  {
    PoolHash h1 = PoolHash::calc_from_data({1,2,3});
    PoolHash h2 = PoolHash::from_binary(h1.to_binary());
    PoolHash h3 = PoolHash::calc_from_data({1,3,2});
    PoolHash h4 = PoolHash::from_binary(h3.to_binary());
    EXPECT_FALSE(h1.is_empty());
    EXPECT_FALSE(h2.is_empty());
    EXPECT_FALSE(h3.is_empty());
    EXPECT_FALSE(h4.is_empty());
    EXPECT_EQ(h1, h2);
    EXPECT_EQ(h3, h4);
    EXPECT_NE(h1, h3);
    EXPECT_NE(h2, h4);
  }
}

TEST_F(PoolHashTest, FromInvalidString)
{
  EXPECT_TRUE(::PoolHash::from_string("Invalid string").is_empty());

  ::std::string valid = PoolHash::calc_from_data({1,2,3}).to_string();

  {
    ::std::string invalid(valid);
    invalid.insert(invalid.begin(), 'Q');
    EXPECT_TRUE(::PoolHash::from_string(invalid).is_empty());
  }

  {
    ::std::string invalid(valid);
    invalid += "00";
    EXPECT_TRUE(::PoolHash::from_string(invalid).is_empty());
  }

  {
    ::std::string invalid(valid);
    invalid.erase(0, 1);
    EXPECT_TRUE(::PoolHash::from_string(invalid).is_empty());
  }
}

TEST_F(PoolTest, Empty)
{
  {
    Pool p;
    EXPECT_FALSE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());
    EXPECT_TRUE(p.previous_hash().is_empty());
    EXPECT_TRUE(p.hash().is_empty());
    EXPECT_TRUE(p.to_binary().empty());
    EXPECT_EQ(p.transactions_count(), static_cast<size_t>(0));
  }

  {
    Pool p(PoolHash(), 0);
    EXPECT_TRUE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());
    EXPECT_TRUE(p.previous_hash().is_empty());
    EXPECT_TRUE(p.hash().is_empty());
    EXPECT_TRUE(p.to_binary().empty());
    EXPECT_EQ(p.transactions_count(), static_cast<size_t>(0));
    EXPECT_EQ(p.sequence(), static_cast<Pool::sequence_t>(0));
  }

  {
    Pool p(PoolHash::calc_from_data({}), 1);
    EXPECT_TRUE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());
    EXPECT_EQ(p.previous_hash(), PoolHash::calc_from_data({}));
    EXPECT_TRUE(p.hash().is_empty());
    EXPECT_TRUE(p.to_binary().empty());
    EXPECT_EQ(p.transactions_count(), static_cast<size_t>(0));
    EXPECT_EQ(p.sequence(), static_cast<Pool::sequence_t>(1));
  }
}

TEST_F(PoolTest, MakeValid)
{
  {
    Pool p;
    EXPECT_FALSE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());

    p.set_sequence(0);
    EXPECT_TRUE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());
    EXPECT_TRUE(p.previous_hash().is_empty());
    EXPECT_TRUE(p.hash().is_empty());
    EXPECT_TRUE(p.to_binary().empty());
    EXPECT_EQ(p.transactions_count(), static_cast<size_t>(0));
    EXPECT_EQ(p.sequence(), static_cast<Pool::sequence_t>(0));
  }

  {
    Pool p;
    EXPECT_FALSE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());

    p.set_previous_hash(PoolHash::calc_from_data({}));
    EXPECT_TRUE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());
    EXPECT_EQ(p.previous_hash(), PoolHash::calc_from_data({}));
    EXPECT_TRUE(p.hash().is_empty());
    EXPECT_TRUE(p.to_binary().empty());
    EXPECT_EQ(p.transactions_count(), static_cast<size_t>(0));
    EXPECT_EQ(p.sequence(), static_cast<Pool::sequence_t>(0));
  }

  {
    Pool p;
    EXPECT_FALSE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());

    p.set_storage(Storage());
    EXPECT_TRUE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());
    EXPECT_EQ(p.previous_hash(), PoolHash{});
    EXPECT_TRUE(p.hash().is_empty());
    EXPECT_TRUE(p.to_binary().empty());
    EXPECT_EQ(p.transactions_count(), static_cast<size_t>(0));
    EXPECT_EQ(p.sequence(), static_cast<Pool::sequence_t>(0));
  }

  {
    Pool p;
    EXPECT_FALSE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());

    EXPECT_TRUE(p.add_user_field(UFID_COMMENT, "Comment"));
    EXPECT_TRUE(p.is_valid());
    EXPECT_FALSE(p.is_read_only());
    EXPECT_EQ(p.previous_hash(), PoolHash{});
    EXPECT_TRUE(p.hash().is_empty());
    EXPECT_TRUE(p.to_binary().empty());
    EXPECT_EQ(p.transactions_count(), static_cast<size_t>(0));
    EXPECT_EQ(p.sequence(), static_cast<Pool::sequence_t>(0));
  }
}

TEST_F(PoolTest, SetReadOnlyAfterCompose)
{
  Pool p(PoolHash::calc_from_data({1}), 1);
  Transaction t{addr1, addr2, Currency("CS"), 1_c};
  EXPECT_TRUE(p.is_valid());
  EXPECT_FALSE(p.is_read_only());
  EXPECT_TRUE(p.add_transaction(t, true));
  EXPECT_EQ(p.transactions_count(), static_cast<size_t>(1));

  EXPECT_TRUE(p.compose());
  EXPECT_TRUE(p.is_valid());
  EXPECT_TRUE(p.is_read_only());

  p.set_sequence(p.sequence() + 1);
  EXPECT_EQ(p.sequence(), static_cast<Pool::sequence_t>(1));

  p.set_previous_hash(PoolHash::calc_from_data({2}));
  EXPECT_EQ(p.previous_hash(), PoolHash::calc_from_data({1}));

  EXPECT_FALSE(p.add_transaction(t, true));
  EXPECT_EQ(p.transactions_count(), static_cast<size_t>(1));
}

TEST_F(PoolTest, ToFromBinaryValidEmpty)
{
  {
    Pool src(PoolHash(), 0);
    EXPECT_TRUE(src.is_valid());
    EXPECT_FALSE(src.is_read_only());

    EXPECT_TRUE(src.compose());
    EXPECT_TRUE(src.is_valid());
    EXPECT_TRUE(src.is_read_only());

    Pool dst = Pool::from_binary(src.to_binary());
    EXPECT_TRUE(dst.is_valid());
    EXPECT_TRUE(dst.is_read_only());
    EXPECT_EQ(src, dst);
  }

  {
    Pool src(PoolHash::calc_from_data({1}), 1);
    EXPECT_TRUE(src.is_valid());
    EXPECT_FALSE(src.is_read_only());

    EXPECT_TRUE(src.compose());
    EXPECT_TRUE(src.is_valid());
    EXPECT_TRUE(src.is_read_only());

    Pool dst = Pool::from_binary(src.to_binary());
    EXPECT_EQ(src, dst);
  }
}

TEST_F(PoolTest, FromBinaryInvalidEmpty)
{
  EXPECT_FALSE(Pool::from_binary({}).is_valid());
  EXPECT_FALSE(Pool::from_binary({1,2,3}).is_valid());

  Pool src(PoolHash::calc_from_data({1}), 1);
  EXPECT_TRUE(src.compose());
  ::csdb::internal::byte_array valid = src.to_binary();
  EXPECT_FALSE(valid.empty());

  {
    ::csdb::internal::byte_array invalid(valid);
    invalid.resize(invalid.size() - 1);
    EXPECT_FALSE(Pool::from_binary(invalid).is_valid());
  }

  {
    ::csdb::internal::byte_array invalid(valid);
    invalid[0] = ~invalid[0];
    EXPECT_FALSE(Pool::from_binary(invalid).is_valid());
  }
}

TEST_F(PoolTest, ErrorSaveInvalidOrUncomposed)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));
  ASSERT_TRUE(s.last_hash().is_empty());

  {
    Pool p;
    EXPECT_FALSE(p.save(s));
  }

  {
    Pool p;
    EXPECT_FALSE(p.compose());
    EXPECT_FALSE(p.save(s));
  }

  {
    Pool p(PoolHash{}, 0, s);
    EXPECT_TRUE(p.is_valid());
    EXPECT_FALSE(p.save(s));
  }
}

TEST_F(PoolTest, SaveLoadEmpty)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool src1(PoolHash{}, 0, s);
  EXPECT_TRUE(src1.compose());
  EXPECT_FALSE(src1.hash().is_empty());
  EXPECT_TRUE(src1.save());
  EXPECT_EQ(src1.hash(), s.last_hash());

  Pool src2(src1.hash(), src1.sequence() + 1, src1.storage());
  EXPECT_TRUE(src2.compose());
  EXPECT_FALSE(src2.hash().is_empty());
  EXPECT_TRUE(src2.save());
  EXPECT_EQ(src2.hash(), s.last_hash());

  Pool res1 = Pool::load(src1.hash(), s);
  Pool res2 = Pool::load(src2.hash(), s);
  EXPECT_TRUE(res1.is_valid());
  EXPECT_TRUE(res2.is_valid());
  EXPECT_TRUE(res1.is_read_only());
  EXPECT_TRUE(res2.is_read_only());
  EXPECT_EQ(src1, res1);
  EXPECT_EQ(src2, res2);
}

TEST_F(PoolTest, SaveEmptyDuplicate)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool p(PoolHash{}, 0, s);
  EXPECT_TRUE(p.compose());
  EXPECT_FALSE(p.hash().is_empty());
  EXPECT_TRUE(p.save());
  EXPECT_EQ(p.hash(), s.last_hash());

  EXPECT_FALSE(p.save());
  EXPECT_EQ(s.last_error(), Storage::InvalidParameter);
}

TEST_F(PoolTest, SaveLoadNotFound)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool p(PoolHash{}, 0, s);
  EXPECT_TRUE(p.compose());
  EXPECT_FALSE(p.hash().is_empty());
  EXPECT_TRUE(p.save());
  EXPECT_EQ(p.hash(), s.last_hash());

  ::csdb::internal::byte_array hash_binary = p.hash().to_binary();
  hash_binary[0] = ~hash_binary[0];
  PoolHash hash = PoolHash::from_binary(hash_binary);
  Pool res = Pool::load(hash, s);
  EXPECT_FALSE(res.is_valid());
  EXPECT_EQ(s.last_error(), Storage::DatabaseError);
  EXPECT_EQ(s.db_last_error(), Database::NotFound);
}

TEST_F(PoolTest, FromToBinaryWithTransactions)
{
  Pool src{PoolHash{}, 0};
  EXPECT_TRUE(src.is_valid());

  EXPECT_TRUE(src.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 1_c), true));
  EXPECT_TRUE(src.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 2_c), true));
  EXPECT_TRUE(src.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 3_c), true));

  EXPECT_EQ(src.transactions_count(), static_cast<size_t>(3));
  for (size_t i = 0; i < src.transactions_count(); ++i) {
    Transaction t = src.transaction(i);
    EXPECT_TRUE(t.is_valid());
    EXPECT_FALSE(t.id().is_valid());
  }

  EXPECT_TRUE(src.compose());
  EXPECT_TRUE(src.is_read_only());
  EXPECT_EQ(src.transactions_count(), static_cast<size_t>(3));
  for (size_t i = 0; i < src.transactions_count(); ++i) {
    Transaction t = src.transaction(i);
    EXPECT_TRUE(t.is_valid());
    EXPECT_TRUE(t.id().is_valid());
    EXPECT_EQ(t.id().pool_hash(), src.hash());
  }

  Pool dst = Pool::from_binary(src.to_binary());
  EXPECT_TRUE(dst.is_valid());
  EXPECT_TRUE(dst.is_read_only());
  EXPECT_EQ(src, dst);

  for (size_t i = 0; i < dst.transactions_count(); ++i) {
    Transaction t = dst.transaction(src.transaction(i).id());
    EXPECT_TRUE(t.is_valid());
    EXPECT_TRUE(t.id().is_valid());
    EXPECT_EQ(t.id().pool_hash(), dst.hash());
    EXPECT_EQ(t.id(), src.transaction(i).id());
  }
}

TEST_F(PoolTest, UserFieldCompare)
{
  Pool p1{PoolHash{}, 0}, p2{PoolHash{}, 0};
  EXPECT_EQ(p1, p2);
  EXPECT_TRUE(p1.add_user_field(UFID_COMMENT, "Comment"));
  EXPECT_NE(p1, p2);
  EXPECT_TRUE(p2.add_user_field(UFID_COMMENT, "Comment"));
  EXPECT_EQ(p1, p2);
  EXPECT_FALSE(p1.add_user_field(UFID_COMMENT, UserField{}));
  EXPECT_EQ(p1, p2);
  EXPECT_TRUE(p1.add_user_field(1, 123.456_c));
  EXPECT_NE(p1, p2);
  EXPECT_TRUE(p2.add_user_field(1, 123.456_c));
  EXPECT_EQ(p1, p2);
  EXPECT_TRUE(p1.add_user_field(UFID_COMMENT, 100));
  EXPECT_NE(p1, p2);
  EXPECT_TRUE(p2.add_user_field(UFID_COMMENT, 200));
  EXPECT_NE(p1, p2);
  EXPECT_TRUE(p2.add_user_field(UFID_COMMENT, 100));
  EXPECT_EQ(p1, p2);
}

TEST_F(PoolTest, UserFieldAdd)
{
  Pool p{PoolHash{}, 0};
  EXPECT_EQ(p.user_field_ids(), ::std::set<user_field_id_t>({}));
  EXPECT_TRUE(p.add_user_field(1, 100));
  EXPECT_TRUE(p.add_user_field(2, "Text"));
  EXPECT_TRUE(p.add_user_field(3, 123.456_c));
  EXPECT_EQ(p.user_field_ids(), ::std::set<user_field_id_t>({1,2,3}));
  EXPECT_EQ(p.user_field(1), UserField(100));
  EXPECT_EQ(p.user_field(2), UserField("Text"));
  EXPECT_EQ(p.user_field(3), UserField(123.456_c));
  EXPECT_EQ(p.user_field(4), UserField());
}

TEST_F(PoolTest, UserFieldSerialize)
{
  Pool src{PoolHash{}, 0};
  EXPECT_EQ(src.user_field_ids(), ::std::set<user_field_id_t>({}));
  EXPECT_TRUE(src.add_user_field(1, 100));
  EXPECT_TRUE(src.add_user_field(2, "Text"));
  EXPECT_TRUE(src.add_user_field(3, 123.456_c));
  EXPECT_EQ(src.user_field_ids(), ::std::set<user_field_id_t>({1,2,3}));
  EXPECT_EQ(src.user_field(1), UserField(100));
  EXPECT_EQ(src.user_field(2), UserField("Text"));
  EXPECT_EQ(src.user_field(3), UserField(123.456_c));
  EXPECT_EQ(src.user_field(4), UserField());

  ASSERT_TRUE(src.compose());
  ::csdb::internal::byte_array enc = src.to_binary();
  EXPECT_FALSE(enc.empty());

  Pool res = Pool::from_binary(enc);
  EXPECT_TRUE(res.is_valid());
  EXPECT_EQ(res.user_field_ids(), ::std::set<user_field_id_t>({1,2,3}));
  EXPECT_EQ(res.user_field(1), UserField(100));
  EXPECT_EQ(res.user_field(2), UserField("Text"));
  EXPECT_EQ(res.user_field(3), UserField(123.456_c));
  EXPECT_EQ(res.user_field(4), UserField());
  EXPECT_EQ(src, res);
}

TEST_F(PoolTest, UserFieldBlockAddForToOnly)
{
  Pool p_src{PoolHash{}, 0};
  EXPECT_TRUE(p_src.add_user_field(UFID_COMMENT, "Pool Comment"));
  EXPECT_EQ(p_src.user_field_ids(), ::std::set<user_field_id_t>({UFID_COMMENT}));
  EXPECT_EQ(p_src.user_field(UFID_COMMENT), UserField("Pool Comment"));

  Transaction t_src{addr1, addr2, Currency("CS"), 1_c};
  EXPECT_TRUE(t_src.add_user_field(UFID_COMMENT, "Transaction Comment"));
  EXPECT_EQ(t_src.user_field_ids(), ::std::set<user_field_id_t>({UFID_COMMENT}));
  EXPECT_EQ(t_src.user_field(UFID_COMMENT), UserField("Transaction Comment"));
  EXPECT_TRUE(p_src.add_transaction(t_src, true));

  EXPECT_TRUE(p_src.compose());
  EXPECT_FALSE(p_src.add_user_field(UFID_COMMENT, 1));
  EXPECT_FALSE(p_src.add_user_field(1, 1_c));
  EXPECT_EQ(p_src.user_field_ids(), ::std::set<user_field_id_t>({UFID_COMMENT}));
  EXPECT_EQ(p_src.user_field(UFID_COMMENT), UserField("Pool Comment"));

  Pool p_res = Pool::from_binary(p_src.to_binary());
  EXPECT_TRUE(p_res.is_valid());
  EXPECT_TRUE(p_res.is_read_only());
  EXPECT_EQ(p_src, p_res);

  EXPECT_EQ(p_res.transactions_count(), static_cast<size_t>(1));
  Transaction t_res = p_res.transaction(0);
  EXPECT_TRUE(t_res.is_valid());
  EXPECT_TRUE(t_res.is_read_only());
  EXPECT_EQ(t_src, t_res);

  EXPECT_FALSE(p_res.add_user_field(1, 1));
  EXPECT_FALSE(t_res.add_user_field(1, 1));
  EXPECT_EQ(p_src, p_res);
  EXPECT_EQ(t_src, t_res);
}

//
// Get transaction by source, target
//

TEST_F(PoolTest, GetTransactionBySource)
{
  Pool pool{PoolHash{}, 0};
  ASSERT_TRUE(pool.is_valid());
  ASSERT_FALSE(pool.is_read_only());

  // Should work with non read-only pool

  Transaction t0{addr1, addr2, Currency("CS"), 12_c};
  ASSERT_TRUE(pool.add_transaction(t0, true));

  Transaction t1{addr1, addr3, Currency("CS"), 13_c};
  ASSERT_TRUE(pool.add_transaction(t1, true));

  EXPECT_TRUE(pool.get_last_by_source(addr1).is_valid());
  EXPECT_FALSE(pool.get_last_by_source(addr2).is_valid());

  // And on read-only as well

  ASSERT_TRUE(pool.compose());
  ASSERT_TRUE(pool.is_valid());
  ASSERT_TRUE(pool.is_read_only());

  EXPECT_TRUE(pool.get_last_by_source(addr1).is_valid());
  EXPECT_FALSE(pool.get_last_by_source(addr2).is_valid());

  // Case if source appears multiple times, should return last transaction 

  EXPECT_EQ(pool.get_last_by_source(addr1).amount(), 13_c);
}

TEST_F(PoolTest, GetTransactionByTarget)
{
  Pool pool{PoolHash{}, 0};
  ASSERT_TRUE(pool.is_valid());
  ASSERT_FALSE(pool.is_read_only());

  // Should work with non read-only pool

  Transaction t0{addr1, addr2, Currency("CS"), 12_c};
  ASSERT_TRUE(pool.add_transaction(t0, true));

  Transaction t1{addr3, addr2, Currency("CS"), 32_c};
  ASSERT_TRUE(pool.add_transaction(t1, true));

  EXPECT_TRUE(pool.get_last_by_target(addr2).is_valid());
  EXPECT_FALSE(pool.get_last_by_target(addr1).is_valid());

  // And on read-only as well

  ASSERT_TRUE(pool.compose());
  ASSERT_TRUE(pool.is_valid());
  ASSERT_TRUE(pool.is_read_only());

  EXPECT_TRUE(pool.get_last_by_target(addr2).is_valid());
  EXPECT_FALSE(pool.get_last_by_target(addr1).is_valid());

  // Case if target appears multiple times, should return last transaction

  EXPECT_EQ(pool.get_last_by_target(addr2).amount(), 32_c);
}```
# ..\node\csdb\unittests\csdb_unit_tests_shared_data.cpp 
```cpp 
#include "csdb_unit_tests_shared_data.h"

#include <vector>

#include <gtest/gtest.h>

class SharedDataTest : public ::testing::Test
{
protected:
  void TearDown()
  {
    EXPECT_EQ(TestSharedData::counter(), 0);
  }
};

TEST_F(SharedDataTest, CreateAndDestroy)
{
  TestSharedData a;
  EXPECT_EQ(a.value(), 0);
  EXPECT_EQ(a.is_copied(), false);
}

TEST_F(SharedDataTest, Copy)
{
  TestSharedData a;
  EXPECT_EQ(a.value(), 0);
  TestSharedData b(a);
  EXPECT_EQ(b.value(), 0);

  EXPECT_EQ(a.is_copied(), false);
  EXPECT_EQ(b.is_copied(), false);
  EXPECT_EQ(a.is_same(b), true);
}

TEST_F(SharedDataTest, Assignment)
{
  TestSharedData a;
  EXPECT_EQ(a.value(), 0);
  TestSharedData b;
  EXPECT_EQ(b.value(), 0);
  b = a;
  EXPECT_EQ(b.value(), 0);

  EXPECT_EQ(a.is_copied(), false);
  EXPECT_EQ(b.is_copied(), false);
  EXPECT_EQ(a.is_same(b), true);
}

TEST_F(SharedDataTest, AssignmentAndCopyMixed)
{
  TestSharedData a;
  EXPECT_EQ(a.value(), 0);
  TestSharedData b;
  EXPECT_EQ(b.value(), 0);
  b = a;
  EXPECT_EQ(b.value(), 0);
  TestSharedData c(a);
  EXPECT_EQ(c.value(), 0);

  EXPECT_EQ(a.is_copied(), false);
  EXPECT_EQ(b.is_copied(), false);
  EXPECT_EQ(c.is_copied(), false);
  EXPECT_EQ(a.is_same(b), true);
  EXPECT_EQ(a.is_same(c), true);
}

TEST_F(SharedDataTest, NoCopyChange)
{
  TestSharedData a;
  EXPECT_EQ(a.value(), 0);
  a.setValue(1);
  EXPECT_EQ(a.value(), 1);
  a.setValue(2);
  EXPECT_EQ(a.value(), 2);

  EXPECT_EQ(a.is_copied(), false);
}

TEST_F(SharedDataTest, SimpleCopyOnWrite)
{
  TestSharedData a;
  EXPECT_EQ(a.value(), 0);
  TestSharedData b(a);
  EXPECT_EQ(b.value(), 0);
  EXPECT_EQ(a.is_copied(), false);
  EXPECT_EQ(b.is_copied(), false);
  EXPECT_EQ(a.is_same(b), true);

  b.setValue(1);
  EXPECT_EQ(b.value(), 1);
  EXPECT_EQ(a.is_copied(), false);
  EXPECT_EQ(b.is_copied(), true);
}

TEST_F(SharedDataTest, TripleCopyOnWrite)
{
  TestSharedData a;
  EXPECT_EQ(a.value(), 0);
  TestSharedData b(a);
  EXPECT_TRUE(b.copy_semantic_used());
  EXPECT_EQ(b.value(), 0);
  EXPECT_EQ(a.is_copied(), false);
  EXPECT_EQ(b.is_copied(), false);
  EXPECT_EQ(a.is_same(b), true);

  b.setValue(1);
  EXPECT_EQ(b.value(), 1);
  EXPECT_EQ(a.is_copied(), false);
  EXPECT_EQ(b.is_copied(), true);

  TestSharedData c;
  c = a;
  EXPECT_EQ(c.value(), 0);
  EXPECT_EQ(c.is_copied(), false);
  EXPECT_EQ(c.is_same(a), true);
  EXPECT_EQ(c.is_same(b),false);

  c.setValue(2);
  EXPECT_EQ(c.value(), 2);
  EXPECT_EQ(c.is_copied(), true);
}

namespace {
  TestSharedData get_test_data(int value)
  {
    return TestSharedData(value);
  }
} // namespace

TEST_F(SharedDataTest, MoveConstructorAndAssignment)
{
  std::vector<TestSharedData> a(1);
  EXPECT_FALSE(a[0].move_semantic_used());
  EXPECT_FALSE(a[0].copy_semantic_used());
  a[0].setValue(2);
  a.insert(a.begin(), TestSharedData(1));
  EXPECT_EQ(a[0].value(), 1);
  EXPECT_EQ(a[1].value(), 2);
  EXPECT_TRUE(a[0].move_semantic_used());
  EXPECT_TRUE(a[1].move_semantic_used());
  EXPECT_FALSE(a[0].copy_semantic_used());
  EXPECT_FALSE(a[1].copy_semantic_used());

  a[1] = get_test_data(100);
  EXPECT_EQ(a[1].value(), 100);
  EXPECT_TRUE(a[1].move_semantic_used());
  EXPECT_FALSE(a[1].copy_semantic_used());
}

namespace {
  void tsd_assign(TestSharedData& a, const TestSharedData* b)
  {
    a = *b;
  }
} // namespace

TEST_F(SharedDataTest, SelfAssignment)
{
  TestSharedData a(100);
  EXPECT_EQ(a.value(), 100);
  EXPECT_FALSE(a.is_copied());
  EXPECT_FALSE(a.move_semantic_used());
  EXPECT_FALSE(a.copy_semantic_used());

  tsd_assign(a, &a);
  EXPECT_EQ(a.value(), 100);
  EXPECT_FALSE(a.is_copied());
  EXPECT_FALSE(a.move_semantic_used());
  EXPECT_FALSE(a.copy_semantic_used());

  TestSharedData b(200);
  tsd_assign(a, &b);
  EXPECT_EQ(a.value(), 200);
  EXPECT_TRUE(a.is_same(b));
  EXPECT_FALSE(a.is_copied());
  EXPECT_FALSE(a.move_semantic_used());
  EXPECT_TRUE(a.copy_semantic_used());
}
```
# ..\node\csdb\unittests\csdb_unit_tests_shared_data.h 
```cpp 
/**
  * @file csdb_unit_tests_shared_data.h
  * @author Evgeny V. Zalivochkin
  */

#pragma once
#ifndef _CREDITS_CSDB_UNIT_TESTS_SHARED_DATA_H_INCLUDED_
#define _CREDITS_CSDB_UNIT_TESTS_SHARED_DATA_H_INCLUDED_

#include "csdb/internal/shared_data.h"
#include <atomic>

class TestSharedData
{
  SHARED_DATA_CLASS_DECLARE(TestSharedData)

public:
  explicit TestSharedData(int value);
  bool is_copied() const;
  bool is_same(const TestSharedData &other) const;

  int value() const;
  void setValue(int new_value);

  static int counter();
};

#endif // _CREDITS_CSDB_UNIT_TESTS_SHARED_DATA_H_INCLUDED_
```
# ..\node\csdb\unittests\csdb_unit_tests_shared_data_p.cpp 
```cpp 
#include "csdb_unit_tests_shared_data.h"

#include "csdb/internal/shared_data_ptr_implementation.h"

class TestSharedData::priv : public csdb::internal::shared_data
{
public:
  priv()
  {
    ++counter_;
  }

  priv(int value) : value_(value)
  {
    ++counter_;
  }

  priv(const priv& other) :
    csdb::internal::shared_data(other),
    copy_constuctor_called_(true)
  {
    ++counter_;
  }

  ~priv()
  {
    --counter_;
  }

public:
  bool copy_constuctor_called_ = false;
  int value_ = 0;
  static std::atomic<int> counter_;

  friend class SharedDataTest;
};

std::atomic<int> TestSharedData::priv::counter_(0);

SHARED_DATA_CLASS_IMPLEMENTATION(TestSharedData)

TestSharedData::TestSharedData(int value) : d(new TestSharedData::priv(value))
{
}

bool TestSharedData::is_copied() const
{
  return d->copy_constuctor_called_;
}

bool TestSharedData::is_same(const TestSharedData &other) const
{
  return (&(*d)) == (&(*other.d));
}

int TestSharedData::value() const
{
  return d->value_;
}

void TestSharedData::setValue(int new_value)
{
  d->value_ = new_value;
}

int TestSharedData::counter()
{
  return TestSharedData::priv::counter_;
}
```
# ..\node\csdb\unittests\csdb_unit_tests_sorted_array_set.cpp 
```cpp 
#include "csdb/internal/sorted_array_set.h"

#include <gtest/gtest.h>

using namespace ::csdb::internal;

TEST(SortedArraySet, DISABLED_Basic_Defaults)
{
  sorted_array_set set(nullptr, 0, 0);

  EXPECT_EQ(set.size(), 0);
}

TEST(SortedArraySet, Basic_Size)
{
  {
    uint8_t array[] = { 1, 2, 3, 4 };

    sorted_array_set set(array, 4, 1);

    EXPECT_EQ(set.size(), 4);
  }

  {
    uint8_t array[] = { 1, 2, 3, 4 };

    sorted_array_set set(array, 2, 2);

    EXPECT_EQ(set.size(), 2);
  }
}

TEST(SortedArraySet, Basic_Contains)
{
  uint8_t array[] = { 1, 2, 3, 4 };

  sorted_array_set set(array, 4, 1);

  {
    uint8_t item = 1;
    EXPECT_TRUE(set.contains(&item));
  }

  {
    uint8_t item = 4;
    EXPECT_TRUE(set.contains(&item));
  }

  {
    uint8_t item = 5;
    EXPECT_FALSE(set.contains(&item));
  }
}

TEST(SortedArraySet, Basic_GetIndex)
{
  uint8_t array[] = { 1, 2, 3, 4 };

  {
    sorted_array_set set(array, 4, 1);

    {
      uint8_t item = 1;
      EXPECT_EQ(*set[set.getIndex(&item)], 1);
    }

    {
      uint8_t item = 4;
      EXPECT_EQ(*set[set.getIndex(&item)], 4);
    }

    {
      uint8_t item = 5;
      EXPECT_EQ(set.getIndex(&item), set.size());
    }
  }

  {
    sorted_array_set set(array, 2, 2);

    {
      uint8_t item[] = {1 , 2};
      size_t index = set.getIndex(item);
      EXPECT_EQ(index, 0);
    }

    {
      uint8_t item[] = {3 , 4};
      size_t index = set.getIndex(item);
      EXPECT_EQ(index, 1);
    }

    {
      uint8_t item[] = {5, 6};
      size_t index = set.getIndex(item);
      EXPECT_EQ(index, set.size());
    }
  }
}

//
// Complex tests
//

#include <algorithm>
#include <vector>

namespace
{
  static constexpr size_t NUM_ITEMS = 10;

  template <int N>
  struct Item
  {
    static constexpr size_t NUM_BYTES = N;
    uint8_t data[N];

    bool operator<(const Item& o) const
    {
      auto res = std::lexicographical_compare(data, data + NUM_BYTES, o.data, o.data + NUM_BYTES);
      return res;
    }

    bool operator==(const Item& o) const
    {
      return memcmp(data, o.data, NUM_BYTES) == 0;
    }

    static Item generateItem()
    {
      Item item;

      std::generate(item.data, item.data + NUM_BYTES, []()
      {
        return rand();
      });

      return item;
    }
  };

  template <class T, class A = std::vector<T>>
  A generateArray(size_t numItems)
  {
    A array;
    array.resize(numItems);

    std::generate(std::begin(array), std::end(array), []()
      {
        return T::generateItem();
      });

    std::sort(std::begin(array), std::end(array));

    return array;
  }
}

constexpr size_t NUM_ELEMENTS = 200 * 1000;

using Item32 = Item<32>;

TEST(SortedArraySet, Complex_Contains)
{
  using Item = Item32;
  auto source = generateArray<Item>(NUM_ELEMENTS);

  assert(std::is_sorted(std::begin(source), std::end(source)));

  sorted_array_set set(source.data(), source.size(), sizeof(Item));

  for (size_t i = 0; i < 20; ++i)
  {
    auto index = (rand() * rand()) % source.size();
    const Item& item = source[index];

    auto found = set.contains(&item);
    EXPECT_TRUE(found);
  }
}

TEST(SortedArraySet, Complex_GetIndex)
{
  using Item = Item32;
  auto source = generateArray<Item>(NUM_ELEMENTS);

  assert(std::is_sorted(std::begin(source), std::end(source)));

  sorted_array_set set(source.data(), source.size(), sizeof(Item));

  for (size_t i = 0; i < 20; ++i)
  {
    auto index = (rand() * rand()) % source.size();
    const Item& item = source[index];

    auto foundIndex = set.getIndex(&item);
    EXPECT_TRUE(index == foundIndex);
  }
}

TEST(SortedArraySet, Complex_SquareBraces)
{
  using Item = Item32;
  auto source = generateArray<Item>(NUM_ELEMENTS);

  assert(std::is_sorted(std::begin(source), std::end(source)));

  sorted_array_set set(source.data(), source.size(), sizeof(Item));

  for (size_t i = 0; i < 20; ++i)
  {
    auto index = (rand() * rand()) % source.size();
    const Item& item = source[index];

    auto foundIndex = set.getIndex(&item);

    auto equal = (memcmp( &item, set[foundIndex], Item::NUM_BYTES ) == 0);
    EXPECT_TRUE(equal);
  }
}

TEST(SortedArraySet, Complex_InitFromVoid)
{
  using Item = Item32;
  auto source = generateArray<Item32>(NUM_ELEMENTS);

  assert(std::is_sorted(std::begin(source), std::end(source)));

  const void* ptr = static_cast<const void*>(source.data());
  sorted_array_set set(ptr, source.size(), sizeof(Item));

  for (size_t i = 0; i < 20; ++i)
  {
    auto index = (rand() * rand()) % source.size();
    const Item& item = source[index];

    auto found = set.contains(&item);
    EXPECT_TRUE(found);
  }
}

TEST(SortedArraySet, Complex_ItemLength13)
{
  using Item = Item<13>;
  auto source = generateArray<Item>(NUM_ELEMENTS);

  assert(std::is_sorted(std::begin(source), std::end(source)));

  const void* ptr = static_cast<const void*>(source.data());
  sorted_array_set set(ptr, source.size(), sizeof(Item));

  for (size_t i = 0; i < 20; ++i)
  {
    auto index = (rand() * rand()) % source.size();
    const Item& item = source[index];

    auto found = set.contains(&item);
    EXPECT_TRUE(found);
  }
}

//
// Helper functions
//

TEST(SortedArraySet, Helpers_Sort)
{
  constexpr size_t BYTES_PER_ELEMENT = 16;
  using Item = Item<BYTES_PER_ELEMENT>;
  using Array = std::vector<Item>;

  Array array(NUM_ELEMENTS);

  std::generate(std::begin(array), std::end(array), []()
    {
      return Item::generateItem();
    });

  sorted_array_set::sort<BYTES_PER_ELEMENT>(array.data(), array.size());

  auto sorted = (std::is_sorted(std::begin(array), std::end(array)));
  EXPECT_TRUE(sorted);
}

TEST(SortedArraySet, Helpers_IsSorted)
{
  constexpr size_t BYTES_PER_ELEMENT = 16;
  using Item = Item<BYTES_PER_ELEMENT>;
  using Array = std::vector<Item>;

  Array array(NUM_ELEMENTS);

  std::generate(std::begin(array), std::end(array), []()
  {
    return Item::generateItem();
  });

  sorted_array_set::sort<BYTES_PER_ELEMENT>(array.data(), array.size());

  auto sorted = sorted_array_set::isSorted<BYTES_PER_ELEMENT>(array.data(), array.size());
  EXPECT_TRUE(sorted);
}

/*
TEST(CopyAssign, DISABLED_ShouldNotCompile)
{
  sorted_array_set a;
  sorted_array_set b(a);
  sorted_array_set c = a;
}
*/

//
// Tests for templated version
//

TEST(SortedArraySetTemplate, Complex_Contains)
{
  using Item = Item32;
  auto source = generateArray<Item32>(NUM_ELEMENTS);

  assert(std::is_sorted(std::begin(source), std::end(source)));

  const void* ptr = static_cast<const void*>(source.data());

  sorted_array_set_t<Item::NUM_BYTES> set(ptr, source.size());

  for (size_t i = 0; i < 1000; ++i)
  {
    auto index = (rand() * rand()) % source.size();
    const Item& item = source[index];

    auto found = set.contains(&item);
    EXPECT_TRUE(found);
  }
}

TEST(SortedArraySetTemplate, Complex_GetIndex)
{
  using Item = Item32;
  auto source = generateArray<Item>(NUM_ELEMENTS);

  assert(std::is_sorted(std::begin(source), std::end(source)));

  sorted_array_set_t<Item::NUM_BYTES> set(source.data(), source.size());

  for (size_t i = 0; i < 20; ++i)
  {
    auto index = (rand() * rand()) % source.size();
    const Item& item = source[index];

    auto foundIndex = set.getIndex(&item);
    EXPECT_TRUE(index == foundIndex);
  }
}

TEST(SortedArraySetTemplate, Complex_SquareBraces)
{
  using Item = Item32;
  auto source = generateArray<Item>(NUM_ELEMENTS);

  assert(std::is_sorted(std::begin(source), std::end(source)));

  sorted_array_set_t<Item::NUM_BYTES> set(source.data(), source.size());

  for (size_t i = 0; i < 20; ++i)
  {
    auto index = (rand() * rand()) % source.size();
    const Item& item = source[index];

    auto foundIndex = set.getIndex(&item);

    auto equal = (memcmp(&item, set[foundIndex], Item::NUM_BYTES) == 0);
    EXPECT_TRUE(equal);
  }
}

TEST(SortedArraySetTemplate, Helpers_Sort)
{
  using Item = Item32;
  auto source = generateArray<Item32>(NUM_ELEMENTS);

  sorted_array_set_t<32>::sort(source.data(), source.size());

  auto sorted = (std::is_sorted(std::begin(source), std::end(source)));
  EXPECT_TRUE(sorted);
}

TEST(SortedArraySetTemplate, Helpers_IsSorted)
{
  using Item = Item32;
  auto source = generateArray<Item32>(NUM_ELEMENTS);

  sorted_array_set_t<32>::sort(source.data(), source.size());

  auto sorted = sorted_array_set_t<32>::isSorted(source.data(), source.size());
  EXPECT_TRUE(sorted);
}
```
# ..\node\csdb\unittests\csdb_unit_tests_storage.cpp 
```cpp 
#include "csdb/storage.h"

#include "csdb_unit_tests_environment.h"

#include "csdb/wallet.h"
#include "csdb/internal/utils.h"

using namespace csdb;

class StorageTest : public ::testing::Test
{
};

class StorageTestNotOpen : public ::testing::Test
{
};

class StorageTestEmpty : public ::testing::Test
{
protected:
  StorageTestEmpty() :
    path_to_tests(internal::app_data_path() + "transaction_unittests")
  {
  }

  void SetUp() override
  {
    ASSERT_TRUE(addr1.is_valid());
    ASSERT_TRUE(addr2.is_valid());
    ASSERT_TRUE(addr3.is_valid());
  }

  void TearDown() override
  {
    ASSERT_TRUE(internal::path_remove(path_to_tests));
  }

  std::string path_to_tests;
  ::csdb::Address addr1 = ::csdb::Address::from_string("0000000000000000000000000000000000000000");
  ::csdb::Address addr2 = ::csdb::Address::from_string("0000000000000000000000000000000000000001");
  ::csdb::Address addr3 = ::csdb::Address::from_string("0000000000000000000000000000000000000002");
};

TEST_F(StorageTestNotOpen, LastError)
{
  ::csdb::Storage s;
  EXPECT_EQ(s.last_error(), ::csdb::Storage::NoError);
  EXPECT_FALSE(s.last_error_message().empty());
  EXPECT_EQ(s.db_last_error(), ::csdb::Database::NotOpen);
  EXPECT_FALSE(s.db_last_error_message().empty());
}

TEST_F(StorageTestNotOpen, FailedOpen)
{
  ::csdb::Storage s;
  EXPECT_EQ(s.last_error(), ::csdb::Storage::NoError);
  EXPECT_FALSE(s.open("/dev/null"));
  EXPECT_FALSE(s.isOpen());
  EXPECT_EQ(s.last_error(), ::csdb::Storage::DatabaseError);
  EXPECT_EQ(s.db_last_error(), ::csdb::Database::IOError);
}

TEST_F(StorageTestNotOpen, FailedOpenWithEmptyOptions)
{
  ::csdb::Storage s;
  EXPECT_FALSE(s.isOpen());
  EXPECT_FALSE(s.open(::csdb::Storage::OpenOptions{}));
  EXPECT_FALSE(s.isOpen());
  EXPECT_EQ(s.last_error(), ::csdb::Storage::DatabaseError);
  EXPECT_EQ(s.db_last_error(), ::csdb::Database::NotOpen);

  s = ::csdb::Storage::get(::csdb::Storage::OpenOptions{});
  EXPECT_FALSE(s.isOpen());
  EXPECT_EQ(s.last_error(), ::csdb::Storage::DatabaseError);
  EXPECT_EQ(s.db_last_error(), ::csdb::Database::NotOpen);
}

TEST_F(StorageTestNotOpen, CopyAndAssignment)
{
  ::csdb::Storage s1, s2;
  EXPECT_EQ(s1.last_error(), ::csdb::Storage::NoError);
  EXPECT_FALSE(s1.last_error_message().empty());
  EXPECT_EQ(s1.db_last_error(), ::csdb::Database::NotOpen);
  EXPECT_FALSE(s1.db_last_error_message().empty());

  EXPECT_EQ(s2.last_error(), ::csdb::Storage::NoError);
  EXPECT_FALSE(s2.last_error_message().empty());
  EXPECT_EQ(s2.db_last_error(), ::csdb::Database::NotOpen);
  EXPECT_FALSE(s2.db_last_error_message().empty());

  Storage s3(s1), s4;
  EXPECT_FALSE(s3.open("/dev/null"));
  EXPECT_EQ(s1.last_error(), ::csdb::Storage::DatabaseError);
  EXPECT_EQ(s1.db_last_error(), ::csdb::Database::IOError);

  EXPECT_EQ(s4.last_error(), ::csdb::Storage::NoError);
  EXPECT_FALSE(s4.last_error_message().empty());
  EXPECT_EQ(s4.db_last_error(), ::csdb::Database::NotOpen);
  EXPECT_FALSE(s4.db_last_error_message().empty());

  s4 = s1;
  EXPECT_EQ(s4.last_error(), ::csdb::Storage::DatabaseError);
  EXPECT_EQ(s4.db_last_error(), ::csdb::Database::IOError);

  EXPECT_EQ(s2.last_error(), ::csdb::Storage::NoError);
  EXPECT_FALSE(s2.last_error_message().empty());
  EXPECT_EQ(s2.db_last_error(), ::csdb::Database::NotOpen);
  EXPECT_FALSE(s2.db_last_error_message().empty());

  s4 = ::csdb::Storage();
  EXPECT_EQ(s4.last_error(), ::csdb::Storage::NoError);
  EXPECT_FALSE(s4.last_error_message().empty());
  EXPECT_EQ(s4.db_last_error(), ::csdb::Database::NotOpen);
  EXPECT_FALSE(s4.db_last_error_message().empty());

  EXPECT_EQ(s1.last_error(), ::csdb::Storage::DatabaseError);
  EXPECT_EQ(s1.db_last_error(), ::csdb::Database::IOError);
}

TEST_F(StorageTest, OpenDefaultLocation)
{
  bool callback_called = false;
  // We need to use callback to prevent rescan of potetialy existing default database
  auto callback = [&callback_called](const Storage::OpenProgress&)
  {
    callback_called = true;
    return true;
  };

  ::csdb::Storage s;
  EXPECT_TRUE(s.open(std::string{}, callback));
  if (callback_called) {
    EXPECT_FALSE(s.isOpen());
    EXPECT_EQ(s.last_error(), ::csdb::Storage::UserCancelled);
  }
  else {
    EXPECT_TRUE(s.isOpen());
    EXPECT_EQ(s.last_error(), ::csdb::Storage::NoError);
    EXPECT_EQ(s.db_last_error(), ::csdb::Database::NoError);
  }

  s.close();
  callback_called = false;
  s = ::csdb::Storage::get(std::string{}, callback);
  if (callback_called) {
    EXPECT_FALSE(s.isOpen());
    EXPECT_EQ(s.last_error(), ::csdb::Storage::UserCancelled);
    callback_called = false;
  }
  else {
    EXPECT_TRUE(s.isOpen());
    EXPECT_EQ(s.last_error(), ::csdb::Storage::NoError);
    EXPECT_EQ(s.db_last_error(), ::csdb::Database::NoError);
  }
}

TEST_F(StorageTestEmpty, WeakPtr)
{
  ::std::shared_ptr<Storage> storage = ::std::make_shared<Storage>();
  EXPECT_TRUE(storage->open(path_to_tests));
  EXPECT_TRUE(storage->isOpen());

  Storage::WeakPtr wp = storage->weak_ptr();
  ASSERT_FALSE(wp.expired());
  {
    Storage s(wp);
    EXPECT_TRUE(s.isOpen());
  }

  storage->close();
  ASSERT_FALSE(wp.expired());
  {
    Storage s(wp);
    EXPECT_FALSE(s.isOpen());
  }

  storage.reset();
  ASSERT_TRUE(wp.expired());
  {
    Storage s(wp);
    EXPECT_FALSE(s.isOpen());
    EXPECT_EQ(s.last_error(), Storage::NoError);
  }
};

TEST_F(StorageTestEmpty, RetrieveTransaction)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool p1{PoolHash{}, 0};
  ASSERT_TRUE(p1.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 10_c), true));
  ASSERT_TRUE(p1.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 20_c), true));
  ASSERT_TRUE(p1.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 30_c), true));
  ASSERT_TRUE(p1.compose());

  ::std::map<TransactionID, Transaction> trans1;
  for (size_t i = 0; i < p1.transactions_count(); ++i) {
    Transaction t = p1.transaction(i);
    trans1.emplace(t.id(), t);
  }

  Pool p2{p1.hash(), 1};
  ASSERT_TRUE(p2.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 1.01_c), true));
  ASSERT_TRUE(p2.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 1.02_c), true));
  ASSERT_TRUE(p2.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 1.03_c), true));
  ASSERT_TRUE(p2.compose());

  ::std::map<TransactionID, Transaction> trans2;
  for (size_t i = 0; i < p2.transactions_count(); ++i) {
    Transaction t = p2.transaction(i);
    trans2.emplace(t.id(), t);
  }

  // Пока не записан ни один пул - все результаты должны быть инвалидны
  for (auto& it : trans1) {
    Transaction t = s.transaction(it.first);
    EXPECT_FALSE(t.is_valid());
  }

  for (auto& it : trans2) {
    Transaction t = s.transaction(it.first);
    EXPECT_FALSE(t.is_valid());
  }

  // Запишем первый пул
  ASSERT_TRUE(s.pool_save(p1));
  for (auto& it : trans1) {
    Transaction t = s.transaction(it.first);
    EXPECT_TRUE(t.is_valid());
    EXPECT_EQ(t, it.second);
  }

  for (auto& it : trans2) {
    Transaction t = s.transaction(it.first);
    EXPECT_FALSE(t.is_valid());
  }

  // Запишем второй пул
  ASSERT_TRUE(s.pool_save(p2));
  for (auto& it : trans1) {
    Transaction t = s.transaction(it.first);
    EXPECT_TRUE(t.is_valid());
    EXPECT_EQ(t, it.second);
  }

  for (auto& it : trans2) {
    Transaction t = s.transaction(it.first);
    EXPECT_TRUE(t.is_valid());
    EXPECT_EQ(t, it.second);
  }
}

//
// Get by source & target
//

TEST_F(StorageTestEmpty, GetTransactionBySourceAndTarget)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool p1{PoolHash{}, 0};
  ASSERT_TRUE(p1.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 112_c), true));
  ASSERT_TRUE(p1.add_transaction(Transaction(addr1, addr3, Currency("RUB"), 113_c), true));
  ASSERT_TRUE(p1.compose());

  Pool p2{p1.hash(), 1};
  ASSERT_TRUE(p2.add_transaction(Transaction(addr2, addr1, Currency("RUB"), 221_c), true));
  ASSERT_TRUE(p2.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 223_c), true));
  ASSERT_TRUE(p2.compose());

  Pool p3{p2.hash(), 2};
  ASSERT_TRUE(p3.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 331_c), true));
  ASSERT_TRUE(p3.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 333_c), true));
  ASSERT_TRUE(p3.compose());

  ASSERT_TRUE(s.pool_save(p1));
  ASSERT_TRUE(s.pool_save(p2));
  ASSERT_TRUE(s.pool_save(p3));

  EXPECT_EQ(s.get_last_by_source(addr3).amount(), 333_c);
  EXPECT_EQ(s.get_last_by_source(addr2).amount(), 223_c);
  EXPECT_EQ(s.get_last_by_source(addr1).amount(), 113_c);

  EXPECT_EQ(s.get_last_by_target(addr3).amount(), 223_c);
  EXPECT_EQ(s.get_last_by_target(addr2).amount(), 112_c);
  EXPECT_EQ(s.get_last_by_target(addr1).amount(), 333_c);

  ::csdb::Address addr4 = ::csdb::Address::from_string("0000000000000000000000000000000000000004");
  EXPECT_FALSE(s.get_last_by_source(addr4).is_valid());
  EXPECT_FALSE(s.get_last_by_target(addr4).is_valid());
}```
# ..\node\csdb\unittests\csdb_unit_tests_transaction.cpp 
```cpp 
#include "csdb/transaction.h"

#include <cstring>
#include <iostream>

#include <gtest/gtest.h>

#include "csdb_unit_tests_environment.h"
#include "binary_streams.h"

class TransactionIDTest : public ::testing::Test
{
};

class TransactionTest : public ::testing::Test
{
protected:
  void SetUp() override
  {
    EXPECT_TRUE(addr1.is_valid());
    EXPECT_TRUE(addr2.is_valid());
    EXPECT_TRUE(addr3.is_valid());
    EXPECT_NE(addr1, addr2);
    EXPECT_NE(addr2, addr3);
  }

protected:
  ::csdb::Address addr1 = ::csdb::Address::from_string("0000000000000000000000000000000000000000");
  ::csdb::Address addr2 = ::csdb::Address::from_string("0000000000000000000000000000000000000001");
  ::csdb::Address addr3 = ::csdb::Address::from_string("0000000000000000000000000000000000000002");
};

using namespace csdb;

TEST_F(TransactionIDTest, ToStringZeroTerminated)
{
  /// \todo Исключить использование этого конструктора TransactionID
  ::std::string str = TransactionID(PoolHash::calc_from_data({1,2,3}), 0).to_string();
  EXPECT_EQ(str.size(), strlen(str.c_str()));
}

TEST_F(TransactionIDTest, FromValidString)
{
  /// \todo Исключить использование этого конструктора TransactionID
  TransactionID id1{PoolHash::calc_from_data({1,2,3}), 0};
  TransactionID id2{PoolHash::calc_from_data({1,2,3}), 1};

  TransactionID id3 = TransactionID::from_string(id1.to_string());
  TransactionID id4 = TransactionID::from_string(id2.to_string());

  EXPECT_TRUE(id1.is_valid());
  EXPECT_TRUE(id2.is_valid());
  EXPECT_TRUE(id3.is_valid());
  EXPECT_TRUE(id4.is_valid());

  EXPECT_NE(id1.to_string(), id2.to_string());
  EXPECT_EQ(id1, id3);
  EXPECT_EQ(id2, id4);
  EXPECT_NE(id1, id2);
  EXPECT_NE(id3, id4);
}

TEST_F(TransactionIDTest, FromInvalidString)
{
  /// \todo Исключить использование этого конструктора TransactionID
  ::std::string valid = TransactionID(PoolHash::calc_from_data({1,2,3}), 0).to_string();
  auto pos = valid.find(':');
  ASSERT_NE(::std::string::npos, pos);

  {
    ::std::string invalid{valid, 0, pos};
    EXPECT_FALSE(TransactionID::from_string(invalid).is_valid());
  }

  {
    ::std::string invalid{valid, 0, pos + 1};
    EXPECT_FALSE(TransactionID::from_string(invalid).is_valid());
  }

  {
    EXPECT_FALSE(TransactionID::from_string(valid + "A").is_valid());
  }

  {
    ::std::string invalid{valid, 1};
    EXPECT_FALSE(TransactionID::from_string(invalid).is_valid());
  }
}

TEST_F(TransactionTest, SimpleCreation)
{
  EXPECT_FALSE(Transaction().is_valid());
  EXPECT_TRUE(Transaction(addr1, addr2, Currency("CS"), 1_c).is_valid());
  EXPECT_FALSE(Transaction(addr1, addr1, Currency("CS"), 1_c).is_valid());
  EXPECT_FALSE(Transaction(addr1, addr2, Currency("CS"), 0_c).is_valid());
}

TEST_F(TransactionTest, CreateAndMakeValid)
{
  Transaction t;
  EXPECT_FALSE(t.is_valid());
  t.set_source(addr1);
  EXPECT_FALSE(t.is_valid());
  t.set_target(addr2);
  EXPECT_FALSE(t.is_valid());
  t.set_currency(Currency("CS"));
  EXPECT_FALSE(t.is_valid());
  t.set_amount(0.01_c);
  EXPECT_TRUE(t.is_valid());
}

TEST_F(TransactionTest, InternalComparator)
{
  EXPECT_EQ(Transaction(), Transaction());
  EXPECT_EQ(Transaction(addr1, addr2, Currency("CS"), 1_c), Transaction(addr1, addr2, Currency("CS"), 1_c));
  EXPECT_NE(Transaction(addr1, addr2, Currency("CS"), 1_c), Transaction(addr1, addr2, Currency("CS"), 2_c));
  EXPECT_NE(Transaction(addr1, addr2, Currency("CS"), 1_c), Transaction(addr1, addr2, Currency("CS1"), 1_c));
  EXPECT_NE(Transaction(addr1, addr2, Currency("CS"), 1_c), Transaction(addr1, addr3, Currency("CS"), 1_c));

  Transaction t1(addr1, addr2, Currency("CS"), 1_c);
  Transaction t2(t1);
  EXPECT_EQ(t1, t2);
  EXPECT_TRUE(t1.add_user_field(UFID_COMMENT, "Comment"));
  EXPECT_NE(t1, t2);
  EXPECT_TRUE(t2.add_user_field(UFID_COMMENT, "Comment"));
  EXPECT_EQ(t1, t2);
  EXPECT_TRUE(t2.add_user_field(UFID_COMMENT, 123.456_c));
  EXPECT_NE(t1, t2);
}

TEST_F(TransactionTest, ToBinaryInvalid)
{
  EXPECT_TRUE(Transaction().to_binary().empty());
  EXPECT_TRUE(Transaction(addr1, addr2, Currency("CS"), 0_c).to_binary().empty());
  EXPECT_TRUE(Transaction(addr1, addr1, Currency("CS"), 0_c).to_binary().empty());
}

TEST_F(TransactionTest, ToFromBinaryValid)
{
  Transaction sample1(addr1, addr2, Currency("CS"), 1_c);
  Transaction sample2(addr2, addr1, Currency("CS"), 1_c);
  EXPECT_NE(sample1, sample2);
  ::csdb::internal::byte_array enc1 = sample1.to_binary();
  ::csdb::internal::byte_array enc2 = sample2.to_binary();
  EXPECT_FALSE(enc1.empty());
  EXPECT_FALSE(enc2.empty());
  EXPECT_NE(enc1, enc2);

  Transaction t1 = Transaction::from_binary(enc1);
  Transaction t2 = Transaction::from_binary(enc2);
  EXPECT_TRUE(t1.is_valid());
  EXPECT_TRUE(t2.is_valid());
  EXPECT_EQ(t1, sample1);
  EXPECT_EQ(t2, sample2);
}

TEST_F(TransactionTest, FromBinaryInvalid)
{
  EXPECT_FALSE(Transaction::from_binary({}).is_valid());
  EXPECT_FALSE(Transaction::from_binary({1,2,3}).is_valid());

  ::csdb::internal::byte_array valid = Transaction(addr1, addr2, Currency("CS"), 1_c).to_binary();
  EXPECT_FALSE(valid.empty());

  {
    ::csdb::internal::byte_array invalid(valid);
    invalid.resize(invalid.size() - 1);
    EXPECT_FALSE(Transaction::from_binary(invalid).is_valid());
  }

  {
    ::csdb::internal::byte_array invalid(valid);
    invalid[0] = ~invalid[0];
    EXPECT_FALSE(Transaction::from_binary(invalid).is_valid());
  }
}

TEST_F(TransactionTest, UserFieldAdd)
{
  Transaction t(addr1, addr2, Currency("CS"), 1_c);
  EXPECT_EQ(t.user_field_ids(), ::std::set<user_field_id_t>({}));
  EXPECT_TRUE(t.add_user_field(1, 100));
  EXPECT_TRUE(t.add_user_field(2, "Text"));
  EXPECT_TRUE(t.add_user_field(3, 123.456_c));
  EXPECT_EQ(t.user_field_ids(), ::std::set<user_field_id_t>({1,2,3}));
  EXPECT_EQ(t.user_field(1), UserField(100));
  EXPECT_EQ(t.user_field(2), UserField("Text"));
  EXPECT_EQ(t.user_field(3), UserField(123.456_c));
  EXPECT_EQ(t.user_field(4), UserField());
}

TEST_F(TransactionTest, UserFieldSerialize)
{
  Transaction src(addr1, addr2, Currency("CS"), 1_c);
  EXPECT_EQ(src.user_field_ids(), ::std::set<user_field_id_t>({}));
  EXPECT_TRUE(src.add_user_field(1, 100));
  EXPECT_TRUE(src.add_user_field(2, "Text"));
  EXPECT_TRUE(src.add_user_field(3, 123.456_c));
  EXPECT_EQ(src.user_field_ids(), ::std::set<user_field_id_t>({1,2,3}));
  EXPECT_EQ(src.user_field(1), UserField(100));
  EXPECT_EQ(src.user_field(2), UserField("Text"));
  EXPECT_EQ(src.user_field(3), UserField(123.456_c));
  EXPECT_EQ(src.user_field(4), UserField());

  ::csdb::internal::byte_array enc = src.to_binary();
  EXPECT_FALSE(enc.empty());

  Transaction res = Transaction::from_binary(enc);
  EXPECT_TRUE(res.is_valid());
  EXPECT_EQ(res.user_field_ids(), ::std::set<user_field_id_t>({1,2,3}));
  EXPECT_EQ(res.user_field(1), UserField(100));
  EXPECT_EQ(res.user_field(2), UserField("Text"));
  EXPECT_EQ(res.user_field(3), UserField(123.456_c));
  EXPECT_EQ(res.user_field(4), UserField());
  EXPECT_EQ(src, res);
}

TEST_F(TransactionTest, Balance)
{
  {
    Transaction t{addr1, addr2, Currency("CS"), 1.23_c};
    EXPECT_TRUE(t.is_valid());
    EXPECT_EQ(t.amount(), 1.23_c);
    EXPECT_EQ(t.balance(), 1.23_c);
    t.set_balance(4.56_c);
    EXPECT_EQ(t.amount(), 1.23_c);
    EXPECT_EQ(t.balance(), 4.56_c);
  }

  {
    Transaction t1{addr1, addr2, Currency("CS"), 1.23_c, 4.56_c};
    EXPECT_TRUE(t1.is_valid());
    EXPECT_EQ(t1.amount(), 1.23_c);
    EXPECT_EQ(t1.balance(), 4.56_c);

    Transaction t2 = Transaction::from_binary(t1.to_binary());
    EXPECT_TRUE(t2.is_valid());
    EXPECT_EQ(t2.amount(), 1.23_c);
    EXPECT_EQ(t2.balance(), 4.56_c);

    t2.set_balance(7.89_c);
    EXPECT_EQ(t2.amount(), 1.23_c);
    EXPECT_EQ(t2.balance(), 7.89_c);
    EXPECT_EQ(t1.balance(), 4.56_c);
  }
}

TEST_F(TransactionTest, PreventReadOnlyModification)
{
  Pool p{PoolHash{}, 0};
  ASSERT_TRUE(p.is_valid());
  ASSERT_TRUE(p.add_transaction(Transaction{addr1, addr2, Currency("CS"), 1_c}, true));

  Transaction t = p.transaction(0);
  ASSERT_TRUE(t.is_valid());
  ASSERT_FALSE(t.id().is_valid());

  ASSERT_TRUE(p.compose());
  t = p.transaction(0);
  EXPECT_TRUE(t.is_valid());
  EXPECT_TRUE(t.is_read_only());
  EXPECT_TRUE(t.id().is_valid());

  Amount save = t.amount();
  t.set_amount(save + 1_c);
  EXPECT_EQ(t.amount(), save);

  save = t.balance();
  t.set_balance(save + 1_c);
  EXPECT_EQ(t.balance(), save);
}

TEST_F(TransactionTest, DropIDThenAddingToPool)
{
  Pool p_src{PoolHash{}, 0};
  ASSERT_TRUE(p_src.is_valid());
  ASSERT_TRUE(p_src.add_transaction(Transaction{addr1, addr2, Currency("CS"), 1_c}, true));
  ASSERT_TRUE(p_src.compose());

  Transaction t_src = p_src.transaction(0);
  EXPECT_TRUE(t_src.is_valid());
  EXPECT_TRUE(t_src.is_read_only());
  EXPECT_TRUE(t_src.id().is_valid());

  Pool p_dst{PoolHash{}, 1};
  ASSERT_TRUE(p_dst.is_valid());
  ASSERT_TRUE(p_dst.add_transaction(t_src, true));

  Transaction t_dst = p_dst.transaction(0);
  EXPECT_TRUE(t_dst.is_valid());
  EXPECT_EQ(t_src, t_dst);
  EXPECT_FALSE(t_dst.id().is_valid());

  ASSERT_TRUE(p_dst.compose());
  t_dst = p_dst.transaction(0);
  EXPECT_TRUE(t_dst.is_valid());
  EXPECT_EQ(t_src, t_dst);
  EXPECT_TRUE(t_dst.id().is_valid());
  EXPECT_NE(t_src.id(), t_dst.id());
}
```
# ..\node\csdb\unittests\csdb_unit_tests_user_field.cpp 
```cpp 
#include "csdb/user_field.h"

#include <iostream>

#include "csdb_unit_tests_environment.h"

#include "csdb/internal/types.h"
#include "binary_streams.h"

class UserFieldTest : public ::testing::Test
{
protected:
  ::csdb::internal::byte_array encode(::csdb::UserField source)
  {
    ::csdb::priv::obstream os;
    os.put(source);
    return os.buffer();
  }

  bool decode(::csdb::UserField& result, const ::csdb::internal::byte_array& source)
  {
    ::csdb::priv::ibstream is(source.data(), source.size());
    return is.get(result) && is.empty();
  }
};

class UserFieldSerializationTest : public UserFieldTest,
                                   public ::testing::WithParamInterface<::csdb::UserField>
{
};

using namespace ::csdb;

TEST_F(UserFieldTest, Construction)
{
  {
    UserField f;
    EXPECT_FALSE(f.is_valid());
    EXPECT_EQ(f.type(), UserField::Unknown);
    EXPECT_EQ(f.value<int>(), 0);
    EXPECT_TRUE(f.value<::std::string>().empty());
    EXPECT_EQ(f.value<Amount>(), 0_c);
  }

  {
    UserField f(true);
    EXPECT_TRUE(f.is_valid());
    EXPECT_EQ(f.type(), UserField::Integer);
    EXPECT_NE(f.value<int>(), 0);
    EXPECT_TRUE(f.value<bool>());
    EXPECT_TRUE(f.value<::std::string>().empty());
    EXPECT_EQ(f.value<Amount>(), 0_c);
  }

  {
    UserField f('A');
    EXPECT_TRUE(f.is_valid());
    EXPECT_EQ(f.type(), UserField::Integer);
    EXPECT_EQ(f.value<char>(), 'A');
    EXPECT_TRUE(f.value<::std::string>().empty());
    EXPECT_EQ(f.value<Amount>(), 0_c);
  }

  {
    UserField f(-1);
    EXPECT_TRUE(f.is_valid());
    EXPECT_EQ(f.type(), UserField::Integer);
    EXPECT_EQ(f.value<int>(), -1);
    EXPECT_TRUE(f.value<::std::string>().empty());
    EXPECT_EQ(f.value<Amount>(), 0_c);
  }

  {
    UserField f(std::string("Test string"));
    EXPECT_TRUE(f.is_valid());
    EXPECT_EQ(f.type(), UserField::String);
    EXPECT_EQ(f.value<int>(), 0);
    EXPECT_EQ(f.value<::std::string>(), "Test string");
    EXPECT_EQ(f.value<Amount>(), 0_c);
  }

  {
    UserField f("Test string");
    EXPECT_TRUE(f.is_valid());
    EXPECT_EQ(f.type(), UserField::String);
    EXPECT_EQ(f.value<int>(), 0);
    EXPECT_EQ(f.value<::std::string>(), "Test string");
    EXPECT_EQ(f.value<Amount>(), 0_c);
  }

  {
    UserField f(-123.456_c);
    EXPECT_TRUE(f.is_valid());
    EXPECT_EQ(f.type(), UserField::Amount);
    EXPECT_EQ(f.value<int>(), 0);
    EXPECT_TRUE(f.value<::std::string>().empty());
    EXPECT_EQ(f.value<Amount>(), -123.456_c);
  }
}

TEST_F(UserFieldTest, SerializeInvalid)
{
  UserField f;
  EXPECT_FALSE(f.is_valid());
  EXPECT_TRUE(encode(f).empty());
}

TEST_P(UserFieldSerializationTest, Valid)
{
  UserField src = GetParam();
  EXPECT_TRUE(src.is_valid());

  ::csdb::internal::byte_array enc = encode(src);
  EXPECT_FALSE(enc.empty());

  UserField res;
  EXPECT_FALSE(res.is_valid());
  EXPECT_TRUE(decode(res, enc));
  EXPECT_EQ(src, res);
}

TEST_P(UserFieldSerializationTest, Truncate)
{
  UserField src = GetParam();
  EXPECT_TRUE(src.is_valid());

  ::csdb::internal::byte_array valid = encode(src);
  EXPECT_FALSE(valid.empty());

  ::csdb::internal::byte_array invalid(valid);
  invalid.resize(invalid.size() - 1);

  {
    UserField res(1);
    EXPECT_FALSE(decode(res, invalid));
    EXPECT_EQ(res, UserField(1));
  }

  {
    UserField res("Test string");
    EXPECT_FALSE(decode(res, invalid));
    EXPECT_EQ(res, UserField("Test string"));
  }

  {
    UserField res(123.456_c);
    EXPECT_FALSE(decode(res, invalid));
    EXPECT_EQ(res, UserField(123.456_c));
  }
}

TEST_P(UserFieldSerializationTest, Corrupt)
{
  UserField src = GetParam();
  EXPECT_TRUE(src.is_valid());

  ::csdb::internal::byte_array valid = encode(src);
  EXPECT_FALSE(valid.empty());

  ::csdb::internal::byte_array invalid(valid);
  invalid[0] = ~invalid[0];

  {
    UserField res(1);
    EXPECT_FALSE(decode(res, invalid));
    EXPECT_EQ(res, UserField(1));
  }

  {
    UserField res("Test string");
    EXPECT_FALSE(decode(res, invalid));
    EXPECT_EQ(res, UserField("Test string"));
  }

  {
    UserField res(123.456_c);
    EXPECT_FALSE(decode(res, invalid));
    EXPECT_EQ(res, UserField(123.456_c));
  }
}

INSTANTIATE_TEST_CASE_P(, UserFieldSerializationTest, ::testing::Values(
  UserField(true),
  UserField(false),
  UserField(0),
  UserField(-1),
  UserField(1),
  UserField("Test string"),
  UserField(123.456_c)
));
```
# ..\node\csdb\unittests\csdb_unit_tests_utils.cpp 
```cpp 
#include "csdb/internal/utils.h"
#include <fstream>
#include <gtest/gtest.h>

namespace
{

bool make_file(const std::string &path, size_t size = 0)
{
  std::ofstream os(path);
  if (!os.is_open()) {
    return false;
  }

  if (0 != size) {
    os << ::std::string(size, '\0');
  }

  return true;
}

}

class UtilsTest : public ::testing::Test
{
};

using namespace csdb;

TEST_F(UtilsTest, FromHex)
{
  const internal::byte_array a{0x45, 0xAB};
  EXPECT_EQ(internal::from_hex("45AB"), a);
  EXPECT_EQ(internal::from_hex("45ABXX12"), a);
}

TEST_F(UtilsTest, ToHex)
{
  const internal::byte_array a{0x45, 0xAB};
  EXPECT_EQ( internal::to_hex(a), "45AB");

  const internal::byte_array b{0x45, 0xAB, 0xDE, 0x3A};
  EXPECT_EQ(internal::to_hex(b), "45ABDE3A");
}

TEST_F(UtilsTest, PathAddSeparator)
{
#ifdef _MSC_VER
# define SEP "\\"
#else
# define SEP "/"
#endif
  EXPECT_EQ(internal::path_add_separator(""), "");
  EXPECT_EQ(internal::path_add_separator("a"), "a" SEP);
  EXPECT_EQ(internal::path_add_separator("a/"), "a/");
  EXPECT_EQ(internal::path_add_separator("a\\"), "a\\");
  EXPECT_EQ(internal::path_add_separator("a\\a/a"), "a\\a/a" SEP);
  EXPECT_EQ(internal::path_add_separator("a\\a/a/"), "a\\a/a/");
  EXPECT_EQ(internal::path_add_separator("a\\a/a\\"), "a\\a/a\\");
}

TEST_F(UtilsTest, DataDir)
{
  EXPECT_FALSE(internal::app_data_path().empty());
}

TEST_F(UtilsTest, Exists)
{
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path()));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "dir_not_found/"));

  const std::string filename = internal::app_data_path() + "file";
  EXPECT_TRUE(make_file(filename));
  EXPECT_FALSE(internal::dir_exists(filename));
  EXPECT_TRUE(internal::file_exists(filename));
  EXPECT_TRUE(internal::file_remove(filename));
  EXPECT_FALSE(internal::file_exists(filename));
}

TEST_F(UtilsTest, OperationDir)
{
  EXPECT_TRUE(internal::dir_make(internal::app_data_path() + "dir"));
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path() + "dir"));

  EXPECT_TRUE(internal::dir_remove(internal::app_data_path() + "dir"));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "dir"));

  EXPECT_FALSE(internal::dir_make(internal::app_data_path() + "dir/dir"));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "dir/dir"));
}

TEST_F(UtilsTest, OperationPath)
{
  EXPECT_TRUE(internal::path_make(internal::app_data_path() + "a/b/c/"));
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path() + "a/b/c/"));

  EXPECT_TRUE(internal::path_remove(internal::app_data_path() + "a/b/c/"));
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path() + "a/b/"));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "a/b/c/"));

  EXPECT_TRUE(make_file(internal::app_data_path() + "a/b/file"));
  EXPECT_TRUE(internal::file_exists(internal::app_data_path() + "a/b/file"));

  EXPECT_TRUE(internal::path_remove(internal::app_data_path() + "a/"));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "a/"));

  EXPECT_FALSE(internal::file_exists(internal::app_data_path() + "a/b/file"));

  EXPECT_TRUE(internal::path_make(internal::app_data_path() + "a/b/c"));
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path() + "a/b/c"));

  EXPECT_TRUE(internal::path_remove(internal::app_data_path() + "a/b/c"));
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path() + "a/b"));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "a/b/c"));

  EXPECT_TRUE(make_file(internal::app_data_path() + "a/b/file"));
  EXPECT_TRUE(internal::file_exists(internal::app_data_path() + "a/b/file"));

  EXPECT_TRUE(internal::path_remove(internal::app_data_path() + "a"));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "a"));

  EXPECT_FALSE(internal::file_exists(internal::app_data_path() + "a/b/file"));
}

TEST_F(UtilsTest, FileSize)
{
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path()));
  EXPECT_TRUE(internal::path_make(internal::app_data_path() + "a/b"));
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path() + "a/b"));
  EXPECT_TRUE(make_file(internal::app_data_path() + "a/b/file", 100));
  EXPECT_TRUE(internal::file_exists(internal::app_data_path() + "a/b/file"));
  EXPECT_EQ(internal::file_size(internal::app_data_path() + "a/b/file"), static_cast<size_t>(100));
  EXPECT_FALSE(internal::file_exists(internal::app_data_path() + "a/b/file/"));
  EXPECT_EQ(internal::file_size(internal::app_data_path() + "a/b/file/"), static_cast<size_t>(-1));
  EXPECT_FALSE(internal::file_exists(internal::app_data_path() + "a/b"));
  EXPECT_EQ(internal::file_size(internal::app_data_path() + "a/b"), static_cast<size_t>(-1));

  EXPECT_TRUE(internal::path_remove(internal::app_data_path() + "a"));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "a"));
}

TEST_F(UtilsTest, PathSize)
{
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path()));
  EXPECT_TRUE(internal::path_make(internal::app_data_path() + "a/b/c"));
  EXPECT_TRUE(internal::dir_exists(internal::app_data_path() + "a/b/c"));

  EXPECT_TRUE(make_file(internal::app_data_path() + "a/b/file1", 1));
  EXPECT_TRUE(internal::file_exists(internal::app_data_path() + "a/b/file1"));
  EXPECT_EQ(internal::file_size(internal::app_data_path() + "a/b/file1"), static_cast<size_t>(1));

  EXPECT_TRUE(make_file(internal::app_data_path() + "a/b/file2", 2));
  EXPECT_TRUE(internal::file_exists(internal::app_data_path() + "a/b/file2"));
  EXPECT_EQ(internal::file_size(internal::app_data_path() + "a/b/file2"), static_cast<size_t>(2));

  EXPECT_TRUE(make_file(internal::app_data_path() + "a/b/c/file1", 4));
  EXPECT_TRUE(internal::file_exists(internal::app_data_path() + "a/b/c/file1"));
  EXPECT_EQ(internal::file_size(internal::app_data_path() + "a/b/c/file1"), static_cast<size_t>(4));

  EXPECT_TRUE(make_file(internal::app_data_path() + "a/b/c/file2", 8));
  EXPECT_TRUE(internal::file_exists(internal::app_data_path() + "a/b/c/file2"));
  EXPECT_EQ(internal::file_size(internal::app_data_path() + "a/b/c/file2"), static_cast<size_t>(8));

  EXPECT_EQ(internal::path_size(internal::app_data_path() + "a/b/c/file1"), static_cast<size_t>(4));
  EXPECT_EQ(internal::path_size(internal::app_data_path() + "a/b/c/file2"), static_cast<size_t>(8));
  EXPECT_EQ(internal::path_size(internal::app_data_path() + "a/b/c/"), static_cast<size_t>(12));
  EXPECT_EQ(internal::path_size(internal::app_data_path() + "a/b/c"), static_cast<size_t>(12));

  EXPECT_EQ(internal::path_size(internal::app_data_path() + "a/b/file1"), static_cast<size_t>(1));
  EXPECT_EQ(internal::path_size(internal::app_data_path() + "a/b/file2"), static_cast<size_t>(2));
  EXPECT_EQ(internal::path_size(internal::app_data_path() + "a/b/"), static_cast<size_t>(15));
  EXPECT_EQ(internal::path_size(internal::app_data_path() + "a/b"), static_cast<size_t>(15));

  EXPECT_TRUE(internal::path_remove(internal::app_data_path() + "a"));
  EXPECT_FALSE(internal::dir_exists(internal::app_data_path() + "a"));
}
```
# ..\node\csdb\unittests\csdb_unit_tests_wallet.cpp 
```cpp 
#include "csdb/wallet.h"

#include "csdb_unit_tests_environment.h"

#include "csdb/internal/utils.h"

class WalletTest : public ::testing::Test
{
protected:
  WalletTest() :
    path_to_tests_(::csdb::internal::app_data_path() + "csdb_unittests_wallet")
  {
  }

  void TearDown() override
  {
    ASSERT_TRUE(::csdb::internal::path_remove(path_to_tests_));
  }

  ::std::string path_to_tests_;
  ::csdb::Address addr1 = ::csdb::Address::from_string("0000000000000000000000000000000000000000");
  ::csdb::Address addr2 = ::csdb::Address::from_string("0000000000000000000000000000000000000001");
  ::csdb::Address addr3 = ::csdb::Address::from_string("0000000000000000000000000000000000000002");
};

using namespace ::csdb;

TEST_F(WalletTest, Empty)
{
  Wallet w;
  EXPECT_FALSE(w.is_valid());
  EXPECT_FALSE(w.address().is_valid());
  EXPECT_TRUE(w.currencies().empty());
  EXPECT_EQ(w.amount(Currency("RUB")), 0_c);
}

TEST_F(WalletTest, ClosedStorage)
{
  Storage s;
  Wallet w = Wallet::get(addr1, s);
  EXPECT_FALSE(w.is_valid());
  EXPECT_FALSE(w.address().is_valid());
  EXPECT_TRUE(w.currencies().empty());
  EXPECT_EQ(w.amount(Currency("RUB")), 0_c);
}

TEST_F(WalletTest, EmptyStorage)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));

  Wallet w = Wallet::get(addr1, s);
  EXPECT_TRUE(w.is_valid());
  EXPECT_TRUE(w.address().is_valid());
  EXPECT_TRUE(w.currencies().empty());
  EXPECT_EQ(w.amount(Currency("RUB")), 0_c);
}

TEST_F(WalletTest, OnePool)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool p1{s.last_hash(), 0, s};
  ASSERT_TRUE(p1.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 10_c), true));
  ASSERT_TRUE(p1.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 20_c), true));
  ASSERT_TRUE(p1.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 30_c), true));
  ASSERT_TRUE(p1.compose());
  ASSERT_TRUE(p1.save());

  Wallet w1 = Wallet::get(addr1, s);
  EXPECT_TRUE(w1.is_valid());
  EXPECT_TRUE(w1.address().is_valid());
  EXPECT_EQ(w1.currencies().size(), static_cast<size_t>(1));
  EXPECT_EQ(w1.amount(Currency("RUB")), 20_c);

  Wallet w2 = Wallet::get(addr2, s);
  EXPECT_TRUE(w2.is_valid());
  EXPECT_TRUE(w2.address().is_valid());
  EXPECT_EQ(w2.currencies().size(), static_cast<size_t>(1));
  EXPECT_EQ(w2.amount(Currency("RUB")), -10_c);

  Wallet w3 = Wallet::get(addr3, s);
  EXPECT_TRUE(w3.is_valid());
  EXPECT_TRUE(w3.address().is_valid());
  EXPECT_EQ(w3.currencies().size(), static_cast<size_t>(1));
  EXPECT_EQ(w3.amount(Currency("RUB")), -10_c);
}

TEST_F(WalletTest, MultiPoolOneCurrency)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool p{s.last_hash(), 0, s};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 10_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 20_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 30_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 300_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 200_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 150_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  Wallet w1 = Wallet::get(addr1, s);
  EXPECT_TRUE(w1.is_valid());
  EXPECT_TRUE(w1.address().is_valid());
  EXPECT_EQ(w1.currencies().size(), static_cast<size_t>(1));
  EXPECT_EQ(w1.amount(Currency("RUB")), -130_c);

  Wallet w2 = Wallet::get(addr2, s);
  EXPECT_TRUE(w2.is_valid());
  EXPECT_TRUE(w2.address().is_valid());
  EXPECT_EQ(w2.currencies().size(), static_cast<size_t>(1));
  EXPECT_EQ(w2.amount(Currency("RUB")), 90_c);

  Wallet w3 = Wallet::get(addr3, s);
  EXPECT_TRUE(w3.is_valid());
  EXPECT_TRUE(w3.address().is_valid());
  EXPECT_EQ(w3.currencies().size(), static_cast<size_t>(1));
  EXPECT_EQ(w3.amount(Currency("RUB")), 40_c);
}

TEST_F(WalletTest, MultiPoolMultiCurrency)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool p{s.last_hash(), 0, s};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 10_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 20_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 30_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 300_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 200_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 150_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("USD"), 0.05_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("USD"), 0.06_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("USD"), 0.07_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("USD"), 0.19_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("USD"), 0.18_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("USD"), 0.09_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  Wallet w1 = Wallet::get(addr1, s);
  EXPECT_TRUE(w1.is_valid());
  EXPECT_TRUE(w1.address().is_valid());
  EXPECT_EQ(w1.currencies().size(), static_cast<size_t>(2));
  EXPECT_EQ(w1.amount(Currency("RUB")), -130_c);
  EXPECT_EQ(w1.amount(Currency("USD")), -0.08_c);

  Wallet w2 = Wallet::get(addr2, s);
  EXPECT_TRUE(w2.is_valid());
  EXPECT_TRUE(w2.address().is_valid());
  EXPECT_EQ(w2.currencies().size(), static_cast<size_t>(2));
  EXPECT_EQ(w2.amount(Currency("RUB")), 90_c);
  EXPECT_EQ(w2.amount(Currency("USD")), 0_c);

  Wallet w3 = Wallet::get(addr3, s);
  EXPECT_TRUE(w3.is_valid());
  EXPECT_TRUE(w3.address().is_valid());
  EXPECT_EQ(w3.currencies().size(), static_cast<size_t>(2));
  EXPECT_EQ(w3.amount(Currency("RUB")), 40_c);
  EXPECT_EQ(w3.amount(Currency("USD")), 0.08_c);
}

TEST_F(WalletTest, UnexistingAddress)
{
  Storage s;
  ASSERT_TRUE(s.open(path_to_tests_));
  ASSERT_TRUE(s.last_hash().is_empty());

  Pool p{s.last_hash(), 0, s};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 10_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 20_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 30_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("RUB"), 300_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("RUB"), 200_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("RUB"), 150_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("USD"), 0.05_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("USD"), 0.06_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("USD"), 0.07_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  p = Pool{p.hash(), p.sequence() + 1, p.storage()};
  ASSERT_TRUE(p.add_transaction(Transaction(addr1, addr2, Currency("USD"), 0.19_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr2, addr3, Currency("USD"), 0.18_c), true));
  ASSERT_TRUE(p.add_transaction(Transaction(addr3, addr1, Currency("USD"), 0.09_c), true));
  ASSERT_TRUE(p.compose());
  ASSERT_TRUE(p.save());
  ASSERT_EQ(s.last_hash(), p.hash());

  ::csdb::internal::byte_array ukey = addr1.public_key();
  EXPECT_FALSE(ukey.empty());
  ukey[0] = ~ukey[0];

  Wallet w = Wallet::get(Address::from_public_key(ukey), s);
  EXPECT_TRUE(w.is_valid());
  EXPECT_TRUE(w.address().is_valid());
  EXPECT_EQ(w.currencies().size(), static_cast<size_t>(0));
}
```
# ..\node\csnode\include\csnode\bitheap.hpp 
```cpp 
#ifndef BITHEAP_H
#define BITHEAP_H

#include <bitset>
#include <climits>
#include <limits>

namespace cs {
template <typename T, size_t BitSize = sizeof(T) * CHAR_BIT, typename = std::enable_if<std::is_integral<T>::value>>
class BitHeap {
public:
    using MinMaxRange = std::pair<T, T>;

public:
    BitHeap()
    : greatest_(std::numeric_limits<T>::max())
    , isValueSet_(false) {
    }

    void push(T val) {
        if (!isValueSet_) {
            greatest_ = val;
            isValueSet_ = true;
            return;
        }

        if (val > greatest_) {
            T shift = val - greatest_;
            bits_ <<= shift;
            // curr greatest
            size_t ind = shift - 1;
            if (ind < BitSize)
                bits_.set(ind);
            // new greatest
            greatest_ = val;
        }
        else if (val < greatest_) {
            size_t ind = greatest_ - val - 1;
            if (ind < BitSize)
                bits_.set(ind);
        }
    }

    void pop(T val) {
        if (val < greatest_) {
            size_t ind = greatest_ - val - 1;
            if (ind < BitSize) {
                bits_.reset(ind);
            }
            return;
        }
        if (val == greatest_) {
            --greatest_;
            int count = BitSize;
            while (!bits_[0] && count--) {
                bits_ >>= 1;
                --greatest_;
            }
            if (count < 0) {
                isValueSet_ = false;
                return;
            }
            bits_ >>= 1;
        }
    }

    bool empty() const {
        return !isValueSet_;
    }

    MinMaxRange minMaxRange() const {
        return std::make_pair(greatest_ - BitSize, greatest_);
    }

    bool contains(T val) const {
        if (val > greatest_)
            return false;
        else if (val == greatest_)
            return true;
        else {
            size_t ind = greatest_ - val - 1;
            if (ind < BitSize)
                return bits_.test(ind) == 1;
            else
                return false;
        }
    }

    size_t count() const {
        if (empty())
            return 0;
        else
            return 1 + bits_.count();
    }

private:
    T greatest_;
    uint8_t isValueSet_;
    std::bitset<BitSize> bits_;
};

}  // namespace cs

#endif
```
# ..\node\csnode\include\csnode\blockchain.hpp 
```cpp 
#ifndef BLOCKCHAIN_HPP
#define BLOCKCHAIN_HPP

#include <list>
#include <map>
#include <memory>
#include <mutex>
#include <vector>

#include <fstream>
#include <iostream>
#include <string>

#include <boost/dynamic_bitset.hpp>

#include <csdb/address.hpp>
#include <csdb/amount.hpp>
#include <csdb/amount_commission.hpp>
#include <csdb/pool.hpp>
#include <csdb/storage.hpp>

#include <csdb/internal/types.hpp>
#include <csnode/nodecore.hpp>
#include <csnode/walletscache.hpp>
#include <csnode/walletsids.hpp>
#include <csnode/walletspools.hpp>

#include <lib/system/concurrent.hpp>

#include <condition_variable>
#include <mutex>

namespace cs {
class BlockHashes;
class WalletsIds;
class Fee;
class TransactionsPacket;
class BlockValidator;

/** @brief   The new block signal emits when finalizeBlock() occurs just before recordBlock() */
using StoreBlockSignal = cs::Signal<void(const csdb::Pool&)>;

/** @brief   The write block or remove block signal emits when block is flushed to disk */
using ChangeBlockSignal = cs::Signal<void(const cs::Sequence)>;
using ReadBlockSignal = csdb::ReadBlockSignal;
}  // namespace cs

class BlockChain {
public:
    using Transactions = std::vector<csdb::Transaction>;
    using WalletId = csdb::internal::WalletId;
    using WalletAddress = csdb::Address;
    using WalletData = cs::WalletsCache::WalletData;
    using Mask = boost::dynamic_bitset<uint64_t>;

    enum class AddressType {
        PublicKey,
        Id
    };

    explicit BlockChain(csdb::Address genesisAddress, csdb::Address startAddress);
    ~BlockChain();

    bool init(const std::string& path);
    bool isGood() const;

    // return unique id of database if at least one unique block has written, otherwise (only genesis block) 0
    uint64_t uuid() const;

    // utility methods

    csdb::Address getAddressByType(const csdb::Address& addr, AddressType type) const;
    bool isEqual(const csdb::Address& laddr, const csdb::Address& raddr) const;

    static csdb::Address getAddressFromKey(const std::string&);

    // create/save block and related methods

    /**
     * @fn    bool BlockChain::storeBlock(csdb::Pool pool, bool by_sync);
     *
     * @brief Stores a block
     *
     * @author    Alexander Avramenko
     * @date  23.11.2018
     *
     * @param pool    The pool representing block to store in blockchain. Its sequence number MUST be
     *                set. It will be modified.
     * @param by_sync False if block is new, just constructed, true if block is received via sync subsystem.
     *                False - addNewWalletsToPool() called. If true updateWalletIds() called.
     *
     * @return    True if it succeeds, false if it fails. True DOES NOT MEAN the block recorded to
     *            chain. It means block is correct and possibly recorded. If it is not recorded now, it is cached
     *            for future use and will be recorded on time
     */

    bool storeBlock(csdb::Pool& pool, bool bySync);

    /**
     * @fn    std::optional<csdb::Pool> BlockChain::createBlock(csdb::Pool pool);
     *
     * @brief Creates a block and records to blockchain
     *
     * @author    Alexander Avramenko
     * @date  23.11.2018
     *
     * @param pool    The pool.
     *
     * @return    The new recorded block if ok, otherwise nullopt.
     */

    std::optional<csdb::Pool> createBlock(csdb::Pool pool) {
        return recordBlock(pool, true);
    }

    void removeWalletsInPoolFromCache(const csdb::Pool& pool);
    void removeLastBlock();

    // updates fees in every transaction
    void setTransactionsFees(cs::TransactionsPacket& packet);
    void setTransactionsFees(csdb::Pool& pool);
    void setTransactionsFees(std::vector<csdb::Transaction>& transactions);
    void setTransactionsFees(std::vector<csdb::Transaction>& transactions, const cs::Bytes& characteristicMask);

    void addNewWalletsToPool(csdb::Pool& pool);

    // storage adaptor
    void close();
    bool getTransaction(const csdb::Address& addr, const int64_t& innerId, csdb::Transaction& result) const;

public:
    /**
     * @fn    std::size_t BlockChain::getCachedBlocksSize() const;
     *
     * @brief Gets amount of cached blocks
     *
     * @author    Alexander Avramenko
     * @date  06.12.2018
     *
     * @return    The cached blocks amount.
     */

    std::size_t getCachedBlocksSize() const;

    // continuous interval from ... to
    using SequenceInterval = std::pair<cs::Sequence, cs::Sequence>;

    /**
     * @fn    std::vector<SequenceInterval> BlockChain::getReqiredBlocks() const;
     *
     * @brief Gets required blocks in form vector of intervals. Starts with last written block and view through all cached
     * ones. Each interval means [first..second] including bounds. Last interval ends with current round number
     *
     * @author    Alexander Avramenko
     * @date  23.11.2018
     *
     * @return    The required blocks in form vector of intervals
     */

    std::vector<SequenceInterval> getRequiredBlocks() const;

    /**
     * @fn    void BlockChain::testCachedBlocks();
     *
     * @brief Tests cached blocks: removes outdated, records actual until sequence interrupted
     *
     * @author    Alexander Avramenko
     * @date  23.11.2018
     */

    void testCachedBlocks();

public signals:

    /** @brief The new block event. Raised when the next incoming block is finalized and just before stored into chain */
    cs::StoreBlockSignal storeBlockEvent;

    /** @brief The cached block event. Raised when the next block is flushed to storage */
    cs::ChangeBlockSignal cachedBlockEvent;

    /** @brief The remove block event. Raised when the next block is flushed to storage */
    cs::ChangeBlockSignal removeBlockEvent;

    const cs::ReadBlockSignal& readBlockEvent() const;

public slots:

    // prototype is void (csdb::Transaction)
    // subscription is placed in SmartContracts constructor
    void onPayableContractReplenish(const csdb::Transaction& starter) {
        this->walletsCacheUpdater_->invokeReplenishPayableContract(starter);
    }
    void onPayableContractTimeout(const csdb::Transaction& starter) {
        this->walletsCacheUpdater_->rollbackReplenishPayableContract(starter);
    }
    void onContractEmittedAccepted(const csdb::Transaction& emitted, const csdb::Transaction& starter) {
        this->walletsCacheUpdater_->smartSourceTransactionReleased(emitted, starter);
    }

public:

    // load methods

    csdb::Pool loadBlock(const csdb::PoolHash&) const;
    csdb::Pool loadBlock(const cs::Sequence sequence) const;
    csdb::Pool loadBlockMeta(const csdb::PoolHash&, size_t& cnt) const;
    csdb::Transaction loadTransaction(const csdb::TransactionID&) const;
    void iterateOverWallets(const std::function<bool(const cs::WalletsCache::WalletData::Address&, const cs::WalletsCache::WalletData&)>);
    csdb::Pool getLastBlock() const {
        return loadBlock(getLastSequence());
    }

    // info

    size_t getSize() const;
    uint64_t getWalletsCountWithBalance();
    csdb::PoolHash getLastHash() const;
    cs::Sequence getLastSequence() const;
    csdb::PoolHash getHashBySequence(cs::Sequence seq) const;

    // get inner data (from caches)

    bool findWalletData(const csdb::Address&, WalletData& wallData, WalletId& id) const;
    bool findWalletData(WalletId id, WalletData& wallData) const;
    bool findWalletId(const WalletAddress& address, WalletId& id) const;
    // wallet transactions: pools cache + db search
    void getTransactions(Transactions& transactions, csdb::Address address, uint64_t offset, uint64_t limit);
    // wallets modified by last new block
    bool getModifiedWallets(Mask& dest) const;

#ifdef MONITOR_NODE
    void iterateOverWriters(const std::function<bool(const cs::WalletsCache::WalletData::Address&, const cs::WalletsCache::TrustedData&)>);
    void applyToWallet(const csdb::Address&, const std::function<void(const cs::WalletsCache::WalletData&)>); 
#endif
	uint32_t getTransactionsCount(const csdb::Address&);

#ifdef TRANSACTIONS_INDEX
    csdb::TransactionID getLastTransaction(const csdb::Address&);
    csdb::PoolHash getPreviousPoolHash(const csdb::Address&, const csdb::PoolHash&);

    std::pair<csdb::PoolHash, uint32_t> getLastNonEmptyBlock();
    std::pair<csdb::PoolHash, uint32_t> getPreviousNonEmptyBlock(const csdb::PoolHash&);
    uint64_t getTransactionsCount() const {
        return total_transactions_count_;
    }
#endif

    const csdb::Address& getGenesisAddress() const;

private:
    bool findAddrByWalletId(const WalletId id, csdb::Address& addr) const;

    void writeGenesisBlock();
#ifdef TRANSACTIONS_INDEX
    void createTransactionsIndex(csdb::Pool&);
#endif

    void logBlockInfo(csdb::Pool& pool);

    // Thread unsafe
    bool finalizeBlock(csdb::Pool& pool, bool isTrusted, cs::PublicKeys lastConfidants);

    void onReadFromDB(csdb::Pool block, bool* shouldStop);
    bool postInitFromDB();

    template <typename WalletCacheProcessor>
    bool updateWalletIds(const csdb::Pool& pool, WalletCacheProcessor& proc);
    bool insertNewWalletId(const csdb::Address& newWallAddress, WalletId newWalletId, cs::WalletsCache::Initer& initer);
    bool insertNewWalletId(const csdb::Address& newWallAddress, WalletId newWalletId, cs::WalletsCache::Updater& updater);

    void addNewWalletToPool(const csdb::Address& walletAddress, const csdb::Pool::NewWalletInfo::AddressId& addressId, csdb::Pool::NewWallets& newWallets);

    bool updateFromNextBlock(csdb::Pool& pool);

    // returns true if new id was inserted
    bool getWalletId(const WalletAddress& address, WalletId& id);
    bool findWalletData_Unsafe(WalletId id, WalletData& wallData) const;

    class TransactionsLoader;

    bool findDataForTransactions(csdb::Address address, csdb::Address& wallPubKey, WalletId& id, cs::WalletsPools::WalletData::PoolsHashes& hashesArray) const;

    void getTransactions(Transactions& transactions, csdb::Address wallPubKey, WalletId id, const cs::WalletsPools::WalletData::PoolsHashes& hashesArray, uint64_t offset,
                         uint64_t limit);

    bool good_;

    mutable std::recursive_mutex dbLock_;
    csdb::Storage storage_;

    std::unique_ptr<cs::BlockHashes> blockHashes_;

    const csdb::Address genesisAddress_;
    const csdb::Address startAddress_;
    std::unique_ptr<cs::WalletsIds> walletIds_;
    std::unique_ptr<cs::WalletsCache> walletsCacheStorage_;
    std::unique_ptr<cs::WalletsCache::Updater> walletsCacheUpdater_;
    std::unique_ptr<cs::WalletsPools> walletsPools_;
    mutable cs::SpinLock cacheMutex_{ATOMIC_FLAG_INIT};

#ifdef TRANSACTIONS_INDEX
    uint64_t total_transactions_count_ = 0;

    struct NonEmptyBlockData {
        csdb::PoolHash hash;
        uint32_t transCount = 0;
    };
    std::map<csdb::PoolHash, NonEmptyBlockData> previousNonEmpty_;

    NonEmptyBlockData lastNonEmptyBlock_;
#endif

    /**
     * @fn    std::optional<csdb::Pool> BlockChain::recordBlock(csdb::Pool pool, std::optional<cs::PrivateKey> writer_key);
     *
     * @brief Finish pool, sign it or test signature, then record block to chain
     *
     * @author    Alexander Avramenko
     * @date  23.11.2018
     *
     * @param pool    The pool to finish &amp; record to chain.
     *
     * @return    A std::pair of bool (success or fail) and std::optional&lt;csdb::Pool&gt; (recorded
     *            pool)
     */

    std::optional<csdb::Pool> recordBlock(csdb::Pool& pool, bool isTrusted);

    // to store outrunning blocks until the time to insert comes;
    // stores pairs of <sequence, metadata>
    struct BlockMeta {
        csdb::Pool pool;
        // indicates that block has got by sync, so it is checked & tested in other way than ordinary ones
        bool by_sync;
    };
    std::map<cs::Sequence, BlockMeta> cachedBlocks_;

    // block storage to defer storing it in blockchain until confirmation from other nodes got
    // (idea is it is more easy not to store block immediately then to revert it after storing)
    csdb::Pool deferredBlock_;

    std::unique_ptr<cs::BlockValidator> blockValidator_;

    uint64_t uuidFromHash(const csdb::PoolHash& h) const {
        if (!h.is_empty()) {
            return *reinterpret_cast<uint64_t*>(h.to_binary().data());
        }
        return 0;
    }

    uint64_t uuidFromBlock(const csdb::Pool& block) const {
        if (block.is_valid()) {
            return uuidFromHash(block.hash());
        }
        return 0;
    }

    //uint64_t initUuid() const;

    // may be modified once in uuid() method:
    mutable uint64_t uuid_ = 0;
};

class TransactionsIterator {
public:
    TransactionsIterator(BlockChain&, const csdb::Address&);

    void next();
    bool isValid() const;

    const csdb::Pool& getPool() const {
        return lapoo_;
    }

    const csdb::Transaction& operator*() const {
        return *it_;
    }
    auto operator-> () const {
        return it_;
    }

private:
#ifdef TRANSACTIONS_INDEX
    void setFromTransId(const csdb::TransactionID&);
#else
    void setFromHash(const csdb::PoolHash&);
#endif

    BlockChain& bc_;

    csdb::Address addr_;
    csdb::Pool lapoo_;
    std::vector<csdb::Transaction>::const_reverse_iterator it_;
};

#endif  //  BLOCKCHAIN_HPP
```
# ..\node\csnode\include\csnode\blockhashes.hpp 
```cpp 
#ifndef BLOCKHASHES_HPP
#define BLOCKHASHES_HPP

#include <csdb/pool.hpp>
#include <vector>

namespace cs {
class BlockHashes {
public:
    struct DbStructure {
        cs::Sequence first_;
        cs::Sequence last_;
    };

public:
    BlockHashes();

    const DbStructure& getDbStructure() const {
        return db_;
    }

    bool empty() const {
        return hashes_.empty();
    }

    void initStart();
    bool initFromPrevBlock(csdb::Pool prevBlock);
    void initFinish();
    bool loadNextBlock(csdb::Pool nextBlock);

    csdb::PoolHash find(cs::Sequence seq) const;

    cs::Sequence find(csdb::PoolHash hash) const;

    csdb::PoolHash removeLast();

    csdb::PoolHash getLast() const;

    const std::vector<csdb::PoolHash>& getHashes() const;

private:
    std::vector<csdb::PoolHash> hashes_;

    DbStructure db_;
    bool isDbInited_;
};
}  // namespace cs

#endif  //  BLOCKHASHES_HPP
```
# ..\node\csnode\include\csnode\blockvalidator.hpp 
```cpp 
#ifndef BLOCK_VALIDATOR_HPP
#define BLOCK_VALIDATOR_HPP

#include <map>
#include <memory>

#include <csdb/pool.hpp>

class BlockChain;

namespace cs {

class ValidationPlugin;
class WalletsState;

class BlockValidator {
public:
    using ValidationFlags = uint32_t;

    enum ValidationLevel : uint32_t {
        noValidation = 0,
        hashIntergrity = 1,
        blockNum = 1 << 1,
        timestamp = 1 << 2,
        blockSignatures = 1 << 3,
        smartSignatures = 1 << 4,
        balances = 1 << 5,
        transactionsSignatures = 1 << 6
    };

    enum SeverityLevel : uint8_t {
        warningsAsErrors = 1,
        greaterThanWarnings,
        onlyFatalErrors
    };

    explicit BlockValidator(const BlockChain&);
    ~BlockValidator();
    bool validateBlock(const csdb::Pool&, ValidationFlags = hashIntergrity, SeverityLevel = greaterThanWarnings);

    BlockValidator(const BlockValidator&) = delete;
    BlockValidator(BlockValidator&&) = delete;
    BlockValidator& operator=(const BlockValidator&) = delete;
    BlockValidator& operator=(BlockValidator&&) = delete;

private:
    enum ErrorType : uint8_t {
        noError = 0,
        warning = 1 << 1,
        error = 1 << 2,
        fatalError = 1 << 3
    };

    bool return_(ErrorType, SeverityLevel);

    const BlockChain& bc_;
    std::map<ValidationLevel, std::unique_ptr<ValidationPlugin>> plugins_;

    friend class ValidationPlugin;

    std::shared_ptr<WalletsState> wallets_;
    csdb::Pool prevBlock_;
};
}  // namespace cs
#endif  // BLOCKVALIDATOR_HPP
```
# ..\node\csnode\include\csnode\blockvalidatorplugins.hpp 
```cpp 
#ifndef BLOCK_VALIDATOR_PLUGINS_HPP
#define BLOCK_VALIDATOR_PLUGINS_HPP

#include <vector>

#include <cscrypto/cryptotypes.hpp>
#include <csdb/amount.hpp>
#include <csdb/transaction.hpp>
#include <csnode/blockvalidator.hpp>
#include <csnode/transactionspacket.hpp>
#include <lib/system/common.hpp>

namespace cs {

class ValidationPlugin {
public:
    ValidationPlugin(BlockValidator& bv)
    : blockValidator_(bv) {
    }

    virtual ~ValidationPlugin() = default;

    using ErrorType = BlockValidator::ErrorType;
    virtual ErrorType validateBlock(const csdb::Pool&) = 0;

protected:
    const BlockChain& getBlockChain() {
        return blockValidator_.bc_;
    }
    auto getWallets() {
        return blockValidator_.wallets_;
    }
    auto& getPrevBlock() {
        return blockValidator_.prevBlock_;
    }

private:
    BlockValidator& blockValidator_;
};

class HashValidator : public ValidationPlugin {
public:
    HashValidator(BlockValidator& bv)
    : ValidationPlugin(bv) {
    }
    ErrorType validateBlock(const csdb::Pool&) override;
};

class BlockNumValidator : public ValidationPlugin {
public:
    BlockNumValidator(BlockValidator& bv)
    : ValidationPlugin(bv) {
    }
    ErrorType validateBlock(const csdb::Pool&) override;
};

class TimestampValidator : public ValidationPlugin {
public:
    TimestampValidator(BlockValidator& bv)
    : ValidationPlugin(bv) {
    }
    ErrorType validateBlock(const csdb::Pool&) override;
};

class BlockSignaturesValidator : public ValidationPlugin {
public:
    BlockSignaturesValidator(BlockValidator& bv)
    : ValidationPlugin(bv) {
    }
    ErrorType validateBlock(const csdb::Pool&) override;
};

class SmartSourceSignaturesValidator : public ValidationPlugin {
public:
    using Transactions = std::vector<csdb::Transaction>;
    using SmartSignatures = std::vector<csdb::Pool::SmartSignature>;
    using Packets = std::vector<cs::TransactionsPacket>;

    SmartSourceSignaturesValidator(BlockValidator& bv)
    : ValidationPlugin(bv) {
    }
    ErrorType validateBlock(const csdb::Pool&) override;

private:
    bool containsNewState(const Transactions&);
    Packets grepNewStatesPacks(const Transactions&, bool switchFees);
    bool checkSignatures(const SmartSignatures&, const Packets&);

    // must be performed if block version is 0
    // to pass validation
    csdb::Transaction switchCountedFee(const csdb::Transaction& newState);
};

///
/// @brief check balances when prev block was added to blockchain
///
class BalanceChecker : public ValidationPlugin {
public:
    BalanceChecker(BlockValidator& bv)
    : ValidationPlugin(bv) {
    }
    ErrorType validateBlock(const csdb::Pool&) override;

private:
    static constexpr csdb::Amount zeroBalance_ = 0;
};

class TransactionsChecker : public ValidationPlugin {
public:
    TransactionsChecker(BlockValidator& bv)
    : ValidationPlugin(bv) {
    }
    ErrorType validateBlock(const csdb::Pool&) override;

private:
    bool checkSignature(const csdb::Transaction&);
};
}  // namespace cs
#endif  // BLOCK_VALIDATOR_PLUGINS_HPP
```
# ..\node\csnode\include\csnode\confirmationlist.hpp 
```cpp 
#ifndef CONFIRMATIONLIST_HPP
#define CONFIRMATIONLIST_HPP

#include <csnode/nodecore.hpp>
#include <lib/system/common.hpp>

#include <map>
#include <optional>

namespace cs {
struct TrustedConfirmation {
    bool bigBang = false;
    cs::ConfidantsKeys confidants;
    cs::Bytes mask;
    cs::Signatures signatures;
};

class ConfirmationList {
public:
    void add(cs::RoundNumber rNum, bool bang, const cs::ConfidantsKeys& confidants, const cs::Bytes& confirmationsMask, const cs::Signatures& confirmation);
    void remove(cs::RoundNumber);
    std::optional<cs::TrustedConfirmation> find(cs::RoundNumber) const;

private:
    // confidant confirmation
    std::map<cs::RoundNumber, TrustedConfirmation> confirmationList_;
};
}  // namespace cs

#endif  // CONFIRMATIONLIST_HPP
```
# ..\node\csnode\include\csnode\conveyer.hpp 
```cpp 
#ifndef CONVEYER_HPP
#define CONVEYER_HPP

#include <csnode/nodecore.hpp>
#include <csnode/packetqueue.hpp>

#include <lib/system/common.hpp>
#include <lib/system/signals.hpp>

#include <memory>
#include <optional>

namespace csdb {
class Transaction;
}

namespace cs {
using PacketFlushSignal = cs::Signal<void(const cs::TransactionsPacket&)>;

///
/// @brief The Conveyer class, represents utils and mechanics
/// to transfer packets of transactions, consensus helper.
///
class ConveyerBase {
protected:
    ConveyerBase();
    ~ConveyerBase();

public:
    enum class NotificationState {
        Equal,
        GreaterEqual
    };

    enum : unsigned int {
        HashTablesStorageCapacity = cs::values::kDefaultMetaStorageMaxSize,
        CharacteristicMetaCapacity = HashTablesStorageCapacity,

        // queue
        MaxPacketTransactions = 100,
        MaxPacketsPerRound = 10,
        MaxQueueSize = 1000000
    };

    ///
    /// @brief Sets cached conveyer round number for utility.
    /// @warning Call this method before setTable method.
    ///
    void setRound(cs::RoundNumber round);

    ///
    /// @brief Adds transaction to conveyer, start point of conveyer.
    /// @param transaction csdb Transaction, not valid transavtion would not be
    /// sent to network.
    ///
    void addTransaction(const csdb::Transaction& transaction);

    ///
    /// @brief Adds packet to transactions block as monolith entity.
    /// @param packet Created from outside packet with transactions.
    ///
    void addSeparatePacket(const cs::TransactionsPacket& packet);

    ///
    /// @brief Adds transactions packet received by network.
    /// @param packet Created from network transactions packet.
    ///
    void addTransactionsPacket(const cs::TransactionsPacket& packet);

    ///
    /// @brief Returns current round transactions packet hash table.
    ///
    const cs::TransactionsPacketTable& transactionsPacketTable() const;

    ///
    /// @brief Returns transactions packet queue, first stage of conveyer.
    ///
    const cs::PacketQueue& packetQueue() const;

    ///
    /// @brief Returns pair of transactions packet created in current round and smart contract packets.
    /// @warning Slow-performance method. Thread safe.
    ///
    std::optional<std::pair<cs::TransactionsPacket, cs::Packets>> createPacket() const;

    // round info

    ///
    /// @brief Starts round of conveyer, checks all transactions packet hashes.
    /// at round table.
    /// @param table Current blockchain round table.
    /// @warning Call this method after setRound.
    ///
    void setTable(const cs::RoundTable& table);

    ///
    /// @fn void ConveyerBase::updateRoundTable(const cs::RoundTable& table).
    ///
    /// @brief Updates the round table described by table.
    ///
    /// @author Alexander Avramenko.
    /// @date  29.11.2018.
    ///
    /// @param cachedRound Remove conveyer meta storage to this point.
    /// @param [in,out]    table   The new round table contains trusted nodes and round number.
    /// @warning all meta in conveyer will be removed from cached round to table round number.
    ///
    void updateRoundTable(cs::RoundNumber cachedRound, const RoundTable& table);

    ///
    /// @brief Returns current blockchain round table.
    ///
    const cs::RoundTable& currentRoundTable() const;

    // confidants helpers

    ///
    /// @brief Returns current round confidants keys.
    ///
    const cs::ConfidantsKeys& confidants() const;

    ///
    /// @brief Returns current round confidants keys count.
    ///
    size_t confidantsCount() const;

    ///
    /// @brief Returns existing state of confidant by index at current round.
    ///
    bool isConfidantExists(size_t index) const;

    ///
    /// @brief Returns existing state of confidant by his public key.
    ///
    bool isConfidantExists(const cs::PublicKey& confidant) const;

    ///
    /// @brief Returns confidant key at current round table by index.
    /// @warning call isConfidantExits before using this method.
    ///
    const cs::PublicKey& confidantByIndex(size_t index) const;

    ///
    /// @brief Returns confidant public key if confidant exists in round table.
    /// @param index. Index of condifant.
    /// @warning Returns copy of public key.
    ///
    std::optional<cs::PublicKey> confidantIfExists(size_t index) const;

    // round information interfaces

    ///
    /// @brief Returns blockchain round table of Round key.
    /// @warning If round table does not exist in meta, returns nullptr.
    ///
    const cs::RoundTable* roundTable(cs::RoundNumber round) const;

    ///
    /// @brief Returns current round number.
    /// Returns copy of atomic round number.
    ///
    cs::RoundNumber currentRoundNumber() const;

    ///
    /// @brief Returns previous round number (special for characteristic and pool creation).
    ///
    cs::RoundNumber previousRoundNumber() const;

    ///
    /// @brief Returns current round needed hashes.
    ///
    const cs::PacketsHashes& currentNeededHashes() const;

    ///
    /// @brief Returns round needed hashes.
    /// @return returns cs::Hashes. If no hashes found returns nullptr.
    ///
    const cs::PacketsHashes* neededHashes(cs::RoundNumber round) const;

    ///
    /// @brief Adds synced packet to conveyer.
    ///
    void addFoundPacket(cs::RoundNumber round, cs::TransactionsPacket&& packet);

    ///
    /// @brief Returns state of current round hashes sync.
    /// Checks conveyer needed round hashes on empty state.
    ///
    bool isSyncCompleted() const;

    ///
    /// @brief Returns state of arg round hashes sync.
    ///
    bool isSyncCompleted(cs::RoundNumber round) const;

    // writer notifications

    ///
    /// @brief Returns confidants notifications to writer.
    ///
    const cs::Notifications& notifications() const;

    ///
    /// @brief Adds writer notification in bytes representation.
    /// @param bytes Received from network notification bytes.
    ///
    void addNotification(const cs::Bytes& bytes);

    ///
    /// @brief Returns count of needed writer notifications.
    ///
    std::size_t neededNotificationsCount() const;

    ///
    /// @brief Returns current notifications check of needed count.
    /// @param state Check state of notifications.
    ///
    bool isEnoughNotifications(NotificationState state) const;

    // characteristic meta

    ///
    /// @brief Adds characteristic meta if early characteristic recevied from network.
    /// @param meta Created on network characteristic meta information.
    ///
    void addCharacteristicMeta(cs::RoundNumber round, CharacteristicMeta&& characteristic);

    ///
    /// @brief Returns characteristic meta from storage if found otherwise return empty meta.
    /// @param round Current blockchain round.
    ///
    std::optional<cs::CharacteristicMeta> characteristicMeta(cs::RoundNumber round);

    // characteristic

    ///
    /// @brief Sets round characteristic function.
    /// @param characteristic Created characteristic on network level.
    ///
    void setCharacteristic(const Characteristic& characteristic, cs::RoundNumber round);

    ///
    /// @brief Returns current round characteristic.
    ///
    const cs::Characteristic* characteristic(cs::RoundNumber round) const;

    ///
    /// @brief Returns calcualted characteristic hash.
    ///
    cs::Hash characteristicHash(cs::RoundNumber round) const;

    ///
    /// @brief Applyies current round characteristic to create csdb::Pool.
    /// @param metaPoolInfo pool meta information.
    /// @param sender Sender public key.
    /// @return pool Returns created csdb::Pool, otherwise returns nothing.
    ///
    std::optional<csdb::Pool> applyCharacteristic(const cs::PoolMetaInfo& metaPoolInfo);

    // hash table storage

    ///
    /// @brief Searches transactions packet in current hash table, or in hash table storage.
    /// @param hash Created transactions packet hash.
    /// @return Returns transactions packet if its found, otherwise returns nothing.
    /// @warning No thread safe.
    ///
    std::optional<cs::TransactionsPacket> findPacket(const cs::TransactionsPacketHash& hash, const cs::RoundNumber round) const;

    ///
    /// @brief Returns existing of invalid transaction in meta storage.
    /// @param innerId of transaction to search equal transaction.
    /// @warning thread safe method.
    ///
    bool isMetaTransactionInvalid(int64_t id);

    ///
    /// @brief Returns summary block (first stage) transactions count that
    /// does not flushed to network. Thread safe method.
    ///
    size_t packetQueueTransactionsCount() const;

    // sync, try do not use it :]
    std::unique_lock<cs::SharedMutex> lock() const;

public signals:
    cs::PacketFlushSignal packetFlushed;

public slots:

    /// try to send transactions packets to network
    void flushTransactions();

protected:
    void removeHashesFromTable(const cs::PacketsHashes& hashes);
    cs::TransactionsPacketTable& poolTable(cs::RoundNumber round);

private:
    struct Impl;
    std::unique_ptr<Impl> pimpl_;

    mutable cs::SharedMutex sharedMutex_;
};

class Conveyer : public ConveyerBase {
public:
    ///
    /// @brief Instance of conveyer, singleton.
    /// @return Returns static conveyer object reference, Meyers singleton.
    ///
    static Conveyer& instance();

private:
    Conveyer()
    : ConveyerBase() {
    }

    ~Conveyer() = default;
};
}  // namespace cs

#endif  // CONVEYER_HPP
```
# ..\node\csnode\include\csnode\cyclicbuffer.hpp 
```cpp 
#ifndef CYCLIC_BUFFER_H
#define CYCLIC_BUFFER_H

#include <cstdint>

template <typename T, uint32_t N>
class CyclicBuffer {
public:
    CyclicBuffer()
    : size_(0)
    , back_(0) {
    }

    void push_back(const T& val) {
        back_ = (back_ + 1) % N;
        data_[back_] = val;
        ++size_;
    }

    T& back() {
        return data_[back_];
    }
    const T& back() const {
        return data_[back_];
    }

    void pop_back() {
        back_ = (back_ - 1 + N) % N;
        --size_;
    }

    void push_front(const T& val) {
        size_t ind = (back_ - size_ + N) % N;
        data_[ind] = val;
        ++size_;
    }

    T& front() {
        return data_[getFrontInd(0)];
    }
    const T& front() const {
        return data_[getFrontInd(0)];
    }

    void pop_front() {
        --size_;
    }

    T& operator[](size_t ind) {
        return data_[getFrontInd(ind)];
    }
    const T& operator[](size_t ind) const {
        return data_[getFrontInd(ind)];
    }

    bool full() const {
        return size_ == N;
    }
    bool empty() const {
        return !size_;
    }
    size_t size() const {
        return size_;
    }

private:
    size_t getFrontInd(size_t offset) const {
        decltype(N) frontInd = back_ + 1 - size_;
        return (frontInd + static_cast<decltype(N)>(offset) + N) % N;
    }

private:
    T data_[N];
    decltype(N) size_;
    decltype(N) back_;
};

#endif
```
# ..\node\csnode\include\csnode\datastream.hpp 
```cpp 
#ifndef DATASTREAM_HPP
#define DATASTREAM_HPP

#include <algorithm>
#include <csnode/nodecore.hpp>
#include <exception>
#include <string>
#include <type_traits>

#include <boost/asio/ip/udp.hpp>
#include <csdb/pool.hpp>

#include <lib/system/common.hpp>
#include <lib/system/structures.hpp>
#include <lib/system/utils.hpp>

namespace cs::csval {
const constexpr std::size_t v4Size = 4;
const constexpr std::size_t v6Size = 16;
}  // namespace cs::csval

namespace cs {
///
/// The Data stream class represents an entity that controls data from any char array.
///
class DataStream {
public:
    enum class Status {
        Read,
        Write
    };

    ///
    /// Constructors to read data from packet
    ///
    explicit DataStream(char* packet, std::size_t dataSize)
    : data_(packet)
    , index_(0)
    , dataSize_(dataSize) {
        head_ = data_;
    }

    explicit DataStream(const char* packet, std::size_t dataSize)
    : DataStream(const_cast<char*>(packet), dataSize) {
    }

    explicit DataStream(const uint8_t* packet, std::size_t dataSize)
    : DataStream(reinterpret_cast<const char*>(packet), dataSize) {
    }

    ///
    /// Constructor to write data
    ///
    explicit DataStream(cs::Bytes& storage)
    : bytes_(&storage) {
    }

    ///
    /// Try to get enpoint from data.
    ///
    /// @return Returns current end point from data.
    /// If data stream can not return valid enpoint then returns empty enpoint.
    ///
    boost::asio::ip::udp::endpoint parseEndpoint() {
        boost::asio::ip::udp::endpoint point;

        if (!isAvailable(sizeof(char))) {
            badState();
            return point;
        }

        char flags = *(data_ + index_);
        char v6 = flags & 1;
        char addressFlag = (flags >> 1) & 1;
        char portFlag = (flags >> 2) & 1;

        ++index_;

        std::size_t size = 0;

        if (addressFlag) {
            size += (v6) ? csval::v6Size : csval::v4Size;
        }

        if (portFlag) {
            size += sizeof(uint16_t);
        }

        if (!isAvailable(size)) {
            badState();
            return point;
        }

        boost::asio::ip::address address;

        if ((index_ + size) <= dataSize_) {
            if (addressFlag) {
                address = v6 ? boost::asio::ip::address(createAddress<boost::asio::ip::address_v6>()) : boost::asio::ip::address(createAddress<boost::asio::ip::address_v4>());
            }

            uint16_t port = 0;

            if (portFlag) {
                port = *(reinterpret_cast<uint16_t*>(data_ + index_));
                index_ += sizeof(uint16_t);
            }

            point = boost::asio::ip::udp::endpoint(address, port);
        }

        return point;
    }

    ///
    /// Returns current state of stream.
    ///
    /// @return Returns state of stream.
    ///
    bool isValid() const {
        if (index_ > dataSize_) {
            return false;
        }

        return state_;
    }

    ///
    /// Returns state of available bytes.
    ///
    /// @param size Count of bytes.
    /// @return Returns state of available bytes.
    ///
    bool isAvailable(std::size_t size) {
        return (index_ + size) <= dataSize_;
    }

    ///
    /// Returns pointer to start of the data.
    ///
    char* data() const {
        if (!bytes_) {
            return data_ + index_;
        }
        else {
            return reinterpret_cast<char*>(bytes_->data());
        }
    }

    ///
    /// Try to get field from stream by sizeof(T).
    ///
    /// @return Returns stream field.
    /// If stream can not return field than returns empty T().
    ///
    template <typename T>
    inline T parseValue() {
        if (!isAvailable(sizeof(T))) {
            badState();
            return T();
        }

        T field = cs::Utils::getFromArray<T>(data_, index_);
        index_ += sizeof(T);

        return field;
    }

    ///
    /// Try to add field to stream.
    ///
    /// @param streamField Added type.
    ///
    template <typename T>
    inline void addValue(const T& streamField) {
        if (bytes_) {
            const char* ptr = reinterpret_cast<const char*>(&streamField);

            for (std::size_t i = 0; i < sizeof(T); ++i) {
                bytes_->push_back(static_cast<cs::Byte>(*(ptr + i)));
            }
        }
    }

    ///
    /// Returns byte array from stream.
    ///
    /// @return Returns byte array.
    /// If stream can not return valid array than returns empty byte array.
    ///
    template <typename T, std::size_t size>
    inline std::array<T, size> parseArray() {
        std::array<T, size> array = {0};

        if (!isAvailable(size)) {
            badState();
            return array;
        }

        for (std::size_t i = 0; i < size; ++i) {
            array[i] = static_cast<T>(data_[i + index_]);
        }

        index_ += size;
        return array;
    }

    ///
    /// Adds char array to data stream.
    ///
    /// @param array Char array.
    ///
    template <typename T, std::size_t size>
    inline void addArray(const std::array<T, size>& array) {
        if (bytes_) {
            bytes_->insert(bytes_->end(), array.begin(), array.end());
        }
    }

    ///
    /// Adds fixed string to stream.
    ///
    /// @param fixedString Template FixedString.
    ///
    template <std::size_t size>
    inline void addFixedString(const FixedString<size>& fixedString) {
        if (bytes_) {
            bytes_->insert(bytes_->end(), fixedString.begin(), fixedString.end());
        }
    }

    ///
    /// Returns fixed string by template size.
    ///
    /// @return Returns template FixedString.
    /// If stream can not return available bytes size it returns zero FixedString.
    ///
    template <std::size_t size>
    inline FixedString<size> parseFixedString() {
        FixedString<size> str;

        if (!isAvailable(size)) {
            badState();
            return str;
        }

        for (std::size_t i = 0; i < size; ++i) {
            str[i] = data_[i + index_];
        }

        index_ += size;

        return str;
    }

    ///
    /// Returns byte size of write/read data.
    ///
    /// @return Returns data stream size.
    ///
    std::size_t size() const {
        if (!bytes_) {
            return dataSize_ - index_;
        }
        else {
            return bytes_->size();
        }
    }

    ///
    /// @brief Returns Read/Write status of stream.
    ///
    Status status() const {
        if (bytes_ != nullptr) {
            return Status::Write;
        }

        return Status::Read;
    }

    ///
    /// Adds enpoint to stream.
    ///
    /// @param enpoint Boost enpoint.
    ///
    void addEndpoint(const boost::asio::ip::udp::endpoint& endpoint) {
        if (!bytes_) {
            return;
        }

        char v6 = endpoint.address().is_v6();
        bytes_->push_back(static_cast<cs::Byte>((v6 | 6)));

        if (v6) {
            boost::asio::ip::address_v6::bytes_type bytes = endpoint.address().to_v6().to_bytes();
            addArray(bytes);
        }
        else {
            boost::asio::ip::address_v4::bytes_type bytes = endpoint.address().to_v4().to_bytes();
            addArray(bytes);
        }

        addValue(endpoint.port());
    }

    ///
    /// Skips compile time size.
    ///
    /// If stream can not skip size than it does nothing.
    ///
    template <std::size_t size>
    inline void skip() {
        if (!isAvailable(size)) {
            badState();
            return;
        }

        index_ += size;
    }

    ///
    /// Adds bytes vector to stream.
    /// @param data Vector of bytes to write.
    ///
    void addVector(const cs::Bytes& data) {
        if (bytes_) {
            addValue(data.size());
            bytes_->insert(bytes_->end(), data.begin(), data.end());
        }
    }

    ///
    /// Returns bytes vector.
    ///
    /// @return Returns byte vector.
    /// If stream can not return size of bytes it returns empty vector.
    ///
    cs::Bytes parseVector() {
        cs::Bytes result;

        if (!isAvailable(sizeof(std::size_t))) {
            badState();
            return result;
        }

        std::size_t size = parseValue<size_t>();

        if (isAvailable(size)) {
            result = cs::Bytes(data_ + index_, data_ + index_ + size);
            index_ += size;
        }
        else {
            badState();
        }

        return result;
    }

    ///
    /// Adds std::string chars to stream.
    ///
    /// @param string Any information represented as std::string.
    ///
    void addString(const std::string& string) {
        if (bytes_) {
            addValue(string.size());
            bytes_->insert(bytes_->end(), string.begin(), string.end());
        }
    }

    ///
    /// @return Returns std::string by arguments size.
    /// If stream can not return size of bytes it returns empty std::string.
    ///
    std::string parseString() {
        std::string result;

        if (!isAvailable(sizeof(std::size_t))) {
            badState();
            return result;
        }

        std::size_t size = parseValue<size_t>();

        if (isAvailable(size)) {
            result = std::string(data_ + index_, data_ + index_ + size);
            index_ += size;
        }
        else {
            badState();
        }

        return result;
    }

    ///
    /// @brief Adds bytesView entity to stream.
    ///
    void addBytesView(const cs::BytesView& bytesView) {
        if (bytes_) {
            addValue(bytesView.size());
            insertBytes(bytesView.data(), bytesView.size());
        }
    }

    ///
    /// @brief Returns BytesView entity if can, otherwise return empty object.
    ///
    cs::BytesView parseBytesView() {
        cs::BytesView bytesView;
        size_t size = parseValue<size_t>();

        if (isAvailable(size)) {
            bytesView = cs::BytesView(reinterpret_cast<cs::Byte*>(data_), size);
            index_ += size;
        }
        else {
            badState();
        }

        return bytesView;
    }

    ///
    /// Peeks next parameter.
    ///
    /// @return Returns next T parameter.
    ///
    template <typename T>
    inline const T& peek() const {
        return *(reinterpret_cast<T*>(data_ + index_));
    }

    ///
    /// @brief Converts to template entity if compile.
    /// @brief For parsing converts last not readed part.
    ///
    template <typename T>
    T convert() const {
        if (bytes_) {
            return T(bytes_->begin(), bytes_->end());
        }
        else {
            return T(data_, data_ + (dataSize_ - index_));
        }
    }

private:
    // attributes
    char* data_ = nullptr;
    char* head_ = nullptr;

    std::size_t index_ = 0;
    std::size_t dataSize_ = 0;
    bool state_ = true;

    // main storage
    cs::Bytes* bytes_ = nullptr;

    // creates template address
    template <typename T>
    T createAddress() {
        typename T::bytes_type bytes;

        for (std::size_t i = 0; i < bytes.size(); ++i, ++index_) {
            bytes[i] = static_cast<unsigned char>(data_[index_]);
        }

        return T(bytes);
    }

    void badState() {
        state_ = false;
    }

    void insertBytes(const char* data, std::size_t index) {
        if (bytes_) {
            bytes_->insert(bytes_->end(), data, data + index);
        }
    }

    void insertBytes(const cs::Byte* data, std::size_t size) {
        insertBytes(reinterpret_cast<const char*>(data), size);
    }
};

///
/// Get entities from stream operators
///
inline DataStream& operator>>(DataStream& stream, boost::asio::ip::udp::endpoint& endPoint) {
    endPoint = stream.parseEndpoint();
    return stream;
}

template <typename T, std::size_t size>
inline DataStream& operator>>(DataStream& stream, std::array<T, size>& array) {
    array = stream.template parseArray<T, size>();
    return stream;
}

template <typename T>
inline DataStream& operator>>(DataStream& stream, T& value) {
    static_assert(std::is_trivial_v<T>, "Template parameter to must be trivial. Overload this function for non-trivial type");
    value = stream.template parseValue<T>();
    return stream;
}

inline DataStream& operator>>(DataStream& stream, cs::Bytes& data) {
    data = stream.parseVector();
    return stream;
}

inline DataStream& operator>>(DataStream& stream, std::string& data) {
    data = stream.parseString();
    return stream;
}

template <std::size_t size>
inline DataStream& operator>>(DataStream& stream, FixedString<size>& fixedString) {
    fixedString = stream.template parseFixedString<size>();
    return stream;
}

inline DataStream& operator>>(DataStream& stream, cs::HashVector& hashVector) {
    stream >> hashVector.sender >> hashVector.hash >> hashVector.signature;
    return stream;
}

inline DataStream& operator>>(DataStream& stream, cs::HashMatrix& matrix) {
    stream >> matrix.sender;

    for (std::size_t i = 0; i < kHashVectorCount; ++i) {
        stream >> matrix.hashVector[i];
    }

    stream >> matrix.signature;
    return stream;
}

inline DataStream& operator>>(DataStream& stream, cs::TransactionsPacketHash& hash) {
    cs::Bytes bytes;
    stream >> bytes;

    if (!bytes.empty()) {
        hash = cs::TransactionsPacketHash::fromBinary(bytes);
    }

    return stream;
}

inline DataStream& operator>>(DataStream& stream, cs::TransactionsPacket& packet) {
    cs::Bytes bytes;
    stream >> bytes;

    if (!bytes.empty()) {
        packet = cs::TransactionsPacket::fromBinary(bytes);
    }

    return stream;
}

inline DataStream& operator>>(DataStream& stream, csdb::PoolHash& hash) {
    cs::Bytes bytes;
    stream >> bytes;

    if (!bytes.empty()) {
        hash = csdb::PoolHash::from_binary(std::move(bytes));
    }

    return stream;
}

inline DataStream& operator>>(DataStream& stream, csdb::Pool& pool) {
    cs::Bytes bytes;
    stream >> bytes;

    if (!bytes.empty()) {
        pool = csdb::Pool::from_binary(std::move(bytes));
    }

    return stream;
}

template <typename T, typename U>
inline DataStream& operator>>(DataStream& stream, std::vector<T, U>& entities) {
    std::size_t size;
    stream >> size;

    if (size == 0) {
        return stream;
    }

    std::vector<T, U> expectedEntities;
    expectedEntities.reserve(size);

    for (std::size_t i = 0; i < size; i++) {
        T entity;
        stream >> entity;

        expectedEntities.push_back(entity);
    }

    if (size != expectedEntities.size()) {
        cserror() << "Data stream parsing of vector: vector parsing failed";
    }

    entities = std::move(expectedEntities);
    return stream;
}

inline DataStream& operator>>(DataStream& stream, cs::BytesView& bytesView) {
    bytesView = stream.parseBytesView();
    return stream;
}

template <typename T, typename U>
inline DataStream& operator>>(DataStream& stream, std::pair<T, U>& pair) {
    stream >> pair.first;
    stream >> pair.second;
    return stream;
}

inline DataStream& operator>>(DataStream& stream, csdb::Amount& amount) {
    cs::Bytes bytes;
    stream >> bytes;

    if (stream.isValid()) {
        amount = csdb::Amount::fromBytes(bytes);
    }

    return stream;
}

///
/// Writes entities to stream operators
///
template <typename T, std::size_t size>
inline DataStream& operator<<(DataStream& stream, const std::array<T, size>& array) {
    stream.addArray(array);
    return stream;
}

template <typename T>
inline DataStream& operator<<(DataStream& stream, const T& value) {
    static_assert(std::is_trivial_v<T>, "Template parameter to must be trivial. Overload this function for non-trivial type");
    stream.addValue(value);
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const cs::Bytes& data) {
    stream.addVector(data);
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const boost::asio::ip::udp::endpoint& endpoint) {
    stream.addEndpoint(endpoint);
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const cs::TransactionsPacketHash& hash) {
    stream << hash.toBinary();
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const std::string& data) {
    stream.addString(data);
    return stream;
}

template <std::size_t size>
inline DataStream& operator<<(DataStream& stream, const FixedString<size>& fixedString) {
    stream.addFixedString(fixedString);
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const cs::HashVector& hashVector) {
    stream << hashVector.sender;
    stream << hashVector.hash;
    stream << hashVector.signature;
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const cs::HashMatrix& matrix) {
    stream << matrix.sender;

    for (std::size_t i = 0; i < kHashVectorCount; ++i) {
        stream << matrix.hashVector[i];
    }

    stream << matrix.signature;
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const cs::TransactionsPacket& packet) {
    stream << packet.toBinary();
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const csdb::PoolHash& hash) {
    stream << hash.to_binary();
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const csdb::Pool& pool) {
    uint32_t bSize;
    auto dataPtr = const_cast<csdb::Pool&>(pool).to_byte_stream(bSize);
    stream << cs::Bytes(dataPtr, dataPtr + bSize);
    return stream;
}

template <typename T, typename U>
inline DataStream& operator<<(DataStream& stream, const std::vector<T, U>& entities) {
    stream << entities.size();

    for (const auto& entity : entities) {
        stream << entity;
    }

    return stream;
}

inline DataStream& operator<<(DataStream& stream, const cs::BytesView& bytesView) {
    stream.addBytesView(bytesView);
    return stream;
}

template <typename T, typename U>
inline DataStream& operator<<(DataStream& stream, const std::pair<T, U>& pair) {
    stream << pair.first;
    stream << pair.second;
    return stream;
}

inline DataStream& operator<<(DataStream& stream, const csdb::Amount& amount) {
    stream << amount.toBytes();
    return stream;
}
}  // namespace cs

#endif  // DATASTREAM_HPP
```
# ..\node\csnode\include\csnode\dynamicbuffer.hpp 
```cpp 
#ifndef DYNAMICBUFFER_HPP
#define DYNAMICBUFFER_HPP

#include <cstddef>
#include <memory>

namespace csval {
const std::size_t defaultSize = 5000;
}

namespace cs {
///
/// RAII fixed dynamic memory c-array wrapper
///
class DynamicBuffer final {
public:
    explicit DynamicBuffer(std::size_t size = csval::defaultSize);
    explicit DynamicBuffer(const char* data, std::size_t size);
    explicit DynamicBuffer(const unsigned char* data, std::size_t size);

    DynamicBuffer(const DynamicBuffer& buffer);
    DynamicBuffer(DynamicBuffer&& buffer);

    DynamicBuffer& operator=(const DynamicBuffer& buffer);
    DynamicBuffer& operator=(DynamicBuffer&& buffer);

    ~DynamicBuffer();

    char& operator[](std::size_t index);
    const char& operator[](std::size_t index) const;

    ///
    /// Returns pointer to c-array
    ///
    char* get() const;

    ///
    /// get() method similar
    ///
    char* operator*() const;

    ///
    /// Returns c-array fixed size
    ///
    std::size_t size() const;

    // stl - like interace
    char* begin();
    char* end();
    const char* begin() const;
    const char* end() const;

private:
    char* array_ = nullptr;
    std::size_t size_ = 0;

    friend void swap(DynamicBuffer&, DynamicBuffer&);
};

bool operator==(const DynamicBuffer& lhs, const DynamicBuffer& rhs);
bool operator!=(const DynamicBuffer& lhs, const DynamicBuffer& rhs);

void swap(DynamicBuffer& lhs, DynamicBuffer& rhs);

///
/// Smart dynamic buffer
///
using DynamicBufferPtr = std::shared_ptr<DynamicBuffer>;
}  // namespace cs

#endif  // DYNAMICBUFFER_HPP
```
# ..\node\csnode\include\csnode\fee.hpp 
```cpp 
#ifndef SOLVER_FEE_HPP
#define SOLVER_FEE_HPP

#include <cstddef>
#include <vector>

#include <csdb/amount_commission.hpp>
#include <csdb/transaction.hpp>

namespace cs {
namespace fee {

using Transactions = std::vector<csdb::Transaction>;

///
/// @brief sets counted fee for each transaction in passed container
///
void setCountedFees(Transactions&);

///
/// @brief allows to estimate weather max fee is enough before consensus
/// @return true if max fee >= countedFee
///
bool estimateMaxFee(const csdb::Transaction&, csdb::AmountCommission& countedFee);

///
/// @return counted fee for transaction
///
csdb::AmountCommission getFee(const csdb::Transaction&);

} // namespace fee
} // namespace cs
#endif  // SOLVER_FEE_HPP
```
# ..\node\csnode\include\csnode\itervalidator.hpp 
```cpp 
#ifndef ITER_VALIDATOR_HPP
#define ITER_VALIDATOR_HPP

#include <memory>
#include <set>
#include <vector>

#include <csnode/nodecore.hpp>
#include <csnode/transactionsvalidator.hpp>
#include <lib/system/common.hpp>

namespace cs {
class SolverContext;
class WalletsState;

class IterValidator {
public:
    using Transactions = std::vector<csdb::Transaction>;

    IterValidator(WalletsState& wallets);
    Characteristic formCharacteristic(SolverContext&, Transactions&, Packets& smartsPackets);

private:
    bool validateTransactions(SolverContext&, Bytes& characteristicMask, const Transactions&);

    void checkRejectedSmarts(SolverContext&, Bytes& characteristicMask, const Transactions&);

    void checkSignaturesSmartSource(SolverContext&, Packets& smartContractsPackets);
    void checkTransactionsSignatures(SolverContext& context, const Transactions& transactions, Bytes& characteristicMask, Packets& smartsPackets);
    bool checkTransactionSignature(SolverContext& context, const csdb::Transaction& transaction);

    bool deployAdditionalCheck(SolverContext& context, size_t trxInd, const csdb::Transaction& transaction);

    std::unique_ptr<TransactionsValidator> pTransval_;
    std::set<csdb::Address> smartSourceInvalidSignatures_;
};
}  // namespace cs
#endif  // ITER_VALIDATOR_HPP
```
# ..\node\csnode\include\csnode\node.hpp 
```cpp 
#ifndef NODE_HPP
#define NODE_HPP

#include <iostream>
#include <memory>
#include <string>

#include <client/config.hpp>
#include <csconnector/csconnector.hpp>
#include <csstats.hpp>

#include <csnode/conveyer.hpp>
#include <lib/system/timer.hpp>

#include <net/neighbourhood.hpp>

#include "blockchain.hpp"
#include "confirmationlist.hpp"
#include "packstream.hpp"
#include "roundstat.hpp"

class Transport;

namespace cs {
class SolverCore;
}

namespace cs {
class PoolSynchronizer;
}  // namespace cs

class Node {
public:
    enum Level {
        Normal,
        Confidant,
        Main,
        Writer
    };

    enum MessageActions {
        Process,
        Postpone,
        Drop
    };

    using RefExecution = std::pair<cs::Sequence, uint32_t>;

    explicit Node(const Config&);
    ~Node();

    bool isGood() const {
        return good_;
    }

    void run();
    void stop();

    static void requestStop();

    std::string getSenderText(const cs::PublicKey& sender);

    // incoming requests processing
    void getBigBang(const uint8_t* data, const size_t size, const cs::RoundNumber rNum);
    void getRoundTableSS(const uint8_t* data, const size_t size, const cs::RoundNumber);
    void getTransactionsPacket(const uint8_t* data, const std::size_t size);
    void getNodeStopRequest(const cs::RoundNumber round, const uint8_t* data, const std::size_t size);
    bool canBeTrusted();

    // SOLVER3 methods
    void getRoundTable(const uint8_t* data, const size_t size, const cs::RoundNumber, const cs::PublicKey& sender);
    void sendHash(cs::RoundNumber round);
    void getHash(const uint8_t* data, const size_t size, cs::RoundNumber rNum, const cs::PublicKey& sender);
    void roundPackRequest(const cs::PublicKey& respondent, cs::RoundNumber round);
    void getRoundPackRequest(const uint8_t* data, const size_t size, cs::RoundNumber rNum, const cs::PublicKey& sender);
    void roundPackReply(const cs::PublicKey& respondent);
    void sendHashReply(const csdb::PoolHash& hash, const cs::PublicKey& respondent);
    void getHashReply(const uint8_t* data, const size_t size, cs::RoundNumber rNum, const cs::PublicKey& sender);

    // consensus communication
    void sendStageOne(cs::StageOne&);
    void sendStageTwo(cs::StageTwo&);
    void sendStageThree(cs::StageThree&);

    void getStageOne(const uint8_t* data, const size_t size, const cs::PublicKey& sender);
    void getStageTwo(const uint8_t* data, const size_t size, const cs::PublicKey& sender);
    void getStageThree(const uint8_t* data, const size_t size);

    void adjustStageThreeStorage();
    void stageRequest(MsgTypes msgType, uint8_t respondent, uint8_t required /*, uint8_t iteration*/);
    void getStageRequest(const MsgTypes msgType, const uint8_t* data, const size_t size, const cs::PublicKey& requester);
    void sendStageReply(const uint8_t sender, const cs::Signature& signature, const MsgTypes msgType, const uint8_t requester, cs::Bytes& message);

    // smart-contracts consensus communicatioin
    void sendSmartStageOne(const cs::ConfidantsKeys& smartConfidants, const cs::StageOneSmarts& stageOneInfo);
    void getSmartStageOne(const uint8_t* data, const size_t size, const cs::RoundNumber rNum, const cs::PublicKey& sender);
    void sendSmartStageTwo(const cs::ConfidantsKeys& smartConfidants, cs::StageTwoSmarts& stageTwoInfo);
    void getSmartStageTwo(const uint8_t* data, const size_t size, const cs::RoundNumber rNum, const cs::PublicKey& sender);
    void sendSmartStageThree(const cs::ConfidantsKeys& smartConfidants, cs::StageThreeSmarts& stageThreeInfo);
    void getSmartStageThree(const uint8_t* data, const size_t size, const cs::RoundNumber rNum, const cs::PublicKey& sender);
    void smartStageEmptyReply(uint8_t requesterNumber);
    void smartStageRequest(MsgTypes msgType, cs::Sequence smartRound, uint32_t startTransaction, cs::PublicKey confidant, uint8_t respondent, uint8_t required);
    void getSmartStageRequest(const MsgTypes msgType, const uint8_t* data, const size_t size, const cs::PublicKey& requester);
    void sendSmartStageReply(const cs::Bytes& message, const cs::RoundNumber smartRNum, const cs::Signature& signature, const MsgTypes msgType, const cs::PublicKey& requester);

    void addSmartConsensus(uint64_t id);
    void removeSmartConsensus(uint64_t id);
    void checkForSavedSmartStages(uint64_t id);

    void sendSmartReject(const std::vector<RefExecution>& rejectList);
    void getSmartReject(const uint8_t* data, const size_t size, const cs::RoundNumber rNum, const cs::PublicKey& sender);

    csdb::PoolHash spoileHash(const csdb::PoolHash& hashToSpoil);
    csdb::PoolHash spoileHash(const csdb::PoolHash& hashToSpoil, const cs::PublicKey& pKey);

    cs::ConfidantsKeys retriveSmartConfidants(const cs::Sequence startSmartRoundNumber) const;

    void onRoundStart(const cs::RoundTable& roundTable);
    void startConsensus();

    void prepareRoundTable(cs::RoundTable& roundTable, const cs::PoolMetaInfo& poolMetaInfo, cs::StageThree& st3);
    bool receivingSignatures(const cs::Bytes& sigBytes, const cs::Bytes& roundBytes, const cs::RoundNumber rNum, const cs::Bytes& trustedMask,
                             const cs::ConfidantsKeys& newConfidants, cs::Signatures& poolSignatures);
    void addRoundSignature(const cs::StageThree& st3);
    // smart-contracts consensus stages sending and getting

    // send request for next round info from trusted node specified by index in list
    void sendRoundTableRequest(uint8_t respondent);

    // send request for next round info from node specified node
    void sendRoundTableRequest(const cs::PublicKey& respondent);
    void getRoundTableRequest(const uint8_t*, const size_t, const cs::RoundNumber, const cs::PublicKey&);
    void sendRoundTableReply(const cs::PublicKey& target, bool hasRequestedInfo);
    void getRoundTableReply(const uint8_t* data, const size_t size, const cs::PublicKey& respondent);
    // called by solver, review required:
    bool tryResendRoundTable(const cs::PublicKey& target, const cs::RoundNumber rNum);
    void sendRoundTable();

    // transaction's pack syncro
    void getPacketHashesRequest(const uint8_t*, const std::size_t, const cs::RoundNumber, const cs::PublicKey&);
    void getPacketHashesReply(const uint8_t*, const std::size_t, const cs::RoundNumber, const cs::PublicKey& sender);

    void getCharacteristic(const uint8_t* data, const size_t size, const cs::RoundNumber round, const cs::PublicKey& sender, cs::Signatures&& poolSignatures,
                           cs::Bytes&& realTrusted);

    void cleanConfirmationList(cs::RoundNumber rNum);

    // syncro get functions
    void getBlockRequest(const uint8_t*, const size_t, const cs::PublicKey& sender);
    void getBlockReply(const uint8_t*, const size_t);

    // transaction's pack syncro
    void sendTransactionsPacket(const cs::TransactionsPacket& packet);
    void sendPacketHashesRequest(const cs::PacketsHashes& hashes, const cs::RoundNumber round, uint32_t requestStep);
    void sendPacketHashesRequestToRandomNeighbour(const cs::PacketsHashes& hashes, const cs::RoundNumber round);
    void sendPacketHashesReply(const cs::Packets& packets, const cs::RoundNumber round, const cs::PublicKey& target);

    // smarts consensus additional functions:

    // syncro send functions
    void sendBlockReply(const cs::PoolsBlock& poolsBlock, const cs::PublicKey& target, std::size_t packCounter);

    void flushCurrentTasks();
    void becomeWriter();

    bool isPoolsSyncroStarted();

    std::optional<cs::TrustedConfirmation> getConfirmation(cs::RoundNumber round) const;

    // this function should filter the packages only using their roundNumber
    MessageActions chooseMessageAction(const cs::RoundNumber, const MsgTypes, const cs::PublicKey);

    const cs::PublicKey& getNodeIdKey() const {
        return nodeIdKey_;
    }

    Level getNodeLevel() const {
        return myLevel_;
    }

    uint8_t getConfidantNumber() const {
        return myConfidantIndex_;
    }

    uint8_t subRound() const {
        return subRound_;
    }

    BlockChain& getBlockChain() {
        return blockChain_;
    }

    const BlockChain& getBlockChain() const {
        return blockChain_;
    }

    cs::SolverCore* getSolver() {
        return solver_;
    }

    const cs::SolverCore* getSolver() const {
        return solver_;
    }

#ifdef NODE_API
    csconnector::connector* getConnector() {
        return api_.get();
    }
#endif

    template <typename T>
    using SmartsSignal = cs::Signal<void(T&, bool)>;
    using SmartStageRequestSignal = cs::Signal<void(uint8_t, cs::Sequence, uint32_t, uint8_t, uint8_t, cs::PublicKey&)>;
    using StopSignal = cs::Signal<void()>;

    // args: [failed list, restart list]
    using RejectedSmartContractsSignal = cs::Signal<void(const std::vector<RefExecution>&)>;

public signals:
    SmartsSignal<cs::StageOneSmarts> gotSmartStageOne;
    SmartsSignal<cs::StageTwoSmarts> gotSmartStageTwo;
    SmartsSignal<cs::StageThreeSmarts> gotSmartStageThree;
    SmartStageRequestSignal receivedSmartStageRequest;
    RejectedSmartContractsSignal gotRejectedContracts;

    inline static StopSignal stopRequested;

private slots:
    void onStopRequested();

public slots:
    void processTimer();
    void onTransactionsPacketFlushed(const cs::TransactionsPacket& packet);
    void onPingReceived(cs::Sequence sequence, const cs::PublicKey& sender);
    void sendBlockRequest(const ConnectionPtr target, const cs::PoolsRequestedSequences& sequences, std::size_t packCounter);

private:
    bool init(const Config& config);
    void sendRoundPackage(const cs::PublicKey& target);
    void sendRoundPackageToAll();

    void storeRoundPackageData(const cs::RoundTable& roundTable, const cs::PoolMetaInfo& poolMetaInfo, const cs::Characteristic& characteristic, cs::StageThree& st3);

    bool readRoundData(cs::RoundTable& roundTable, bool bang);
    void reviewConveyerHashes();

    // conveyer
    void processPacketsRequest(cs::PacketsHashes&& hashes, const cs::RoundNumber round, const cs::PublicKey& sender);
    void processPacketsReply(cs::Packets&& packets, const cs::RoundNumber round);
    void processTransactionsPacket(cs::TransactionsPacket&& packet);

    /// sending interace methods

    // default methods without flags
    template <typename... Args>
    void sendDefault(const cs::PublicKey& target, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    // to neighbour
    template <typename... Args>
    bool sendToNeighbour(const cs::PublicKey& target, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    template <typename... Args>
    void sendToNeighbour(const ConnectionPtr target, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    template <class... Args>
    void tryToSendDirect(const cs::PublicKey& target, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    template <class... Args>
    bool sendToRandomNeighbour(const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    template <class... Args>
    void sendToConfidants(const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    // smarts
    template <class... Args>
    void sendToList(const std::vector<cs::PublicKey>& listMembers, const cs::Byte listExeption, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    // to neighbours
    template <typename... Args>
    bool sendToNeighbours(const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    // broadcast
    template <class... Args>
    void sendBroadcast(const MsgTypes msgType, const cs::RoundNumber round, Args&&... args);

    template <typename... Args>
    void sendBroadcast(const cs::PublicKey& target, const MsgTypes& msgType, const cs::RoundNumber round, Args&&... args);

    template <typename... Args>
    void sendBroadcastImpl(const MsgTypes& msgType, const cs::RoundNumber round, Args&&... args);

    // write values to stream
    template <typename... Args>
    void writeDefaultStream(Args&&... args);

    RegionPtr compressPoolsBlock(const cs::PoolsBlock& poolsBlock, std::size_t& realBinSize);
    cs::PoolsBlock decompressPoolsBlock(const uint8_t* data, const size_t size);

    // TODO: C++ 17 static inline?
    static const csdb::Address genesisAddress_;
    static const csdb::Address startAddress_;

    const cs::PublicKey nodeIdKey_;
    const cs::PrivateKey nodeIdPrivate_;
    bool good_ = true;

    bool stopRequested_ = false;

    // file names for crypto public/private keys
    inline const static std::string privateKeyFileName_ = "NodePrivate.txt";
    inline const static std::string publicKeyFileName_ = "NodePublic.txt";

    Level myLevel_{Level::Normal};
    cs::Byte myConfidantIndex_{cs::ConfidantConsts::InvalidConfidantIndex};

    // main cs storage
    BlockChain blockChain_;

    // appidional dependencies
    cs::SolverCore* solver_;
    Transport* transport_;

#ifdef NODE_API
    std::unique_ptr<csconnector::connector> api_;
#endif

    RegionAllocator allocator_;
    RegionAllocator packStreamAllocator_;

    uint32_t startPacketRequestPoint_ = 0;

    // ms timeout
    static const uint32_t packetRequestStep_ = 450;
    static const size_t maxPacketRequestSize_ = 1000;
    static const int64_t maxPingSynchroDelay_ = 90000;

    // serialization/deserialization entities
    cs::IPackStream istream_;
    cs::OPackStream ostream_;

    cs::PoolSynchronizer* poolSynchronizer_;

    // sends transactions blocks to network
    cs::Timer sendingTimer_;
    cs::Byte subRound_{0};

    // round package sent data storage
    struct SentRoundData {
        cs::RoundTable table;
        cs::Byte subRound{0};
    };

    struct SentSignatures {
        cs::Signatures poolSignatures;
        cs::Signatures roundSignatures;
        cs::Signatures trustedConfirmation;
    };

    cs::Bytes lastRoundTableMessage_;
    cs::Bytes lastSignaturesMessage_;

    std::vector<cs::Bytes> stageOneMessage_;
    std::vector<cs::Bytes> stageTwoMessage_;
    std::vector<cs::Bytes> stageThreeMessage_;
    bool stageThreeSent_ = false;

    std::vector<cs::Bytes> smartStageOneMessage_;
    std::vector<cs::Bytes> smartStageTwoMessage_;
    std::vector<cs::Bytes> smartStageThreeMessage_;

    std::vector<cs::StageOneSmarts> smartStageOneStorage_;
    std::vector<cs::StageTwoSmarts> smartStageTwoStorage_;
    std::vector<cs::StageThreeSmarts> smartStageThreeStorage_;
    int corruptionLevel_ = 0;

    std::vector<cs::Stage> smartStageTemporary_;
    // smart consensus IDs:
    std::vector<uint64_t> activeSmartConsensuses_;

    SentRoundData lastSentRoundData_;
    SentSignatures lastSentSignatures_;

    std::vector<bool> badHashReplyCounter_;

    // round stat
    cs::RoundStat stat_;

    // confirmation list
    cs::ConfirmationList confirmationList_;
    cs::RoundTableMessage currentRoundTableMessage_;

    //expected rounds
    std::vector<cs::RoundNumber> expectedRounds_;
    cs::Sequence maxHeighboursSequence_ = 0;
    cs::Bytes lastTrustedMask_;
};

std::ostream& operator<<(std::ostream& os, Node::Level nodeLevel);

#endif  // NODE_HPP
```
# ..\node\csnode\include\csnode\nodecore.hpp 
```cpp 
#ifndef NODE_CORE_HPP
#define NODE_CORE_HPP

#include <csdb/pool.hpp>
#include <map>
#include <unordered_map>
#include <unordered_set>

#include <boost/circular_buffer.hpp>

#include <client/params.hpp>
#include <csnode/transactionspacket.hpp>

#include <lib/system/common.hpp>
#include <lib/system/metastorage.hpp>

namespace std {
// transactions packet hash specialization
template <>
struct hash<cs::TransactionsPacketHash> {
    std::size_t operator()(const cs::TransactionsPacketHash& packetHash) const noexcept;
};
}  // namespace std

namespace cs {
// table for fast transactions storage
using TransactionsPacketTable = std::map<TransactionsPacketHash, TransactionsPacket>;  // TODO: check performance of map/unordered_map

// array of packets
using TransactionsBlock = std::vector<cs::TransactionsPacket>;

// array of notifications
using Notifications = std::vector<cs::Bytes>;
using Signatures = std::vector<cscrypto::Signature>;
// round data
using PublicKeys = std::vector<PublicKey>;
using PrivateKeys = std::vector<PrivateKey>;

using ConfidantsKeys = PublicKeys;
using PacketsHashes = std::vector<cs::TransactionsPacketHash>;
using Packets = std::vector<cs::TransactionsPacket>;
using Signatures = std::vector<cs::Signature>;
using Hashes = std::vector<cs::Hash>;

using PoolsRequestedSequences = std::vector<cs::Sequence>;
using PoolsBlock = std::vector<csdb::Pool>;

enum NodeConsts : uint32_t {
    NeighboursRequestDelay = 350,
    MaxRoundDeltaInStopRequest = 100 ///< Max allowed round difference in NodeStopRequest, otherwise ignore the command
};

enum ConveyerConsts : uint32_t {
    TransactionsFlushRound = 2,
    TransactionsPacketInterval = 1000
};

enum ConfidantConsts : Byte {
    FirstWriterIndex = std::numeric_limits<uint8_t>::min(),
    InvalidConfidantIndex = std::numeric_limits<uint8_t>::max(),
};

enum SpoilingConsts : Byte {
    SpoilByRoundNumber,
    SpoilByPublicKey,
};

// all info about round
struct Characteristic {
    cs::Bytes mask;
};

struct RoundTable {
    RoundNumber round = 0;
    PublicKey general;
    ConfidantsKeys confidants;
    PacketsHashes hashes;
    Characteristic characteristic;
};

struct PoolMetaInfo {
    std::string timestamp;
    cs::PublicKey writerKey;
    csdb::PoolHash previousHash;
    cs::Sequence sequenceNumber;
    cs::Bytes realTrustedMask;
    std::vector<csdb::Pool::SmartSignature> smartSignatures;
    cs::Bytes confirmationMask;
    cs::Signatures confirmations;
};

struct HashVector {
    cs::Byte sender;
    cs::Hash hash;
    cs::Signature signature;
};

constexpr std::size_t kHashVectorCount = 5;

struct HashMatrix {
    cs::Byte sender;
    cs::HashVector hashVector[kHashVectorCount];
    cs::Signature signature;
};

// metas
struct PoolSyncMeta {
    csdb::Pool pool;
    cs::Signature signature;
    cs::PublicKey sender;
};

using PoolMetaMap = std::map<cs::Sequence, cs::PoolSyncMeta>;

struct ConveyerMeta {
    cs::Characteristic characteristic;
    cs::TransactionsPacketTable hashTable;
    cs::PacketsHashes neededHashes;
    cs::RoundTable roundTable;
    cs::Notifications notifications;
    cs::TransactionsPacket invalidTransactions;
};

struct CharacteristicMeta {
    cs::Bytes bytes;
    cs::PublicKey sender;
    cs::Signatures signatures;
    cs::Bytes realTrusted;
};

struct RoundTableMessage {
    cs::Bytes message;
    cs::RoundNumber round = 0;
    cs::PublicKey sender;
};

// meta storages
using ConveyerMetaStorage = cs::MetaStorage<cs::ConveyerMeta>;
using CharacteristicMetaStorage = cs::MetaStorage<cs::CharacteristicMeta>;

// zero constants, used as "empty"
struct Zero {
    inline static cs::Hash hash;
    inline static cs::Signature signature;
    inline static cs::PublicKey key;

    Zero();
};
}  // namespace cs

#endif  // NODE_CORE_HPP
```
# ..\node\csnode\include\csnode\nodeutils.hpp 
```cpp 
#ifndef NODEUTILS_HPP
#define NODEUTILS_HPP

#include <csnode/nodecore.hpp>

namespace csdb {
class Pool;
}

namespace cs {
class NodeUtils {
public:
    static bool checkGroupSignature(const cs::ConfidantsKeys& confidants, const cs::Bytes& mask, const cs::Signatures& signatures, const cs::Hash& hash);
    static size_t realTrustedValue(const cs::Bytes& mask);
    static cs::Bytes getTrustedMask(const csdb::Pool& block);
    static std::string roundsToString(const std::vector<cs::RoundNumber>& rounds);
};
}  // namespace cs

#endif  // NODEUTILS_HPP
```
# ..\node\csnode\include\csnode\packetqueue.hpp 
```cpp 
#ifndef PACKETQUEUE_HPP
#define PACKETQUEUE_HPP

#include <deque>
#include <optional>

#include <csnode/nodecore.hpp>
#include <boost/noncopyable.hpp>

namespace cs {
// implements business logic for transpaction packet
class PacketQueue : public boost::noncopyable {
public:
    explicit PacketQueue(size_t queueSize, size_t transactionsSize, size_t packetsPerRound);
    ~PacketQueue() = default;

    bool push(const csdb::Transaction& transaction);
    void push(const cs::TransactionsPacket& packet);

    cs::TransactionsBlock pop();

    std::deque<cs::TransactionsPacket>::const_iterator begin() const;
    std::deque<cs::TransactionsPacket>::const_iterator end() const;

    size_t size() const;
    bool isEmpty() const;
    std::deque<cs::TransactionsPacket>::const_reference back() const;

private:
    std::deque<cs::TransactionsPacket> queue_;

    size_t maxQueueSize_;
    size_t maxTransactionsSize_;
    size_t maxPacketsPerRound_;

    cs::RoundNumber cachedRound_;
    size_t cachedPackets_;
};
}

#endif // PACKETQUEUE_HPP
```
# ..\node\csnode\include\csnode\packstream.hpp 
```cpp 
#ifndef PACKSTREAM_HPP
#define PACKSTREAM_HPP

#include <algorithm>
#include <cstring>
#include <type_traits>

#include <csnode/nodecore.hpp>
#include <csnode/transactionspacket.hpp>

#include <csdb/pool.hpp>
#include <csdb/transaction.hpp>

#include <lib/system/hash.hpp>

#include <net/packet.hpp>

namespace cs {
class IPackStream {
public:
    void init(const cs::Byte* ptr, const size_t size) {
        ptr_ = ptr;
        end_ = ptr_ + size;
        good_ = true;
    }

    template <typename T>
    bool canPeek() const {
        return static_cast<uint32_t>(end_ - ptr_) >= sizeof(T);
    }

    template <typename T>
    const T& peek() const {
        return *(reinterpret_cast<const T*>(ptr_));
    }

    template <typename T>
    void skip() {
        ptr_ += sizeof(T);
    }

    template <typename T>
    void safeSkip(uint32_t num = 1) {
        auto size = sizeof(T) * num;

        if (!isBytesAvailable(size)) {
            good_ = false;
        }
        else {
            ptr_ += size;
        }
    }

    template <typename T>
    IPackStream& operator>>(T& cont) {
        if (!canPeek<T>()) {
            good_ = false;
        }
        else {
            cont = peek<T>();
            skip<T>();
        }

        return *this;
    }

    template <size_t Length>
    IPackStream& operator>>(FixedString<Length>& str) {
        if (!isBytesAvailable(Length)) {
            good_ = false;
        }
        else {
            std::copy(ptr_, ptr_ + Length, str.data());
            ptr_ += Length;
        }

        return *this;
    }

    template <size_t Length>
    IPackStream& operator>>(cs::ByteArray<Length>& byteArray) {
        if (!isBytesAvailable(Length)) {
            good_ = false;
        }
        else {
            std::copy(ptr_, ptr_ + Length, byteArray.data());
            ptr_ += Length;
        }

        return *this;
    }

    template <typename T, typename A>
    IPackStream& operator>>(std::vector<T, A>& vector) {
        std::size_t size = 0;
        (*this) >> size;

        if (size == 0) {
            return *this;
        }

        // check min needed bytes. It may be more bytes needed on the elements.
        if (!isBytesAvailable(size)) {
            good_ = false;
            return *this;
        }

        std::vector<T, A> entity;
        entity.reserve(size);

        for (std::size_t i = 0; i < size; ++i) {
            T element;
            (*this) >> element;

            if (!good()) {
                break;
            }

            entity.push_back(std::move(element));
        }

        if (entity.size() != size) {
            cserror() << "Pack stream -> vector parsing failed";
            return *this;
        }

        vector = std::move(entity);
        return *this;
    }

    template <typename T, typename U>
    IPackStream& operator>>(std::pair<T, U>& pair) {
        T first;
        (*this) >> first;

        if (!good_) {
            return *this;
        }

        U second;
        (*this) >> second;

        if (!good_) {
            return *this;
        }

        pair = std::make_pair(std::move(first), std::move(second));
        return *this;
    }

    bool good() const {
        return good_;
    }

    bool end() const {
        return ptr_ == end_;
    }

    operator bool() const {
        return good() && !end();
    }

    const cs::Byte* getCurrentPtr() const {
        return ptr_;
    }

    const cs::Byte* getEndPtr() const {
        return end_;
    }

    size_t remainsBytes() const {
        return static_cast<size_t>(end_ - ptr_);
    }

    bool isBytesAvailable(size_t bytes) const {
        return remainsBytes() >= bytes;
    }

private:
    const cs::Byte* ptr_ = nullptr;
    const cs::Byte* end_ = nullptr;
    bool good_ = false;
};

class OPackStream {
public:
    OPackStream(RegionAllocator* allocator, const cs::PublicKey& nodeIdKey)
    : allocator_(allocator)
    , packets_(new Packet[Packet::MaxFragments]())
    , packetsEnd_(packets_)
    , senderKey_(nodeIdKey) {
    }

    ~OPackStream() {
        delete[] packets_;
    }

    void init(cs::Byte flags) {
        clear();
        ++id_;

        newPack();

        *ptr_ = flags;
        ++ptr_;

        if (flags & BaseFlags::Fragmented) {
            *this << static_cast<uint16_t>(0) << packetsCount_;
        }

        if (!(flags & BaseFlags::NetworkMsg)) {
            *this << id_ << senderKey_;
        }
    }

    void init(uint8_t flags, const cs::PublicKey& receiver) {
        init(flags);
        *this << receiver;
    }

    void clear() {
        for (auto ptr = packets_; ptr != packetsEnd_; ++ptr) {
            ptr->~Packet();
        }

        packetsCount_ = 0;
        finished_ = false;
        packetsEnd_ = packets_;
    }

    template <typename T>
    OPackStream& operator<<(const T& value) {
        static_assert(sizeof(T) <= Packet::MaxSize, "Type too long");
        const auto left = static_cast<uint32_t>(end_ - ptr_);

        if (left >= sizeof(T)) {
            *(reinterpret_cast<T*>(ptr_)) = value;
            ptr_ += sizeof(T);
        }
        else {
            const auto pointer = reinterpret_cast<const cs::Byte*>(&value);
            std::copy(pointer, (pointer + left), ptr_);
            newPack();
            std::copy(pointer + left, pointer + sizeof(T), ptr_);
            ptr_ += sizeof(T) - left;
        }

        return *this;
    }

    template <size_t Length>
    OPackStream& operator<<(const FixedString<Length>& str) {
        insertBytes(str.data(), Length);
        return *this;
    }

    template <size_t Length>
    OPackStream& operator<<(const cs::ByteArray<Length>& byteArray) {
        insertBytes(byteArray.data(), Length);
        return *this;
    }

    OPackStream& operator<<(cs::BytesView view) {
        (*this) << view.size();
        insertBytes(view.data(), static_cast<uint32_t>(view.size()));
        return *this;
    }

    template <typename T, typename A>
    OPackStream& operator<<(const std::vector<T, A>& vector) {
        (*this) << vector.size();

        for (const auto& element : vector) {
            (*this) << element;
        }

        return *this;
    }

    template <typename T, typename U>
    OPackStream& operator<<(const std::pair<T, U>& pair) {
        (*this) << pair.first;
        (*this) << pair.second;

        return *this;
    }

    Packet* getPackets() {
        if (!finished_) {
            allocator_->shrinkLast(static_cast<uint32_t>(ptr_ - static_cast<cs::Byte*>((packetsEnd_ - 1)->data())));

            if (packetsCount_ > 1) {
                for (auto p = packets_; p != packetsEnd_; ++p) {
                    cs::Byte* data = static_cast<cs::Byte*>(p->data());

                    // TODO: make next impossible, see newPack()
                    if (!p->isFragmented()) {
                        cserror() << "Malformed packet: Fragmented flag not set for fragmented packet";
                        assert(false);
                    }

                    *reinterpret_cast<uint16_t*>(data + Offsets::FragmentsNum) = packetsCount_;
                }
            }
            finished_ = true;
        }

        return packets_;
    }

    uint32_t getPacketsCount() {
        return packetsCount_;
    }

    cs::Byte* getCurrentPtr() {
        return ptr_;
    }

    uint32_t getCurrentSize() const {
        return static_cast<uint32_t>(ptr_ - static_cast<cs::Byte*>((packetsEnd_ - 1)->data()));
    }

private:
    void newPack() {
        RegionPtr tempBuffer;
        cs::Byte* tail = nullptr;
        static constexpr size_t insertedSize = sizeof(uint16_t) + sizeof(packetsCount_);

        if (packetsCount_ == 1) {
            ptr_ = static_cast<cs::Byte*>(packets_->data());

            if (!packets_->isFragmented()) {
                csdebug() << "Fragmentation flag is not set in fragmented packet, correcting";
                *ptr_ |= BaseFlags::Fragmented;

                packets_->recalculateHeadersLength();

                // insert size_inserted bytes from [1] and shift current content "rightward"
                ++ptr_;

                size_t shiftedSize = static_cast<size_t>(end_ - ptr_);
                tempBuffer = allocator_->allocateNext(static_cast<uint32_t>(shiftedSize));
                tail = static_cast<cs::Byte*>(tempBuffer.get());

                std::copy(ptr_, end_, tail);
                *this << static_cast<uint16_t>(0) << static_cast<decltype(packetsCount_)>(0);

                insertBytes(tail, static_cast<uint32_t>(shiftedSize - insertedSize));
                tail += (shiftedSize - insertedSize);
            }
        }

        new (packetsEnd_) Packet(allocator_->allocateNext(Packet::MaxSize));

        ptr_ = static_cast<cs::Byte*>(packetsEnd_->data());
        end_ = ptr_ + packetsEnd_->size();

        if (packetsEnd_ != packets_) {
            auto begin = static_cast<cs::Byte*>(packets_->data());
            auto end = begin + packets_->getHeadersLength();

            std::copy(begin, end, ptr_);
            *reinterpret_cast<uint16_t*>(static_cast<cs::Byte*>(packetsEnd_->data()) + static_cast<uint32_t>(Offsets::FragmentId)) = packetsCount_;

            ptr_ += packets_->getHeadersLength();

            if (tail != nullptr) {
                insertBytes(tail, insertedSize);
            }
        }

        ++packetsCount_;
        ++packetsEnd_;
    }

    void insertBytes(char const* bytes, uint32_t size) {
        while (size > 0) {
            if (ptr_ == end_) {
                newPack();
            }

            const auto toPut = std::min(static_cast<uint32_t>(end_ - ptr_), size);
            std::copy(bytes, bytes + toPut, ptr_);

            size -= toPut;
            ptr_ += toPut;
            bytes += toPut;
        }
    }

    void insertBytes(const cs::Byte* bytes, uint32_t size) {
        insertBytes(reinterpret_cast<const char*>(bytes), size);
    }

    cs::Byte* ptr_ = nullptr;
    cs::Byte* end_ = nullptr;

    RegionAllocator* allocator_;

    Packet* packets_;
    uint16_t packetsCount_ = 0;
    Packet* packetsEnd_;
    bool finished_ = false;

    uint64_t id_ = 0;
    cs::PublicKey senderKey_;
};
}  // namespace cs

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(std::string& str) {
    std::size_t size = 0;
    (*this) >> size;

    if (!good_) {
        return *this;
    }

    if (!isBytesAvailable(size)) {
        good_ = false;
    }
    else {
        auto nextPtr = ptr_ + size;
        str = std::string(ptr_, nextPtr);

        ptr_ = nextPtr;
    }

    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(cs::Bytes& bytes) {
    size_t size = 0;
    (*this) >> size;

    if (!good_) {
        return *this;
    }

    if (!isBytesAvailable(size)) {
        good_ = false;
    }
    else {
        auto nextPtr = ptr_ + size;
        bytes = cs::Bytes(ptr_, nextPtr);

        ptr_ = nextPtr;
    }

    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(csdb::Pool& pool) {
    cs::Bytes bytes;
    (*this) >> bytes;
    pool = csdb::Pool::from_binary(std::move(bytes));
    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(ip::address& addr) {
    if (!canPeek<uint8_t>()) {
        good_ = false;
    }
    else {
        if (*(ptr_++) & 1) {
            if (static_cast<uint32_t>(end_ - ptr_) < 16) {
                good_ = false;
            }
            else {
                ip::address_v6::bytes_type bt;

                for (auto& b : bt) {
                    (*this) >> b;
                }

                addr = ip::make_address_v6(bt);
            }
        }
        else {
            uint32_t ipnum;

            for (auto ptr = reinterpret_cast<cs::Byte*>(&ipnum) + 3; ptr >= reinterpret_cast<cs::Byte*>(&ipnum); --ptr) {
                (*this) >> *ptr;
            }

            addr = ip::make_address_v4(ipnum);
        }
    }

    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(cs::TransactionsPacketHash& hash) {
    cs::Bytes bytes;
    (*this) >> bytes;

    if (!good()) {
        return *this;
    }

    hash = cs::TransactionsPacketHash::fromBinary(std::move(bytes));
    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(cs::TransactionsPacket& packet) {
    cs::Bytes bytes;
    (*this) >> bytes;

    packet = cs::TransactionsPacket::fromBinary(bytes);
    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(cs::HashVector& hashVector) {
    (*this) >> hashVector.sender >> hashVector.hash >> hashVector.signature;
    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(cs::HashMatrix& hashMatrix) {
    (*this) >> hashMatrix.sender;

    for (std::size_t i = 0; i < kHashVectorCount; ++i) {
        (*this) >> hashMatrix.hashVector[i];
    }

    (*this) >> hashMatrix.signature;

    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(csdb::PoolHash& hash) {
    cs::Bytes bytes;
    (*this) >> bytes;
    hash = csdb::PoolHash::from_binary(std::move(bytes));
    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(cs::BytesView& view) {
    size_t size = 0;
    (*this) >> size;

    if (!good_) {
        return *this;
    }

    if (!isBytesAvailable(size)) {
        good_ = false;
    }
    else {
        view = cs::BytesView(ptr_, size);
        ptr_ += size;
    }

    return *this;
}

template <>
inline cs::IPackStream& cs::IPackStream::operator>>(RegionPtr& regionPtr) {
    std::size_t size = regionPtr.size();

    if (!isBytesAvailable(size)) {
        good_ = false;
    }
    else {
        std::copy(ptr_, ptr_ + size, reinterpret_cast<char*>(regionPtr.get()));
        ptr_ += size;
    }

    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const ip::address& ip) {
    (*this) << static_cast<cs::Byte>(ip.is_v6());

    if (ip.is_v6()) {
        auto bts = ip.to_v6().to_bytes();

        for (auto& b : bts) {
            (*this) << b;
        }
    }
    else {
        uint32_t ipnum = ip.to_v4().to_uint();

        for (auto ptr = reinterpret_cast<cs::Byte*>(&ipnum) + 3; ptr >= reinterpret_cast<cs::Byte*>(&ipnum); --ptr) {
            (*this) << *ptr;
        }
    }

    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const std::string& str) {
    (*this) << str.size();
    insertBytes(str.data(), static_cast<uint32_t>(str.size()));
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const cs::Bytes& bytes) {
    (*this) << bytes.size();
    insertBytes(reinterpret_cast<const char*>(bytes.data()), static_cast<uint32_t>(bytes.size()));
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const csdb::Transaction& trans) {
    (*this) << trans.to_byte_stream();
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const csdb::Pool& pool) {
    uint32_t bSize;
    auto dataPtr = const_cast<csdb::Pool&>(pool).to_byte_stream(bSize);

    (*this) << static_cast<std::size_t>(bSize);
    insertBytes(static_cast<char*>(dataPtr), bSize);
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const cs::TransactionsPacketHash& hash) {
    (*this) << hash.toBinary();
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const cs::TransactionsPacket& packet) {
    (*this) << packet.toBinary();
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const cs::HashVector& hashVector) {
    (*this) << hashVector.sender << hashVector.hash << hashVector.signature;
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const cs::HashMatrix& hashMatrix) {
    (*this) << hashMatrix.sender;

    for (std::size_t i = 0; i < kHashVectorCount; ++i) {
        (*this) << hashMatrix.hashVector[i];
    }

    (*this) << hashMatrix.signature;
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const csdb::PoolHash& hash) {
    (*this) << hash.to_binary();
    return *this;
}

template <>
inline cs::OPackStream& cs::OPackStream::operator<<(const RegionPtr& regionPtr) {
    insertBytes(reinterpret_cast<const char*>(regionPtr.get()), static_cast<uint32_t>(regionPtr.size()));
    return *this;
}
#endif  // PACKSTREAM_HPP
```
# ..\node\csnode\include\csnode\poolsynchronizer.hpp 
```cpp 
#ifndef POOLSYNCHRONIZER_HPP
#define POOLSYNCHRONIZER_HPP

#include <csdb/pool.hpp>
#include <csnode/blockchain.hpp>
#include <csnode/nodecore.hpp>
#include <csnode/packstream.hpp>

#include <lib/system/signals.hpp>
#include <lib/system/timer.hpp>

#include <net/neighbourhood.hpp>

#include <client/config.hpp>

class Node;

namespace cs {

using PoolSynchronizerRequestSignal = cs::Signal<void(const ConnectionPtr target, const PoolsRequestedSequences& sequences, std::size_t packet)>;

class PoolSynchronizer {
public:
    explicit PoolSynchronizer(const PoolSyncData& data, Transport* transport, BlockChain* blockChain);

    void sync(cs::RoundNumber roundNum, cs::RoundNumber difference = roundDifferentForSync, bool isBigBand = false);

    // syncro get functions
    void getBlockReply(cs::PoolsBlock&& poolsBlock, std::size_t packetNum);

    // syncro send functions
    void sendBlockRequest();

    bool isSyncroStarted() const;

    bool isOneBlockReply() const;

    bool isFastMode() const;

    static const cs::RoundNumber roundDifferentForSync = cs::values::kDefaultMetaStorageMaxSize;

public signals:
    PoolSynchronizerRequestSignal sendRequest;

private slots:
    void onTimeOut();
    void onRoundSimulation();

    void onWriteBlock(const csdb::Pool pool);
    void onWriteBlock(const cs::Sequence sequence);
    void onRemoveBlock(const cs::Sequence sequence);

private:
    enum class CounterType;
    enum class SequenceRemovalAccuracy;
    class NeighboursSetElemet;

    // pool sync progress
    bool showSyncronizationProgress(const cs::Sequence lastWrittenSequence) const;

    bool checkActivity(const CounterType counterType);

    void sendBlock(const NeighboursSetElemet& neighbour);

    bool getNeededSequences(NeighboursSetElemet& neighbour);

    void checkNeighbourSequence(const cs::Sequence sequence, const SequenceRemovalAccuracy accuracy);

    void removeExistingSequence(const cs::Sequence sequence, const SequenceRemovalAccuracy accuracy);

    void refreshNeighbours();

    bool isLastRequest() const;

    bool isAvailableRequest(const cs::PoolSynchronizer::NeighboursSetElemet& nh) const;

    void synchroFinished();

    ConnectionPtr getConnection(const NeighboursSetElemet& neighbour) const;

    void printNeighbours(const std::string& funcName) const;

private:
    enum class CounterType {
        ROUND,
        TIMER
    };

    enum class SequenceRemovalAccuracy {
        EXACT,
        LOWER_BOUND,
        UPPER_BOUND
    };

    class NeighboursSetElemet {
    public:
        explicit NeighboursSetElemet(uint8_t neighbourIndex, const cs::PublicKey& publicKey, uint8_t blockPoolsCount)
        : neighbourIndex_(neighbourIndex)
        , key_(publicKey)
        , roundCounter_(0) {
            sequences_.reserve(blockPoolsCount);
        }

        inline bool removeSequnce(const cs::Sequence sequence, const SequenceRemovalAccuracy accuracy) {
            if (sequences_.empty()) {
                return false;
            }

            bool success = false;

            switch (accuracy) {
                case SequenceRemovalAccuracy::EXACT: {
                    auto it = std::find(sequences_.begin(), sequences_.end(), sequence);
                    if (it != sequences_.end()) {
                        sequences_.erase(it);
                        success = true;
                    }
                    break;
                }
                case SequenceRemovalAccuracy::LOWER_BOUND: {
                    auto it = std::upper_bound(sequences_.begin(), sequences_.end(), sequence);
                    if (it != sequences_.begin()) {
                        sequences_.erase(sequences_.begin(), it);
                        success = true;
                    }
                    break;
                }
                case SequenceRemovalAccuracy::UPPER_BOUND: {
                    auto it = std::lower_bound(sequences_.begin(), sequences_.end(), sequence);
                    if (it != sequences_.end()) {
                        sequences_.erase(it, sequences_.end());
                        success = true;
                    }
                    break;
                }
            }
            return success;
        }
        inline void setSequences(const PoolsRequestedSequences& sequences) {
            resetSequences();
            sequences_ = sequences;
        }
        inline void addSequences(const cs::Sequence sequence) {
            sequences_.push_back(sequence);
        }
        inline void reset() {
            resetSequences();
            resetRoundCounter();
        }
        inline void resetSequences() {
            sequences_.clear();
        }
        inline void resetRoundCounter() {
            roundCounter_ = 0;
        }
        inline void setIndex(const uint8_t num) {
            neighbourIndex_ = num;
        }
        inline void setPublicKey(const cs::PublicKey& publicKey) {
            key_ = publicKey;
        }

        inline uint8_t index() const {
            return neighbourIndex_;
        }
        inline const cs::PublicKey& publicKey() const {
            return key_;
        }
        inline const PoolsRequestedSequences& sequences() const {
            return sequences_;
        }
        inline cs::RoundNumber roundCounter() const {
            return roundCounter_;
        }

        inline void increaseRoundCounter() {
            if (!sequences_.empty()) {
                ++roundCounter_;
            }
        }

        bool operator<(const NeighboursSetElemet& other) const {
            if (sequences_.empty() || other.sequences_.empty()) {
                return sequences_.size() > other.sequences_.size();
            }

            return sequences_.front() < other.sequences_.front();
        }

        friend std::ostream& operator<<(std::ostream& os, const NeighboursSetElemet& el) {
            os << "idx: " << cs::numeric_cast<int>(el.neighbourIndex_) << ", seqs:";

            if (el.sequences_.empty()) {
                os << " empty";
            }
            else {
                for (const auto seq : el.sequences_) {
                    os << " " << seq;
                }
            }

            os << ", round counter: " << el.roundCounter_;

            return os;
        }

    private:
        uint8_t neighbourIndex_;             // neighbour number
        cs::PublicKey key_;                  // neighbour public key
        PoolsRequestedSequences sequences_;  // requested sequence
        cs::RoundNumber roundCounter_;
    };

private:
    const PoolSyncData syncData_;

    Transport* transport_;
    BlockChain* blockChain_;

    // flag starting  syncronization
    bool isSyncroStarted_ = false;
    // [key] = sequence,
    // [value] =  packet counter
    // value: increase each new round
    std::map<cs::Sequence, cs::RoundNumber> requestedSequences_;

    std::vector<NeighboursSetElemet> neighbours_;

    cs::Timer timer_;
    cs::Timer roundSimulation_;

    friend std::ostream& operator<<(std::ostream&, const PoolSynchronizer::CounterType);
    friend std::ostream& operator<<(std::ostream&, const PoolSynchronizer::SequenceRemovalAccuracy);
};

inline std::ostream& operator<<(std::ostream& os, const PoolSynchronizer::CounterType type) {
    switch (type) {
        case PoolSynchronizer::CounterType::ROUND:
            os << "ROUND";
            break;
        case PoolSynchronizer::CounterType::TIMER:
            os << "TIMER";
            break;
    }

    return os;
}

inline std::ostream& operator<<(std::ostream& os, const PoolSynchronizer::SequenceRemovalAccuracy type) {
    switch (type) {
        case PoolSynchronizer::SequenceRemovalAccuracy::EXACT:
            os << "EXACT";
            break;
        case PoolSynchronizer::SequenceRemovalAccuracy::LOWER_BOUND:
            os << "LOWER_BOUND";
            break;
        case PoolSynchronizer::SequenceRemovalAccuracy::UPPER_BOUND:
            os << "UPPER_BOUND";
            break;
    }

    return os;
}
}  // namespace cs

#endif  // POOLSYNCHRONIZER_HPP
```
# ..\node\csnode\include\csnode\roundstat.hpp 
```cpp 
#pragma once

#include <csdb/pool.hpp>
#include <lib/system/common.hpp>

#include <chrono>
#include <set>

namespace cs {
constexpr size_t MaxStoredDurations = 1000;

class RoundStat {
public:
    RoundStat();

    void onRoundStart(cs::RoundNumber round);

    // called when next block is read from database
    void onReadBlock(csdb::Pool block, bool* should_stop);

    // called when next block is stored
    void onStoreBlock(csdb::Pool block);

    size_t total_transactions() const {
        return totalAcceptedTransactions_;
    }

private:
    // amount of transactions received (to verify or not or to ignore)
    size_t totalReceivedTransactions_;

    // amount of accepted transactions (stored in blockchain)
    size_t totalAcceptedTransactions_;

    // amount of deferred transactions (in deferred block)
    size_t deferredTransactionsCount_;
    std::chrono::steady_clock::time_point startPointMs_;
    size_t totalDurationMs_;

    // std::multiset<size_t> shortestRounds_;
    // std::multiset<size_t> longestRounds_;

    size_t node_start_round;
    size_t start_skip_rounds;
};

}  // namespace cs
```
# ..\node\csnode\include\csnode\transactionspacket.hpp 
```cpp 
#ifndef TRANSACTIONS_PACKET_HPP
#define TRANSACTIONS_PACKET_HPP

#include <csdb/transaction.hpp>
#include <lib/system/common.hpp>

#include <string>
#include <vector>

namespace cs {
///
/// Wrapper of std::vector<uint8_t> to represent hash
///
class TransactionsPacketHash {
public:  // Static interface
    ///
    /// @brief Gets a hash from a string representation
    /// @param String representation of a hash
    /// @return Hash obtained from a string representation.
    ///         If the string representation is incorrect, an empty hash is returned.
    ///
    static TransactionsPacketHash fromString(const ::std::string& str);

    ///
    /// @brief Gets a hash from a binary representation
    /// @param Binary representation of a hash
    /// @return Hash obtained from a binary representation.
    ///         If the binary representation is incorrect, an empty hash is returned.
    ///
    static TransactionsPacketHash fromBinary(const cs::Bytes& data);
    static TransactionsPacketHash fromBinary(cs::Bytes&& data);

    ///
    /// @brief Calculates hash from binary data
    /// @param vector of bytes
    /// @return hash
    ///
    static TransactionsPacketHash calcFromData(const cs::Bytes& data);

public:  // Interface
    ///
    /// @brief Сhecks hash size bytes on 0
    /// @return true if hash size == 0
    ///
    bool isEmpty() const noexcept;

    ///
    /// @brief Returns hash bytes count
    /// @return hash bytes count
    ///
    size_t size() const noexcept;

    ///
    /// @brief Coverts transactions packet hash to string.
    /// @return hash bytes as string
    ///
    std::string toString() const noexcept;

    ///
    /// @brief Coverts transactions packet hash to binary.
    /// @return vector of bytes
    ///
    const cs::Bytes& toBinary() const noexcept;

    bool operator==(const TransactionsPacketHash& other) const noexcept;
    bool operator!=(const TransactionsPacketHash& other) const noexcept;
    bool operator<(const TransactionsPacketHash& other) const noexcept;

private:  // Members
    cs::Bytes m_bytes;
};

///
/// Flexible strorage for transactions
///
class TransactionsPacket {
public:  // Static interface
    ///
    /// @brief Gets a transactions packet from a binary representation.
    /// @param Binary representation of a packet.
    /// @return Hash obtained from a binary representation.
    ///         If the binary representation is incorrect, an empty packet is returned.
    ///
    static TransactionsPacket fromBinary(const cs::Bytes& data);

    ///
    /// @brief Gets a transactions packet from a binary representation
    /// @param Binary representation of a transactions packet
    /// @param Binary representation size
    /// @return Hash obtained from a binary representation.
    ///         If the binary representation is incorrect, an empty packet is returned.
    ///
    static TransactionsPacket fromByteStream(const char* data, size_t size);

public:  // Interface
    enum Serialization : cs::Byte {
        Signatures = 0x01,
        Transactions = 0x04,
        All = Serialization::Signatures | Serialization::Transactions
    };

    TransactionsPacket() = default;

    TransactionsPacket(const TransactionsPacket& packet) = default;
    TransactionsPacket(TransactionsPacket&& packet);

    TransactionsPacket& operator=(const TransactionsPacket& packet);

    ///
    /// @brief Coverts transactions packet to binary representation.
    /// @return packet as binary representation
    ///
    cs::Bytes toBinary(Serialization options = Serialization::All) const noexcept;

    ///
    /// @brief Generates hash
    /// @return True if hash generated successed
    ///
    bool makeHash();

    ///
    /// @brief Checks on hash empty state
    /// @return True if hash is empty
    ///
    bool isHashEmpty() const noexcept;

    ///
    /// @brief Returns packet hash
    /// @return Packet hash, check it on empty state
    ///
    const TransactionsPacketHash& hash() const noexcept;

    ///
    /// @brief Returns transactions count
    /// @return Size of transactions vector
    ///
    size_t transactionsCount() const noexcept;

    ///
    /// @brief Adds signature to transaction vector
    /// @param signature Signature to add
    ///
    bool addSignature(const cs::Byte index, const cs::Signature& signature);

    ///
    /// @brief Adds transaction to transaction vector
    /// @param transaction Any transaction to add
    ///
    bool addTransaction(const csdb::Transaction& transaction);

    ///
    /// @brief Returns transactions
    /// @return Reference to transactions vector
    ///
    const std::vector<csdb::Transaction>& transactions() const noexcept;

    ///
    /// @brief Returns transactions
    /// @return Reference to signatures vector
    ///
    const cs::BlockSignatures& signatures() const noexcept;

    ///
    /// @brief Returns trabsactions, non const version
    /// @return Reference to transactions vector
    ///
    std::vector<csdb::Transaction>& transactions();

    ///
    /// @brief Clears transactions vector
    ///
    void clear() noexcept;

private:  // Service
    void put(::csdb::priv::obstream& os, Serialization options) const;
    bool get(::csdb::priv::ibstream& is);

private:  // Members
    TransactionsPacketHash m_hash;
    std::vector<csdb::Transaction> m_transactions;
    cs::BlockSignatures m_signatures;
};
}  // namespace cs

#endif  // TRANSACTIONS_PACKET_HPP
```
# ..\node\csnode\include\csnode\transactionstail.hpp 
```cpp 
#ifndef TRANSACTIONS_TAIL_H
#define TRANSACTIONS_TAIL_H

#include "bitheap.hpp"

namespace cs {
class TransactionsTail {
public:
    static constexpr size_t BitSize = 1024;
    using TransactionId = int64_t;

public:
    bool empty() const {
        return heap_.empty();
    }

    void push(TransactionId trxId) {
        heap_.push(trxId);
    }

    TransactionId getLastTransactionId() const {
        return heap_.minMaxRange().second;
    }

    bool isAllowed(TransactionId trxId) const {
        if (heap_.empty())
            return true;
        else {
            const Heap::MinMaxRange& range = heap_.minMaxRange();
            if (trxId > range.second)
                return true;
            else if (trxId < range.first)
                return false;
            else
                return !heap_.contains(trxId);
        }
    }

    std::string printRange() {
        if (heap_.empty()) {
            return "any";
        }
        std::ostringstream os;
        os << '[' << heap_.minMaxRange().first << ".." << heap_.minMaxRange().second << ']';
        return os.str();
    }

private:
    using Heap = BitHeap<TransactionId, BitSize>;
    Heap heap_;
};

}  // namespace cs

#endif
```
# ..\node\csnode\include\csnode\transactionsvalidator.hpp 
```cpp 
#ifndef TRANSACTIONS_VALIDATOR_HPP
#define TRANSACTIONS_VALIDATOR_HPP

#include <csdb/pool.hpp>
#include <csdb/transaction.hpp>
#include <csnode/walletsstate.hpp>
#include <lib/system/common.hpp>
#include <limits>
#include <map>
#include <vector>

namespace cs {

class SolverContext;

class TransactionsValidator {
public:
    using Transactions = std::vector<csdb::Transaction>;
    using CharacteristicMask = cs::Bytes;
    using TransactionIndex = WalletsState::TransactionIndex;
    using RejectedSmarts = std::vector<std::pair<csdb::Transaction, size_t>>;

public:
    struct Config {
        size_t initialNegNodesNum_ = 2 * 1024 * 1024;
    };

public:
    TransactionsValidator(WalletsState& walletsState, const Config& config);

    void reset(size_t transactionsNum);
    bool validateTransaction(SolverContext& context, const Transactions& trxs, size_t trxInd);
    size_t checkRejectedSmarts(SolverContext& context, const Transactions& trxs, CharacteristicMask& maskIncluded);
    void validateByGraph(SolverContext& context, CharacteristicMask& maskIncluded, const Transactions& trxs);

    void clearCaches();
    void addRejectedNewState(const csdb::Address& newState);

    size_t getCntRemovedTrxsByGraph() const;

private:
    using TrxList = std::vector<TransactionIndex>;
    using Node = WalletsState::WalletData;
    using Stack = std::vector<Node*>;
    static constexpr csdb::Amount zeroBalance_ = 0.0_c;

private:
    bool validateTransactionAsSource(SolverContext& context, const Transactions& trxs, size_t trxInd);
    bool validateNewStateAsSource(SolverContext& context, const csdb::Transaction& trx);
    bool validateCommonAsSource(SolverContext& context, const Transactions& trxs, size_t trxInd, WalletsState::WalletData& wallState);

    bool validateTransactionAsTarget(const csdb::Transaction& trx);

    void removeTransactions(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded);
    bool removeTransactions_PositiveOne(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded);
    bool removeTransactions_PositiveAll(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded);
    bool removeTransactions_NegativeOne(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded);
    bool removeTransactions_NegativeAll(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded);

    size_t makeSmartsValid(SolverContext& context, RejectedSmarts& smarts, const csdb::Address& source, CharacteristicMask& maskIncluded);

private:
    Config config_;
    WalletsState& walletsState_;
    TrxList trxList_;
    std::map<csdb::Address, csdb::Amount> payableMaxFees_;
    std::vector<csdb::Address> rejectedNewStates_;
    Stack negativeNodes_;
    size_t cntRemovedTrxs_;
};

inline void TransactionsValidator::clearCaches() {
    payableMaxFees_.clear();
    rejectedNewStates_.clear();
}

inline void TransactionsValidator::addRejectedNewState(const csdb::Address& newState) {
    rejectedNewStates_.push_back(newState);
}

inline size_t TransactionsValidator::getCntRemovedTrxsByGraph() const {
    return cntRemovedTrxs_;
}

}  // namespace cs
#endif  // TRANSACTIONS_VALIDATOR_HPP
```
# ..\node\csnode\include\csnode\walletscache.hpp 
```cpp 
#ifndef WALLETS_CACHE_HPP
#define WALLETS_CACHE_HPP

#include <boost/dynamic_bitset.hpp>
#include <cscrypto/cscrypto.hpp>
#include <csdb/address.hpp>
#include <csdb/amount.hpp>
#include <csdb/pool.hpp>
#include <csdb/transaction.hpp>
#include <csnode/nodecore.hpp>
#include <csnode/transactionstail.hpp>
#include <list>
#include <map>
#include <memory>
#include <vector>

#include <lib/system/common.hpp>

class BlockChain;

namespace csdb {
class Pool;
class Transaction;
}  // namespace csdb

namespace cs {
class WalletsIds;

constexpr size_t InitialWalletsNum = 1 * 512 * 1024;

class WalletsCache {
public:
    using WalletId = csdb::internal::WalletId;
    using Mask = boost::dynamic_bitset<uint64_t>;

    struct Config {
        size_t initialWalletsNum_ = InitialWalletsNum;
    };

public:
    struct WalletData {
        using Address = cs::PublicKey;

        Address address_;
        csdb::Amount balance_;
        TransactionsTail trxTail_;
		uint64_t transNum_ = 0;

#ifdef MONITOR_NODE
        uint64_t createTime_ = 0;        
#endif
#ifdef TRANSACTIONS_INDEX
        csdb::TransactionID lastTransaction_;
#endif
    };

    struct TrustedData {
        uint64_t times = 0;
        uint64_t times_trusted = 0;
        csdb::Amount totalFee;
    };

public:
    static void convert(const csdb::Address& address, WalletData::Address& walletAddress);
    static void convert(const WalletData::Address& walletAddress, csdb::Address& address);

    void iterateOverWallets(const std::function<bool(const WalletData::Address&, const WalletData&)>);

#ifdef MONITOR_NODE
    void iterateOverWriters(const std::function<bool(const WalletData::Address&, const TrustedData&)>);
#endif

    uint64_t getCount() const {
        return wallets_.size();
    }

private:
    using Data = std::vector<WalletData*>;

    class ProcessorBase {
    public:
        ProcessorBase(WalletsCache& data)
        : data_(data) {
        }
        virtual ~ProcessorBase() {
        }
        virtual bool findWalletId(const csdb::Address& address, WalletId& id) = 0;

    protected:
        void load(csdb::Pool& curr, const cs::ConfidantsKeys& confidants, const BlockChain& blockchain);
        double load(const csdb::Transaction& tr, const BlockChain& blockchain);
        double loadTrxForSource(const csdb::Transaction& tr, const BlockChain& blockchain);
        void fundConfidantsWalletsWithFee(const csdb::Amount& totalFee, const cs::ConfidantsKeys& confidants, const std::vector<uint8_t>& realTrusted);
        void loadTrxForTarget(const csdb::Transaction& tr);
        virtual WalletData& getWalletData(WalletId id, const csdb::Address& address) = 0;
        virtual void setModified(WalletId id) = 0;
        void invokeReplenishPayableContract(const csdb::Transaction&);
        void rollbackReplenishPayableContract(const csdb::Transaction&, const csdb::Amount& execFee = 0);
        void smartSourceTransactionReleased(const csdb::Transaction& smartSourceTrx, const csdb::Transaction& initTrx);
        void checkSmartWaitingForMoney(const csdb::Transaction& initTransaction, const csdb::Transaction& newStateTransaction);
        bool isClosedSmart(const csdb::Transaction& transaction);
        void checkClosedSmart(const csdb::Transaction& transaction);
        void fundConfidantsWalletsWithExecFee(const csdb::Transaction& transaction, const BlockChain& blockchain);

        /*#ifdef MONITOR_NODE
            std::map<WalletData::Address, WriterData> writers_;
        #endif*/

    protected:
        static WalletData& getWalletData(Data& wallets, WalletId id, const csdb::Address& address);
#ifdef MONITOR_NODE
        bool setWalletTime(const WalletData::Address& address, const uint64_t& p_timeStamp);
#endif

    protected:
        WalletsCache& data_;
    };

public:
    class Initer : protected ProcessorBase {
    public:
        using ProcessorBase::invokeReplenishPayableContract;
        using ProcessorBase::rollbackReplenishPayableContract;
        Initer(WalletsCache& data);
        void loadPrevBlock(csdb::Pool& curr, const cs::ConfidantsKeys& confidants, const BlockChain& blockchain);
        bool moveData(WalletId srcIdSpecial, WalletId destIdNormal);
        bool isFinishedOk() const;

    protected:
        bool findWalletId(const csdb::Address& address, WalletId& id) override;
        WalletData& getWalletData(WalletId id, const csdb::Address& address) override;
        void setModified(WalletId id) override;

    protected:
        Data walletsSpecial_;
    };

    class Updater : protected ProcessorBase {
    public:
        using ProcessorBase::invokeReplenishPayableContract;
        using ProcessorBase::rollbackReplenishPayableContract;
        using ProcessorBase::smartSourceTransactionReleased;
        Updater(WalletsCache& data);
        void loadNextBlock(csdb::Pool& curr, const cs::ConfidantsKeys& confidants, const BlockChain& blockchain);
        const WalletData* findWallet(WalletId id) const;
        const Mask& getModified() const {
            return modified_;
        }

    protected:
        bool findWalletId(const csdb::Address& address, WalletId& id) override;
        WalletData& getWalletData(WalletId id, const csdb::Address& address) override;
        void setModified(WalletId id) override;

    protected:
        Mask modified_;
    };

public:
    WalletsCache(const Config& config, csdb::Address genesisAddress, csdb::Address startAddress, WalletsIds& walletsIds);
    ~WalletsCache();
    WalletsCache(const WalletsCache&) = delete;
    WalletsCache& operator=(const WalletsCache&) = delete;
    WalletsCache(const WalletsCache&&) = delete;
    WalletsCache& operator=(const WalletsCache&&) = delete;

    static csdb::Address findSmartContractIniter(const csdb::Transaction& tr, const BlockChain& blockchain);
    static csdb::Transaction findSmartContractInitTrx(const csdb::Transaction& tr, const BlockChain& blockchain);

    std::unique_ptr<Initer> createIniter();
    std::unique_ptr<Updater> createUpdater();

private:
    const Config config_;
    WalletsIds& walletsIds_;
    const csdb::Address genesisAddress_;
    const csdb::Address startAddress_;
    std::list<csdb::Transaction> smartPayableTransactions_;
    std::list<csdb::Transaction> closedSmarts_;

#ifdef MONITOR_NODE
    std::map<WalletData::Address, TrustedData> trusted_info_;
#endif

    Data wallets_;
};

}  // namespace cs

#endif
```
# ..\node\csnode\include\csnode\walletsids.hpp 
```cpp 
#ifndef WALLET_IDS_HPP
#define WALLET_IDS_HPP

#include <csdb/address.hpp>
#include <memory>
#include <type_traits>
#include <unordered_map>
#include "csdb/internal/types.hpp"

namespace cs {

class WalletsIds {
public:
    using WalletId = csdb::internal::WalletId;
    using WalletAddress = csdb::Address;

public:
    class Special {
    public:
        static bool isSpecial(WalletId id);
        static WalletId makeSpecial(WalletId id);
        static WalletId makeNormal(WalletId id);

    public:
        Special(WalletsIds& norm);
        // returns true if new id was inserted
        bool insertNormal(const WalletAddress& address, WalletId id, WalletId& idSpecial);
        bool findAnyOrInsertSpecial(const WalletAddress& address, WalletId& id);

    private:
        WalletsIds& norm_;
        WalletId nextIdSpecial_;
        static constexpr uint32_t maskSpecial_ = (1u << 31);
        static constexpr WalletId noSpecial_ = 0;

        static_assert(std::is_integral<WalletId>::value, "WalletId is expected to be integer");
        static_assert(sizeof(WalletId) == sizeof(maskSpecial_), "sizeof(WalletId) == sizeof(maskSpecial_)");
    };

public:
    class Normal {
    public:
        Normal(WalletsIds& norm);

        // returns true if new id was inserted
        bool insert(const WalletAddress& address, WalletId id);
        bool find(const WalletAddress& address, WalletId& id) const;
        bool findaddr(const WalletId& id, WalletAddress& address) const;
        // returns true if new id was inserted
        bool get(const WalletAddress& address, WalletId& id);
        bool remove(const WalletAddress& address);

    private:
        WalletsIds& norm_;
    };

public:
    WalletsIds();
    WalletsIds(const WalletsIds&) = delete;
    WalletsIds& operator=(const WalletsIds&) = delete;
    WalletsIds(const WalletsIds&&) = delete;
    WalletsIds& operator=(const WalletsIds&&) = delete;

    Special& special() {
        return *special_;
    }
    const Special& special() const {
        return *special_;
    }

    Normal& normal() {
        return *norm_;
    }
    const Normal& normal() const {
        return *norm_;
    }

private:
    using Data = std::unordered_map<WalletAddress, WalletId>;
    Data data_;
    WalletId nextId_;
    std::unique_ptr<Special> special_;
    std::unique_ptr<Normal> norm_;
};

}  // namespace cs

#endif
```
# ..\node\csnode\include\csnode\walletspools.hpp 
```cpp 
#ifndef WALLETS_POOLS_HPP
#define WALLETS_POOLS_HPP

#include <array>
#include <cscrypto/cscrypto.hpp>
#include <csdb/address.hpp>
#include <csdb/amount.hpp>
#include <csdb/internal/types.hpp>
#include <csdb/pool.hpp>
#include <csnode/cyclicbuffer.hpp>
#include <limits>
#include <memory>
#include <vector>

namespace csdb {
class Pool;
class Transaction;
}  // namespace csdb

namespace cs {
class WalletsIds;

class WalletsPools {
public:
    using WalletId = csdb::internal::WalletId;
    using PoolHash = std::array<uint8_t, cscrypto::kHashSize>;

public:
    struct WalletData {
        struct PoolHashData {
            PoolHash poolHash;
            uint32_t trxNum;
            static constexpr size_t maxTrxNum = std::numeric_limits<uint32_t>::max();
        };
        static constexpr size_t maxPoolsHashesNum_ = 100;
        using PoolsHashes = CyclicBuffer<PoolHashData, maxPoolsHashesNum_>;

        PoolsHashes poolsHashes_;
    };

public:
    static void convert(const csdb::PoolHash& poolHashDb, PoolHash& poolHashCache);
    static void convert(const PoolHash& poolHashCache, csdb::PoolHash& poolHashDb);

public:
    WalletsPools(csdb::Address genesisAddress, csdb::Address startAddress, const WalletsIds& walletsIds);
    ~WalletsPools();
    WalletsPools(const WalletsPools&) = delete;
    WalletsPools& operator=(const WalletsPools&) = delete;
    WalletsPools(const WalletsPools&&) = delete;
    WalletsPools& operator=(const WalletsPools&&) = delete;

    void addWallet(WalletId id);
    void loadPrevBlock(csdb::Pool& curr);
    void loadNextBlock(csdb::Pool& curr);

    const WalletData* findWallet(WalletId id) const;

private:
    void* impl_;
};

}  // namespace cs

#endif
```
# ..\node\csnode\include\csnode\walletsstate.hpp 
```cpp 
#ifndef WALLETS_STATE_HPP
#define WALLETS_STATE_HPP

#include <boost/dynamic_bitset.hpp>
#include <csdb/address.hpp>
#include <csdb/amount.hpp>
#include <csdb/internal/types.hpp>
#include <csnode/transactionstail.hpp>
#include <csnode/walletscache.hpp>
#include <unordered_map>
#include <vector>

class BlockChain;

namespace cs {
class WalletsCache;
class WalletsIds;

class WalletsState {
public:
    using WalletAddress = csdb::Address;
    using WalletId = csdb::internal::WalletId;
    using Mask = boost::dynamic_bitset<uint64_t>;
    using TransactionIndex = uint32_t;
    static constexpr TransactionIndex noInd_ = std::numeric_limits<TransactionIndex>::max();
    static constexpr WalletId noWalletId_ = 0;

public:
    struct WalletData {
        TransactionIndex lastTrxInd_{};
        csdb::Amount balance_{};
        TransactionsTail trxTail_{};
    };

public:
    explicit WalletsState(const BlockChain& blockchain, size_t initialWalletsNum = InitialWalletsNum);

    void updateFromSource();
    WalletData& getData(const WalletAddress& address, WalletId& id);
    void setModified(const WalletId& id);

private:
    class WalletsExisting {
    public:
        explicit WalletsExisting(const BlockChain& blockchain, size_t initialWalletsNum = InitialWalletsNum);
        ~WalletsExisting();

        void updateFromSource();
        WalletData* getData(const WalletId& id);
        void setModified(const WalletId& id);

    private:
        bool updateFromSource(const WalletId& id);

    private:
        const BlockChain& blockchain_;
        using Storage = std::vector<WalletData*>;
        Storage storage_;
        Mask toCopy_;
        Mask modified_;
    };

    class WalletsNew {
    public:
        void clear();
        WalletData& getData(const WalletAddress& address);

    private:
        using Storage = std::unordered_map<WalletAddress, WalletData>;
        Storage storage_;
    };

private:
    const BlockChain& blockchain_;
    WalletsExisting wallExisting_;
    WalletsNew wallNew_;
};
}  // namespace cs

#endif
```
# ..\node\csnode\src\blockchain.cpp 
```cpp 
#include <base58.h>
#include <csdb/currency.hpp>
#include <lib/system/hash.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>
#include <limits>

#include <csnode/blockchain.hpp>
#include <csnode/blockhashes.hpp>
#include <csnode/blockvalidator.hpp>
#include <csnode/conveyer.hpp>
#include <csnode/datastream.hpp>
#include <csnode/fee.hpp>
#include <csnode/nodeutils.hpp>
#include <solver/smartcontracts.hpp>

#include <client/config.hpp>

//#define RECREATE_INDEX

using namespace cs;

BlockChain::BlockChain(csdb::Address genesisAddress, csdb::Address startAddress)
: good_(false)
, dbLock_()
, genesisAddress_(genesisAddress)
, startAddress_(startAddress)
, walletIds_(new WalletsIds)
, walletsCacheStorage_(new WalletsCache(WalletsCache::Config(), genesisAddress, startAddress, *walletIds_))
, walletsPools_(new WalletsPools(genesisAddress, startAddress, *walletIds_))
, cacheMutex_()
, blockValidator_(std::make_unique<cs::BlockValidator>(*this)) {
    cs::Connector::connect(&storage_.readBlockEvent(), this, &BlockChain::onReadFromDB);
    walletsCacheUpdater_ = walletsCacheStorage_->createUpdater();
    blockHashes_ = std::make_unique<cs::BlockHashes>();
}

BlockChain::~BlockChain() {
}

bool BlockChain::init(const std::string& path) {
    cslog() << "Trying to open DB...";

    size_t totalLoaded = 0;
    csdb::Storage::OpenCallback progress = [&](const csdb::Storage::OpenProgress& progress) {
        ++totalLoaded;
        if (progress.poolsProcessed % 1000 == 0) {
            std::cout << '\r' << WithDelimiters(progress.poolsProcessed) << "";
        }
        return false;
    };

    if (!storage_.open(path, progress)) {
        cserror() << "Couldn't open database at " << path;
        return false;
    }

    cslog() << "\rDB is opened, loaded " << WithDelimiters(totalLoaded) << " blocks";

    if (storage_.last_hash().is_empty()) {
        csdebug() << "Last hash is empty...";
        if (storage_.size()) {
            cserror() << "failed!!! Delete the Database!!! It will be restored from nothing...";
            return false;
        }
        writeGenesisBlock();
    }
    else {
        if (!postInitFromDB()) {
            return false;
        }
        std::cout << "Done\n";
    }

#if defined(TRANSACTIONS_INDEX) && defined(RECREATE_INDEX)
    for (uint32_t seq = 0; seq <= getLastSequence(); ++seq) {
        auto pool = loadBlock(seq);
        createTransactionsIndex(pool);
    }

    cslog() << "Recreated the index 0->" << getLastSequence() << ". Finishing with error now. Because we can";
    return false;
#else
    good_ = true;
    return true;
#endif
}

bool BlockChain::isGood() const {
    return good_;
}

uint64_t BlockChain::uuid() const {
    cs::Lock lock(dbLock_);
    return uuid_;
}

void BlockChain::onReadFromDB(csdb::Pool block, bool* shouldStop) {
    if (block.sequence() == 1) {
        cs::Lock lock(dbLock_);
        uuid_ = uuidFromBlock(block);
        csdebug() << "Blockchain: UUID = " << uuid_;
    }
    if (!blockValidator_->validateBlock(block, BlockValidator::ValidationLevel::hashIntergrity, BlockValidator::SeverityLevel::greaterThanWarnings)) {
        *shouldStop = true;
        return;
    }
    if (!updateWalletIds(block, *walletsCacheUpdater_.get())) {
        cserror() << "Blockchain: updateWalletIds() failed on block #" << block.sequence();
        *shouldStop = true;
    }
    else {
        walletsCacheUpdater_->loadNextBlock(block, block.confidants(), *this);
        if (!blockHashes_->initFromPrevBlock(block)) {
            cserror() << "Blockchain: blockHashes_->initFromPrevBlock(block) failed on block #" << block.sequence();
            *shouldStop = true;
        }
        else {
#ifdef TRANSACTIONS_INDEX
            const auto cnt_tr = block.transactions_count();
            if (cnt_tr > 0) {
                total_transactions_count_ += cnt_tr;

                if (lastNonEmptyBlock_.transCount && block.hash() != lastNonEmptyBlock_.hash) {
                    previousNonEmpty_[block.hash()] = lastNonEmptyBlock_;
                }
                lastNonEmptyBlock_.hash = block.hash();
                lastNonEmptyBlock_.transCount = static_cast<uint32_t>(block.transactions().size());
            }
#endif
        }
    }
}

bool BlockChain::postInitFromDB() {
    auto func = [](const WalletData::Address&, const WalletData& wallet) {
        double bal = wallet.balance_.to_double();
        if (bal < -std::numeric_limits<double>::min()) {
            csdebug() << "Wallet with negative balance (" << bal << ") detected: " << cs::Utils::byteStreamToHex(wallet.address_.data(), wallet.address_.size()) << " ("
                      << EncodeBase58(wallet.address_.data(), wallet.address_.data() + wallet.address_.size()) << ")";
        }
        return true;
    };
    walletsCacheStorage_->iterateOverWallets(func);
    return true;
}

#ifdef TRANSACTIONS_INDEX
void BlockChain::createTransactionsIndex(csdb::Pool& pool) {
#ifdef RECREATE_INDEX
    static std::map<csdb::Address, csdb::PoolHash> lapoos;
#endif

    // Update
    std::set<csdb::Address> indexedAddrs;

    auto lbd = [&indexedAddrs, &pool, this](const csdb::Address& addr) {
        auto key = getAddressByType(addr, BlockChain::AddressType::PublicKey);
        if (indexedAddrs.insert(key).second) {
#ifdef RECREATE_INDEX
            csdb::PoolHash lapoo = lapoos[key];
            lapoos[key] = pool.hash();
#else
            csdb::PoolHash lapoo = getLastTransaction(key).pool_hash();
#endif
            std::lock_guard<decltype(dbLock_)> l(dbLock_);
            storage_.set_previous_transaction_block(key, pool.hash(), lapoo);
        }
    };

    for (auto& tr : pool.transactions()) {
        lbd(tr.source());
        lbd(tr.target());
    }

    if (pool.transactions().size()) {
        total_transactions_count_ += pool.transactions().size();

        if (lastNonEmptyBlock_.transCount && pool.hash() != lastNonEmptyBlock_.hash) {
            previousNonEmpty_[pool.hash()] = lastNonEmptyBlock_;
        }

        lastNonEmptyBlock_.hash = pool.hash();
        lastNonEmptyBlock_.transCount = static_cast<uint32_t>(pool.transactions().size());
    }
}
#endif

cs::Sequence BlockChain::getLastSequence() const {
    std::lock_guard lock(dbLock_);

    if (deferredBlock_.is_valid()) {
        return deferredBlock_.sequence();
    }
    else if (!blockHashes_->empty()) {
        return blockHashes_->getDbStructure().last_;
    }
    else {
        return 0;
    }
}

void BlockChain::writeGenesisBlock() {
    cswarning() << "Adding the genesis block";

    csdb::Pool genesis;
    csdb::Transaction transaction;

    std::string strAddr = "5B3YXqDTcWQFGAqEJQJP3Bg1ZK8FFtHtgCiFLT5VAxpe";
    std::vector<uint8_t> pub_key;
    DecodeBase58(strAddr, pub_key);

    csdb::Address test_address = csdb::Address::from_public_key(pub_key);
    transaction.set_target(test_address);
    transaction.set_source(genesisAddress_);
    transaction.set_currency(csdb::Currency(1));
    transaction.set_amount(csdb::Amount(249'471'071, 0));
    transaction.set_max_fee(csdb::AmountCommission(0.0));
    transaction.set_counted_fee(csdb::AmountCommission(0.0));
    transaction.set_innerID(0);

    genesis.add_transaction(transaction);

    genesis.set_previous_hash(csdb::PoolHash());
    genesis.set_sequence(0);
    addNewWalletsToPool(genesis);

    csdebug() << "Genesis block completed ... trying to save";

    finalizeBlock(genesis, true, cs::PublicKeys{});
    deferredBlock_ = genesis;
    emit storeBlockEvent(deferredBlock_);

    csdebug() << genesis.hash().to_string();

    uint32_t bSize;
    genesis.to_byte_stream(bSize);
}

void BlockChain::iterateOverWallets(const std::function<bool(const cs::WalletsCache::WalletData::Address&, const cs::WalletsCache::WalletData&)> func) {
    std::lock_guard lock(cacheMutex_);
    walletsCacheStorage_->iterateOverWallets(func);
}

#ifdef MONITOR_NODE
void BlockChain::iterateOverWriters(const std::function<bool(const cs::WalletsCache::WalletData::Address&, const cs::WalletsCache::TrustedData&)> func) {
    std::lock_guard lock(cacheMutex_);
    walletsCacheStorage_->iterateOverWriters(func);
}

void BlockChain::applyToWallet(const csdb::Address& addr, const std::function<void(const cs::WalletsCache::WalletData&)> func) {
    std::lock_guard lock(cacheMutex_);
    WalletId id;
    if (!walletIds_->normal().find(addr, id)) {
        return;
    }
    auto wd = walletsCacheUpdater_->findWallet(id);

    func(*wd);
}
#endif

csdb::PoolHash BlockChain::getLastHash() const {
    std::lock_guard lock(dbLock_);

    if (deferredBlock_.is_valid()) {
        return deferredBlock_.hash().clone();
    }

    return storage_.last_hash();
}

size_t BlockChain::getSize() const {
    std::lock_guard lock(dbLock_);
    const auto storageSize = storage_.size();
    return deferredBlock_.is_valid() ? (storageSize + 1) : storageSize;
}

csdb::Pool BlockChain::loadBlock(const csdb::PoolHash& ph) const {
    if (ph.is_empty()) {
        return csdb::Pool{};
    }

    std::lock_guard l(dbLock_);

    if (deferredBlock_.hash() == ph) {
        return deferredBlock_.clone();
    }

    return storage_.pool_load(ph);
}

csdb::Pool BlockChain::loadBlock(const cs::Sequence sequence) const {
    std::lock_guard lock(dbLock_);

    if (deferredBlock_.is_valid() && deferredBlock_.sequence() == sequence) {
        // deferredBlock already composed:
        return deferredBlock_.clone();
    }
    // storage loads blocks by 1-based index: 1 => pool[0], 2 => pool[1] etc.
    if (sequence > getLastSequence()) {
        return csdb::Pool{};
    }
    return storage_.pool_load(sequence + 1);
}

csdb::Pool BlockChain::loadBlockMeta(const csdb::PoolHash& ph, size_t& cnt) const {
    std::lock_guard lock(dbLock_);

    if (deferredBlock_.hash() == ph) {
        return deferredBlock_.clone();
    }

    return storage_.pool_load_meta(ph, cnt);
}

csdb::Transaction BlockChain::loadTransaction(const csdb::TransactionID& transId) const {
    std::lock_guard l(dbLock_);
    csdb::Transaction transaction;

    if (deferredBlock_.hash() == transId.pool_hash()) {
        transaction = deferredBlock_.transaction(transId).clone();
        transaction.set_time(deferredBlock_.get_time());
    }
    else {
        transaction = storage_.transaction(transId);
        transaction.set_time(storage_.pool_load(transId.pool_hash()).get_time());
    }

    return transaction;
}

void BlockChain::removeLastBlock() {
    csmeta(csdebug) << "begin";
    csdb::Pool pool{};

    {
        std::lock_guard lock(dbLock_);

        if (deferredBlock_.is_valid()) {
            pool = deferredBlock_;
            deferredBlock_ = csdb::Pool{};
        }
        else {
            pool = storage_.pool_remove_last();
        }
    }

    if (!pool.is_valid()) {
        csmeta(cserror) << "Error! Removed pool is not valid";
        return;
    }

    if (pool.sequence() == 0) {
        csmeta(cswarning) << "Attempt to remove Genesis block !!!!!";
        return;
    }

    const auto lastHash = blockHashes_->getLast();
    const csdb::PoolHash poolHash = pool.hash();

    if (lastHash == poolHash) {
        blockHashes_->removeLast();
        csmeta(csdebug) << "Remove last hash is ok, sequence: " << pool.sequence();
    }
    else {
        csmeta(cserror) << "Error! Last pool hash mismatch";
        const auto findSequence = blockHashes_->find(poolHash);
        const auto& bh = blockHashes_->getHashes();
        csmeta(cserror) << "Block hashes size: " << bh.size() << ", Pool sequence: " << pool.sequence() << ", in Block hashes sequence: " << findSequence
                        << (findSequence != 0 ? "" : " (hash not found)");
        // if (findSequence == 0) {
        //  for (std::size_t i = 0; i < bh.size(); ++i) {
        //    csmeta(csdebug) << "Block hash [" << i << "]: " << bh[i].to_string();
        //  }
        //}
    }

#ifdef TRANSACTIONS_INDEX
    total_transactions_count_ -= pool.transactions().size();
#endif

    removeWalletsInPoolFromCache(pool);

    emit removeBlockEvent(pool.sequence());

    csmeta(csdebug) << "done";
}

csdb::Address BlockChain::getAddressFromKey(const std::string& key) {
    if (key.size() == kPublicKeyLength) {
        csdb::Address res = csdb::Address::from_public_key(key.data());
        return res;
    }
    else {
        csdb::internal::WalletId id = *reinterpret_cast<const csdb::internal::WalletId*>(key.data());
        csdb::Address res = csdb::Address::from_wallet_id(id);
        return res;
    }
}

void BlockChain::removeWalletsInPoolFromCache(const csdb::Pool& pool) {
    try {
        std::lock_guard lock(cacheMutex_);
        const csdb::Pool::NewWallets& newWallets = pool.newWallets();

        for (const auto& newWall : newWallets) {
            csdb::Address newWallAddress;
            if (!pool.getWalletAddress(newWall, newWallAddress)) {
                cserror() << "Wrong new wallet data";
                return;
            }
            if (!walletIds_->normal().remove(newWallAddress)) {
                cswarning() << "Wallet was not removed";
            }
        }
    }
    catch (std::exception& e) {
        cserror() << "Exc=" << e.what();
    }
    catch (...) {
        cserror() << "Exc=...";
    }
}

void BlockChain::logBlockInfo(csdb::Pool& pool) {
    const auto& trusted = pool.confidants();
    std::string realTrustedString;
    auto mask = cs::Utils::bitsToMask(pool.numberTrusted(), pool.realTrusted());
    for (auto i : mask) {
        realTrustedString = realTrustedString + "[" + std::to_string(static_cast<int>(i)) + "] ";
    }

    csdebug() << " trusted count " << trusted.size() << ", RealTrusted = " << realTrustedString;
    for (const auto& t : trusted) {
        csdebug() << "\t- " << cs::Utils::byteStreamToHex(t.data(), t.size());
    }
    csdebug() << " transactions count " << pool.transactions_count();
    if (pool.user_field_ids().count(0) > 0) {
        csdebug() << " time: " << pool.user_field(0).value<std::string>().c_str();
    }
    csdebug() << " previous hash: " << pool.previous_hash().to_string();
    csdebug() << " hash(" << pool.sequence() << "): " << pool.hash().to_string();
    csdebug() << " last storage size: " << getSize();
}

bool BlockChain::finalizeBlock(csdb::Pool& pool, bool isTrusted, cs::PublicKeys lastConfidants) {
    if (!pool.compose()) {
        csmeta(cserror) << "Couldn't compose block: " << pool.sequence();
        return false;
    }

    cs::Sequence currentSequence = pool.sequence();
    const auto& confidants = pool.confidants();
    const auto& signatures = pool.signatures();
    const auto& realTrusted = pool.realTrusted();
    if (currentSequence > 1) {
        csdebug() << "Finalize: starting confidants validation procedure:";

        cs::Bytes trustedToHash;
        cs::DataStream tth(trustedToHash);
        tth << currentSequence;
        tth << confidants;

        cs::Hash trustedHash = cscrypto::calculateHash(trustedToHash.data(), trustedToHash.size());

        cs::Signatures sigs = pool.roundConfirmations();
        const auto& confMask = cs::Utils::bitsToMask(pool.numberConfirmations(), pool.roundConfirmationMask());
        // for debugging only delete->
        csdebug() << "Mask size = " << confMask.size() << " for next confidants:";
        for (auto& it : lastConfidants) {
            csdebug() << cs::Utils::byteStreamToHex(it.data(), it.size());
        }
        // <-delete
        if (confMask.size() > 1) {
            if (!NodeUtils::checkGroupSignature(lastConfidants, confMask, sigs, trustedHash)) {
                csdebug() << "           The Confidants confirmations are not OK";
                return false;
            }
            else {
                csdebug() << "           The Confidants confirmations are OK";
            }
        }
        else {
            // TODO: add SS PKey to the prevConfidants
        }
    }

    if (signatures.empty() && (!isTrusted || pool.sequence() != 0)) {
        csmeta(csdebug) << "The pool #" << pool.sequence() << " doesn't contain signatures";
        return false;
    }

    if (signatures.size() < static_cast<size_t>(cs::Utils::maskValue(realTrusted)) && !isTrusted && pool.sequence() != 0) {
        csmeta(csdebug) << "The number of signatures is insufficient";
        return false;
    }
    auto mask = cs::Utils::bitsToMask(pool.numberTrusted(), pool.realTrusted());

    // pool signatures check: start
    if (pool.sequence() > 0) {
        //  csmeta(csdebug) << "Pool Hash: " << cs::Utils::byteStreamToHex(pool.hash().to_binary().data(), pool.hash().to_binary().size());
        //  csmeta(csdebug) << "Prev Hash: " << cs::Utils::byteStreamToHex(pool.previous_hash().to_binary().data(), pool.previous_hash().to_binary().size());
        Hash tempHash;
        auto hash = pool.hash().to_binary();
        std::copy(hash.cbegin(), hash.cend(), tempHash.data());
        if (NodeUtils::checkGroupSignature(confidants, mask, signatures, tempHash)) {
            csmeta(csdebug) << "The number of signatures is sufficient and all of them are OK!";
        }
        else {
            cswarning() << "Some of Pool Signatures aren't valid. The pool will not be written to DB";
            return false;
        }
    }
    else {
        csmeta(csdebug) << "Genesis block will be written without signatures verification";
    }
    // pool signatures check: end

#ifdef TRANSACTIONS_INDEX
    createTransactionsIndex(pool);
#endif

    if (!updateFromNextBlock(pool)) {
        csmeta(cserror) << "Error in updateFromNextBlock()";
        return false;
    }

    csmeta(csdetails) << "last hash: " << pool.hash().to_string();
    return true;
}

csdb::PoolHash BlockChain::getHashBySequence(cs::Sequence seq) const {
    std::lock_guard lock(dbLock_);

    if (deferredBlock_.sequence() == seq) {
        return deferredBlock_.hash().clone();
    }

    return blockHashes_->find(seq);
}

uint64_t BlockChain::getWalletsCountWithBalance() {
    std::lock_guard lock(cacheMutex_);

    uint64_t count = 0;
    auto proc = [&](const WalletData::Address& addr, const WalletData& wallet) {
        constexpr csdb::Amount zero_balance(0);
        if (!addr.empty() && wallet.balance_ >= zero_balance) {
            count++;
        }
        return true;
    };
    walletsCacheStorage_->iterateOverWallets(proc);
    return count;
}

class BlockChain::TransactionsLoader {
public:
    using Transactions = std::vector<csdb::Transaction>;

public:
    TransactionsLoader(csdb::Address wallPubKey, BlockChain::WalletId id, bool isToLoadWalletsPoolsCache, BlockChain& blockchain, Transactions& transactions)
    : wallPubKey_(wallPubKey)
    , isToLoadWalletsPoolsCache_(isToLoadWalletsPoolsCache)
    , blockchain_(blockchain)
    , transactions_(transactions) {
        if (isToLoadWalletsPoolsCache_) {
            std::lock_guard lock(blockchain_.cacheMutex_);
            blockchain.walletsPools_->addWallet(id);
        }
    }

    bool load(const csdb::PoolHash& poolHash, uint64_t& offset, uint64_t limit, csdb::PoolHash& prevPoolHash) {
        csdb::Pool curr = blockchain_.loadBlock(poolHash);
        if (!curr.is_valid())
            return false;

        if (curr.transactions_count()) {
            bool hasMyTransactions = false;

            for (auto trans : curr.transactions()) {
                if (transactions_.size() == limit)
                    break;

                if (trans.target() == wallPubKey_ || trans.source() == wallPubKey_) {
                    hasMyTransactions = true;

                    if (offset == 0)
                        transactions_.push_back(trans);
                    else
                        --offset;
                }
            }

            if (hasMyTransactions && isToLoadWalletsPoolsCache_) {
                std::lock_guard lock(blockchain_.cacheMutex_);
                blockchain_.walletsPools_->loadPrevBlock(curr);
            }
        }

        prevPoolHash = curr.previous_hash();

        return true;
    }

private:
    csdb::Address wallPubKey_;
    const bool isToLoadWalletsPoolsCache_;
    BlockChain& blockchain_;
    Transactions& transactions_;
};

void BlockChain::getTransactions(Transactions& transactions, csdb::Address address, uint64_t offset, uint64_t limit) {
    for (auto trIt = TransactionsIterator(*this, address); trIt.isValid(); trIt.next()) {
        if (offset > 0) {
            --offset;
            continue;
        }

        transactions.push_back(*trIt);
        transactions.back().set_time(trIt.getPool().get_time());

        if (--limit == 0)
            break;
    }
}

bool BlockChain::findDataForTransactions(csdb::Address address, csdb::Address& wallPubKey, WalletId& id, WalletsPools::WalletData::PoolsHashes& hashesArray) const {
    std::lock_guard lock(cacheMutex_);

    if (address.is_wallet_id()) {
        id = address.wallet_id();

        const WalletData* wallDataPtr = walletsCacheUpdater_->findWallet(id);

        if (!wallDataPtr) {
            return false;
        }

        WalletsCache::convert(wallDataPtr->address_, wallPubKey);
    }
    else
    {
        if (!walletIds_->normal().find(address, id)) {
            return false;
        }

        wallPubKey = address;
    }

    const WalletsPools::WalletData* wallData = walletsPools_->findWallet(id);
    if (wallData) {
        hashesArray = wallData->poolsHashes_;
    }

    return true;
}

void BlockChain::getTransactions(Transactions& transactions, csdb::Address wallPubKey, WalletId id, const WalletsPools::WalletData::PoolsHashes& hashesArray, uint64_t offset,
                                 uint64_t limit) {
    bool isToLoadWalletsPoolsCache = hashesArray.empty() && wallPubKey != genesisAddress_ && wallPubKey != startAddress_;
    if (wallPubKey.is_public_key()) {
        WalletId _id;

        if (!findWalletId(wallPubKey, _id)) {
            return;
        }

        wallPubKey = csdb::Address::from_wallet_id(_id);
    }

    TransactionsLoader trxLoader(wallPubKey, id, isToLoadWalletsPoolsCache, *this, transactions);
    csdb::PoolHash prevHash = getLastHash();

    for (size_t i = hashesArray.size() - 1; i != std::numeric_limits<decltype(i)>::max(); --i) {
        const auto& poolHashData = hashesArray[i];

        if (poolHashData.trxNum < WalletsPools::WalletData::PoolHashData::maxTrxNum && poolHashData.trxNum <= offset) {
            offset -= poolHashData.trxNum;
            continue;
        }

        csdb::PoolHash currHash;
        WalletsPools::convert(poolHashData.poolHash, currHash);

        if (!trxLoader.load(currHash, offset, limit, prevHash)) {
            return;
        }

        if (transactions.size() >= limit) {
            return;
        }
    }

    while (true) {
        csdb::PoolHash currHash = prevHash;

        if (!trxLoader.load(currHash, offset, limit, prevHash)) {
            break;
        }
    }
}

template <typename WalletCacheProcessor>
bool BlockChain::updateWalletIds(const csdb::Pool& pool, WalletCacheProcessor& proc) {
    try {
        std::lock_guard lock(cacheMutex_);

        const csdb::Pool::NewWallets& newWallets = pool.newWallets();
        for (const auto& newWall : newWallets) {
            csdb::Address newWallAddress;
            if (!pool.getWalletAddress(newWall, newWallAddress)) {
                cserror() << "Wrong new wallet data";
                return false;
            }

            if (!insertNewWalletId(newWallAddress, newWall.walletId_, proc)) {
                cserror() << "Wallet was already added as new";
                return false;
            }
        }
    }
    catch (std::exception& e) {
        cserror() << "Exc=" << e.what();
        return false;
    }
    catch (...) {
        cserror() << "Exc=...";
        return false;
    }

    return true;
}

bool BlockChain::insertNewWalletId(const csdb::Address& newWallAddress, WalletId newWalletId, WalletsCache::Initer& initer) {
    WalletId idSpecial{};

    if (!walletIds_->special().insertNormal(newWallAddress, newWalletId, idSpecial)) {
        cserror() << "Cannot add new wallet";
        return false;
    }

    if (WalletsIds::Special::isSpecial(idSpecial)) {
        if (!initer.moveData(idSpecial, newWalletId)) {
            cserror() << "Cannot move special wallet id data to newWalletId: idSpecial=" << idSpecial << " newWalletId=" << newWalletId;
            return false;
        }
    }

    return true;
}

bool BlockChain::insertNewWalletId(const csdb::Address& newWallAddress, WalletId newWalletId, WalletsCache::Updater&) {
    if (!walletIds_->normal().insert(newWallAddress, newWalletId)) {
        cserror() << "Cannot add new wallet";
        return false;
    }

    return true;
}

void BlockChain::addNewWalletToPool(const csdb::Address& walletAddress, const csdb::Pool::NewWalletInfo::AddressId& addressId, csdb::Pool::NewWallets& newWallets) {
    if (!walletAddress.is_public_key()) {
        return;
    }

    if (walletAddress == genesisAddress_) {
        return;
    }

    WalletId id{};

    if (getWalletId(walletAddress, id)) {
        newWallets.emplace_back(csdb::Pool::NewWalletInfo{addressId, id});
    }
}

void BlockChain::addNewWalletsToPool(csdb::Pool& pool) {
    csdb::Pool::NewWallets* newWallets = pool.newWallets();

    if (!newWallets) {
        cserror() << "Pool is read-only";
        return;
    }

    newWallets->clear();

    csdb::Pool::Transactions& transactions = pool.transactions();

    for (size_t idx = 0; idx < transactions.size(); ++idx) {
        {
            csdb::Pool::NewWalletInfo::AddressId addressId = {idx, csdb::Pool::NewWalletInfo::AddressType::AddressIsSource};
            addNewWalletToPool(transactions[idx].source(), addressId, *newWallets);
        }
        {
            csdb::Pool::NewWalletInfo::AddressId addressId = {idx, csdb::Pool::NewWalletInfo::AddressType::AddressIsTarget};
            addNewWalletToPool(transactions[idx].target(), addressId, *newWallets);
        }
    }

    const auto& confidants = pool.confidants();
    size_t confWalletsIndexStart = transactions.size();
    for (size_t i = 0; i < confidants.size(); ++i) {
        csdb::Pool::NewWalletInfo::AddressId addressId = {confWalletsIndexStart + i, csdb::Pool::NewWalletInfo::AddressType::AddressIsTarget};
        addNewWalletToPool(csdb::Address::from_public_key(confidants[i]), addressId, *newWallets);
    }
}

void BlockChain::close() {
    cs::Lock lock(dbLock_);
    storage_.close();
}

bool BlockChain::getTransaction(const csdb::Address& addr, const int64_t& innerId, csdb::Transaction& result) const {
    cs::Lock lock(dbLock_);
    return storage_.get_from_blockchain(addr, innerId, result);
}

bool BlockChain::updateFromNextBlock(csdb::Pool& nextPool) {
    if (!walletsCacheUpdater_) {
        cserror() << "!walletsCacheUpdater";
        return false;
    }

    try {
        std::lock_guard lock(cacheMutex_);

        // currently block stores own round confidants, not next round:
        const auto& currentRoundConfidants = nextPool.confidants();
        walletsCacheUpdater_->loadNextBlock(nextPool, currentRoundConfidants, *this);
        walletsPools_->loadNextBlock(nextPool);
        if (!blockHashes_->loadNextBlock(nextPool)) {
            cslog() << "Error writing DB structure";
        }
    }
    catch (std::exception& e) {
        cserror() << "Exc=" << e.what();
        return false;
    }
    catch (...) {
        cserror() << "Exc=...";
        return false;
    }
    return true;
}

bool BlockChain::findWalletData(const csdb::Address& address, WalletData& wallData, WalletId& id) const {
    if (address.is_wallet_id()) {
        id = address.wallet_id();
        return findWalletData(address.wallet_id(), wallData);
    }

    std::lock_guard lock(cacheMutex_);

    if (!walletIds_->normal().find(address, id)) {
        return false;
    }

    return findWalletData_Unsafe(id, wallData);
}

bool BlockChain::findWalletData(WalletId id, WalletData& wallData) const {
    std::lock_guard lock(cacheMutex_);
    return findWalletData_Unsafe(id, wallData);
}

bool BlockChain::findWalletData_Unsafe(WalletId id, WalletData& wallData) const {
    const WalletData* wallDataPtr = walletsCacheUpdater_->findWallet(id);

    if (wallDataPtr) {
        wallData = *wallDataPtr;
        return true;
    }

    return false;
}

bool BlockChain::getModifiedWallets(Mask& dest) const {
    std::lock_guard lock(cacheMutex_);

    bool isNewModified = (walletsCacheUpdater_->getModified().size() != dest.size()) || walletsCacheUpdater_->getModified().any();

    dest.resize(walletsCacheUpdater_->getModified().size(), true);
    dest |= walletsCacheUpdater_->getModified();

    return isNewModified;
}

bool BlockChain::findWalletId(const WalletAddress& address, WalletId& id) const {
    if (address.is_wallet_id()) {
        id = address.wallet_id();
        return true;
    }
    else if (address.is_public_key()) {
        std::lock_guard lock(cacheMutex_);
        return walletIds_->normal().find(address, id);
    }

    cserror() << "Wrong address";
    return false;
}

bool BlockChain::getWalletId(const WalletAddress& address, WalletId& id) {
    if (address.is_wallet_id()) {
        id = address.wallet_id();
        return false;
    }
    else if (address.is_public_key()) {
        std::lock_guard lock(cacheMutex_);
        return walletIds_->normal().get(address, id);
    }

    cserror() << "Wrong address";
    return false;
}

bool BlockChain::findAddrByWalletId(const WalletId id, csdb::Address& addr) const {
    if (!walletIds_->normal().findaddr(id, addr)) {
        return false;
    }

    return true;
}

std::optional<csdb::Pool> BlockChain::recordBlock(csdb::Pool& pool, bool isTrusted) {
    const auto last_seq = getLastSequence();
    const auto pool_seq = pool.sequence();

    csdebug() << "BLOCKCHAIN> finish & store block #" << pool_seq << " to chain";

    if (last_seq + 1 != pool_seq) {
        cserror() << "BLOCKCHAIN> cannot record block #" << pool_seq << " to chain, last sequence " << last_seq;
        return std::nullopt;
    }

    pool.set_previous_hash(getLastHash());

    constexpr cs::Sequence NoSequence = std::numeric_limits<cs::Sequence>::max();
    cs::Sequence flushed_block_seq = NoSequence;

    {
        cs::Lock lock(dbLock_);

        if (deferredBlock_.is_valid()) {

            deferredBlock_.set_storage(storage_);

            if (deferredBlock_.save()) {
                flushed_block_seq = deferredBlock_.sequence();
                if (uuid_ == 0 && flushed_block_seq == 1) {
                    uuid_ = uuidFromBlock(deferredBlock_);
                    csdebug() << "Blockchain: UUID = " << uuid_;
                }
            }
            else {
                csmeta(cserror) << "Couldn't save block: " << deferredBlock_.sequence();
            }
        }
    }

    if (flushed_block_seq != NoSequence) {
        csdebug() << "---------------------------- Flush block #" << flushed_block_seq << " to disk ---------------------------";
        csdebug() << "signatures amount = " << deferredBlock_.signatures().size() << ", smartSignatures amount = " << deferredBlock_.smartSignatures().size()
                  << ", see block info above";
        csdebug() << "----------------------------------------------------------------------------------";
    }

    {
        cs::Lock lock(dbLock_);

        cs::PublicKeys lastConfidants;
        if (pool_seq > 1) {
            if (deferredBlock_.sequence() + 1 == pool_seq) {
                lastConfidants = deferredBlock_.confidants();
            }
            else {
                lastConfidants = loadBlock(pool_seq - 1).confidants();
            }
        }

        // next 2 calls order is extremely significant: finalizeBlock() may call to smarts-"enqueue"-"execute", so deferredBlock MUST BE SET properly
        deferredBlock_ = pool;
        if (finalizeBlock(deferredBlock_, isTrusted, lastConfidants)) {
            csdebug() << "The block is correct";
        }
        else {
            csdebug() << "the signatures of the block are incorrect";
            return std::nullopt;
        }
        pool = deferredBlock_.clone();
    }
    csdetails() << "Pool #" << deferredBlock_.sequence() << ": " << cs::Utils::byteStreamToHex(deferredBlock_.to_binary().data(), deferredBlock_.to_binary().size());
    emit storeBlockEvent(pool);

    // log cached block
    csdebug() << "----------------------- Defer block #" << pool.sequence() << " until next round ----------------------";
    logBlockInfo(pool);
    csdebug() << "----------------------------------- " << pool.sequence() << " --------------------------------------";

    return std::make_optional(pool);
}

bool BlockChain::storeBlock(csdb::Pool& pool, bool bySync) {
    csdebug() << csfunc() << ":";

    const auto lastSequence = getLastSequence();
    const auto poolSequence = pool.sequence();

    if (poolSequence <= lastSequence) {
        // ignore
        csdebug() << "BLOCKCHAIN> ignore oudated block #" << poolSequence << ", last written #" << lastSequence;
        // it is not error, so caller code nothing to do with it
        return true;
    }

    if ((pool.numberConfirmations() == 0 || pool.roundConfirmations().size() == 0) && pool.sequence() > 1) {
        return false;
    }

    if (poolSequence == lastSequence) {
        std::lock_guard lock(dbLock_);

        if (!deferredBlock_.signatures().empty()) {
            // ignore
            csdebug() << "BLOCKCHAIN> ignore oudated block #" << poolSequence << ", last written #" << lastSequence;
            // it is not error, so caller code nothing to do with it
            return true;
        }
        else {
            csdebug() << "BLOCKCHAIN> we have to rewrite #" << poolSequence;
            // removeLastBlock();
        }
    }

    if (poolSequence == lastSequence + 1) {
        if (pool.previous_hash() != getLastHash()) {
            csdebug() << "BLOCKCHAIN> new pool\'s prev. hash does not equal to current last hash, remove own last block and cancel store operation";
            if (getLastHash().is_empty()) {
                cserror() << "BLOCKCHAIN> own last hash is empty";
            }
            if (pool.previous_hash().is_empty()) {
                cserror() << "BLOCKCHAIN> new pool\'s prev. hash is empty";
            }
            removeLastBlock();
            return false;
        }

        setTransactionsFees(pool);

        // update wallet ids
        if (bySync) {
            // ready-to-record block does not require anything
            csdebug() << "BLOCKCHAIN> store block #" << poolSequence << " to chain, update wallets ids";
            updateWalletIds(pool, *walletsCacheUpdater_);
        }
        else {
            csdebug() << "BLOCKCHAIN> store block #" << poolSequence << " add new wallets to pool";
            addNewWalletsToPool(pool);
        }

        // write immediately
        if (recordBlock(pool, false).has_value()) {
            csdebug() << "BLOCKCHAIN> block #" << poolSequence << " has recorded to chain successfully";
            // unable to call because stack overflow in case of huge written blocks amount possible:
            // testCachedBlocks();
            return true;
        }

        csdebug() << "BLOCKCHAIN> failed to store block #" << poolSequence << " to chain";
        removeLastBlock();
        return false;
    }

    if (cachedBlocks_.count(poolSequence) > 0) {
        csdebug() << "BLOCKCHAIN> ignore duplicated block #" << poolSequence << " in cache";
        // it is not error, so caller code nothing to do with it
        return true;
    }
    // cache block for future recording
    csdebug() << "BLOCKCHAIN> cached block has " << pool.signatures().size();
    cachedBlocks_.emplace(poolSequence, BlockMeta{pool, bySync});
    csdebug() << "BLOCKCHAIN> cache block #" << poolSequence << " for future (" << cachedBlocks_.size() << " total)";
    cachedBlockEvent(poolSequence);
    // cache always successful
    return true;
}

void BlockChain::testCachedBlocks() {
    csdebug() << "BLOCKCHAIN> test cached blocks";
    if (cachedBlocks_.empty()) {
        csdebug() << "BLOCKCHAIN> no cached blocks";
        return;
    }

    auto lastSeq = getLastSequence() + 1;
    // clear unnecessary sequence
    if (cachedBlocks_.cbegin()->first < lastSeq) {
        auto it = cachedBlocks_.lower_bound(lastSeq);
        if (it != cachedBlocks_.begin()) {
            csdebug() << "BLOCKCHAIN> Remove outdated blocks up to #" << (*it).first << " from cache";
            cachedBlocks_.erase(cachedBlocks_.begin(), it);
        }
    }

    while (!cachedBlocks_.empty()) {
        auto firstBlockInCache = cachedBlocks_.begin();

        if ((*firstBlockInCache).first == lastSeq) {
            csdebug() << "BLOCKCHAIN> Retrieve required block #" << lastSeq << " from cache";
            // retrieve and use block if it is exactly what we need:

            const bool ok = storeBlock((*firstBlockInCache).second.pool, (*firstBlockInCache).second.by_sync);
            cachedBlocks_.erase(firstBlockInCache);
            if (!ok) {
                cserror() << "BLOCKCHAIN> Failed to record cached block to chain, drop it & wait to request again";
                break;
            }
            ++lastSeq;
        }
        else {
            // stop processing, we have not got required block in cache yet
            csdebug() << "BLOCKCHAIN> Stop store block from cache. Next blocks in cache #" << (*firstBlockInCache).first;
            break;
        }
    }
}

const cs::ReadBlockSignal& BlockChain::readBlockEvent() const {
    return storage_.readBlockEvent();
}

std::size_t BlockChain::getCachedBlocksSize() const {
    return cachedBlocks_.size();
}

std::vector<BlockChain::SequenceInterval> BlockChain::getRequiredBlocks() const {
    const auto firstSequence = getLastSequence() + 1;
    const auto currentRoundNumber = cs::Conveyer::instance().currentRoundNumber();

    if (firstSequence >= currentRoundNumber) {
        return std::vector<SequenceInterval>();
    }

    const auto roundNumber = currentRoundNumber > 0 ? std::max(firstSequence, currentRoundNumber - 1) : 0;

    // return at least [next, 0] or [next, currentRoundNumber]:
    std::vector<SequenceInterval> vec{std::make_pair(firstSequence, roundNumber)};

    // always point to last interval
    auto firstUpper = cachedBlocks_.upper_bound(firstSequence);

    if (firstUpper != cachedBlocks_.end()) {
        auto sequence = firstUpper->first;
        vec[0].second = sequence - 1;

        while ((++firstUpper) != cachedBlocks_.end()) {
            ++sequence;
            if (firstUpper->first != sequence) {
                vec.emplace_back(std::make_pair(sequence, firstUpper->first - 1));
                sequence = firstUpper->first;
            }
        }
    }

    // add last interval [final + 1, end]
    if (!cachedBlocks_.empty()) {
        const auto lastCahedBlock = cachedBlocks_.crbegin()->first;
        if (roundNumber > lastCahedBlock) {
            vec.emplace_back(std::make_pair(lastCahedBlock, roundNumber));
        }
    }

    return vec;
}

void BlockChain::setTransactionsFees(TransactionsPacket& packet) {
    fee::setCountedFees(packet.transactions());
}

void BlockChain::setTransactionsFees(csdb::Pool& pool) {
    fee::setCountedFees(pool.transactions());
}

void BlockChain::setTransactionsFees(std::vector<csdb::Transaction>& transactions) {
    fee::setCountedFees(transactions);
}

void BlockChain::setTransactionsFees(std::vector<csdb::Transaction>& transactions, const cs::Bytes&) {
    fee::setCountedFees(transactions);
}

const csdb::Address& BlockChain::getGenesisAddress() const {
    return genesisAddress_;
}

csdb::Address BlockChain::getAddressByType(const csdb::Address& addr, AddressType type) const {
    csdb::Address addr_res{};
    switch (type) {
        case AddressType::PublicKey:
            if (addr.is_public_key() || !findAddrByWalletId(addr.wallet_id(), addr_res)) {
                addr_res = addr;
            }

            break;
        case AddressType::Id:
            uint32_t _id;
            if (findWalletId(addr, _id)) {
                addr_res = csdb::Address::from_wallet_id(_id);
            }

            break;
    }
    return addr_res;
}

bool BlockChain::isEqual(const csdb::Address& laddr, const csdb::Address& raddr) const {
    if (getAddressByType(laddr, AddressType::PublicKey) == getAddressByType(raddr, AddressType::PublicKey)) {
        return true;
    }

    return false;
}

uint32_t BlockChain::getTransactionsCount(const csdb::Address& addr) {
    std::lock_guard lock(cacheMutex_);
    WalletId id;

    if (addr.is_wallet_id()) {
        id = addr.wallet_id();
    }

    else if (!walletIds_->normal().find(addr, id)) {
        return 0;
    }

    const WalletData* wallDataPtr = walletsCacheUpdater_->findWallet(id);

    if (!wallDataPtr) {
        return 0;
    }

    return static_cast<uint32_t>(wallDataPtr->transNum_);
}

//uint64_t BlockChain::initUuid() const {
//    // protects from subsequent calls
//    if (uuid_ != 0) {
//        return uuid_;
//    }
//    // lookup in hashes
//    if (!blockHashes_->empty()) {
//        const auto& hashes = blockHashes_->getHashes();
//        if (hashes.size() > 1) {
//            const auto tmp = uuidFromHash(hashes[1]);
//            if (tmp != 0) {
//                return tmp;
//            }
//        }
//    }
//    // lookup in chain
//    return uuidFromBlock(loadBlock(1));
//}

#ifdef TRANSACTIONS_INDEX
csdb::TransactionID BlockChain::getLastTransaction(const csdb::Address& addr) {
    std::lock_guard lock(cacheMutex_);
    WalletId id;

    if (addr.is_wallet_id()) {
        id = addr.wallet_id();
    }
    else if (!walletIds_->normal().find(addr, id)) {
        return csdb::TransactionID();
    }

    const WalletData* wallDataPtr = walletsCacheUpdater_->findWallet(id);

    if (!wallDataPtr) {
        return csdb::TransactionID();
    }

    return wallDataPtr->lastTransaction_;
}

csdb::PoolHash BlockChain::getPreviousPoolHash(const csdb::Address& addr, const csdb::PoolHash& ph) {
    std::lock_guard lock(dbLock_);
    return storage_.get_previous_transaction_block(getAddressByType(addr, BlockChain::AddressType::PublicKey), ph);
}

std::pair<csdb::PoolHash, uint32_t> BlockChain::getLastNonEmptyBlock() {
    std::lock_guard lock(dbLock_);
    return std::make_pair(lastNonEmptyBlock_.hash, lastNonEmptyBlock_.transCount);
}

std::pair<csdb::PoolHash, uint32_t> BlockChain::getPreviousNonEmptyBlock(const csdb::PoolHash& ph) {
    std::lock_guard lock(dbLock_);
    const auto it = previousNonEmpty_.find(ph);

    if (it != previousNonEmpty_.end()) {
        return std::make_pair(it->second.hash, it->second.transCount);
    }

    return std::pair<csdb::PoolHash, uint32_t>();
}

TransactionsIterator::TransactionsIterator(BlockChain& bc, const csdb::Address& addr)
: bc_(bc)
, addr_(addr) {
    setFromTransId(bc_.getLastTransaction(addr));
}

void TransactionsIterator::setFromTransId(const csdb::TransactionID& lTrans) {
    if (lTrans.is_valid()) {
        lapoo_ = bc_.loadBlock(lTrans.pool_hash());
        it_ = lapoo_.transactions().rbegin() + (lapoo_.transactions().size() - lTrans.index() - 1);
    }
    else {
        lapoo_ = csdb::Pool{};
    }
}

bool TransactionsIterator::isValid() const {
    return lapoo_.is_valid();
}

void TransactionsIterator::next() {
    while (++it_ != lapoo_.transactions().rend()) {
        if (bc_.isEqual(it_->source(), addr_) || bc_.isEqual(it_->target(), addr_)) {
            break;
        }
    }

    // Oops, no more in this blockfTransactionsListGet
    if (it_ == lapoo_.transactions().rend()) {
        auto ph = bc_.getPreviousPoolHash(addr_, lapoo_.hash());
        lapoo_ = bc_.loadBlock(ph);

        if (lapoo_.is_valid()) {
            it_ = lapoo_.transactions().rbegin();
            // transactions() cannot be empty
            if (!bc_.isEqual(it_->source(), addr_) && !bc_.isEqual(it_->target(), addr_)) {
                next();  // next should be executed only once
            }
        }
    }
}

#else

void TransactionsIterator::setFromHash(const csdb::PoolHash& ph) {
    auto hash = ph;
    bool found = false;

    while (!found) {
        lapoo_ = bc_.loadBlock(hash);

        if (!lapoo_.is_valid()) {
            break;
        }

        for (it_ = lapoo_.transactions().rbegin(); it_ != lapoo_.transactions().rend(); ++it_) {
            if (bc_.isEqual(it_->source(), addr_) || bc_.isEqual(it_->target(), addr_)) {
                found = true;
                break;
            }
        }

        hash = lapoo_.previous_hash();
    }
}

TransactionsIterator::TransactionsIterator(BlockChain& bc, const csdb::Address& addr)
: bc_(bc)
, addr_(addr) {
    setFromHash(bc_.getLastHash());
}

bool TransactionsIterator::isValid() const {
    return lapoo_.is_valid();
}

void TransactionsIterator::next() {
    bool found = false;

    while (++it_ != lapoo_.transactions().rend()) {
        if (bc_.isEqual(it_->source(), addr_) || bc_.isEqual(it_->target(), addr_)) {
            found = true;
            break;
        }
    }

    if (!found) {
        setFromHash(lapoo_.previous_hash());
    }
}

#endif
```
# ..\node\csnode\src\blockhashes.cpp 
```cpp 
#include <csnode/blockhashes.hpp>
#include <cstring>
#include <fstream>
#include <lib/system/logger.hpp>

namespace cs {
BlockHashes::BlockHashes()
: db_{}
, isDbInited_(false) {
}

void BlockHashes::initStart() {
}

bool BlockHashes::initFromPrevBlock(csdb::Pool prevBlock) {
    cs::Sequence seq = prevBlock.sequence();
    db_.last_ = seq;
    if (!isDbInited_) {
        db_.first_ = 0;
        db_.last_ = seq;
        hashes_.reserve(db_.last_ + 1);
        isDbInited_ = true;
    }

    hashes_.emplace_back(prevBlock.hash());
    return true;
}

void BlockHashes::initFinish() {
    if (hashes_.size() >= 2) {
        size_t lh = 0;
        size_t rh = hashes_.size() - 1;
        while (lh < rh) {
            std::swap(hashes_[lh++], hashes_[rh--]);
        }
    }

    for (const auto& hash : hashes_) {
        cslog() << "READ> " << hash.to_string();
    }
}

bool BlockHashes::loadNextBlock(csdb::Pool nextBlock) {
    cs::Sequence seq = nextBlock.sequence();
    if (!isDbInited_) {
        db_.first_ = 0;
        db_.last_ = seq;
        isDbInited_ = true;
    }
    else if (seq <= db_.last_) {
        csdebug() << __func__ << ": seq <= db_.last_";
        return false;
    }

    if (seq != hashes_.size()) {
        csdebug() << __func__ << ": seq != hashes_.size()";
        return false;  // see BlockChain::putBlock
    }

    hashes_.emplace_back(nextBlock.hash());
    db_.last_ = seq;
    return true;
}

csdb::PoolHash BlockHashes::find(cs::Sequence seq) const {
    if (empty()) {
        return csdb::PoolHash();
    }
    const auto& range = getDbStructure();
    if (seq < range.first_ || range.last_ < seq) {
        return csdb::PoolHash();
    }
    return hashes_[seq];
}

cs::Sequence BlockHashes::find(csdb::PoolHash hash) const {
    const auto result = std::find(hashes_.cbegin(), hashes_.cend(), hash);

    if (result != hashes_.cend()) {
        return std::distance(hashes_.cbegin(), result);
    }

    return 0;
}

csdb::PoolHash BlockHashes::removeLast() {
    if (hashes_.empty()) {
        return csdb::PoolHash{};
    }
    const auto result = hashes_.back();
    hashes_.pop_back();
    --db_.last_;
    return result;
}

csdb::PoolHash BlockHashes::getLast() const {
    if (hashes_.empty()) {
        return csdb::PoolHash{};
    }
    return hashes_.back();
}

const std::vector<csdb::PoolHash>& BlockHashes::getHashes() const {
    return hashes_;
}

}  // namespace cs
```
# ..\node\csnode\src\blockvalidator.cpp 
```cpp 
#include <csnode/blockvalidator.hpp>

#include <csnode/blockchain.hpp>
#include <csnode/walletsstate.hpp>

#include <csnode/blockvalidatorplugins.hpp>

namespace cs {

BlockValidator::BlockValidator(const BlockChain& bc)
: bc_(bc)
, wallets_(::std::make_shared<WalletsState>(bc_)) {
    plugins_.insert(std::make_pair(hashIntergrity, std::make_unique<HashValidator>(*this)));
    plugins_.insert(std::make_pair(blockNum, std::make_unique<BlockNumValidator>(*this)));
    plugins_.insert(std::make_pair(timestamp, std::make_unique<TimestampValidator>(*this)));
    plugins_.insert(std::make_pair(blockSignatures, std::make_unique<BlockSignaturesValidator>(*this)));
    plugins_.insert(std::make_pair(smartSignatures, std::make_unique<SmartSourceSignaturesValidator>(*this)));
    plugins_.insert(std::make_pair(balances, std::make_unique<BalanceChecker>(*this)));
    plugins_.insert(std::make_pair(transactionsSignatures, std::make_unique<TransactionsChecker>(*this)));
}

BlockValidator::~BlockValidator() {
}

inline bool BlockValidator::return_(ErrorType error, SeverityLevel severity) {
    return !(error >> severity);
}

bool BlockValidator::validateBlock(const csdb::Pool& block, ValidationFlags flags, SeverityLevel severity) {
    if (!flags || block.sequence() == 0) {
        return true;
    }

    if (!block.is_valid()) {
        cserror() << "BlockValidator: invalid block received";
        return false;
    }

    if (!prevBlock_.is_valid() || block.sequence() - prevBlock_.sequence() != 1) {
        prevBlock_ = bc_.loadBlock(block.previous_hash());
        if (!prevBlock_.is_valid()) {
            cserror() << "BlockValidator: block with hash " << block.previous_hash().to_string() << " is not valid.";
            return false;
        }
    }

    ErrorType validationResult = noError;
    for (auto& plugin : plugins_) {
        if (flags & plugin.first) {
            validationResult = plugin.second->validateBlock(block);
            if (!return_(validationResult, severity)) {
                return false;
            }
        }
    }

    prevBlock_ = block;
    return true;
}
}  // namespace cs
```
# ..\node\csnode\src\blokcvalidatorplugins.cpp 
```cpp 
#include <csnode/blockvalidatorplugins.hpp>

#include <string>
#include <algorithm>
#include <set>

#include <csdb/pool.hpp>
#include <csnode/blockchain.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/common.hpp>
#include <csnode/walletsstate.hpp>
#include <csnode/walletscache.hpp>
#include <csdb/amount_commission.hpp>
#include <csdb/pool.hpp>
#include <cscrypto/cscrypto.hpp>
#include <smartcontracts.hpp>

#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace {
const char* kLogPrefix = "BlockValidator: ";
const cs::Sequence kGapBtwNeighbourBlocks = 1;
const csdb::user_field_id_t kTimeStampUserFieldNum = 0;
const uint8_t kBlockVerToSwitchCountedFees = 0;
} // namespace

namespace cs {

ValidationPlugin::ErrorType HashValidator::validateBlock(const csdb::Pool& block) {
  auto prevHash = block.previous_hash();
  auto& prevBlock = getPrevBlock();
  auto data = prevBlock.to_binary();
  auto countedPrevHash = csdb::PoolHash::calc_from_data(cs::Bytes(data.data(),
                                                          data.data() +
                                                          prevBlock.hashingLength()));
  if (prevHash != countedPrevHash) {
    csfatal() << kLogPrefix << ": prev pool's (" << prevBlock.sequence()
              << ") hash != real prev pool's hash";
    return ErrorType::fatalError;      
  }
  return ErrorType::noError;
}

ValidationPlugin::ErrorType BlockNumValidator::validateBlock(const csdb::Pool& block) {
  auto& prevBlock = getPrevBlock();
  if (block.sequence() - prevBlock.sequence() != kGapBtwNeighbourBlocks) {
    cserror() << kLogPrefix << "Current block's sequence is " << block.sequence()
              << ", previous block sequence is " << prevBlock.sequence();
    return ErrorType::error;
  }
  return ErrorType::noError;
}

ValidationPlugin::ErrorType TimestampValidator::validateBlock(const csdb::Pool& block) {
  auto& prevBlock = getPrevBlock();

  auto prevBlockTimestampUf = prevBlock.user_field(kTimeStampUserFieldNum);
  if (!prevBlockTimestampUf.is_valid()) {
    cswarning() << kLogPrefix << "Block with sequence " << prevBlock.sequence() << " has no timestamp";
    return ErrorType::warning;
  }
  auto currentBlockTimestampUf = block.user_field(kTimeStampUserFieldNum);
  if (!currentBlockTimestampUf.is_valid()) {
    cswarning() << kLogPrefix << "Block with sequence " << block.sequence() << " has no timestamp";
    return ErrorType::warning;
  }

  auto prevBlockTimestamp = std::stoll(prevBlockTimestampUf.value<std::string>());
  auto currentBlockTimestamp = std::stoll(currentBlockTimestampUf.value<std::string>());
  if (currentBlockTimestamp < prevBlockTimestamp) {
    cswarning() << kLogPrefix << "Block with sequence " << block.sequence()
                << " has timestamp " << currentBlockTimestamp
                << " less than " << prevBlockTimestamp
                << " in block with sequence " << prevBlock.sequence();
    return ErrorType::warning;
  }
  return ErrorType::noError;
}

ValidationPlugin::ErrorType BlockSignaturesValidator::validateBlock(const csdb::Pool& block) {
  uint64_t realTrustedMask = block.realTrusted();
#ifdef _MSC_VER
  size_t numOfRealTrusted = static_cast<decltype(numOfRealTrusted)>(__popcnt64(realTrustedMask));
#else
  size_t numOfRealTrusted = static_cast<decltype(numOfRealTrusted)>(__builtin_popcountl(realTrustedMask));
#endif

  auto signatures = block.signatures();
  if (signatures.size() != numOfRealTrusted) {
    cserror() << kLogPrefix << "in block " << block.sequence()
              << " num of signatures (" << signatures.size()
              << ") != num of real trusted (" << numOfRealTrusted << ")";
    return ErrorType::error;
  }

  auto confidants = block.confidants();
  const size_t maxTrustedNum = sizeof(realTrustedMask) * 8;
  if (confidants.size() > maxTrustedNum) {
    cserror() << kLogPrefix << "in block " << block.sequence()
              << " num of confidants " << confidants.size()
              << " is greated than max bits in realTrustedMask";
    return ErrorType::error;
  }

  size_t checkingSignature = 0;
  auto signedData = cscrypto::calculateHash(block.to_binary().data(), block.hashingLength());
  for (size_t i = 0; i < confidants.size(); ++i) {
    if (realTrustedMask & (1ull << i)) {
      if (!cscrypto::verifySignature(signatures[checkingSignature],
                                     confidants[i],
                                     signedData.data(),
                                     cscrypto::kHashSize)) {
        cserror() << kLogPrefix << "block " << block.sequence()
                  << " has invalid signatures";
        return ErrorType::error;
      }
      ++checkingSignature;
    }
  }

  return ErrorType::noError;
}

ValidationPlugin::ErrorType SmartSourceSignaturesValidator::validateBlock(const csdb::Pool& block) {
  const auto& transactions = block.transactions();
  const auto& smartSignatures = block.smartSignatures();

  if (smartSignatures.empty()) {
    if (containsNewState(transactions)) {
        cserror() << kLogPrefix << "no smart signatures in block "
                  << block.sequence() << ", which contains new state";
        return ErrorType::error;
    }
    return ErrorType::noError;
  }

  bool switchCountedFees = block.version() == kBlockVerToSwitchCountedFees;
  auto smartPacks = grepNewStatesPacks(transactions, switchCountedFees);

  if (!checkSignatures(smartSignatures, smartPacks)) {
    return ErrorType::error;
  }

  return ErrorType::noError;
}

bool SmartSourceSignaturesValidator::checkSignatures(const SmartSignatures& sigs,
                                                     const Packets& smartPacks) {
  if (sigs.size() != smartPacks.size()) {
    cserror() << kLogPrefix << "q-ty of smart signatures != q-ty of real smart packets"; 
    return false;
  }

  for (const auto& pack : smartPacks) {
    auto it = std::find_if(sigs.begin(), sigs.end(),
                           [&pack] (const csdb::Pool::SmartSignature& s) {
                           return pack.transactions()[0].source().public_key() == s.smartKey; });

    if (it == sigs.end()) {
      cserror() << kLogPrefix << "no smart signatures for new state with key "
                << pack.transactions()[0].source().to_string();
      return false;
    }

    auto initPool = getBlockChain().loadBlock(it->smartConsensusPool);
    const auto& confidants = initPool.confidants();
    const auto& smartSignatures = it->signatures;
    for (const auto& s : smartSignatures) {
      if (s.first >= confidants.size()) {
        cserror() << kLogPrefix << "smart signature validation: no conf with index "
                  << s.first << " in init pool with sequence " << initPool.sequence();
        return false;
      }
      if (!cscrypto::verifySignature(s.second, confidants[s.first], pack.hash().toBinary().data(), cscrypto::kHashSize)) {
        cserror() << kLogPrefix << "incorrect signature of smart "
                  << pack.transactions()[0].source().to_string() << " of confidant " << s.first
                  << " from init pool with sequence " << initPool.sequence();
        return false;
      }
    }
  }

  return true;
}

inline bool SmartSourceSignaturesValidator::containsNewState(const Transactions& trxs) {
  for (const auto& t : trxs) {
    if (SmartContracts::is_new_state(t)) {
      return true;
    }
  }
  return false;
}

Packets SmartSourceSignaturesValidator::grepNewStatesPacks(const Transactions& trxs, bool switchFees) {
  Packets res;
  for (size_t i = 0; i < trxs.size(); ++i) {
    if (SmartContracts::is_new_state(trxs[i])) {
      cs::TransactionsPacket pack;
      pack.addTransaction(switchFees ? switchCountedFee(trxs[i]) : trxs[i]);
      std::for_each(trxs.begin() + i + 1, trxs.end(),
          [&] (const csdb::Transaction& t) {
            if (t.source() == trxs[i].source()) {
              pack.addTransaction(switchFees ? switchCountedFee(t) : t);
            }
          });
      pack.makeHash();
      res.push_back(pack);
    }
  }
  return res;
}

csdb::Transaction SmartSourceSignaturesValidator::switchCountedFee(const csdb::Transaction& t) {
  auto initTrx = WalletsCache::findSmartContractInitTrx(t, getBlockChain());
  if (!initTrx.is_valid()) {
    cserror() << kLogPrefix << " no init transaction for smart source transaction in blockchain";
    return t;
  }
  csdb::Transaction res(t.innerID(), t.source(), t.target(), t.currency(), t.amount(), t.max_fee(),
                        initTrx.counted_fee(), t.signature());
  auto ufIds = t.user_field_ids();
  for (const auto& id : ufIds) {
    res.add_user_field(id, t.user_field(id));
  }
  return res;
}

ValidationPlugin::ErrorType BalanceChecker::validateBlock(const csdb::Pool&) {
  const auto& prevBlock = getPrevBlock();
  if (prevBlock.transactions().empty()) {
    return ErrorType::noError;
  }

  const auto& trxs = prevBlock.transactions();
  auto wallets = getWallets();
  wallets->updateFromSource();
  for (const auto& t : trxs) {
    WalletsState::WalletId id{};
    const WalletsState::WalletData& wallState = wallets->getData(t.source(), id);
    if (wallState.balance_ < zeroBalance_) {
      cserror() << kLogPrefix << "error detected in pool " << prevBlock.sequence()
                << ", wall address " << t.source().to_string()
                << " has balance " << wallState.balance_.to_double();
      return ErrorType::error;
    }
  }

  return ErrorType::noError;
}

ValidationPlugin::ErrorType TransactionsChecker::validateBlock(const csdb::Pool& block) {
  const auto& trxs = block.transactions();
  std::set<csdb::Address> newStates;
  for (const auto& t : trxs) {
    if (SmartContracts::is_new_state(t)) {
      // already checked by another plugin
      newStates.insert(t.source());
      continue;
    }

    auto it = std::find(newStates.begin(), newStates.end(), t.source());
    if (it != newStates.end()) {
      continue;
    }

    if (!checkSignature(t)) {
      cserror() << kLogPrefix << " in pool " << block.sequence()
                << " transaction from " << t.source().to_string()
                << ", with innerID " << t.innerID()
                << " has incorrect signature";
      return ErrorType::error;
    }
  }
  return ErrorType::noError;
}

bool TransactionsChecker::checkSignature(const csdb::Transaction& t) {
  if (t.source().is_wallet_id()) {
    const auto& bc = getBlockChain();
    BlockChain::WalletData dataToFetchPublicKey;
    if (!bc.findWalletData(t.source().wallet_id(), dataToFetchPublicKey)) {
      cserror() << kLogPrefix << "no public key for id "
                << t.source().wallet_id() << " in blockchain";
      return false;
    }
    return t.verify_signature(dataToFetchPublicKey.address_);
  } else {
    return t.verify_signature(t.source().public_key());
  }
}

} // namespace cs
```
# ..\node\csnode\src\confirmationlist.cpp 
```cpp 
#include <csnode/confirmationlist.hpp>

namespace cs {
void ConfirmationList::add(cs::RoundNumber rNum, bool bang, const cs::ConfidantsKeys& confidants, const cs::Bytes& confirmationsMask, const cs::Signatures& confirmation) {
    if (confirmationList_.find(rNum) != confirmationList_.cend()) {
        remove(rNum);
    }

    TrustedConfirmation tConfirmation;
    tConfirmation.bigBang = bang;
    tConfirmation.confidants = confidants;
    tConfirmation.mask = confirmationsMask;
    tConfirmation.signatures = confirmation;

    confirmationList_.emplace(rNum, std::move(tConfirmation));
}

void ConfirmationList::remove(cs::RoundNumber rNum) {
    if (confirmationList_.find(rNum) != confirmationList_.end()) {
        confirmationList_.erase(rNum);
        csdebug() << "The confirmation of R-" << rNum << " was successfully erased, conf.size = " << confirmationList_.size();
    }
    else {
        csdebug() << "The confirmation of R-" << rNum << " was not found";
    }
}

std::optional<cs::TrustedConfirmation> ConfirmationList::find(cs::RoundNumber rNum) const {
    const auto it = confirmationList_.find(rNum);

    if (it == confirmationList_.end()) {
        return std::nullopt;
    }

    return std::make_optional<cs::TrustedConfirmation>(it->second);
}
}  // namespace cs
```
# ..\node\csnode\src\conveyer.cpp 
```cpp 
#include "csnode/conveyer.hpp"

#include <csdb/transaction.hpp>

#include <csnode/datastream.hpp>
#include <solver/smartcontracts.hpp>

#include <exception>
#include <iomanip>

#include <lib/system/hash.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>

namespace {
cs::ConveyerBase* conveyerView = nullptr;
std::once_flag onceFlag = {};

static void setup(cs::ConveyerBase* conveyer) {
    conveyerView = conveyer;
}
}

struct cs::ConveyerBase::Impl {
    explicit Impl(size_t queueSize, size_t transactionsSize, size_t packetsPerRound);

    // first storage of transactions, before sending to network
    cs::PacketQueue packetQueue;

    // current round transactions packets storage
    cs::TransactionsPacketTable packetsTable;

    // main conveyer meta data
    cs::ConveyerMetaStorage metaStorage;

    // characteristic meta base
    cs::CharacteristicMetaStorage characteristicMetas;

    // cached active current round number
    std::atomic<cs::RoundNumber> currentRound = 0;

    // helpers
    const cs::ConveyerMeta* validMeta() &;
};

inline cs::ConveyerBase::Impl::Impl(size_t queueSize, size_t transactionsSize, size_t packetsPerRound)
: packetQueue(queueSize, transactionsSize, packetsPerRound) {
}

inline const cs::ConveyerMeta* cs::ConveyerBase::Impl::validMeta() & {
    cs::ConveyerMeta* meta = metaStorage.get(currentRound);

    if (meta != nullptr) {
        return meta;
    }

    return &(metaStorage.max());
}

cs::ConveyerBase::ConveyerBase() {
    pimpl_ = std::make_unique<cs::ConveyerBase::Impl>(MaxQueueSize, MaxPacketTransactions, MaxPacketsPerRound);
    pimpl_->metaStorage.append(cs::ConveyerMetaStorage::Element());

    std::call_once(::onceFlag, &::setup, this);
}

void cs::ConveyerBase::setRound(cs::RoundNumber round) {
    csmeta(csdebug) << "trying to change round to " << round;

    if (currentRoundNumber() < round) {
        pimpl_->currentRound = round;
        csdebug() << csname() << "cached round updated";
    }
    else {
        cswarning() << csname() << "current round " << currentRoundNumber();
    }
}

cs::ConveyerBase::~ConveyerBase() = default;

void cs::ConveyerBase::addTransaction(const csdb::Transaction& transaction) {
    if (!transaction.is_valid()) {
        cswarning() << csname() << "Can not add no valid transaction to conveyer";
        return;
    }

    cs::Lock lock(sharedMutex_);

    auto id = transaction.innerID();

    if (pimpl_->packetQueue.push(transaction)) {
        csdetails() << csname() << "Add valid transaction to conveyer id: " << id << ", queue size: " << pimpl_->packetQueue.size();
    }
    else {
        cswarning() << csname() << "Add transaction failed to queue, transaction id: " << id << ", queue size: " << pimpl_->packetQueue.size();
    }
}

void cs::ConveyerBase::addSeparatePacket(const cs::TransactionsPacket& packet) {
    csdebug() << csname() << "Add separate transactions packet to conveyer, transactions " << packet.transactionsCount();
    cs::Lock lock(sharedMutex_);

    // add current packet
    pimpl_->packetQueue.push(packet);
}

void cs::ConveyerBase::addTransactionsPacket(const cs::TransactionsPacket& packet) {
    cs::TransactionsPacketHash hash = packet.hash();
    cs::Lock lock(sharedMutex_);

    if (auto iterator = pimpl_->packetsTable.find(hash); iterator == pimpl_->packetsTable.end()) {
        pimpl_->packetsTable.emplace(std::move(hash), packet);
    }
    else {
        csdebug() << csname() << "Same hash already exists at table: " << hash.toString();
    }
}

const cs::TransactionsPacketTable& cs::ConveyerBase::transactionsPacketTable() const {
    return pimpl_->packetsTable;
}

const cs::PacketQueue& cs::ConveyerBase::packetQueue() const {
    return pimpl_->packetQueue;
}

std::optional<std::pair<cs::TransactionsPacket, cs::Packets>> cs::ConveyerBase::createPacket() const {
    cs::Lock lock(sharedMutex_);

    static constexpr size_t smartContractDetector = 1;
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(currentRoundNumber());

    if (!meta) {
        cserror() << csname() << "Can not create transactions packet at round " << currentRoundNumber();
        return std::nullopt;
    }

    cs::TransactionsPacket packet;
    cs::Packets smartContractPackets;

    cs::PacketsHashes& hashes = meta->roundTable.hashes;
    cs::TransactionsPacketTable& table = pimpl_->packetsTable;

    for (const auto& hash : hashes) {
        const auto iterator = table.find(hash);

        if (iterator == table.end()) {
            cswarning() << csname() << "packet creation hash not found";
            return std::nullopt;
        }

        // to smarts
        if (iterator->second.signatures().size() > smartContractDetector) {
            smartContractPackets.push_back(iterator->second);
        }

        const auto& transactions = iterator->second.transactions();

        for (const auto& transaction : transactions) {
            if (!packet.addTransaction(transaction)) {
                cswarning() << csname() << "Can not add transaction at packet creation";
            }
        }
    }

    auto data = std::make_pair<cs::TransactionsPacket, cs::Packets>(std::move(packet), std::move(smartContractPackets));
    return std::make_optional<decltype(data)>(std::move(data));
}

void cs::ConveyerBase::updateRoundTable(cs::RoundNumber cachedRound, const cs::RoundTable& table) {
    cslog() << csname() << "updateRoundTable";

    {
        cs::Lock lock(sharedMutex_);

        while (table.round <= cachedRound) {
            pimpl_->metaStorage.extract(cachedRound);
            --cachedRound;
        }

        pimpl_->currentRound = table.round;

        if (pimpl_->metaStorage.contains(table.round)) {
            cserror() << csname() << "Round table updation failed";
        }
    }

    setTable(table);
}

void cs::ConveyerBase::setTable(const RoundTable& table) {
    csmeta(csdebug) << "started";

    if (table.round < currentRoundNumber()) {
        cserror() << csname() << "Setting table in conveyer failed, current round " << currentRoundNumber() << ", table round " << table.round;
        return;
    }

    const cs::PacketsHashes& hashes = table.hashes;
    cs::PacketsHashes neededHashes;

    {
        cs::SharedLock lock(sharedMutex_);
        std::copy_if(hashes.begin(), hashes.end(), std::back_inserter(neededHashes), [this](const auto& hash) { return (pimpl_->packetsTable.count(hash) == 0u); });
    }

    csdebug() << csname() << "Needed round hashes count " << neededHashes.size();

    for (const auto& hash : neededHashes) {
        csdetails() << csname() << "Need hash " << hash.toString();
    }

    // atomic
    pimpl_->currentRound = table.round;

    cs::ConveyerMetaStorage::Element element;
    element.round = table.round;
    element.meta.neededHashes = std::move(neededHashes);
    element.meta.roundTable = table;

    {
        cs::Lock lock(sharedMutex_);

        if (!pimpl_->metaStorage.contains(pimpl_->currentRound)) {
            pimpl_->metaStorage.append(std::move(element));
        }
        else {
            csfatal() << csname() << "Meta round currently in conveyer";
        }
    }

    csmeta(csdebug) << "done, current table size " << pimpl_->packetsTable.size();
}

const cs::RoundTable& cs::ConveyerBase::currentRoundTable() const {
    return pimpl_->validMeta()->roundTable;
}

const cs::ConfidantsKeys& cs::ConveyerBase::confidants() const {
    return currentRoundTable().confidants;
}

size_t cs::ConveyerBase::confidantsCount() const {
    return confidants().size();
}

bool cs::ConveyerBase::isConfidantExists(size_t index) const {
    const cs::ConfidantsKeys& confidantsReference = confidants();

    if (confidantsReference.size() <= index) {
        csmeta(cserror) << ", index " << index << " out of range , confidants count " << confidantsReference.size() << ", on round " << pimpl_->currentRound;
        return false;
    }

    return true;
}

bool cs::ConveyerBase::isConfidantExists(const cs::PublicKey& confidant) const {
    const cs::ConfidantsKeys& keys = confidants();
    auto iterator = std::find(keys.begin(), keys.end(), confidant);
    return iterator != keys.end();
}

const cs::PublicKey& cs::ConveyerBase::confidantByIndex(size_t index) const {
    return confidants()[index];
}

std::optional<cs::PublicKey> cs::ConveyerBase::confidantIfExists(size_t index) const {
    if (isConfidantExists(index)) {
        return confidants()[index];
    }

    return std::nullopt;
}

const cs::RoundTable* cs::ConveyerBase::roundTable(cs::RoundNumber round) const {
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(round);

    if (!meta) {
        return nullptr;
    }

    return &meta->roundTable;
}

cs::RoundNumber cs::ConveyerBase::currentRoundNumber() const {
    return pimpl_->currentRound;
}

cs::RoundNumber cs::ConveyerBase::previousRoundNumber() const {
    return pimpl_->currentRound - 1;
}

const cs::PacketsHashes& cs::ConveyerBase::currentNeededHashes() const {
    return pimpl_->validMeta()->neededHashes;
}

const cs::PacketsHashes* cs::ConveyerBase::neededHashes(cs::RoundNumber round) const {
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(round);

    if (!meta) {
        cserror() << csname() << "Bad needed hashes, check node logic";
        return nullptr;
    }

    return &(meta->neededHashes);
}

void cs::ConveyerBase::addFoundPacket(cs::RoundNumber round, cs::TransactionsPacket&& packet) {
    cs::Lock lock(sharedMutex_);

    cs::ConveyerMeta* metaPointer = pimpl_->metaStorage.get(round);
    cs::TransactionsPacketTable* tablePointer = nullptr;

    if (metaPointer == nullptr) {
        cserror() << csname() << "Can not add sync packet because meta pointer do not exist";
        return;
    }

    tablePointer = (round == pimpl_->currentRound) ? &pimpl_->packetsTable : &metaPointer->hashTable;

    if (tablePointer == nullptr) {
        cserror() << csname() << "Can not add sync packet because table pointer do not exist";
        return;
    }

    cs::PacketsHashes& hashes = metaPointer->neededHashes;

    if (auto iterator = std::find(hashes.begin(), hashes.end(), packet.hash()); iterator != hashes.end()) {
        csdebug() << csname() << "Adding synced packet";
        hashes.erase(iterator);

        // add to current table
        auto hash = packet.hash();
        tablePointer->emplace(std::move(hash), std::move(packet));
    }
}

bool cs::ConveyerBase::isSyncCompleted() const {
    return isSyncCompleted(currentRoundNumber());
}

bool cs::ConveyerBase::isSyncCompleted(cs::RoundNumber round) const {
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(round);

    if (!meta) {
        cswarning() << csname() << "Needed hashes of " << round << " round not found, looks like old round packet received";
        return true;
    }

    return meta->neededHashes.empty();
}

const cs::Notifications& cs::ConveyerBase::notifications() const {
    return pimpl_->validMeta()->notifications;
}

void cs::ConveyerBase::addNotification(const cs::Bytes& bytes) {
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(currentRoundNumber());

    if (meta != nullptr) {
        csdebug() << csname() << "Writer notification added";
        meta->notifications.push_back(bytes);
    }
}

std::size_t cs::ConveyerBase::neededNotificationsCount() const {
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(pimpl_->currentRound);

    // TODO: check if +1 is correct
    if (meta) {
        return (meta->roundTable.confidants.size() / 2) + 1;
    }

    csdebug() << csname() << "No notifications at current round";
    return 0;
}

bool cs::ConveyerBase::isEnoughNotifications(cs::ConveyerBase::NotificationState state) const {
    cs::SharedLock lock(sharedMutex_);

    const std::size_t neededConfidantsCount = neededNotificationsCount();
    const std::size_t notificationsCount = notifications().size();

    cslog() << csname() << "Current notifications count - " << notificationsCount;
    cslog() << csname() << "Needed confidans count - " << neededConfidantsCount;

    if (state == NotificationState::Equal) {
        return notificationsCount == neededConfidantsCount;
    }

    return notificationsCount >= neededConfidantsCount;
}

void cs::ConveyerBase::addCharacteristicMeta(RoundNumber round, CharacteristicMeta&& characteristic) {
    if (!pimpl_->characteristicMetas.contains(round)) {
        cs::CharacteristicMetaStorage::Element metaElement;
        metaElement.meta = std::move(characteristic);
        metaElement.round = round;

        pimpl_->characteristicMetas.append(std::move(metaElement));
    }
    else {
        csdebug() << csname() << "Received meta is currently in meta stack";
    }
}

std::optional<cs::CharacteristicMeta> cs::ConveyerBase::characteristicMeta(const cs::RoundNumber round) {
    if (!pimpl_->characteristicMetas.contains(round)) {
        csdebug() << csname() << "Characteristic meta not received";
        return std::nullopt;
    }

    auto meta = pimpl_->characteristicMetas.extract(round);
    return std::make_optional<cs::CharacteristicMeta>(std::move(meta).value());
}

void cs::ConveyerBase::setCharacteristic(const Characteristic& characteristic, cs::RoundNumber round) {
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(round);

    if (meta != nullptr) {
        csdebug() << csname() << "Characteristic set to conveyer, #" << round;
        meta->characteristic = characteristic;
    }
}

const cs::Characteristic* cs::ConveyerBase::characteristic(cs::RoundNumber round) const {
    auto meta = pimpl_->metaStorage.get(round);

    if (!meta) {
        cserror() << csname() << "Get characteristic, logic error, can not find characteristic, #" << round;
        return nullptr;
    }

    return &meta->characteristic;
}

cs::Hash cs::ConveyerBase::characteristicHash(cs::RoundNumber round) const {
    const Characteristic* pointer = characteristic(round);

    if (!pointer) {
        cserror() << csname() << "Null pointer of characteristic, return empty Hash, #" << round;
        return cs::Hash();
    }

    return generateHash(pointer->mask.data(), pointer->mask.size());
}

std::optional<csdb::Pool> cs::ConveyerBase::applyCharacteristic(const cs::PoolMetaInfo& metaPoolInfo) {
    cs::RoundNumber round = static_cast<cs::RoundNumber>(metaPoolInfo.sequenceNumber);
    csmeta(csdetails) << ", round " << round;

    cs::Lock lock(sharedMutex_);
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(round);

    if (!meta) {
        cserror() << csname() << "Apply characteristic failed, no meta in meta storage";
        return std::nullopt;
    }

    cs::TransactionsPacketTable hashTable;
    const cs::PacketsHashes& localHashes = meta->roundTable.hashes;
    const cs::Characteristic& characteristic = meta->characteristic;
    cs::TransactionsPacketTable& currentHashTable = poolTable(round);

    csmeta(csdebug) << "characteristic bytes size " << characteristic.mask.size();

    if (!characteristic.mask.empty()) {
        csmeta(csdetails) << "characteristic: " << cs::Utils::byteStreamToHex(characteristic.mask.data(), characteristic.mask.size());
    }

    csmeta(csdebug) << "viewing hashes count " << localHashes.size();
    csmeta(csdebug) << "viewing hash table size " << currentHashTable.size();

    csdb::Pool newPool;
    std::size_t maskIndex = 0;
    const cs::Bytes& mask = characteristic.mask;
    cs::TransactionsPacket invalidTransactions;

    for (const auto& hash : localHashes) {
        // try to get from meta if can
        auto optionalPacket = findPacket(hash, round);

        if (!optionalPacket.has_value()) {
            csmeta(cserror) << "hash not found " << hash.toString() << ", strange behaviour detected";
            removeHashesFromTable(localHashes);
            return std::nullopt;
        }

        auto packet = std::move(optionalPacket).value();
        const auto& transactions = packet.transactions();

        // first look at signatures if it is smarts packet
        if (packet.signatures().size() > 1) {
            const auto& stateTransaction = transactions.front();

            // check range
            if (maskIndex < mask.size() && mask[maskIndex] != 0) {
                csdb::Pool::SmartSignature smartSignatures;
                csdb::UserField userField = stateTransaction.user_field(trx_uf::new_state::RefStart);

                if (userField.is_valid()) {
                    SmartContractRef reference(userField);

                    if (reference.is_valid()) {
                        smartSignatures.smartConsensusPool = reference.sequence;
                    }
                }

                smartSignatures.smartKey = stateTransaction.source().public_key();
                smartSignatures.signatures = packet.signatures();

                newPool.add_smart_signature(smartSignatures);
            }
        }

        // look all next transactions
        for (const auto& transaction : transactions) {
            if (maskIndex < mask.size()) {
                if (mask[maskIndex] != 0u) {
                    newPool.add_transaction(transaction);
                }
                else {
                    invalidTransactions.addTransaction(transaction);
                }
            }

            ++maskIndex;
        }

        if (maskIndex > mask.size()) {
            csmeta(cserror) << "hash failed, mask size: " << mask.size() << " mask index: " << maskIndex;
            removeHashesFromTable(localHashes);
            return std::nullopt;
        }

        // create storage hash table and remove from current hash table
        hashTable.emplace(hash, std::move(packet));
    }

    // remove current hashes from table
    removeHashesFromTable(localHashes);

    csdebug() << "\tinvalid transactions count " << invalidTransactions.transactionsCount();

    // add current round hashes to storage
    meta->hashTable = std::move(hashTable);
    meta->invalidTransactions = std::move(invalidTransactions);

    if (characteristic.mask.size() != newPool.transactions_count()) {
        cslog() << "\tCharacteristic size: " << characteristic.mask.size() << ", new pool transactions count: " << newPool.transactions_count();
        cswarning() << "\tSome of transactions is not valid";
    }

    csdebug() << "\tsequence = " << metaPoolInfo.sequenceNumber;

    // creating new pool
    newPool.set_sequence(metaPoolInfo.sequenceNumber);
    newPool.add_user_field(0, metaPoolInfo.timestamp);
    newPool.add_number_trusted(static_cast<uint8_t>(metaPoolInfo.realTrustedMask.size()));
    newPool.add_real_trusted(cs::Utils::maskToBits(metaPoolInfo.realTrustedMask));
    newPool.set_previous_hash(metaPoolInfo.previousHash);

    if (metaPoolInfo.sequenceNumber > 1) {
        newPool.add_number_confirmations(static_cast<uint8_t>(metaPoolInfo.confirmationMask.size()));
        newPool.add_confirmation_mask(cs::Utils::maskToBits(metaPoolInfo.confirmationMask));
        newPool.add_round_confirmations(metaPoolInfo.confirmations);
    }

    csdebug() << "\twriter key is set to " << cs::Utils::byteStreamToHex(metaPoolInfo.writerKey);
    csmeta(csdetails) << "done";

    return std::make_optional<csdb::Pool>(std::move(newPool));
}

std::optional<cs::TransactionsPacket> cs::ConveyerBase::findPacket(const cs::TransactionsPacketHash& hash, const RoundNumber round) const {
    if (auto iterator = pimpl_->packetsTable.find(hash); iterator != pimpl_->packetsTable.end()) {
        return iterator->second;
    }

    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(round);

    if (!meta) {
        return std::nullopt;
    }

    const auto& value = meta->hashTable;

    if (auto iter = value.find(hash); iter != value.end()) {
        return iter->second;
    }

    return std::nullopt;
}

bool cs::ConveyerBase::isMetaTransactionInvalid(int64_t id) {
    cs::SharedLock lock(sharedMutex_);

    for (const cs::ConveyerMetaStorage::Element& element : pimpl_->metaStorage) {
        const auto& invalidTransactions = element.meta.invalidTransactions.transactions();
        const auto iterator = std::find_if(invalidTransactions.begin(), invalidTransactions.end(), [=](const auto& transaction) { return transaction.innerID() == id; });

        if (iterator != invalidTransactions.end()) {
            return true;
        }
    }

    return false;
}

size_t cs::ConveyerBase::packetQueueTransactionsCount() const {
    cs::SharedLock lock(sharedMutex_);
    size_t count = 0;

    auto begin = pimpl_->packetQueue.begin();
    auto end = pimpl_->packetQueue.end();

    std::for_each(begin, end, [&](const auto& packet) {
        count += packet.transactionsCount();
    });

    return count;
}

std::unique_lock<cs::SharedMutex> cs::ConveyerBase::lock() const {
    return std::unique_lock<cs::SharedMutex>(sharedMutex_);
}

void cs::ConveyerBase::flushTransactions() {
    cs::Lock lock(sharedMutex_);

    auto packets = pimpl_->packetQueue.pop();

    for (auto& packet : packets) {
        if ((packet.transactionsCount() != 0u)) {
            if (packet.isHashEmpty()) {
                if (!packet.makeHash()) {
                    cserror() << csname() << "Transaction packet hashing failed";
                    continue;
                }
            }

            emit packetFlushed(packet);

            auto hash = packet.hash();

            if (auto iter = pimpl_->packetsTable.find(hash); iter == pimpl_->packetsTable.end()) {
                pimpl_->packetsTable.emplace(std::move(hash), std::move(packet));
            }
            else {
                csdebug() << csname() << "Same transaction packet already in packet table " << hash.toString();
            }
        }
    }
}

void cs::ConveyerBase::removeHashesFromTable(const cs::PacketsHashes& hashes) {
    for (const auto& hash : hashes) {
        csdetails() << csname() << " remove hash " << hash.toString();
        pimpl_->packetsTable.erase(hash);
    }
}

cs::TransactionsPacketTable& cs::ConveyerBase::poolTable(cs::RoundNumber round) {
    cs::ConveyerMeta* meta = pimpl_->metaStorage.get(round);

    if (!meta) {
        return pimpl_->packetsTable;
    }

    if (!meta->hashTable.empty()) {
        return meta->hashTable;
    }

    return pimpl_->packetsTable;
}

cs::Conveyer& cs::Conveyer::instance() {
    static cs::Conveyer conveyer;
    return conveyer;
}
```
# ..\node\csnode\src\dynamicbuffer.cpp 
```cpp 
#include "../include/csnode/dynamicbuffer.hpp"
#include <algorithm>

cs::DynamicBuffer::DynamicBuffer(size_t size)
: size_(size) {
  array_ = new char[size];
}

cs::DynamicBuffer::DynamicBuffer(const char* data, std::size_t size)
: size_(size) {
  array_ = new char[size];

  std::copy(data, data + size, array_);
}

cs::DynamicBuffer::DynamicBuffer(const unsigned char* data, std::size_t size)
: DynamicBuffer(reinterpret_cast<const char*>(data), size) {
}

cs::DynamicBuffer::DynamicBuffer(const cs::DynamicBuffer& buffer)
: size_(buffer.size_) {
  array_ = new char[size_];

  std::copy(buffer.array_, buffer.array_ + buffer.size_, array_);
}

cs::DynamicBuffer::DynamicBuffer(cs::DynamicBuffer&& buffer)
: array_(buffer.array_)
, size_(buffer.size_) {
  buffer.array_ = nullptr;
  buffer.size_ = 0;
}

cs::DynamicBuffer& cs::DynamicBuffer::operator=(const cs::DynamicBuffer& buffer) {
  if (this != &buffer) {
    if (array_) {
      delete[] array_;
    }

    size_ = buffer.size_;
    array_ = new char[size_];

    std::copy(buffer.array_, buffer.array_ + buffer.size_, array_);
  }

  return *this;
}

cs::DynamicBuffer& cs::DynamicBuffer::operator=(cs::DynamicBuffer&& buffer) {
  if (this != &buffer) {
    if (array_) {
      delete[] array_;
    }

    size_ = buffer.size_;
    array_ = buffer.array_;

    buffer.size_ = 0;
    buffer.array_ = nullptr;
  }

  return *this;
}

cs::DynamicBuffer::~DynamicBuffer() {
  if (array_) {
    delete[] array_;

    array_ = nullptr;
    size_ = 0;
  }
}

char& cs::DynamicBuffer::operator[](std::size_t index) {
  return const_cast<char&>(static_cast<const DynamicBuffer*>(this)->operator[](index));
}

const char& cs::DynamicBuffer::operator[](std::size_t index) const {
  return *(array_ + index);
}

char* cs::DynamicBuffer::get() const {
  return array_;
}

char* cs::DynamicBuffer::operator*() const {
  return this->get();
}

size_t cs::DynamicBuffer::size() const {
  return size_;
}

char* cs::DynamicBuffer::begin() {
  return array_;
}

char* cs::DynamicBuffer::end() {
  return array_ + size_;
}

const char* cs::DynamicBuffer::begin() const {
  return array_;
}

const char* cs::DynamicBuffer::end() const {
  return array_ + size_;
}

bool cs::operator==(const cs::DynamicBuffer& lhs, const cs::DynamicBuffer& rhs) {
  if (lhs.size() != rhs.size()) {
    return false;
  }

  for (std::size_t i = 0; i < lhs.size(); ++i) {
    if (lhs[i] != rhs[i]) {
      return false;
    }
  }

  return true;
}

bool cs::operator!=(const cs::DynamicBuffer& lhs, const cs::DynamicBuffer& rhs) {
  return !(lhs == rhs);
}

void cs::swap(cs::DynamicBuffer& lhs, cs::DynamicBuffer& rhs) {
  if (&lhs != &rhs) {
    std::swap(lhs.size_, rhs.size_);
    std::swap(lhs.array_, rhs.array_);
  }
}
```
# ..\node\csnode\src\fee.cpp 
```cpp 
#include "csnode/fee.hpp"

#include <tuple>

#include <solver/smartcontracts.hpp>

namespace cs {
namespace {
const size_t kCommonTrSize = 152;

std::array<std::tuple<size_t, double, double>, 14> feeLevels = {
    std::make_tuple(1024 + 512, 0.008746170242, 0.0004828886573),
    std::make_tuple(20 * 1024, 0.03546746927, 0.0005862733239),
    std::make_tuple(50 * 1024, 0.1438276802, 0.001104468428),
    std::make_tuple(100 * 1024, 1.936458209, 0.009641057723),
    std::make_tuple(256 * 1024, 5.26383916, 0.3813112299),
    std::make_tuple(512 * 1024, 38.89480285, 4.874110187),
    std::make_tuple(768 * 1024, 105.7270358, 19.96925763),
    std::make_tuple(1024 * 1024, 287.3958802, 103.8255221),
    std::make_tuple(5 * 1024 * 1024, 781.2229988, 259.834061),
    std::make_tuple(15 * 1024 * 1024, 2123.584282, 651.3469549),
    std::make_tuple(50 * 1024 * 1024, 5772.500564, 2309.930666),
    std::make_tuple(100 * 1024 * 1024, 15691.28339, 5165.460461),
    std::make_tuple(500 * 1024 * 1024, 42653.3305, 9959.829026),
    std::make_tuple(1000 * 1024 * 1024, 115943.7732, 115943.7732)
};
}  // namespace

namespace fee {

csdb::AmountCommission getFee(const csdb::Transaction& t) {
    size_t size = t.to_byte_stream().size();

    if (!SmartContracts::is_smart_contract(t) && size <= kCommonTrSize) {
        return csdb::AmountCommission(kMinFee);
    }

    for (const auto& level : feeLevels) {
        if (size < std::get<0>(level)) {
            if (SmartContracts::is_deploy(t)) {
                return csdb::AmountCommission(std::get<1>(level));
            }
            return csdb::AmountCommission(std::get<2>(level));
        }
    }

    double k = static_cast<double>(size) / std::get<0>(feeLevels[feeLevels.size() - 1]);
    return csdb::AmountCommission(std::get<1>(feeLevels[feeLevels.size() - 1]) * k);
}

bool estimateMaxFee(const csdb::Transaction& t, csdb::AmountCommission& countedFee) {
    countedFee = getFee(t);

    if (SmartContracts::is_smart_contract(t)) {
        countedFee = csdb::AmountCommission(countedFee.to_double() +
                     std::get<2>(feeLevels[0])); // cheapest new state
    }

    return csdb::Amount(t.max_fee().to_double()) >= csdb::Amount(countedFee.to_double());
}

void setCountedFees(Transactions& trxs) {
    for (auto& t : trxs) {
        t.set_counted_fee(getFee(t));  
    }
}
} // namespace fee
}  // namespace cs
```
# ..\node\csnode\src\itervalidator.cpp 
```cpp 
#include <csnode/itervalidator.hpp>

#include <cstring>

#include <csnode/walletsstate.hpp>
#include <smartcontracts.hpp>
#include <solvercontext.hpp>

namespace {
const char* kLogPrefix = "Validator: ";
const uint8_t kInvalidMarker = 0;
const uint8_t kValidMarker = 1;
}  // namespace

namespace cs {

IterValidator::IterValidator(WalletsState& wallets) {
    pTransval_ = std::make_unique<TransactionsValidator>(wallets, TransactionsValidator::Config{});
}

Characteristic IterValidator::formCharacteristic(SolverContext& context, Transactions& transactions, Packets& smartsPackets) {
    cs::Characteristic characteristic;
    characteristic.mask.resize(transactions.size(), kValidMarker);

    checkTransactionsSignatures(context, transactions, characteristic.mask, smartsPackets);

    bool needNewIteration = false;
    size_t iterationCounter = 1;

    do {
        csdebug() << kLogPrefix << "current iteration: " << iterationCounter;
        context.blockchain().setTransactionsFees(transactions, characteristic.mask);
        context.wallets().updateFromSource();
        pTransval_->reset(transactions.size());
        needNewIteration = validateTransactions(context, characteristic.mask, transactions);
        ++iterationCounter;
    } while (needNewIteration);

    checkRejectedSmarts(context, characteristic.mask, transactions);
    pTransval_->clearCaches();

    return characteristic;
}

void IterValidator::checkRejectedSmarts(SolverContext& context, cs::Bytes& characteristicMask, const Transactions& transactions) {
    // test if any of smart-emitted transaction rejected, reject all transactions from this smart
    // 1. collect rejected smart addresses
    [[maybe_unused]] const auto& smarts = context.smart_contracts();
    std::vector<SolverContext::RefExecution> rejectList;
    size_t maskSize = characteristicMask.size();
    size_t i = 0;
    for (const auto& tr : transactions) {
        if (i < maskSize && *(characteristicMask.cbegin() + static_cast<std::ptrdiff_t>(i)) == kInvalidMarker) {
            if (SmartContracts::is_new_state(tr)) {
                csdb::UserField fld = tr.user_field(trx_uf::new_state::RefStart);
                if (fld.is_valid()) {
                    SmartContractRef ref(fld);
                    rejectList.emplace_back(std::make_pair(ref.sequence, static_cast<uint32_t>(ref.transaction)));
                }
            }
        }
        ++i;
    }
    if (!rejectList.empty()) {
        cslog() << kLogPrefix << "reject " << rejectList.size() << " new_state(s) of smart contract(s)";
        context.send_rejected_smarts(rejectList);
    }
}

bool IterValidator::validateTransactions(SolverContext& context, cs::Bytes& characteristicMask, const Transactions& transactions) {
    bool needOneMoreIteration = false;
    const size_t transactionsCount = transactions.size();
    size_t blockedCounter = 0;

    // validate each transaction
    for (size_t i = 0; i < transactionsCount; ++i) {
        if (characteristicMask[i] == kInvalidMarker) {
            continue;
        }

        const csdb::Transaction& transaction = transactions[i];
        bool isValid = pTransval_->validateTransaction(context, transactions, i);

        if (isValid && SmartContracts::is_deploy(transaction)) {
            isValid = deployAdditionalCheck(context, i, transaction);
        }

        if (!isValid) {
            csdebug() << kLogPrefix << "transaction[" << i << "] rejected by validator";
            characteristicMask[i] = kInvalidMarker;
            needOneMoreIteration = true;
            ++blockedCounter;
        }
        else {
            characteristicMask[i] = kValidMarker;
        }
    }

    // validation of all transactions by graph
    size_t restoredCounter = pTransval_->checkRejectedSmarts(context, transactions, characteristicMask);
    if (blockedCounter == restoredCounter) {
        needOneMoreIteration = false;
    }
    pTransval_->validateByGraph(context, characteristicMask, transactions);

    if (pTransval_->getCntRemovedTrxsByGraph() > 0) {
        cslog() << kLogPrefix << "num of trxs rejected by graph validation - " << pTransval_->getCntRemovedTrxsByGraph();
        needOneMoreIteration = true;
    }

    needOneMoreIteration = false; // iterations switched off

    return needOneMoreIteration;
}

bool IterValidator::deployAdditionalCheck(SolverContext& context, size_t trxInd, const csdb::Transaction& transaction) {
    // test with get_valid_smart_address() only for deploy transactions
    bool isValid = true;
    auto sci = context.smart_contracts().get_smart_contract(transaction);

    if (sci.has_value() && sci.value().method.empty()) {  // is deploy
        csdb::Address deployer = context.blockchain().getAddressByType(transaction.source(), BlockChain::AddressType::PublicKey);
        isValid = SmartContracts::get_valid_smart_address(deployer, transaction.innerID(), sci.value().smartContractDeploy) == transaction.target();
    }

    if (!isValid) {
        cslog() << kLogPrefix << ": transaction[" << trxInd << "] rejected, malformed contract address";
    }

    return isValid;
}

void IterValidator::checkTransactionsSignatures(SolverContext& context, const Transactions& transactions, cs::Bytes& characteristicMask, Packets& smartsPackets) {
    checkSignaturesSmartSource(context, smartsPackets);
    size_t transactionsCount = transactions.size();
    size_t maskSize = characteristicMask.size();
    size_t rejectedCounter = 0;
    for (size_t i = 0; i < transactionsCount; ++i) {
        if (i < maskSize) {
            bool correctSignature = checkTransactionSignature(context, transactions[i]);
            if (!correctSignature) {
                characteristicMask[i] = kInvalidMarker;
                rejectedCounter++;
                cslog() << kLogPrefix << "transaction[" << i << "] rejected, incorrect signature.";
                if (SmartContracts::is_new_state(transactions[i])) {
                    pTransval_->addRejectedNewState(context.smart_contracts().absolute_address(transactions[i].source()));
                }
            }
        }
    }
    if (rejectedCounter) {
        cslog() << kLogPrefix << "wrong signatures num: " << rejectedCounter;
    }
}

bool IterValidator::checkTransactionSignature(SolverContext& context, const csdb::Transaction& transaction) {
    BlockChain::WalletData data_to_fetch_pulic_key;
    csdb::Address src = transaction.source();
    // TODO: is_known_smart_contract() does not recognize not yet deployed contract, so all transactions emitted in constructor
    // currently will be rejected
    bool smartSourceTransaction = false;
    bool isSmart = SmartContracts::is_smart_contract(transaction);
    if (!isSmart) {
        smartSourceTransaction = context.smart_contracts().is_known_smart_contract(transaction.source());
    }
    if (!SmartContracts::is_new_state(transaction) && !smartSourceTransaction) {
        if (src.is_wallet_id()) {
            context.blockchain().findWalletData(src.wallet_id(), data_to_fetch_pulic_key);
            return transaction.verify_signature(data_to_fetch_pulic_key.address_);
        }
        return transaction.verify_signature(src.public_key());
    }
    else {
        // special rule for new_state transactions
        if (SmartContracts::is_new_state(transaction) && src != transaction.target()) {
            csdebug() << kLogPrefix << "smart state transaction has different source and target";
            return false;
        }
        auto it = smartSourceInvalidSignatures_.find(transaction.source());
        if (it != smartSourceInvalidSignatures_.end()) {
            csdebug() << kLogPrefix << "smart contract transaction has invalid signature";
            return false;
        }
        return true;
    }
}

void IterValidator::checkSignaturesSmartSource(SolverContext& context, cs::Packets& smartContractsPackets) {
    smartSourceInvalidSignatures_.clear();

    for (auto& smartContractPacket : smartContractsPackets) {
        if (smartContractPacket.transactions().size() > 0) {
            const auto& transaction = smartContractPacket.transactions()[0];

            SmartContractRef smartRef;
            if (SmartContracts::is_new_state(transaction)) {
                smartRef.from_user_field(transaction.user_field(trx_uf::new_state::RefStart));
            }
            else {
                smartRef.from_user_field(transaction.user_field(trx_uf::smart_gen::RefStart));
            }
            if (!smartRef.is_valid()) {
                cslog() << kLogPrefix << "SmartContractRef is not properly set in transaction";
                smartSourceInvalidSignatures_.insert(transaction.source());
                continue;
            }

            csdb::Pool poolWithInitTr = context.blockchain().loadBlock(smartRef.sequence);
            if (!poolWithInitTr.is_valid()) {
                cslog() << kLogPrefix << "failed to load block with init transaction";
                smartSourceInvalidSignatures_.insert(transaction.source());
                continue;
            }

            const auto& confidants = poolWithInitTr.confidants();
            const auto& signatures = smartContractPacket.signatures();
            size_t correctSignaturesCounter = 0;
            for (const auto& signature : signatures) {
                if (signature.first < confidants.size()) {
                    const auto& confidantPublicKey = confidants[signature.first];
                    const cs::Byte* signedHash = smartContractPacket.hash().toBinary().data();
                    if (cscrypto::verifySignature(signature.second, confidantPublicKey, signedHash, cscrypto::kHashSize)) {
                        ++correctSignaturesCounter;
                    }
                }
            }
            if (correctSignaturesCounter < confidants.size() / 2U + 1U) {
                cslog() << kLogPrefix << "is not enough valid signatures";
                smartSourceInvalidSignatures_.insert(transaction.source());
            }
        }
    }
}
}  // namespace cs
```
# ..\node\csnode\src\node.cpp 
```cpp 
#include <algorithm>
#include <csignal>
#include <numeric>
#include <sstream>

#include <solver/solvercore.hpp>

#include <csnode/conveyer.hpp>
#include <csnode/datastream.hpp>
#include <csnode/node.hpp>
#include <csnode/nodecore.hpp>
#include <csnode/nodeutils.hpp>
#include <csnode/poolsynchronizer.hpp>

#include <lib/system/logger.hpp>
#include <lib/system/progressbar.hpp>
#include <lib/system/signals.hpp>
#include <lib/system/utils.hpp>

#include <net/transport.hpp>
#include <net/packetvalidator.hpp>

#include <base58.h>

#include <boost/optional.hpp>

#include <lz4.h>
#include <cscrypto/cscrypto.hpp>

const unsigned MIN_CONFIDANTS = 3;
const unsigned MAX_CONFIDANTS = 100;

const csdb::Address Node::genesisAddress_ = csdb::Address::from_string("0000000000000000000000000000000000000000000000000000000000000001");
const csdb::Address Node::startAddress_ = csdb::Address::from_string("0000000000000000000000000000000000000000000000000000000000000002");

Node::Node(const Config& config)
: nodeIdKey_(config.getMyPublicKey())
, nodeIdPrivate_(config.getMyPrivateKey())
, blockChain_(genesisAddress_, startAddress_)
, allocator_(1 << 24, 5)
, packStreamAllocator_(1 << 26, 5)
, ostream_(&packStreamAllocator_, nodeIdKey_)
, stat_() {
    solver_ = new cs::SolverCore(this, genesisAddress_, startAddress_);
    std::cout << "Start transport... ";
    transport_ = new Transport(config, this);
    std::cout << "Done\n";
    poolSynchronizer_ = new cs::PoolSynchronizer(config.getPoolSyncSettings(), transport_, &blockChain_);

    auto& executor = executor::Executor::getInstance(&blockChain_, solver_, config.getApiSettings().executorPort);

    cs::Connector::connect(&blockChain_.readBlockEvent(), &stat_, &cs::RoundStat::onReadBlock);
    cs::Connector::connect(&blockChain_.storeBlockEvent, &stat_, &cs::RoundStat::onStoreBlock);
    cs::Connector::connect(&blockChain_.storeBlockEvent, &executor, &executor::Executor::onBlockStored);
    cs::Connector::connect(&blockChain_.readBlockEvent(), &executor, &executor::Executor::onReadBlock);
    cs::Connector::connect(&transport_->pingReceived, this, &Node::onPingReceived);
    cs::Connector::connect(&Node::stopRequested, this, &Node::onStopRequested);

    good_ = init(config);
}

Node::~Node() {
    sendingTimer_.stop();

    delete solver_;
    delete transport_;
    delete poolSynchronizer_;
}

bool Node::init(const Config& config) {
#ifdef NODE_API
    std::cout << "Init API... ";
    api_ = std::make_unique<csconnector::connector>(
        blockChain_, solver_,
        csconnector::Config{config.getApiSettings().port, config.getApiSettings().ajaxPort, config.getApiSettings().executorPort, config.getApiSettings().apiexecPort});
    std::cout << "Done\n";
    cs::Connector::connect(&blockChain_.readBlockEvent(), api_.get(), &csconnector::connector::onReadFromDB);
    cs::Connector::connect(&blockChain_.storeBlockEvent, api_.get(), &csconnector::connector::onStoreBlock);
#endif  // NODE_API

    if (!blockChain_.init(config.getPathToDB())) {
        return false;
    }
    cslog() << "Blockchain is ready, contains " << WithDelimiters(stat_.total_transactions()) << " transactions";

#ifdef NODE_API
    api_->run();
#endif  // NODE_API

    if (!transport_->isGood()) {
        return false;
    }
    std::cout << "Transport is init\n";

    if (!solver_) {
        return false;
    }
    std::cout << "Solver is init\n";

    std::cout << "Everything is init\n";

    solver_->setKeysPair(nodeIdKey_, nodeIdPrivate_);
    solver_->startDefault();

    cs::Connector::connect(&sendingTimer_.timeOut, this, &Node::processTimer);
    cs::Connector::connect(&cs::Conveyer::instance().packetFlushed, this, &Node::onTransactionsPacketFlushed);
    cs::Connector::connect(&poolSynchronizer_->sendRequest, this, &Node::sendBlockRequest);

    return true;
}

void Node::run() {
    std::cout << "Running transport\n";
    transport_->run();
}

void Node::stop() {
    good_ = false;

    transport_->stop();
    cswarning() << "[TRANSPORT STOPPED]";

    solver_->finish();
    cswarning() << "[SOLVER STOPPED]";

    blockChain_.close();

    cswarning() << "[BLOCKCHAIN STORAGE CLOSED]";
}

/* Requests */
void Node::flushCurrentTasks() {
    transport_->addTask(ostream_.getPackets(), ostream_.getPacketsCount());
    ostream_.clear();
}

void Node::getBigBang(const uint8_t* data, const size_t size, const cs::RoundNumber rNum) {
    static std::map<cs::RoundNumber, uint8_t> recdBangs;
    auto& conveyer = cs::Conveyer::instance();

    cswarning() << "-----------------------------------------------------------";
    cswarning() << "NODE> BigBang #" << rNum << ": last written #" << blockChain_.getLastSequence() << ", current #" << conveyer.currentRoundNumber();
    cswarning() << "-----------------------------------------------------------";

    istream_.init(data, size);
    istream_ >> subRound_;

    if (subRound_ <= recdBangs[rNum]) {
        cswarning() << "Old Big Bang received: " << rNum << "." << static_cast<int>(subRound_) << " is <= " << rNum << "." << static_cast<int>(recdBangs[rNum]);
        return;
    }

    // cache
    auto cachedRound = conveyer.currentRoundNumber();

    // update round data
    recdBangs[rNum] = subRound_;

    cs::Hash lastBlockHash;
    istream_ >> lastBlockHash;

    cs::RoundTable globalTable;
    globalTable.round = rNum;

    if (!readRoundData(globalTable, true)) {
        cserror() << className() << " read round data from SS failed";
        return;
    }

    // this evil code sould be removed after examination
    cs::Sequence countRemoved = 0;
    cs::Sequence lastSequence = blockChain_.getLastSequence();

    while (lastSequence >= rNum) {
        if (countRemoved == 0) {
            // the 1st time
            csdebug() << "NODE> remove " << lastSequence - rNum << " block(s) required (rNum = " << rNum << ", last_seq = " << lastSequence << ")";
        }

        blockChain_.removeLastBlock();
        cs::RoundNumber tmp = blockChain_.getLastSequence();

        if (lastSequence == tmp) {
            csdebug() << "NODE> cancel remove blocks operation (last removal is failed)";
            break;
        }

        ++countRemoved;
        lastSequence = tmp;
    }

    if (countRemoved > 0) {
        csdebug() << "NODE> " << countRemoved << " block(s) was removed";
    }

    // resend all this round data available
    csdebug() << "NODE> resend last block hash after BigBang";

    // do not pass further the hashes from unsuccessful round
    csmeta(csdebug) << "Get BigBang globalTable.hashes: " << globalTable.hashes.size();

    conveyer.updateRoundTable(cachedRound, globalTable);
    onRoundStart(globalTable);

    poolSynchronizer_->sync(globalTable.round, cs::PoolSynchronizer::roundDifferentForSync, true);

    if (conveyer.isSyncCompleted()) {
        startConsensus();
    }
    else {
        cswarning() << "NODE> non empty required hashes after BB detected";
        sendPacketHashesRequest(conveyer.currentNeededHashes(), conveyer.currentRoundNumber(), startPacketRequestPoint_);
    }
}

void Node::getRoundTableSS(const uint8_t* data, const size_t size, const cs::RoundNumber rNum) {
    istream_.init(data, size);
    if (cs::Conveyer::instance().currentRoundNumber() != 0) {
        csdebug() << "The RoundTable sent by SS doesn't correspond to the current RoundNumber";
        return;
    }
    cslog() << "NODE> get SS Round Table #" << rNum;

    cs::RoundTable roundTable;

    if (!readRoundData(roundTable, false)) {
        cserror() << "NODE> read round data from SS failed, continue without round table";
    }

    // update new round data from SS
    // TODO: fix sub round
    subRound_ = 0;
    roundTable.round = rNum;

    cs::Conveyer::instance().setRound(rNum);
    cs::Conveyer::instance().setTable(roundTable);

    // "normal" start
    if (roundTable.round == 1) {
        onRoundStart(roundTable);
        reviewConveyerHashes();

        return;
    }

    poolSynchronizer_->sync(rNum);
}

void Node::getTransactionsPacket(const uint8_t* data, const std::size_t size) {
    istream_.init(data, size);
    cs::TransactionsPacket packet;
    istream_ >> packet;

    if (packet.hash().isEmpty()) {
        cswarning() << "Received transaction packet hash is empty";
        return;
    }

    processTransactionsPacket(std::move(packet));
}

void Node::getNodeStopRequest(const cs::RoundNumber round, const uint8_t* data, const std::size_t size) {
    const auto localRound = cs::Conveyer::instance().currentRoundNumber();

    if (round < localRound && localRound - round > cs::MaxRoundDeltaInStopRequest) {
        // ignore too aged command to prevent store & re-use by enemies
        return;
    }

    istream_.init(data, size);

    uint16_t version = 0;
    istream_ >> version;

    if (!istream_.good() || istream_.remainsBytes() != cscrypto::kSignatureSize) {
        cswarning() << "NODE> Get stop request parsing failed";
        return;
    }

    cswarning() << "NODE> Get stop request, received version " << version << ", received bytes " << size;

    if (NODE_VERSION > version) {
        cswarning() << "NODE> stop request does not cover my version, continue working";
        return;
    }

    cswarning() << "NODE> Get stop request, node will be closed...";
    stopRequested_ = true;

    // unconditional stop
    stop();
}

bool Node::canBeTrusted() {
#if defined(MONITOR_NODE) || defined(WEB_WALLET_NODE)

    return false;

#else

    if (stopRequested_) {
        return false;
    }

    if (Consensus::DisableTrustedRequestNextRound) {
        // ignore flag after bigbang
        if (myLevel_ == Level::Confidant && subRound_ == 0) {
            return false;
        }
    }

    if (cs::Conveyer::instance().currentRoundNumber() < Consensus::StartingDPOS) {
        csdebug() << "The DPOS doesn't work unless the roundNumber is less than " << Consensus::StartingDPOS;
        return true;
    }

    BlockChain::WalletData wData;
    BlockChain::WalletId wId;

    if (!getBlockChain().findWalletData(csdb::Address::from_public_key(this->nodeIdKey_), wData, wId)) {
        return false;
    }

    if (wData.balance_ < Consensus::MinStakeValue) {
        return false;
    }

    return true;

#endif
}

void Node::getPacketHashesRequest(const uint8_t* data, const std::size_t size, const cs::RoundNumber round, const cs::PublicKey& sender) {
    istream_.init(data, size);

    cs::PacketsHashes hashes;
    istream_ >> hashes;

    csdebug() << "NODE> Get packet hashes request from " << cs::Utils::byteStreamToHex(sender.data(), sender.size());
    csdebug() << "NODE> Requested packet hashes: " << hashes.size();

    if (hashes.empty()) {
        csmeta(cserror) << "Wrong hashes list requested";
        return;
    }

    processPacketsRequest(std::move(hashes), round, sender);
}

void Node::getPacketHashesReply(const uint8_t* data, const std::size_t size, const cs::RoundNumber round, const cs::PublicKey& sender) {
    if (cs::Conveyer::instance().isSyncCompleted(round)) {
        csdebug() << "NODE> sync packets have already finished in round " << round;
        return;
    }

    istream_.init(data, size);

    cs::Packets packets;
    istream_ >> packets;

    if (packets.empty()) {
        csmeta(cserror) << "Packet hashes reply, bad packets parsing";
        return;
    }

    csdebug() << "NODE> Get packet hashes reply: sender " << cs::Utils::byteStreamToHex(sender);
    csdebug() << "NODE> Hashes reply got packets count: " << packets.size();

    processPacketsReply(std::move(packets), round);
}

void Node::getCharacteristic(const uint8_t* data, const size_t size, const cs::RoundNumber round, const cs::PublicKey& sender, cs::Signatures&& poolSignatures,
                             cs::Bytes&& realTrusted) {
    csmeta(csdetails) << "started";
    cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (!conveyer.isSyncCompleted(round)) {
        csdebug() << "NODE> Packet sync not finished, saving characteristic meta to call after sync";

        cs::Bytes characteristicBytes(data, data + size);

        cs::CharacteristicMeta meta;
        meta.bytes = std::move(characteristicBytes);
        meta.sender = sender;
        meta.signatures = std::move(poolSignatures);
        meta.realTrusted = std::move(realTrusted);

        conveyer.addCharacteristicMeta(round, std::move(meta));
        return;
    }

    cs::DataStream poolStream(data, size);
    cs::Characteristic characteristic;
    cs::PoolMetaInfo poolMetaInfo;
    size_t smartSigCount;
    csdb::Pool::SmartSignature tmpSmartSignature;

    poolStream >> poolMetaInfo.timestamp;
    poolStream >> characteristic.mask;
    poolStream >> poolMetaInfo.sequenceNumber;
    poolStream >> poolMetaInfo.previousHash;
    poolStream >> smartSigCount;
    poolMetaInfo.realTrustedMask = realTrusted;

    if (myLevel_ == Level::Confidant) {
        csdebug() << "We probably don't have enough confirmations so we try to throw our last deferred block";
        solver_->removeDeferredBlock(poolMetaInfo.sequenceNumber);
    }

    csdebug() << "Trying to get confidants from round " << round;
    const auto table = conveyer.roundTable(round);

    if (table == nullptr) {
        cserror() << "NODE> cannot access proper round table to add trusted to pool #" << poolMetaInfo.sequenceNumber;
        return;
    }

    const cs::ConfidantsKeys& confidantsReference = table->confidants;
    const std::size_t realTrustedMaskSize = poolMetaInfo.realTrustedMask.size();

    csdebug() << "Real TrustedMask size = " << realTrustedMaskSize;

    if (realTrustedMaskSize > confidantsReference.size()) {
        csmeta(cserror) << ", real trusted mask size: " << realTrustedMaskSize << ", confidants count " << confidantsReference.size() << ", on round " << round;
        return;
    }

    for (size_t idx = 0; idx < realTrustedMaskSize; ++idx) {
        const auto& key = confidantsReference[idx];

        if (poolMetaInfo.realTrustedMask[idx] == 0) {
            poolMetaInfo.writerKey = key;
        }
    }

    if (round != 0) {
        auto confirmation = confirmationList_.find(round);
        if (confirmation.has_value()) {
            poolMetaInfo.confirmationMask = confirmation.value().mask;
            poolMetaInfo.confirmations = confirmation.value().signatures;
        }
    }

    if (!istream_.good()) {
        csmeta(cserror) << "Round info parsing failed, data is corrupted";
        return;
    }

    csdebug() << "NODE> Sequence " << poolMetaInfo.sequenceNumber << ", mask size " << characteristic.mask.size();
    csdebug() << "NODE> Time: " << poolMetaInfo.timestamp;

    if (blockChain_.getLastSequence() > poolMetaInfo.sequenceNumber) {
        csmeta(cswarning) << "blockChain last seq: " << blockChain_.getLastSequence() << " > pool meta info seq: " << poolMetaInfo.sequenceNumber;
        return;
    }

    // otherwise senseless, this block is already in chain
    conveyer.setCharacteristic(characteristic, poolMetaInfo.sequenceNumber);
    std::optional<csdb::Pool> pool = conveyer.applyCharacteristic(poolMetaInfo);

    if (!pool.has_value()) {
        csmeta(cserror) << "Created pool is not valid";
        return;
    }

    pool.value().set_signatures(poolSignatures);
    pool.value().set_confidants(confidantsReference);

    if (!blockChain_.storeBlock(pool.value(), false /*by_sync*/)) {
        cserror() << "NODE> failed to store block in BlockChain";
    }
    else {
        blockChain_.testCachedBlocks();
        confirmationList_.remove(round);
    }

    csmeta(csdetails) << "done";
}

void Node::cleanConfirmationList(cs::RoundNumber rNum) {
    confirmationList_.remove(rNum);
}

cs::ConfidantsKeys Node::retriveSmartConfidants(const cs::Sequence startSmartRoundNumber) const {
    csmeta(csdebug);

    const cs::RoundTable* table = cs::Conveyer::instance().roundTable(startSmartRoundNumber);
    if (table != nullptr) {
        return table->confidants;
    }

    csdb::Pool tmpPool = blockChain_.loadBlock(startSmartRoundNumber);
    const cs::ConfidantsKeys& confs = tmpPool.confidants();
    csdebug() << "___[" << startSmartRoundNumber << "] = [" << tmpPool.sequence() << "]: " << confs.size();
    return confs;
}

void Node::sendTransactionsPacket(const cs::TransactionsPacket& packet) {
    if (packet.hash().isEmpty()) {
        cswarning() << "Send transaction packet with empty hash failed";
        return;
    }

    sendBroadcast(MsgTypes::TransactionPacket, cs::Conveyer::instance().currentRoundNumber(), packet);
}

void Node::sendPacketHashesRequest(const cs::PacketsHashes& hashes, const cs::RoundNumber round, uint32_t requestStep) {
    const cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (conveyer.isSyncCompleted(round)) {
        return;
    }

    csdebug() << "NODE> Sending packet hashes request: " << hashes.size();

    cs::PublicKey main;
    const auto msgType = MsgTypes::TransactionsPacketRequest;
    const auto roundTable = conveyer.roundTable(round);

    // look at main node
    main = (roundTable != nullptr) ? roundTable->general : conveyer.currentRoundTable().general;

    const bool sendToGeneral = sendToNeighbour(main, msgType, round, hashes);

    if (!sendToGeneral) {
        sendPacketHashesRequestToRandomNeighbour(hashes, round);
    }

    auto requestClosure = [round, requestStep, this] {
        const cs::Conveyer& conveyer = cs::Conveyer::instance();

        if (!conveyer.isSyncCompleted(round)) {
            auto neededHashes = conveyer.neededHashes(round);
            if (neededHashes) {
                sendPacketHashesRequest(*neededHashes, round, requestStep + packetRequestStep_);
            }
        }
    };

    // send request again
    cs::Timer::singleShot(static_cast<int>(cs::NeighboursRequestDelay + requestStep), cs::RunPolicy::CallQueuePolicy, requestClosure);
}

void Node::sendPacketHashesRequestToRandomNeighbour(const cs::PacketsHashes& hashes, const cs::RoundNumber round) {
    const auto msgType = MsgTypes::TransactionsPacketRequest;
    const auto neighboursCount = transport_->getNeighboursCount();

    bool successRequest = false;

    for (std::size_t i = 0; i < neighboursCount; ++i) {
        ConnectionPtr connection = transport_->getConnectionByNumber(i);

        if (connection && !connection->isSignal) {
            successRequest = true;
            sendToNeighbour(connection, msgType, round, hashes);
        }
    }

    if (!successRequest) {
        csdebug() << "NODE> Send broadcast hashes request, no neigbours";
        sendBroadcast(msgType, round, hashes);
        return;
    }

    csdebug() << "NODE> Send hashes request to all neigbours";
}

void Node::sendPacketHashesReply(const cs::Packets& packets, const cs::RoundNumber round, const cs::PublicKey& target) {
    if (packets.empty()) {
        return;
    }

    csdebug() << "NODE> Reply transaction packets: " << packets.size();

    const auto msgType = MsgTypes::TransactionsPacketReply;
    const bool success = sendToNeighbour(target, msgType, round, packets);

    if (!success) {
        csdebug() << "NODE> Reply transaction packets: failed send to " << cs::Utils::byteStreamToHex(target.data(), target.size()) << ", perform broadcast";
        sendBroadcast(target, msgType, round, packets);
    }
}

void Node::getBlockRequest(const uint8_t* data, const size_t size, const cs::PublicKey& sender) {
    csmeta(csdebug);

    cs::PoolsRequestedSequences sequences;

    istream_.init(data, size);
    istream_ >> sequences;

    csdebug() << "NODE> Block request got sequences count: " << sequences.size();
    csdebug() << "NODE> Get packet hashes request: sender " << cs::Utils::byteStreamToHex(sender.data(), sender.size());

    if (sequences.empty()) {
        csmeta(cserror) << "Sequences size is 0";
        return;
    }

    std::size_t packetNum = 0;
    istream_ >> packetNum;

    csdebug() << "NODE> Get block request> Getting the request for block: from: " << sequences.front() << ", to: " << sequences.back() << ", id: " << packetNum;

    if (sequences.front() > blockChain_.getLastSequence()) {
        csdebug() << "NODE> Get block request> The requested block: " << sequences.front() << " is beyond last written sequence";
        return;
    }

    const bool isOneBlockReply = poolSynchronizer_->isOneBlockReply();
    const std::size_t reserveSize = isOneBlockReply ? 1 : sequences.size();

    cs::PoolsBlock poolsBlock;
    poolsBlock.reserve(reserveSize);

    auto sendReply = [&] {
        sendBlockReply(poolsBlock, sender, packetNum);
        poolsBlock.clear();
    };

    for (auto& sequence : sequences) {
        csdb::Pool pool = blockChain_.loadBlock(sequence);

        if (pool.is_valid()) {
            poolsBlock.push_back(std::move(pool));

            if (isOneBlockReply) {
                sendReply();
            }
        }
        else {
            csmeta(cserror) << "Load block: " << sequence << " from blockchain is Invalid";
        }
    }

    if (!isOneBlockReply) {
        sendReply();
    }
}

void Node::getBlockReply(const uint8_t* data, const size_t size) {
    if (!poolSynchronizer_->isSyncroStarted()) {
        csdebug() << "NODE> Get block reply> Pool synchronizer already syncro";
        return;
    }

    csdebug() << "NODE> Get Block Reply";

    cs::PoolsBlock poolsBlock = decompressPoolsBlock(data, size);

    if (poolsBlock.empty()) {
        cserror() << "NODE> Get block reply> Pools count is 0";
        return;
    }

    for (const auto& pool : poolsBlock) {
        transport_->syncReplied(pool.sequence());
    }

    std::size_t packetNum = 0;
    istream_ >> packetNum;

    poolSynchronizer_->getBlockReply(std::move(poolsBlock), packetNum);
}

void Node::sendBlockReply(const cs::PoolsBlock& poolsBlock, const cs::PublicKey& target, std::size_t packetNum) {
    for (const auto& pool : poolsBlock) {
        csdebug() << "NODE> Send block reply. Sequence: " << pool.sequence();
    }

    csdebug() << "Node> Sending blocks with signatures:";
    for (const auto& it : poolsBlock) {
        csdebug() << "#" << it.sequence() << " signs = " << it.signatures().size();
    }

    std::size_t realBinSize = 0;
    RegionPtr memPtr = compressPoolsBlock(poolsBlock, realBinSize);

    tryToSendDirect(target, MsgTypes::RequestedBlock, cs::Conveyer::instance().currentRoundNumber(), realBinSize, cs::numeric_cast<uint32_t>(memPtr.size()), memPtr, packetNum);
}

void Node::becomeWriter() {
    myLevel_ = Level::Writer;
    csdebug() << "NODE> Became writer";
}

void Node::processPacketsRequest(cs::PacketsHashes&& hashes, const cs::RoundNumber round, const cs::PublicKey& sender) {
    csdebug() << "NODE> Processing packets sync request";

    cs::Packets packets;

    const auto& conveyer = cs::Conveyer::instance();
    std::unique_lock<cs::SharedMutex> lock = conveyer.lock();

    for (const auto& hash : hashes) {
        std::optional<cs::TransactionsPacket> packet = conveyer.findPacket(hash, round);

        if (packet) {
            packets.push_back(std::move(packet).value());
        }
    }

    if (packets.empty()) {
        csdebug() << "NODE> Cannot find packets in storage";
    }
    else {
        csdebug() << "NODE> Found packets in storage: " << packets.size();
        sendPacketHashesReply(packets, round, sender);
    }
}

void Node::processPacketsReply(cs::Packets&& packets, const cs::RoundNumber round) {
    csdebug() << "NODE> Processing packets reply";

    cs::Conveyer& conveyer = cs::Conveyer::instance();

    for (auto&& packet : packets) {
        conveyer.addFoundPacket(round, std::move(packet));
    }

    if (conveyer.isSyncCompleted(round)) {
        csdebug() << "NODE> Packets sync completed, #" << round;
        transport_->resetNeighbours();

        if (auto meta = conveyer.characteristicMeta(round); meta.has_value()) {
            csdebug() << "NODE> Run characteristic meta";
            getCharacteristic(meta->bytes.data(), meta->bytes.size(), round, meta->sender, std::move(meta->signatures), std::move(meta->realTrusted));
        }

        // if next block maybe stored, the last written sequence maybe updated, so deferred consensus maybe resumed
        if (blockChain_.getLastSequence() + 1 == cs::Conveyer::instance().currentRoundNumber()) {
            csdebug() << "NODE> got all blocks written in current round";
            startConsensus();
        }
    }
}

void Node::processTransactionsPacket(cs::TransactionsPacket&& packet) {
    cs::Conveyer::instance().addTransactionsPacket(packet);
}

void Node::reviewConveyerHashes() {
    const cs::Conveyer& conveyer = cs::Conveyer::instance();
    const bool isHashesEmpty = conveyer.currentRoundTable().hashes.empty();

    if (!isHashesEmpty && !conveyer.isSyncCompleted()) {
        sendPacketHashesRequest(conveyer.currentNeededHashes(), conveyer.currentRoundNumber(), startPacketRequestPoint_);
        return;
    }

    if (isHashesEmpty) {
        csdebug() << "NODE> No hashes in round table, start consensus now";
    }
    else {
        csdebug() << "NODE> All hashes in conveyer, start consensus now";
    }

    startConsensus();
}

bool Node::isPoolsSyncroStarted() {
    return poolSynchronizer_->isSyncroStarted();
}

std::optional<cs::TrustedConfirmation> Node::getConfirmation(cs::RoundNumber round) const {
    return confirmationList_.find(round);
}

void Node::processTimer() {
    cs::Conveyer& conveyer = cs::Conveyer::instance();
    const auto round = conveyer.currentRoundNumber();

    if (myLevel_ == Level::Writer || round <= cs::TransactionsFlushRound) {
        return;
    }

    conveyer.flushTransactions();
}

void Node::onTransactionsPacketFlushed(const cs::TransactionsPacket& packet) {
    CallsQueue::instance().insert(std::bind(&Node::sendTransactionsPacket, this, packet));
}

void Node::onPingReceived(cs::Sequence sequence, const cs::PublicKey& sender) {
    static std::chrono::steady_clock::time_point point = std::chrono::steady_clock::now();
    static std::chrono::milliseconds delta{0};

    auto now = std::chrono::steady_clock::now();
    delta += std::chrono::duration_cast<std::chrono::milliseconds>(now - point);

    if (maxHeighboursSequence_ < sequence) {
        delta = std::chrono::milliseconds(0);
    }

    if (maxPingSynchroDelay_ <= delta.count()) {
        delta = std::chrono::milliseconds(0);
        auto lastSequence = blockChain_.getLastSequence();

        if (lastSequence < sequence) {
            cswarning() << "Last sequence is lower than network max sequence, trying to request round table";

            CallsQueue::instance().insert([=] {
                roundPackRequest(sender, sequence);
            });
        }
    }

    point = now;
}

void Node::sendBlockRequest(const ConnectionPtr target, const cs::PoolsRequestedSequences& sequences, std::size_t packetNum) {
    const auto round = cs::Conveyer::instance().currentRoundNumber();
    csmeta(csdetails) << "Target out(): " << target->getOut() << ", sequence from: " << sequences.front() << ", to: " << sequences.back() << ", packet: " << packetNum
                      << ", round: " << round;

    ostream_.init(BaseFlags::Neighbours | BaseFlags::Signed | BaseFlags::Compressed);
    ostream_ << MsgTypes::BlockRequest;
    ostream_ << round;
    ostream_ << sequences;
    ostream_ << packetNum;

    transport_->deliverDirect(ostream_.getPackets(), ostream_.getPacketsCount(), target);

    ostream_.clear();
}

Node::MessageActions Node::chooseMessageAction(const cs::RoundNumber rNum, const MsgTypes type, const cs::PublicKey sender) {
    if (!good_) {
        return MessageActions::Drop;
    }

    if (poolSynchronizer_->isFastMode()) {
        if (type == MsgTypes::BlockRequest || type == MsgTypes::RequestedBlock) {
            // which round would not be on the remote we may require the requested block or get block request
            return MessageActions::Process;
        }
        else {
            return MessageActions::Drop;
        }
    }

    // always process this types
    switch (type) {
        case MsgTypes::FirstSmartStage:
        case MsgTypes::SecondSmartStage:
        case MsgTypes::ThirdSmartStage:
        case MsgTypes::NodeStopRequest:
        case MsgTypes::TransactionPacket:
        case MsgTypes::TransactionsPacketRequest:
        case MsgTypes::TransactionsPacketReply:
        case MsgTypes::RoundTableRequest:
        case MsgTypes::RejectedContracts:
        case MsgTypes::RoundPackRequest:
            return MessageActions::Process;

        default:
            break;
    }

    const auto round = cs::Conveyer::instance().currentRoundNumber();

    // starts next round, otherwise
    if (type == MsgTypes::RoundTable) {
        if (rNum > round) {
            return MessageActions::Process;
        }

        // TODO: detect absence of proper current round info (round may be set by SS or BB)
        return MessageActions::Drop;
    }

    // BB: every round (for now) may be handled:
    if (type == MsgTypes::BigBang) {
        return MessageActions::Process;
    }

    if (type == MsgTypes::BlockRequest || type == MsgTypes::RequestedBlock) {
        // which round would not be on the remote we may require the requested block or get block request
        return MessageActions::Process;
    }

    if (type == MsgTypes::RoundTableReply) {
        return (rNum >= round ? MessageActions::Process : MessageActions::Drop);
    }

    if (type == MsgTypes::BlockHash) {
        if (rNum < round) {
            // outdated
            return MessageActions::Drop;
        }

        if (rNum > blockChain_.getLastSequence() + cs::Conveyer::HashTablesStorageCapacity) {
            // too many rounds behind the global round
            return MessageActions::Drop;
        }

        if (rNum > round) {
            csdebug() << "NODE> outrunning block hash (#" << rNum << ") is postponed until get round info";
            return MessageActions::Postpone;
        }

        if (!cs::Conveyer::instance().isSyncCompleted()) {
            csdebug() << "NODE> block hash is postponed until conveyer sync is completed";
            return MessageActions::Postpone;
        }

        // in time
        return MessageActions::Process;
    }

    if (rNum < round) {
        return type == MsgTypes::NewBlock ? MessageActions::Process : MessageActions::Drop;
    }

    // outrunning packets mean round lag
    if (rNum > round) {
        if (rNum - round == 1) {
            // wait for next round
            return MessageActions::Postpone;
        }
        else {
            // more then 1 round lag, request round info
            if (round > 1 && subRound_ == 0) {
                // not on the very start
                cswarning() << "NODE> detect round lag (global " << rNum << ", local " << round << ")";
                roundPackRequest(sender, rNum);
                // TODO: roundTableRequest(cs::PublicKey respondent);
            }

            return MessageActions::Drop;
        }
    }

    // (rNum == round) => handle now
    return MessageActions::Process;
}

inline bool Node::readRoundData(cs::RoundTable& roundTable, bool bang) {
    cs::PublicKey mainNode;

    uint8_t confSize = 0;
    istream_ >> confSize;

    csdebug() << "NODE> Number of confidants :" << cs::numeric_cast<int>(confSize);

    if (confSize < MIN_CONFIDANTS || confSize > MAX_CONFIDANTS) {
        cswarning() << "Bad confidants num";
        return false;
    }

    cs::ConfidantsKeys confidants;
    confidants.reserve(confSize);

    istream_ >> mainNode;

    // TODO Fix confidants array getting (From SS)
    for (int i = 0; i < confSize; ++i) {
        cs::PublicKey key;
        istream_ >> key;

        confidants.push_back(std::move(key));
    }
    if (bang) {
        cs::Signature sig;
        istream_ >> sig;

        cs::Bytes trustedToHash;
        cs::DataStream tth(trustedToHash);
        tth << roundTable.round;
        tth << confidants;
        csdebug() << "Message to Sign: " << cs::Utils::byteStreamToHex(trustedToHash);
        // cs::Hash trustedHash = cscrypto::calculateHash(trustedToHash.data(), trustedToHash.size());
        const auto& starter_key = cs::PacketValidator::instance().getStarterKey();
        csdebug() << "SSKey: " << cs::Utils::byteStreamToHex(starter_key.data(), starter_key.size());
        if (!cscrypto::verifySignature(sig, starter_key, trustedToHash.data(), trustedToHash.size())) {
            cswarning() << "The BIGBANG message is incorrect: signature isn't valid";
            return false;
        }
        cs::Bytes confMask;
        cs::Signatures signatures;
        signatures.push_back(sig);
        confMask.push_back(0);
        confirmationList_.remove(roundTable.round);
        confirmationList_.add(roundTable.round, bang, confidants, confMask, signatures);
    }

    if (!istream_.good() || confidants.size() < confSize) {
        cswarning() << "Bad round table format, ignoring";
        return false;
    }

    roundTable.confidants = std::move(confidants);
    roundTable.general = mainNode;
    roundTable.hashes.clear();

    return true;
}

static const char* nodeLevelToString(Node::Level nodeLevel) {
    switch (nodeLevel) {
        case Node::Level::Normal:
            return "Normal";
        case Node::Level::Confidant:
            return "Confidant";
        case Node::Level::Main:
            return "Main";
        case Node::Level::Writer:
            return "Writer";
    }

    return "UNKNOWN";
}

std::ostream& operator<<(std::ostream& os, Node::Level nodeLevel) {
    os << nodeLevelToString(nodeLevel);
    return os;
}

template <typename... Args>
void Node::sendDefault(const cs::PublicKey& target, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    static constexpr cs::Byte defautFlags = 0; // BaseFlags::Fragmented;

    ostream_.init(defautFlags, target);
    csdetails() << "NODE> Sending default to key: " << cs::Utils::byteStreamToHex(target.data(), target.size());

    sendBroadcastImpl(msgType, round, std::forward<Args>(args)...);
}

template <typename... Args>
bool Node::sendToNeighbour(const cs::PublicKey& target, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    ConnectionPtr connection = transport_->getConnectionByKey(target);

    if (connection) {
        sendToNeighbour(connection, msgType, round, std::forward<Args>(args)...);
    }

    return static_cast<bool>(connection);
}

template <typename... Args>
void Node::sendToNeighbour(const ConnectionPtr target, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    ostream_.init(BaseFlags::Neighbours | BaseFlags::Broadcast /*| BaseFlags::Fragmented*/ | BaseFlags::Compressed);
    ostream_ << msgType << round;

    writeDefaultStream(std::forward<Args>(args)...);

    csdetails() << "NODE> Sending Direct data: packets count: " << ostream_.getPacketsCount() << ", last packet size: " << ostream_.getCurrentSize() << ", out: " << target->out
                << ", in: " << target->in << ", specialOut: " << target->specialOut << ", msgType: " << Packet::messageTypeToString(msgType);

    transport_->deliverDirect(ostream_.getPackets(), ostream_.getPacketsCount(), target);
    ostream_.clear();
}

template <class... Args>
void Node::sendBroadcast(const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    ostream_.init(BaseFlags::Broadcast /*| BaseFlags::Fragmented*/ | BaseFlags::Compressed);
    csdetails() << "NODE> Sending broadcast";

    sendBroadcastImpl(msgType, round, std::forward<Args>(args)...);
}

template <class... Args>
void Node::tryToSendDirect(const cs::PublicKey& target, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    const bool success = sendToNeighbour(target, msgType, round, std::forward<Args>(args)...);
    if (!success) {
        sendBroadcast(target, msgType, round, std::forward<Args>(args)...);
    }
}

template <class... Args>
bool Node::sendToRandomNeighbour(const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    ConnectionPtr target = transport_->getRandomNeighbour();
    if (target) {
        sendToNeighbour(target, msgType, round, std::forward<Args>(args)...);
        return true;
    }

    return false;
}

template <class... Args>
void Node::sendToConfidants(const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    const auto& confidants = cs::Conveyer::instance().confidants();
    const auto size = confidants.size();

    for (size_t i = 0; i < size; ++i) {
        const auto& confidant = confidants.at(i);

        if (myConfidantIndex_ == i && nodeIdKey_ == confidant) {
            continue;
        }

        sendBroadcast(confidant, msgType, round, std::forward<Args>(args)...);
    }
}

template <class... Args>
void Node::sendToList(const std::vector<cs::PublicKey>& listMembers, const cs::Byte listExeption, const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    const auto size = listMembers.size();

    for (size_t i = 0; i < size; ++i) {
        const auto& listMember = listMembers[i];

        if (listExeption == i && nodeIdKey_ == listMember) {
            continue;
        }

        sendBroadcast(listMember, msgType, round, std::forward<Args>(args)...);
    }
}

template <typename... Args>
void Node::writeDefaultStream(Args&&... args) {
    (void)(ostream_ << ... << std::forward<Args>(args));  // fold expression
}

template <typename... Args>
bool Node::sendToNeighbours(const MsgTypes msgType, const cs::RoundNumber round, Args&&... args) {
    auto lock = transport_->getNeighboursLock();
    Connections connections = transport_->getNeighboursWithoutSS();

    if (connections.empty()) {
        return false;
    }

    for (auto connection : connections) {
        sendToNeighbour(connection, msgType, round, std::forward<Args>(args)...);
    }
}

template <typename... Args>
void Node::sendBroadcast(const cs::PublicKey& target, const MsgTypes& msgType, const cs::RoundNumber round, Args&&... args) {
    ostream_.init(BaseFlags::Fragmented | BaseFlags::Compressed, target);
    csdetails() << "NODE> Sending broadcast to key: " << cs::Utils::byteStreamToHex(target.data(), target.size());

    sendBroadcastImpl(msgType, round, std::forward<Args>(args)...);
}

template <typename... Args>
void Node::sendBroadcastImpl(const MsgTypes& msgType, const cs::RoundNumber round, Args&&... args) {
    ostream_ << msgType << round;

    writeDefaultStream(std::forward<Args>(args)...);

    csdetails() << "NODE> Sending broadcast data: size: " << ostream_.getCurrentSize() << ", last packet size: " << ostream_.getCurrentSize() << ", round: " << round
                << ", msgType: " << Packet::messageTypeToString(msgType);

    transport_->deliverBroadcast(ostream_.getPackets(), ostream_.getPacketsCount());
    ostream_.clear();
}

RegionPtr Node::compressPoolsBlock(const cs::PoolsBlock& poolsBlock, std::size_t& realBinSize) {
    cs::Bytes bytes;
    cs::DataStream stream(bytes);

    stream << poolsBlock;

    char* data = reinterpret_cast<char*>(bytes.data());
    const int binSize = cs::numeric_cast<int>(bytes.size());

    const auto maxSize = LZ4_compressBound(binSize);
    auto memPtr = allocator_.allocateNext(static_cast<uint32_t>(maxSize));

    const int compressedSize = LZ4_compress_default(data, static_cast<char*>(memPtr.get()), binSize, cs::numeric_cast<int>(memPtr.size()));

    if (!compressedSize) {
        csmeta(cserror) << "Compress poools block error";
    }

    allocator_.shrinkLast(cs::numeric_cast<uint32_t>(compressedSize));

    realBinSize = cs::numeric_cast<std::size_t>(binSize);

    return memPtr;
}

cs::PoolsBlock Node::decompressPoolsBlock(const uint8_t* data, const size_t size) {
    istream_.init(data, size);
    std::size_t realBinSize = 0;
    istream_ >> realBinSize;

    std::uint32_t compressSize = 0;
    istream_ >> compressSize;

    RegionPtr memPtr = allocator_.allocateNext(compressSize);
    istream_ >> memPtr;

    cs::Bytes bytes;
    bytes.resize(realBinSize);
    char* bytesData = reinterpret_cast<char*>(bytes.data());

    const int uncompressedSize = LZ4_decompress_safe(static_cast<char*>(memPtr.get()), bytesData, cs::numeric_cast<int>(compressSize), cs::numeric_cast<int>(realBinSize));

    if (uncompressedSize < 0) {
        csmeta(cserror) << "Decompress poools block error";
    }

    cs::DataStream stream(bytes.data(), bytes.size());
    cs::PoolsBlock poolsBlock;

    stream >> poolsBlock;

    return poolsBlock;
}

void Node::sendStageOne(cs::StageOne& stageOneInfo) {
    corruptionLevel_ = 0;
    if (myLevel_ != Level::Confidant) {
        cswarning() << "NODE> Only confidant nodes can send consensus stages";
        return;
    }

    stageOneInfo.roundTimeStamp = cs::Utils::currentTimestamp();

    csmeta(csdebug) << "Round: " << cs::Conveyer::instance().currentRoundNumber() << "." << cs::numeric_cast<int>(subRound_)
                    << ", Sender: " << static_cast<int>(stageOneInfo.sender) << ", Cand Amount: " << stageOneInfo.trustedCandidates.size()
                    << ", Hashes Amount: " << stageOneInfo.hashesCandidates.size() << ", Time Stamp: " << stageOneInfo.roundTimeStamp;
    csmeta(csdetails) << "Hash: " << cs::Utils::byteStreamToHex(stageOneInfo.hash.data(), stageOneInfo.hash.size());

    size_t expectedMessageSize = sizeof(stageOneInfo.sender) + sizeof(stageOneInfo.hash) + sizeof(stageOneInfo.trustedCandidates.size()) +
                                 sizeof(cs::PublicKey) * stageOneInfo.trustedCandidates.size() + sizeof(stageOneInfo.hashesCandidates.size()) +
                                 sizeof(cs::Hash) * stageOneInfo.hashesCandidates.size() + sizeof(stageOneInfo.roundTimeStamp.size()) + stageOneInfo.roundTimeStamp.size();

    cs::Bytes message;
    message.reserve(expectedMessageSize);

    cs::Bytes messageToSign;
    messageToSign.reserve(sizeof(cs::RoundNumber) + sizeof(uint8_t) + sizeof(cs::Hash));

    cs::DataStream stream(message);
    stream << stageOneInfo.sender;
    stream << stageOneInfo.hash;
    stream << stageOneInfo.trustedCandidates;
    stream << stageOneInfo.hashesCandidates;
    stream << stageOneInfo.roundTimeStamp;

    // hash of message
    stageOneInfo.messageHash = cscrypto::calculateHash(message.data(), message.size());

    cs::DataStream signStream(messageToSign);
    signStream << cs::Conveyer::instance().currentRoundNumber();
    signStream << subRound_;
    signStream << stageOneInfo.messageHash;

    // signature of round number + calculated hash
    stageOneInfo.signature = cscrypto::generateSignature(solver_->getPrivateKey(), messageToSign.data(), messageToSign.size());
    csdebug() << "Stage one Signature R-" << WithDelimiters(cs::Conveyer::instance().currentRoundNumber()) << "(" << static_cast<int>(stageOneInfo.sender)
              << "): " << cs::Utils::byteStreamToHex(stageOneInfo.signature.data(), stageOneInfo.signature.size());

    const int k1 = (corruptionLevel_ / 1) % 2;
    const cs::Byte k2 = static_cast<cs::Byte>(corruptionLevel_ / 16);
    if (k1 == 1 && k2 == myConfidantIndex_) {
        csdebug() << "STAGE ONE ##############> NOTHING WILL BE SENT";
    }
    else {
        sendToConfidants(MsgTypes::FirstStage, cs::Conveyer::instance().currentRoundNumber(), subRound_, stageOneInfo.signature, message);
    }

    csmeta(csdetails) << "Sent message size " << message.size();

    // cache
    stageOneInfo.message = std::move(message);
    csmeta(csdetails) << "done";
}

void Node::getStageOne(const uint8_t* data, const size_t size, const cs::PublicKey& sender) {
    csmeta(csdetails) << "started";

    if (myLevel_ != Level::Confidant) {
        csdebug() << "NODE> ignore stage-1 as no confidant";
        return;
    }

    istream_.init(data, size);

    uint8_t subRound;
    istream_ >> subRound;

    if (subRound != subRound_) {
        cswarning() << "NODE> ignore stage-1 with subround #" << subRound << ", required #" << subRound_;
        return;
    }

    cs::StageOne stage;
    istream_ >> stage.signature;
    istream_ >> stage.message;

    csdetails() << "Stage1 message: " << cs::Utils::byteStreamToHex(stage.message);
    csdetails() << "Stage1 signature: " << cs::Utils::byteStreamToHex(stage.signature);

    if (!istream_.good() || !istream_.end()) {
        csmeta(cserror) << "Bad stage-1 packet format";
        return;
    }

    // hash of part received message
    stage.messageHash = cscrypto::calculateHash(stage.message.data(), stage.message.size());

    cs::Bytes signedMessage;
    cs::DataStream signedStream(signedMessage);
    signedStream << cs::Conveyer::instance().currentRoundNumber();
    signedStream << subRound_;
    signedStream << stage.messageHash;

    // stream for main message
    cs::DataStream stream(stage.message.data(), stage.message.size());
    stream >> stage.sender;
    stream >> stage.hash;
    stream >> stage.trustedCandidates;
    stream >> stage.hashesCandidates;
    stream >> stage.roundTimeStamp;

    const cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (!conveyer.isConfidantExists(stage.sender)) {
        return;
    }

    const cs::PublicKey& confidant = conveyer.confidantByIndex(stage.sender);

    if (!cscrypto::verifySignature(stage.signature, confidant, signedMessage.data(), signedMessage.size())) {
        cswarning() << "NODE> Stage-1 from T[" << static_cast<int>(stage.sender) << "] -  WRONG SIGNATURE!!!";
        return;
    }

    if (confidant != sender) {
        csmeta(csdebug) << "Stage-1 of " << getSenderText(confidant) << " sent by " << getSenderText(sender);
    }
    else {
        csmeta(csdebug) << "Stage-1 of T[" << static_cast<int>(stage.sender) << "], sender key ok";
    }

    csdetails() << csname() << "Hash: " << cs::Utils::byteStreamToHex(stage.hash.data(), stage.hash.size());

    solver_->gotStageOne(std::move(stage));
}

void Node::sendStageTwo(cs::StageTwo& stageTwoInfo) {
    csmeta(csdetails) << "started";

    if (myLevel_ != Level::Confidant && myLevel_ != Level::Writer) {
        cswarning() << "Only confidant nodes can send consensus stages";
        return;
    }

    // TODO: fix it by logic changing
    const size_t confidantsCount = cs::Conveyer::instance().confidantsCount();
    const size_t stageBytesSize = sizeof(stageTwoInfo.sender) + sizeof(size_t)                     // count of signatures
                                  + sizeof(size_t)                                                 // count of hashes
                                  + (sizeof(cs::Signature) + sizeof(cs::Hash)) * confidantsCount;  // signature + hash items

    cs::Bytes bytes;
    bytes.reserve(stageBytesSize);

    cs::DataStream stream(bytes);
    stream << stageTwoInfo.sender;
    stream << stageTwoInfo.signatures;
    stream << stageTwoInfo.hashes;

    // create signature
    stageTwoInfo.signature = cscrypto::generateSignature(solver_->getPrivateKey(), bytes.data(), bytes.size());

    const int k1 = (corruptionLevel_ / 2) % 2;
    const cs::Byte k2 = static_cast<cs::Byte>(corruptionLevel_ / 16);

    if (k1 == 1 && k2 == myConfidantIndex_) {
        csdebug() << "STAGE TWO ##############> NOTHING WILL BE SENT";
    }
    else {
        sendToConfidants(MsgTypes::SecondStage, cs::Conveyer::instance().currentRoundNumber(), subRound_, stageTwoInfo.signature, bytes);
    }

    // cash our stage two
    csmeta(csdetails) << "Bytes size " << bytes.size();

    stageTwoInfo.message = std::move(bytes);

    csmeta(csdetails) << "done";
}

void Node::getStageTwo(const uint8_t* data, const size_t size, const cs::PublicKey& sender) {
    csmeta(csdetails);

    if (myLevel_ != Level::Confidant && myLevel_ != Level::Writer) {
        csdebug() << "NODE> ignore stage-2 as no confidant";
        return;
    }

    csdebug() << "NODE> getting stage-2 from " << getSenderText(sender);

    istream_.init(data, size);

    uint8_t subRound = 0;
    istream_ >> subRound;

    if (subRound != subRound_) {
        cswarning() << "NODE> We got Stage-2 for the Node with SUBROUND, we don't have";
        return;
    }

    cs::StageTwo stage;
    istream_ >> stage.signature;

    cs::Bytes bytes;
    istream_ >> bytes;

    if (!istream_.good() || !istream_.end()) {
        cserror() << "NODE> Bad stage-2 packet format";
        return;
    }

    cs::DataStream stream(bytes.data(), bytes.size());
    stream >> stage.sender;
    stream >> stage.signatures;
    stream >> stage.hashes;

    const cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (!conveyer.isConfidantExists(stage.sender)) {
        return;
    }

    if (!cscrypto::verifySignature(stage.signature, conveyer.confidantByIndex(stage.sender), bytes.data(), bytes.size())) {
        csdebug() << "NODE> stage-2 [" << static_cast<int>(stage.sender) << "] -  WRONG SIGNATURE!!!";
        return;
    }

    csmeta(csdetails) << "Signature is OK";
    stage.message = std::move(bytes);

    csdebug() << "NODE> stage-2 [" << static_cast<int>(stage.sender) << "] is OK!";
    solver_->gotStageTwo(stage);
}

void Node::sendStageThree(cs::StageThree& stageThreeInfo) {
    csdebug() << __func__;

    if (myLevel_ != Level::Confidant) {
        cswarning() << "NODE> Only confidant nodes can send consensus stages";
        return;
    }

    // TODO: think how to improve this code
    const size_t stageSize = 2 * sizeof(uint8_t) + 2 * sizeof(cs::Signature) + stageThreeInfo.realTrustedMask.size();

    cs::Bytes bytes;
    bytes.reserve(stageSize);

    cs::DataStream stream(bytes);
    stream << stageThreeInfo.sender;
    stream << stageThreeInfo.writer;
    stream << stageThreeInfo.iteration;
    stream << stageThreeInfo.blockSignature;
    stream << stageThreeInfo.roundSignature;
    stream << stageThreeInfo.trustedSignature;
    stream << stageThreeInfo.realTrustedMask;

    stageThreeInfo.signature = cscrypto::generateSignature(solver_->getPrivateKey(), bytes.data(), bytes.size());

    const int k1 = (corruptionLevel_ / 4) % 2;
    const cs::Byte k2 = static_cast<cs::Byte>(corruptionLevel_ / 16);

    if (k1 == 1 && k2 == myConfidantIndex_) {
        csdebug() << "STAGE THREE ##############> NOTHING WILL BE SENT";
    }
    else {
        sendToConfidants(MsgTypes::ThirdStage, cs::Conveyer::instance().currentRoundNumber(), subRound_, stageThreeInfo.signature, bytes);
    }

    // cach stage three
    csmeta(csdetails) << "bytes size " << bytes.size();
    stageThreeInfo.message = std::move(bytes);
    stageThreeSent_ = true;
    csmeta(csdetails) << "done";
}

void Node::getStageThree(const uint8_t* data, const size_t size) {
    csmeta(csdetails);

    if (myLevel_ != Level::Confidant && myLevel_ != Level::Writer) {
        csdebug() << "NODE> ignore stage-3 as no confidant";
        return;
    }

    istream_.init(data, size);
    uint8_t subRound = 0;
    istream_ >> subRound;

    if (subRound != subRound_) {
        cswarning() << "NODE> We got Stage-2 for the Node with SUBROUND, we don't have";
        return;
    }

    cs::StageThree stage;
    istream_ >> stage.signature;

    cs::Bytes bytes;
    istream_ >> bytes;

    if (!istream_.good() || !istream_.end()) {
        cserror() << "NODE> Bad stage-3 packet format";
        return;
    }

    cs::DataStream stream(bytes.data(), bytes.size());
    stream >> stage.sender;
    stream >> stage.writer;
    stream >> stage.iteration;  // this is a potential problem!!!
    stream >> stage.blockSignature;
    stream >> stage.roundSignature;
    stream >> stage.trustedSignature;
    stream >> stage.realTrustedMask;

    const cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (!conveyer.isConfidantExists(stage.sender)) {
        return;
    }

    if (!conveyer.isConfidantExists(stage.writer)) {
        return;
    }

    if (stage.iteration < solver_->currentStage3iteration()) {
        stageRequest(MsgTypes::ThirdStage, myConfidantIndex_, stage.sender);
        return;
    }
    else if (stage.iteration > solver_->currentStage3iteration()) {
        // store
        return;
    }

    if (!cscrypto::verifySignature(stage.signature, conveyer.confidantByIndex(stage.sender), bytes.data(), bytes.size())) {
        cswarning() << "NODE> stage-3 from T[" << static_cast<int>(stage.sender) << "] -  WRONG SIGNATURE!!!";
        return;
    }

    stage.message = std::move(bytes);

    csdebug() << "NODE> stage-3 from T[" << static_cast<int>(stage.sender) << "] is OK!";

    solver_->gotStageThree(std::move(stage), (stageThreeSent_ ? 2 : 0));
}

void Node::adjustStageThreeStorage() {
    stageThreeSent_ = false;
}

void Node::stageRequest(MsgTypes msgType, uint8_t respondent, uint8_t required /*, uint8_t iteration*/) {
    csdebug() << __func__;
    if (myLevel_ != Level::Confidant && myLevel_ != Level::Writer) {
        cswarning() << "NODE> Only confidant nodes can request consensus stages";
        return;
    }

    const cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (!conveyer.isConfidantExists(respondent)) {
        return;
    }

    sendDefault(conveyer.confidantByIndex(respondent), msgType, cs::Conveyer::instance().currentRoundNumber(), subRound_, myConfidantIndex_, required /*, iteration*/);
    csmeta(csdetails) << "done";
}

void Node::getStageRequest(const MsgTypes msgType, const uint8_t* data, const size_t size, const cs::PublicKey& requester) {
    csdebug() << __func__;
    csmeta(csdetails) << "started";
    if (myLevel_ != Level::Confidant) {
        return;
    }

    istream_.init(data, size);

    uint8_t subRound = 0;
    istream_ >> subRound;

    if (subRound != subRound_) {
        cswarning() << "NODE> We got Stage-2 for the Node with SUBROUND, we don't have";
        return;
    }

    uint8_t requesterNumber = 0;
    istream_ >> requesterNumber;

    uint8_t requiredNumber = 0;
    istream_ >> requiredNumber;

    if (!istream_.good() || !istream_.end()) {
        cserror() << "Bad StageThree packet format";
        return;
    }

    const cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (!conveyer.isConfidantExists(requesterNumber) || requester != conveyer.confidantByIndex(requesterNumber)) {
        return;
    }

    if (!conveyer.isConfidantExists(requiredNumber)) {
        return;
    }

    switch (msgType) {
        case MsgTypes::FirstStageRequest:
            solver_->gotStageOneRequest(requesterNumber, requiredNumber);
            break;
        case MsgTypes::SecondStageRequest:
            solver_->gotStageTwoRequest(requesterNumber, requiredNumber);
            break;
        case MsgTypes::ThirdStageRequest:
            solver_->gotStageThreeRequest(requesterNumber, requiredNumber /*, iteration*/);
            break;
        default:
            break;
    }
}

void Node::sendStageReply(const uint8_t sender, const cs::Signature& signature, const MsgTypes msgType, const uint8_t requester, cs::Bytes& message) {
    csdebug() << __func__;
    csmeta(csdetails) << "started";

    if (myLevel_ != Level::Confidant) {
        cswarning() << "NODE> Only confidant nodes can send consensus stages";
        return;
    }

    const cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (!conveyer.isConfidantExists(requester) || !conveyer.isConfidantExists(sender)) {
        return;
    }

    const int k1 = (corruptionLevel_ / 8) % 2;
    const cs::Byte k2 = static_cast<cs::Byte>(corruptionLevel_ / 16);

    if (k1 == 1 && k2 == myConfidantIndex_) {
        csdebug() << "STAGE REPLY ##############> NOTHING WILL BE SENT";
    }
    else {
        sendDefault(conveyer.confidantByIndex(requester), msgType, cs::Conveyer::instance().currentRoundNumber(), subRound_, signature, message);
    }

    csmeta(csdetails) << "done";
}

void Node::sendSmartReject(const std::vector<RefExecution>& rejectList) {
    if (rejectList.empty()) {
        csmeta(cserror) << "must not send empty rejected contracts pack";
        return;
    }

    cs::Bytes data;
    cs::DataStream stream(data);

    stream << rejectList;

    csdebug() << "Node: sending " << rejectList.size() << " rejected contract(s) to related smart confidants";
    sendBroadcast(MsgTypes::RejectedContracts, cs::Conveyer::instance().currentRoundNumber(), data);
}

void Node::getSmartReject(const uint8_t* data, const size_t size, const cs::RoundNumber rNum, const cs::PublicKey& sender) {
    csunused(rNum);
    csunused(sender);

    istream_.init(data, size);

    cs::Bytes bytes;
    istream_ >> bytes;

    cs::DataStream stream(bytes.data(), bytes.size());

    std::vector<RefExecution> rejectList;
    stream >> rejectList;

    if (!stream.isValid() || stream.isAvailable(1)) {
        return;
    }
    if (!istream_.good() || istream_.isBytesAvailable(1)) {
        return;
    }

    if (rejectList.empty()) {
        csmeta(cserror) << "empty rejected contracts pack received";
        return;
    }

    csdebug() << "Node: " << rejectList.size() << " rejected contract(s) received";
    emit gotRejectedContracts(rejectList);
}

void Node::sendSmartStageOne(const cs::ConfidantsKeys& smartConfidants, const cs::StageOneSmarts& stageOneInfo) {
    csmeta(csdebug) << "started";
    if (std::find(smartConfidants.cbegin(), smartConfidants.cend(), solver_->getPublicKey()) == smartConfidants.cend()) {
        cswarning() << "NODE> Only confidant nodes can send smart-contract consensus stages";
        return;
    }

    csmeta(csdetails) << std::endl
                      << "Smart starting Round: " << cs::SmartConsensus::blockPart(stageOneInfo.id) << '.' << cs::SmartConsensus::transactionPart(stageOneInfo.id) << std::endl
                      << "Sender: " << static_cast<int>(stageOneInfo.sender) << std::endl
                      << "Hash: " << cs::Utils::byteStreamToHex(stageOneInfo.hash.data(), stageOneInfo.hash.size());

    sendToList(smartConfidants, stageOneInfo.sender, MsgTypes::FirstSmartStage, cs::Conveyer::instance().currentRoundNumber(),
               // payload
               stageOneInfo.message, stageOneInfo.signature);
    csmeta(csdebug) << "done";
}

void Node::getSmartStageOne(const uint8_t* data, const size_t size, const cs::RoundNumber, const cs::PublicKey& sender) {
    csdebug() << __func__ << ": starting";

    istream_.init(data, size);

    cs::StageOneSmarts stage;
    istream_ >> stage.message >> stage.signature;

    if (!istream_.good() || !istream_.end()) {
        cserror() << "Bad Smart Stage One packet format";
        return;
    }
    // hash of part received message
    stage.messageHash = cscrypto::calculateHash(stage.message.data(), stage.message.size());
    if (stage.fillFromBinary()) {
        return;
    }
    cs::Sequence block = cs::SmartConsensus::blockPart(stage.id);
    uint32_t transaction = cs::SmartConsensus::transactionPart(stage.id);
    csdebug() << "SmartStageOne messageHash: " << cs::Utils::byteStreamToHex(stage.messageHash.data(), stage.messageHash.size());
    if (!cscrypto::verifySignature(stage.signature, sender, stage.messageHash.data(), stage.messageHash.size())) {
        cswarning() << "NODE> Smart stage One from T[" << static_cast<int>(stage.sender) << "] {" << block << '.' << transaction << "} -  WRONG SIGNATURE!!!";//
        return;
    }
    csdebug() << __func__ << ": starting {" << block << '.' << transaction << '}';
    
    csmeta(csdebug) << "Sender: " << static_cast<int>(stage.sender) << ", sender key: " << cs::Utils::byteStreamToHex(sender.data(), sender.size()) << std::endl
                    << "Smart#: {" << block << '.' << transaction << '}';
    csdebug() << "Hash: " << cs::Utils::byteStreamToHex(stage.hash.data(), stage.hash.size());

    csdebug() << "NODE> SmartStage One from T[" << static_cast<int>(stage.sender) << "] is OK!";

    if (std::find(activeSmartConsensuses_.cbegin(), activeSmartConsensuses_.cend(), stage.id) == activeSmartConsensuses_.cend()) {
        csdebug() << "The SmartConsensus {" << block << '.' << transaction << "} is not active now, storing the stage";
        smartStageOneStorage_.push_back(stage);
        return;
    }

    emit gotSmartStageOne(stage, false);
}

void Node::sendSmartStageTwo(const cs::ConfidantsKeys& smartConfidants, cs::StageTwoSmarts& stageTwoInfo) {
    csmeta(csdebug) << "started";

    if (std::find(smartConfidants.cbegin(), smartConfidants.cend(), solver_->getPublicKey()) == smartConfidants.cend()) {
        cswarning() << "NODE> Only confidant nodes can send smart-contract consensus stages";
        return;
    }

    // TODO: fix it by logic changing

    size_t confidantsCount = cs::Conveyer::instance().confidantsCount();
    size_t stageBytesSize = sizeof(stageTwoInfo.sender) + (sizeof(cs::Signature) + sizeof(cs::Hash)) * confidantsCount;

    cs::Bytes bytes;
    bytes.reserve(stageBytesSize);

    cs::DataStream stream(bytes);
    stream << stageTwoInfo.sender;
    stream << stageTwoInfo.signatures;
    stream << stageTwoInfo.hashes;

    // create signature
    stageTwoInfo.signature = cscrypto::generateSignature(solver_->getPrivateKey(), bytes.data(), bytes.size());
    sendToList(smartConfidants, stageTwoInfo.sender, MsgTypes::SecondSmartStage, cs::Conveyer::instance().currentRoundNumber(), stageTwoInfo.id, stageTwoInfo.signature, bytes);

    // cash our stage two
    stageTwoInfo.message = std::move(bytes);
    csmeta(csdebug) << "done";
}

void Node::getSmartStageTwo(const uint8_t* data, const size_t size, const cs::RoundNumber, const cs::PublicKey& sender) {
    csmeta(csdebug);

    csdebug() << "NODE> Getting SmartStage Two from " << cs::Utils::byteStreamToHex(sender.data(), sender.size());

    istream_.init(data, size);

    cs::StageTwoSmarts stage;
    istream_ >> stage.id >> stage.signature;

    cs::Bytes bytes;
    istream_ >> bytes;

    if (!istream_.good() || !istream_.end()) {
        cserror() << "NODE> Bad SmartStageTwo packet format";
        return;
    }

    cs::DataStream stream(bytes.data(), bytes.size());
    stream >> stage.sender;
    stream >> stage.signatures;
    stream >> stage.hashes;

    csdebug() << "NODE> Read all data from the stream";

    if (!cscrypto::verifySignature(stage.signature, sender, bytes.data(), bytes.size())) {
        csdebug() << "NODE> Smart Stage Two from T[" << static_cast<int>(stage.sender) << "] -  WRONG SIGNATURE!!!";
        return;
    }

    csdebug() << "Signature is OK";
    stage.message = std::move(bytes);

    csmeta(csdetails) << "Signature is OK";

    emit gotSmartStageTwo(stage, false);
}

void Node::sendSmartStageThree(const cs::ConfidantsKeys& smartConfidants, cs::StageThreeSmarts& stageThreeInfo) {
    csmeta(csdebug) << "started";

    if (std::find(smartConfidants.cbegin(), smartConfidants.cend(), solver_->getPublicKey()) == smartConfidants.cend()) {
        cswarning() << "NODE> Only confidant nodes can send smart-contract consensus stages";
        return;
    }

    // TODO: think how to improve this code

    size_t stageSize = 2 * sizeof(cs::Byte) + stageThreeInfo.realTrustedMask.size() + stageThreeInfo.packageSignature.size();

    cs::Bytes bytes;
    bytes.reserve(stageSize);

    cs::DataStream stream(bytes);
    stream << stageThreeInfo.sender;
    stream << stageThreeInfo.writer;
    stream << stageThreeInfo.realTrustedMask;
    stream << stageThreeInfo.packageSignature;

    stageThreeInfo.signature = cscrypto::generateSignature(solver_->getPrivateKey(), bytes.data(), bytes.size());
    sendToList(smartConfidants, stageThreeInfo.sender, MsgTypes::ThirdSmartStage, cs::Conveyer::instance().currentRoundNumber(),
               // payload:
               stageThreeInfo.id, stageThreeInfo.signature, bytes);

    // cach stage three
    stageThreeInfo.message = std::move(bytes);
    csmeta(csdebug) << "done";
}

void Node::getSmartStageThree(const uint8_t* data, const size_t size, const cs::RoundNumber, const cs::PublicKey& sender) {
    csmeta(csdetails) << "started";
    csunused(sender);

    istream_.init(data, size);

    cs::StageThreeSmarts stage;
    istream_ >> stage.id >> stage.signature;

    cs::Bytes bytes;
    istream_ >> bytes;

    if (!istream_.good() || !istream_.end()) {
        cserror() << "NODE> Bad SmartStage Three packet format";
        return;
    }

    cs::DataStream stream(bytes.data(), bytes.size());
    stream >> stage.sender;
    stream >> stage.writer;
    stream >> stage.realTrustedMask;
    stream >> stage.packageSignature;

    if (!cscrypto::verifySignature(stage.signature, sender, bytes.data(), bytes.size())) {
        csdebug() << "SmartStage Three from T[" << static_cast<int>(stage.sender) << "] -  WRONG SIGNATURE!!!";
        return;
    }

    stage.message = std::move(bytes);

    csdebug() << "NODE> SmartStage-3 from T[" << static_cast<int>(stage.sender) << "] is OK!";

    emit gotSmartStageThree(stage, false);
}

void Node::smartStageRequest(MsgTypes msgType, cs::Sequence smartRound, uint32_t startTransaction, cs::PublicKey confidant, uint8_t respondent, uint8_t required) {
    sendDefault(confidant, msgType, cs::Conveyer::instance().currentRoundNumber(), smartRound, startTransaction, respondent, required);
    csmeta(csdetails) << "done";
}

void Node::getSmartStageRequest(const MsgTypes msgType, const uint8_t* data, const size_t size, const cs::PublicKey& requester) {
    csmeta(csdetails) << "started";

    istream_.init(data, size);

    uint8_t requesterNumber = 0;
    cs::Sequence smartRound = 0;
    uint32_t startTransaction = 0;
    istream_ >> smartRound >> startTransaction >> requesterNumber;

    uint8_t requiredNumber = 0;
    istream_ >> requiredNumber;

    if (!istream_.good() || !istream_.end()) {
        cserror() << "Bad SmartStage request packet format";
        return;
    }

    cs::PublicKey req = requester;

    emit receivedSmartStageRequest(msgType, smartRound, startTransaction, requesterNumber, requiredNumber, req);
}

void Node::sendSmartStageReply(const cs::Bytes& message, const cs::RoundNumber smartRNum, const cs::Signature& signature, const MsgTypes msgType, const cs::PublicKey& requester) {
    csmeta(csdetails) << "started";

    sendDefault(requester, msgType, cs::Conveyer::instance().currentRoundNumber(), smartRNum, signature, message);
    csmeta(csdetails) << "done";
}

void Node::addSmartConsensus(uint64_t id) {
    if (std::find(activeSmartConsensuses_.cbegin(), activeSmartConsensuses_.cend(), id) != activeSmartConsensuses_.cend()) {
        csdebug() << "The smartConsensus for {" << cs::SmartConsensus::blockPart(id) << '.' << cs::SmartConsensus::transactionPart(id) << "} is already active";
        return;
    }

    activeSmartConsensuses_.push_back(id);
    checkForSavedSmartStages(id);
}

void Node::removeSmartConsensus(uint64_t id) {
    const auto it = std::find(activeSmartConsensuses_.cbegin(), activeSmartConsensuses_.cend(), id);
    if (it == activeSmartConsensuses_.cend()) {
        csdebug() << "The smartConsensus for {" << cs::SmartConsensus::blockPart(id) << '.' << cs::SmartConsensus::transactionPart(id) << "} is not active";
    }
    else {
        activeSmartConsensuses_.erase(it);
    }
    auto it_1 = smartStageOneStorage_.cbegin();
    while(it_1 != smartStageOneStorage_.cend()) {
        if (it_1->id == id) {
            it_1 = smartStageOneStorage_.erase(it_1);
        }
        else {
            ++it_1;
        }
    }
    auto it_2 = smartStageTwoStorage_.cbegin();
    while (it_2 != smartStageTwoStorage_.cend()) {
        if (it_2->id == id) {
            it_2 = smartStageTwoStorage_.erase(it_2);
        }
        else {
            ++it_2;
        }
    }
    auto it_3 = smartStageThreeStorage_.cbegin();
    while (it_3 != smartStageThreeStorage_.cend()) {
        if (it_3->id == id) {
            it_3 = smartStageThreeStorage_.erase(it_3);
        }
        else {
            ++it_3;
        }
    }
}

void Node::checkForSavedSmartStages(uint64_t id) {
    for (auto& it : smartStageOneStorage_) {
        if (it.id == id) {
            emit gotSmartStageOne(it, false);
        }
    }
}

// TODO: this function is a part of round table building <===
void Node::addRoundSignature(const cs::StageThree& st3) {
    size_t pos = 0;
    for (size_t i = 0; i < st3.realTrustedMask.size(); i++) {
        if (i == static_cast<size_t>(st3.sender)) {
            break;
        }
        if (st3.realTrustedMask[i] != cs::ConfidantConsts::InvalidConfidantIndex) {
            ++pos;
        }
    }
    csdebug() << "NODE> pos = " << pos << ", poolSigsSize = " << lastSentSignatures_.poolSignatures.size() << ", rtSigsSize = " << lastSentSignatures_.roundSignatures.size()
              << ", roundSigsSize = " << lastSentSignatures_.trustedConfirmation.size();
    std::copy(st3.blockSignature.cbegin(), st3.blockSignature.cend(), lastSentSignatures_.poolSignatures[pos].begin());
    std::copy(st3.roundSignature.cbegin(), st3.roundSignature.cend(), lastSentSignatures_.roundSignatures[pos].begin());
    std::copy(st3.trustedSignature.cbegin(), st3.trustedSignature.cend(), lastSentSignatures_.trustedConfirmation[pos].begin());

    csdebug() << "NODE> Adding signatures of stage3 from T(" << cs::numeric_cast<int>(st3.sender) << ") = " << lastSentSignatures_.roundSignatures.size();
}

void Node::sendRoundPackage(const cs::PublicKey& target) {
    csmeta(csdetails) << "Send round table";
    sendDefault(target, MsgTypes::RoundTable, cs::Conveyer::instance().currentRoundNumber(), subRound_, lastRoundTableMessage_, lastSignaturesMessage_);

    if (!lastSentRoundData_.table.characteristic.mask.empty()) {
        csmeta(csdebug) << "Packing " << lastSentRoundData_.table.characteristic.mask.size() << " bytes of char. mask to send";
    }
}

void Node::sendRoundPackageToAll() {
    // add signatures// blockSignatures, roundSignatures);
    csmeta(csdetails) << "Send round table to all";

    lastSignaturesMessage_.clear();

    cs::DataStream stream(lastSignaturesMessage_);
    stream << lastSentSignatures_.poolSignatures;
    stream << lastSentSignatures_.roundSignatures;
    stream << lastSentSignatures_.trustedConfirmation;

    csdebug() << "NODE> Send Signatures amount = " << lastSentSignatures_.roundSignatures.size();

    sendBroadcast(MsgTypes::RoundTable, cs::Conveyer::instance().currentRoundNumber(), subRound_, lastRoundTableMessage_, lastSignaturesMessage_);

    if (!lastSentRoundData_.table.characteristic.mask.empty()) {
        csmeta(csdebug) << "Packing " << lastSentRoundData_.table.characteristic.mask.size() << " bytes of char. mask to send";
    }

    /////////////////////////////////////////////////////////////////////////// screen output
    csdebug() << "------------------------------------------  SendRoundTable  ---------------------------------------";
    cs::Conveyer& conveyer = cs::Conveyer::instance();
    expectedRounds_.push_back(conveyer.currentRoundNumber() + 1);
    auto& table = conveyer.currentRoundTable();

    csdebug() << "Round " << conveyer.currentRoundNumber() << ", Confidants count " << table.confidants.size();
    csdebug() << "Hashes count: " << table.hashes.size();

    transport_->clearTasks();
    onRoundStart(table);

    // writer sometimes could not have all hashes, need check
    reviewConveyerHashes();
}

void Node::sendRoundTable() {
    becomeWriter();

    cs::Conveyer& conveyer = cs::Conveyer::instance();
    csdebug() << "SendRoundTable: add confirmation for round " << conveyer.currentRoundTable().round << " trusted";
    confirmationList_.add(lastSentRoundData_.table.round, false, conveyer.confidants(), cs::NodeUtils::getTrustedMask(getBlockChain().getLastBlock()),
                          lastSentSignatures_.trustedConfirmation);

    conveyer.setRound(lastSentRoundData_.table.round);
    
    const auto& confidants = conveyer.confidants();
    if (!confidants.empty() && lastTrustedMask_.size() == confidants.size()) {
        for (size_t i = 0; i < lastTrustedMask_.size(); ++i) {
            if (lastTrustedMask_[i] == cs::ConfidantConsts::InvalidConfidantIndex) {
                solver_->addToGraylist(confidants[i], Consensus::GrayListPunishment);
            }
        }
    }
    subRound_ = 0;

    cs::RoundTable table;
    table.round = conveyer.currentRoundNumber();
    table.confidants = lastSentRoundData_.table.confidants;
    table.hashes = lastSentRoundData_.table.hashes;

    conveyer.setTable(table);
    sendRoundPackageToAll();
}

// TODO: this function is a part of round table building <===
void Node::storeRoundPackageData(const cs::RoundTable& newRoundTable, const cs::PoolMetaInfo& poolMetaInfo, const cs::Characteristic& characteristic, cs::StageThree& st3) {
    lastSentRoundData_.table.round = newRoundTable.round;
    lastSentRoundData_.subRound = subRound_;
    // no general stored!
    lastSentRoundData_.table.confidants.clear();
    lastSentRoundData_.table.confidants = newRoundTable.confidants;

    lastSentRoundData_.table.hashes.clear();
    lastSentRoundData_.table.hashes = newRoundTable.hashes;

    lastSentRoundData_.table.characteristic.mask.clear();
    lastSentRoundData_.table.characteristic.mask = characteristic.mask;

    size_t expectedMessageSize = newRoundTable.confidants.size() * sizeof(cscrypto::PublicKey) + sizeof(size_t) + newRoundTable.hashes.size() * sizeof(cscrypto::Hash) +
                                 sizeof(size_t) + poolMetaInfo.timestamp.size() * sizeof(cs::Byte) + sizeof(size_t) + characteristic.mask.size() * sizeof(cs::Byte) +
                                 sizeof(size_t) + sizeof(size_t) + sizeof(cs::Hash) + sizeof(size_t) + poolMetaInfo.realTrustedMask.size() + sizeof(size_t);

    lastRoundTableMessage_.clear();
    lastRoundTableMessage_.reserve(expectedMessageSize);

    cs::DataStream stream(lastRoundTableMessage_);
    stream << lastSentRoundData_.table.confidants;
    stream << poolMetaInfo.realTrustedMask;
    stream << lastSentRoundData_.table.hashes;
    stream << poolMetaInfo.timestamp;
    stream << lastSentRoundData_.table.characteristic.mask;
    stream << poolMetaInfo.sequenceNumber;
    stream << poolMetaInfo.previousHash;

    lastTrustedMask_.clear();
    lastTrustedMask_ = poolMetaInfo.realTrustedMask;
    cs::Bytes trustedList;
    cs::DataStream tStream(trustedList);
    tStream << newRoundTable.round;
    tStream << newRoundTable.confidants;

    st3.trustedHash = cscrypto::calculateHash(trustedList.data(), trustedList.size());
    st3.roundHash = cscrypto::calculateHash(lastRoundTableMessage_.data(), lastRoundTableMessage_.size());

    st3.trustedSignature = cscrypto::generateSignature(solver_->getPrivateKey(), st3.trustedHash.data(), st3.trustedHash.size());

    csdebug() << "Round = " << newRoundTable.round << ", Trusted Signature = " << cs::Utils::byteStreamToHex(st3.trustedSignature);

    st3.roundSignature = cscrypto::generateSignature(solver_->getPrivateKey(), st3.roundHash.data(), st3.roundHash.size());

    // here should be placed parcing of round table

    size_t sigSize = cs::NodeUtils::realTrustedValue(poolMetaInfo.realTrustedMask);

    csdebug() << "NODE> PoolSignatures reserved to size = " << sigSize;

    lastSentSignatures_.poolSignatures.clear();
    lastSentSignatures_.poolSignatures.resize(sigSize);
    lastSentSignatures_.roundSignatures.clear();
    lastSentSignatures_.roundSignatures.resize(sigSize);
    lastSentSignatures_.trustedConfirmation.clear();
    lastSentSignatures_.trustedConfirmation.resize(sigSize);

    csdebug() << "NODE> poolSigsSize = " << lastSentSignatures_.poolSignatures.size() << ", rtSigsSize = " << lastSentSignatures_.roundSignatures.size()
              << ", roundSigsSize = " << lastSentSignatures_.trustedConfirmation.size();
}

void Node::prepareRoundTable(cs::RoundTable& roundTable, const cs::PoolMetaInfo& poolMetaInfo, cs::StageThree& st3) {
    cs::Conveyer& conveyer = cs::Conveyer::instance();
    const cs::Characteristic* block_characteristic = conveyer.characteristic(conveyer.currentRoundNumber());

    if (!block_characteristic) {
        csmeta(cserror) << "Send round info characteristic not found, logic error";
        return;
    }

    storeRoundPackageData(roundTable, poolMetaInfo, *block_characteristic, st3);

    csdebug() << "NODE> StageThree prepared:";

    st3.print();
}
bool Node::receivingSignatures(const cs::Bytes& sigBytes, const cs::Bytes& roundBytes, const cs::RoundNumber rNum, const cs::Bytes& trustedMask,
                               const cs::ConfidantsKeys& newConfidants, cs::Signatures& poolSignatures) {
    cs::Conveyer& conveyer = cs::Conveyer::instance();
    cs::ConfidantsKeys currentConfidants = conveyer.confidants();

    cs::DataStream stream(sigBytes.data(), sigBytes.size());

    stream >> poolSignatures;

    cs::Signatures roundSignatures;
    stream >> roundSignatures;

    cs::Signatures trustedConfirmation;
    stream >> trustedConfirmation;

    csdebug() << "NODE> PoolSigs Amnt = " << poolSignatures.size() << ", TrustedSigs Amnt = " << trustedConfirmation.size() << ", RoundSigs Amnt = " << roundSignatures.size();

    if (trustedMask.size() != currentConfidants.size()) {
        csmeta(cserror) << "Illegal trusted mask count in round table";
        return false;
    }
    cs::Hash tempHash = cscrypto::calculateHash(roundBytes.data(), roundBytes.size());

    if (!cs::NodeUtils::checkGroupSignature(currentConfidants, trustedMask, roundSignatures, tempHash)) {
        csdebug() << "NODE> The roundtable signatures are NOT OK";
        return false;
    }
    else {
        csdebug() << "NODE> The roundtable signatures are ok";
    }

    cs::Bytes trustedToHash;
    cs::DataStream tth(trustedToHash);
    tth << rNum;
    tth << newConfidants;
    cs::Hash trustedHash = cscrypto::calculateHash(trustedToHash.data(), trustedToHash.size());

    if (cs::NodeUtils::checkGroupSignature(currentConfidants, trustedMask, trustedConfirmation, trustedHash)) {
        csdebug() << "NODE> The trusted confirmation for the next round are ok";
        confirmationList_.add(rNum, false, currentConfidants, trustedMask, trustedConfirmation);
    }
    else {
        csdebug() << "NODE> The trusted confirmation for the next round are NOT OK";
        // return false;
    }

    return true;
}

void Node::getRoundTable(const uint8_t* data, const size_t size, const cs::RoundNumber rNum, const cs::PublicKey& sender) {
    csdebug() << "NODE> next round table received, round: " << rNum;
    csmeta(csdetails) << "started";

    if (myLevel_ == Level::Writer) {
        csmeta(cserror) << "Writers don't receive round table";
        return;
    }

    istream_.init(data, size);

    // RoundTable evocation
    cs::Byte subRound = 0;
    istream_ >> subRound;

    // sync state check
    cs::Conveyer& conveyer = cs::Conveyer::instance();

    if (conveyer.currentRoundNumber() == rNum && subRound_ > subRound) {
        cswarning() << "NODE> round table SUBROUND is lesser then local one, ignore round table";
        csmeta(csdetails) << "My subRound: " << static_cast<int>(subRound_) << ", Received subRound: " << static_cast<int>(subRound);
        return;
    }

    cs::Bytes roundBytes;
    istream_ >> roundBytes;

    if (!istream_.good()) {
        csmeta(cserror) << "Malformed packet with round table (1)";
        return;
    }

    cs::Bytes bytes;
    istream_ >> bytes;

    if (!istream_.good()) {
        csmeta(cserror) << "Malformed packet with round table (2)";
        return;
    }

    cs::DataStream roundStream(roundBytes.data(), roundBytes.size());
    cs::ConfidantsKeys confidants;
    roundStream >> confidants;

    if (confidants.size() <= Consensus::MinTrustedNodes && confidants.size() > Consensus::MaxTrustedNodes) {
        csmeta(cserror) << "Illegal confidants count in round table";
        return;
    }

    cs::RoundNumber storedRound = conveyer.currentRoundNumber();
    conveyer.setRound(rNum);
    poolSynchronizer_->sync(conveyer.currentRoundNumber());

    cs::Bytes realTrusted;
    roundStream >> realTrusted;

    const auto ptrRT = conveyer.roundTable(rNum - 1);
    if (ptrRT != nullptr) {
        const cs::ConfidantsKeys& prevConfidants = ptrRT->confidants;
        if (!prevConfidants.empty() && realTrusted.size() == prevConfidants.size()) {
            for (size_t i = 0; i < realTrusted.size(); ++i) {
                if (realTrusted[i] == cs::ConfidantConsts::InvalidConfidantIndex) {
                    solver_->addToGraylist(prevConfidants[i], Consensus::GrayListPunishment);
                }
            }
        }
    }

    cs::Signatures poolSignatures;

    if (!receivingSignatures(bytes, roundBytes, rNum, realTrusted, confidants, poolSignatures) && storedRound == getBlockChain().getLastSequence()) {
        return;
    }

    // update sub round and max heighbours sequence
    subRound_ = subRound;
    maxHeighboursSequence_ = rNum;

    currentRoundTableMessage_.round = rNum;
    currentRoundTableMessage_.sender = sender;
    currentRoundTableMessage_.message = cs::Bytes(data, data + size);

    cs::PacketsHashes hashes;
    roundStream >> hashes;

    cs::RoundTable roundTable;
    roundTable.round = rNum;
    roundTable.confidants = std::move(confidants);
    roundTable.hashes = std::move(hashes);
    roundTable.general = sender;

    csdebug() << "NODE> confidants: " << roundTable.confidants.size();

    // first change conveyer state
    conveyer.setTable(roundTable);

    // create pool by previous round, then change conveyer state.
    getCharacteristic(reinterpret_cast<cs::Byte*>(roundStream.data()), roundStream.size(), conveyer.previousRoundNumber(), sender, std::move(poolSignatures),
                      std::move(realTrusted));

    onRoundStart(conveyer.currentRoundTable());
    reviewConveyerHashes();

    csmeta(csdetails) << "done\n";
}

void Node::sendHash(cs::RoundNumber round) {
    if (!canBeTrusted()) {
        return;
    }

    if (blockChain_.getLastSequence() != round - 1) {
        // should not send hash until have got proper block sequence
        return;
    }

    csdebug() << "NODE> Sending hash to ALL";
    csdb::PoolHash spoiledHash = spoileHash(blockChain_.getLastHash(), solver_->getPublicKey());

    sendToConfidants(MsgTypes::BlockHash, round, subRound_, spoiledHash);
    csdebug() << "NODE> Hash sent, round: " << round << "." << cs::numeric_cast<int>(subRound_);
}

void Node::getHash(const uint8_t* data, const size_t size, cs::RoundNumber rNum, const cs::PublicKey& sender) {
    if (myLevel_ != Level::Confidant) {
        csdebug() << "NODE> ignore hash as no confidant";
        return;
    }

    // TODO: here shoud be placed the DPOS check
    csdetails() << "NODE> get hash of round " << rNum << ", data size " << size;

    istream_.init(data, size);
    uint8_t subRound = 0;
    istream_ >> subRound;

    if (subRound > subRound_) {
        cswarning() << "NODE> We got hash for the Node with SUBROUND: " << static_cast<int>(subRound) << ", we don't have";
        // TODO : Maybe return
    }

    csdb::PoolHash tmp;
    istream_ >> tmp;

    if (!istream_.good() || !istream_.end()) {
        cswarning() << "NODE> bad hash packet format";
        return;
    }

    solver_->gotHash(std::move(tmp), sender);
}

void Node::roundPackRequest(const cs::PublicKey& respondent, cs::RoundNumber round) {
    csdebug() << "NODE> send request for round info  #" << round;
    sendDefault(respondent, MsgTypes::RoundPackRequest, round);
}

void Node::getRoundPackRequest(const uint8_t* data, const size_t size, cs::RoundNumber rNum, const cs::PublicKey& sender) {
    csunused(data);
    csunused(size);

    csdebug() << "NODE> getting roundPack request #" << rNum;

    if (currentRoundTableMessage_.round == rNum && currentRoundTableMessage_.message.size() != 0) {
        roundPackReply(sender);
    }
}

void Node::roundPackReply(const cs::PublicKey& respondent) {
    csdebug() << "NODE> sending roundPack reply to " << cs::Utils::byteStreamToHex(respondent.data(), respondent.size());
    sendDefault(respondent, MsgTypes::RoundTable, currentRoundTableMessage_.round, currentRoundTableMessage_.message);
}

void Node::sendRoundTableRequest(uint8_t respondent) {
    // ask for round info from current trusted on current round
    std::optional<cs::PublicKey> confidant = cs::Conveyer::instance().confidantIfExists(respondent);

    if (confidant.has_value()) {
        sendRoundTableRequest(confidant.value());
    }
    else {
        cserror() << "NODE> cannot request round info, incorrect respondent number";
    }
}

void Node::sendRoundTableRequest(const cs::PublicKey& respondent) {
    const auto round = cs::Conveyer::instance().currentRoundNumber();
    csdebug() << "NODE> send request for next round info after #" << round;

    // ask for next round info:
    sendDefault(respondent, MsgTypes::RoundTableRequest, round, myConfidantIndex_);
}

void Node::getRoundTableRequest(const uint8_t* data, const size_t size, const cs::RoundNumber rNum, const cs::PublicKey& requester) {
    csmeta(csdetails) << "started, round: " << rNum;

    istream_.init(data, size);

    uint8_t requesterNumber;
    istream_ >> requesterNumber;

    if (!istream_.good() || !istream_.end()) {
        cserror() << "NODE> bad RoundInfo request packet format";
        return;
    }

    // special request to re-send again handling
    if (requesterNumber >= cs::Conveyer::instance().confidantsCount()) {
        cserror() << "NODE> incorrect T[" << cs::numeric_cast<int>(requesterNumber) << "] asks for round table";
        return;
    }

    // default request from other trusted node handling
    csdebug() << "NODE> get request for next round info after #" << rNum << " from T[" << cs::numeric_cast<int>(requesterNumber) << "]";
    solver_->gotRoundInfoRequest(requester, rNum);
}

void Node::sendRoundTableReply(const cs::PublicKey& target, bool hasRequestedInfo) {
    csdebug() << "NODE> send RoundInfo reply to " << getSenderText(target);

    if (myLevel_ != Level::Confidant) {
        csdebug() << "Only confidant nodes can reply consensus stages";
    }

    sendDefault(target, MsgTypes::RoundTableReply, cs::Conveyer::instance().currentRoundNumber(), hasRequestedInfo);
}

bool Node::tryResendRoundTable(const cs::PublicKey& target, const cs::RoundNumber rNum) {
    if (lastSentRoundData_.table.round != rNum || lastSentRoundData_.subRound != subRound_) {
        csdebug() << "NODE> unable to repeat round data #" << rNum;
        return false;
    }

    csdebug() << "NODE> Re-send last round info #" << rNum << " to ALL";

    sendRoundPackage(target);

    return true;
}

void Node::getRoundTableReply(const uint8_t* data, const size_t size, const cs::PublicKey& respondent) {
    csmeta(csdetails);

    if (myLevel_ != Level::Confidant) {
        return;
    }

    istream_.init(data, size);

    bool hasRequestedInfo;
    istream_ >> hasRequestedInfo;

    if (!istream_.good() || !istream_.end()) {
        csdebug() << "NODE> bad RoundInfo reply packet format";
        return;
    }

    solver_->gotRoundInfoReply(hasRequestedInfo, respondent);
}

void Node::onRoundStart(const cs::RoundTable& roundTable) {
    bool found = false;
    uint8_t confidantIndex = 0;

    for (auto& conf : roundTable.confidants) {
        if (conf == nodeIdKey_) {
            myLevel_ = Level::Confidant;
            myConfidantIndex_ = confidantIndex;
            found = true;
            break;
        }

        confidantIndex++;
    }

    if (!found) {
        myLevel_ = Level::Normal;
        if (stopRequested_) {
            stop();
            return;
        }
    }

    // TODO: think how to improve this code.
    stageOneMessage_.clear();
    stageOneMessage_.resize(roundTable.confidants.size());
    stageTwoMessage_.clear();
    stageTwoMessage_.resize(roundTable.confidants.size());
    stageThreeMessage_.clear();
    stageThreeMessage_.resize(roundTable.confidants.size());
    stageThreeSent_ = false;

    constexpr int padWidth = 30;

    badHashReplyCounter_.clear();
    badHashReplyCounter_.resize(roundTable.confidants.size());

    for (auto badHash : badHashReplyCounter_) {
        badHash = false;
    }

    std::ostringstream line1;
    for (int i = 0; i < padWidth; i++) {
        line1 << '=';
    }

    line1 << " R-" << WithDelimiters(cs::Conveyer::instance().currentRoundNumber()) << "." << cs::numeric_cast<int>(subRound_) << " ";

    if (Level::Normal == myLevel_) {
        line1 << "NORMAL";
    }
    else {
        line1 << "TRUSTED [" << cs::numeric_cast<int>(myConfidantIndex_) << "]";
    }

    line1 << ' ';

    for (int i = 0; i < padWidth; i++) {
        line1 << '=';
    }

    const auto s = line1.str();
    const std::size_t fixedWidth = s.size();

    cslog() << s;
    csdebug() << " Node key " << cs::Utils::byteStreamToHex(nodeIdKey_);
    cslog() << " Last written sequence = " << WithDelimiters(blockChain_.getLastSequence()) << ", neighbours = " << transport_->getNeighboursCount();

    if (Transport::cntCorruptedFragments > 0 || Transport::cntDirtyAllocs > 0 || Transport::cntExtraLargeNotSent > 0) {
        cslog() << " ! " << Transport::cntDirtyAllocs << " / " << Transport::cntCorruptedFragments << " / " << Transport::cntExtraLargeNotSent;
    }

    std::ostringstream line2;

    for (std::size_t i = 0; i < fixedWidth; ++i) {
        line2 << '-';
    }

    csdebug() << line2.str();
    csdebug() << " Confidants:";

    for (size_t i = 0; i < roundTable.confidants.size(); ++i) {
        auto result = myLevel_ == Level::Confidant && i == myConfidantIndex_;
        auto name = result ? "me" : cs::Utils::byteStreamToHex(roundTable.confidants[i]);

        csdebug() << "[" << i << "] " << name;
    }

    csdebug() << " Hashes: " << roundTable.hashes.size();

    for (size_t j = 0; j < roundTable.hashes.size(); ++j) {
        csdetails() << "[" << j << "] " << cs::Utils::byteStreamToHex(roundTable.hashes[j].toBinary());
    }

    csdebug() << line2.str();
    stat_.onRoundStart(cs::Conveyer::instance().currentRoundNumber());
    csdebug() << line2.str();

    solver_->nextRound();

    if (!sendingTimer_.isRunning()) {
        csdebug() << "NODE> Transaction timer started";
        sendingTimer_.start(cs::TransactionsPacketInterval);
    }
}

void Node::startConsensus() {
    cs::RoundNumber roundNumber = cs::Conveyer::instance().currentRoundNumber();
    solver_->gotConveyerSync(roundNumber);
    transport_->processPostponed(roundNumber);

    // claim the trusted role only if have got proper blockchain:
    if (roundNumber == blockChain_.getLastSequence() + 1) {
        sendHash(roundNumber);
    }
}

std::string Node::getSenderText(const cs::PublicKey& sender) {
    std::ostringstream os;
    unsigned idx = 0;
    for (const auto& key : cs::Conveyer::instance().confidants()) {
        if (std::equal(key.cbegin(), key.cend(), sender.cbegin())) {
            os << "T[" << idx << "]";
            return os.str();
        }
        ++idx;
    }

    os << "N (" << cs::Utils::byteStreamToHex(sender.data(), sender.size()) << ")";
    return os.str();
}

csdb::PoolHash Node::spoileHash(const csdb::PoolHash& hashToSpoil) {
    const auto& binary = hashToSpoil.to_binary();
    const auto round = cs::Conveyer::instance().currentRoundNumber();
    cs::Hash hash = cscrypto::calculateHash(binary.data(), binary.size(), reinterpret_cast<cs::Byte*>(round), sizeof(round));
    cs::Bytes bytesHash(hash.begin(), hash.end());

    return csdb::PoolHash::from_binary(std::move(bytesHash));
}

csdb::PoolHash Node::spoileHash(const csdb::PoolHash& hashToSpoil, const cs::PublicKey& pKey) {
    const auto& binary = hashToSpoil.to_binary();
    cs::Hash hash = cscrypto::calculateHash(binary.data(), binary.size(), pKey.data(), pKey.size());
    cs::Bytes bytesHash(hash.begin(), hash.end());

    return csdb::PoolHash::from_binary(std::move(bytesHash));
}

void Node::smartStageEmptyReply(uint8_t requesterNumber) {
    csunused(requesterNumber);
    csdebug() << "Here should be the smart refusal for the SmartStageRequest";
}

void Node::sendHashReply(const csdb::PoolHash& hash, const cs::PublicKey& respondent) {
    csmeta(csdebug);
    if (myLevel_ != Level::Confidant) {
        csmeta(csdebug) << "Only confidant nodes can send hash reply to other nodes";
        return;
    }

    cs::Signature signature = cscrypto::generateSignature(solver_->getPrivateKey(), hash.to_binary().data(), hash.size());
    sendDefault(respondent, MsgTypes::HashReply, cs::Conveyer::instance().currentRoundNumber(), subRound_, signature, getConfidantNumber(), hash);
}

void Node::getHashReply(const uint8_t* data, const size_t size, cs::RoundNumber rNum, const cs::PublicKey& sender) {
    if (myLevel_ == Level::Confidant) {
        csmeta(csdebug) << "I'm confidant. Exit from getHashReply";
        return;
    }

    csmeta(csdebug);

    istream_.init(data, size);
    uint8_t subRound = 0;
    istream_ >> subRound;

    const auto& conveyer = cs::Conveyer::instance();

    if (conveyer.currentRoundNumber() != rNum || subRound_ != subRound) {
        csdebug() << "NODE> Get hash reply on incorrect round: " << rNum << "(" << subRound << ")";
        return;
    }

    cs::Signature signature;
    istream_ >> signature;

    uint8_t senderNumber = 0;
    istream_ >> senderNumber;

    csdb::PoolHash hash;
    istream_ >> hash;

    if (!conveyer.isConfidantExists(senderNumber)) {
        csmeta(csdebug) << "The message of WRONG HASH was sent by false confidant!";
        return;
    }

    if (badHashReplyCounter_[senderNumber]) {
        csmeta(csdetails) << "Sender num: " << senderNumber << " already send hash reply";
        return;
    }

    badHashReplyCounter_[senderNumber] = true;

    if (!cscrypto::verifySignature(signature, sender, hash.to_binary().data(), hash.size())) {
        csmeta(csdebug) << "The message of WRONG HASH has WRONG SIGNATURE!";
        return;
    }

    const auto badHashReplySummary = std::count_if(badHashReplyCounter_.begin(), badHashReplyCounter_.end(), [](bool badHash) { return badHash; });

    if (static_cast<size_t>(badHashReplySummary) > conveyer.confidantsCount() / 2) {
        csmeta(csdebug) << "This node really have not valid HASH!!! Removing last block from DB and trying to syncronize";
        // TODO: examine what will be done without this function
        blockChain_.removeLastBlock();
    }
}

/*static*/
void Node::requestStop() {
    emit stopRequested();
}

void Node::onStopRequested() {
    if (stopRequested_) {
        // subsequent request is handled as unconditional stop
        stop();
        return;
    }

    stopRequested_ = true;

    if (myLevel_ == Level::Confidant) {
        cslog() << "Node: wait until complete trusted role before exit";
    }
    else {
        stop();
    }
}
```
# ..\node\csnode\src\nodecore.cpp 
```cpp 
#include "nodecore.hpp"

namespace cs {
Zero::Zero() {
    hash.fill(0);
    signature.fill(0);
    key.fill(0);
}
}  // namespace cs

namespace {
// the only purpose of the object is to init static members
static const cs::Zero zero;
}  // namespace

std::size_t std::hash<cs::TransactionsPacketHash>::operator()(const cs::TransactionsPacketHash& packetHash) const noexcept {
    const std::size_t p = 16777619;
    std::size_t hash = 2166136261;

    auto data = packetHash.toBinary();
    auto size = data.size();

    for (std::size_t i = 0; i < size; ++i) {
        hash = (hash ^ data[i]) * p;
    }

    hash += hash << 13;
    hash ^= hash >> 7;
    hash += hash << 3;
    hash ^= hash >> 17;
    hash += hash << 5;

    return hash;
}
```
# ..\node\csnode\src\nodeutils.cpp 
```cpp 
#include <csdb/pool.hpp>
#include <csnode/nodeutils.hpp>

namespace
{
  const char * log_prefix = "Node: ";
}

namespace cs {
/*static*/
bool NodeUtils::checkGroupSignature(const cs::ConfidantsKeys& confidants, const cs::Bytes& mask, const cs::Signatures& signatures, const cs::Hash& hash) {
    if (confidants.size() == 0) {
        csdebug() << log_prefix << "the number of confidants is 0";
        return false;
    }
    if (confidants.size() != mask.size()) {
        cserror() << log_prefix << "the number of confidants doesn't correspond the mask size";
        return false;
    }

    size_t signatureCount = 0;
    for (auto& it : mask) {
        if (it == cs::ConfidantConsts::InvalidConfidantIndex) {
            continue;
        }
        ++signatureCount;
    }

    if (signatures.size() != signatureCount) {
        cserror() << log_prefix << "the number of signatures doesn't correspond the mask value";

        std::string realTrustedString;

        for (auto& i : mask) {
            realTrustedString = realTrustedString + "[" + std::to_string(int(i)) + "] ";
        }

        csdebug() << log_prefix << "mask: " << realTrustedString << ", signatures: ";
        for (auto& it : signatures) {
            csdebug() << '\t' << cs::Utils::byteStreamToHex(it);
        }

        return false;
    }

    signatureCount = 0;
    size_t cnt = 0;
    bool validSig = true;
    size_t cntValid = 0;
    size_t cntInvalid = 0;
    csdebug() << log_prefix << "hash: " << cs::Utils::byteStreamToHex(hash);
    for (auto it : mask) {
        if (it != cs::ConfidantConsts::InvalidConfidantIndex) {
            if (cscrypto::verifySignature(signatures[signatureCount], confidants[cnt], hash.data(), hash.size())) {
                csdetails() << log_prefix << "signature of [" << cnt << "] is valid";
                ++signatureCount;
                ++cntValid;
            }
            else {
                csdebug() << log_prefix << "signature of [" << cnt << "] is NOT VALID: " << cs::Utils::byteStreamToHex(signatures[signatureCount]);
                validSig = false;
                ++signatureCount;
                ++cntInvalid;
            }
        }
        ++cnt;
    }
    if (!validSig) {
        csdebug() << log_prefix << "signatures (" << cntInvalid << ") are not valid";
        return false;
    }
    else {
        csdebug() << log_prefix << "every " << cntValid << " signatures are valid";
        return true;
    }
}

/*static*/
size_t NodeUtils::realTrustedValue(const cs::Bytes& mask) {
    size_t cnt = 0;
    for (auto it : mask) {
        if (it != cs::ConfidantConsts::InvalidConfidantIndex) {
            ++cnt;
        }
    }
    return cnt;
}

/*static*/
cs::Bytes NodeUtils::getTrustedMask(const csdb::Pool& block) {
    if (!block.is_valid()) {
        return cs::Bytes{};
    }
    return cs::Utils::bitsToMask(block.numberTrusted(), block.realTrusted());
}

std::string NodeUtils::roundsToString(const std::vector<RoundNumber>& rounds) {
    std::string value = "(";

    for (auto it : rounds) {
        value += std::to_string(it) + "), (";
    }

    value += ")";

    return value;
}
}  // namespace cs
```
# ..\node\csnode\src\packetqueue.cpp 
```cpp 
#include <csnode/packetqueue.hpp>
#include <csnode/conveyer.hpp>

cs::PacketQueue::PacketQueue(size_t queueSize, size_t transactionsSize, size_t packetsPerRound)
: maxQueueSize_(queueSize)
, maxTransactionsSize_(transactionsSize)
, maxPacketsPerRound_(packetsPerRound) {
    cachedRound_ = 0;
    cachedPackets_ = 0;
}

bool cs::PacketQueue::push(const csdb::Transaction& transaction) {
    if (queue_.size() >= maxQueueSize_) {
        return false;
    }

    if (queue_.empty() || queue_.back().transactions().size() >= maxTransactionsSize_) {
        queue_.push_back(cs::TransactionsPacket{});
    }

    return queue_.back().addTransaction(transaction);
}

void cs::PacketQueue::push(const cs::TransactionsPacket& packet) {
    // ignore size of queue for packs
    queue_.push_back(packet);
    queue_.push_back(cs::TransactionsPacket{});
}

cs::TransactionsBlock cs::PacketQueue::pop() {
    const auto round = cs::Conveyer::instance().currentRoundNumber();
    cs::TransactionsBlock block;

    if (round == cachedRound_ && cachedPackets_ >= maxPacketsPerRound_) {
        return block;
    }

    if (round != cachedRound_) {
        cachedPackets_ = 0;
    }

    while (!queue_.empty() && cachedPackets_ < maxPacketsPerRound_) {
        block.push_back(std::move(queue_.front()));
        queue_.pop_front();

        ++cachedPackets_;
    }

    cachedRound_ = round;
    return block;
}

typename std::deque<cs::TransactionsPacket>::const_iterator cs::PacketQueue::begin() const {
    return queue_.begin();
}

typename std::deque<cs::TransactionsPacket>::const_iterator cs::PacketQueue::end() const {
    return queue_.end();
}

size_t cs::PacketQueue::size() const {
    return queue_.size();
}

bool cs::PacketQueue::isEmpty() const {
    return queue_.empty();
}

std::deque<cs::TransactionsPacket>::const_reference cs::PacketQueue::back() const {
    return queue_.back();
}
```
# ..\node\csnode\src\poolsynchronizer.cpp 
```cpp 
#include "poolsynchronizer.hpp"

#include <lib/system/logger.hpp>
#include <lib/system/progressbar.hpp>
#include <lib/system/utils.hpp>

#include <csnode/conveyer.hpp>

#include <net/transport.hpp>

cs::PoolSynchronizer::PoolSynchronizer(const PoolSyncData& data, Transport* transport, BlockChain* blockChain)
: syncData_(data)
, transport_(transport)
, blockChain_(blockChain) {
    neighbours_.reserve(transport_->getMaxNeighbours());

    refreshNeighbours();

    cs::Connector::connect(&timer_.timeOut, this, &cs::PoolSynchronizer::onTimeOut);
    cs::Connector::connect(&roundSimulation_.timeOut, this, &cs::PoolSynchronizer::onRoundSimulation);

    // Print Pool Sync Data Info
    const uint8_t hl = 25;
    const uint8_t vl = 6;
    csmeta(csdebug) << "Pool sync data : \n"
                    << std::setw(hl) << "Fast mode:        " << std::setw(vl) << syncData_.isFastMode << "\n"
                    << std::setw(hl) << "One reply block:  " << std::setw(vl) << syncData_.oneReplyBlock << "\n"
                    << std::setw(hl) << "Block pools:      " << std::setw(vl) << static_cast<int>(syncData_.blockPoolsCount) << "\n"
                    << std::setw(hl) << "Request round:    " << std::setw(vl) << static_cast<int>(syncData_.requestRepeatRoundCount) << "\n"
                    << std::setw(hl) << "Neighbour packets:" << std::setw(vl) << static_cast<int>(syncData_.neighbourPacketsCount) << "\n"
                    << std::setw(hl) << "Polling frequency:" << std::setw(vl) << syncData_.sequencesVerificationFrequency;
}

void cs::PoolSynchronizer::sync(cs::RoundNumber roundNum, cs::RoundNumber difference, bool isBigBand) {
    if (transport_->getNeighboursCount() == 0) {
        csmeta(csdebug) << "Cannot start sync (no neighbours). Needed sequence: " << roundNum << ",   Requested pools block size:" << syncData_.blockPoolsCount;
        return;
    }

    const cs::Sequence lastWrittenSequence = blockChain_->getLastSequence();

    if (lastWrittenSequence >= roundNum) {
        const bool isFinished = showSyncronizationProgress(lastWrittenSequence);
        if (isFinished) {
            synchroFinished();
        }
        return;
    }

    if (!isSyncroStarted_ && roundNum < (lastWrittenSequence + difference)) {
        return;
    }

    csmeta(csdetails) << "Started";

    if (isSyncroStarted_ && roundNum > 0) {
        --roundNum;
    }

    const std::size_t cachedBlocksSize = blockChain_->getCachedBlocksSize();
    const cs::Sequence totalBlocks = lastWrittenSequence + cachedBlocksSize;

    if (roundNum < totalBlocks) {
        cswarning() << "Round number is lower than synchro total blocks, if same warning will occur again try to restart node";
        csdebug() << "SYNC warning, round number " << roundNum << ", total blocks " << totalBlocks;
        synchroFinished();
        return;
    }

    const cs::Sequence blocksRemaining = roundNum - totalBlocks;

    csdebug() << "SYNC:\n Round num: " << roundNum << "\n Conveyer round: " << cs::Conveyer::instance().currentRoundNumber() << "\n Last written seq: " << lastWrittenSequence
              << "\n Cached blocks: " << cachedBlocksSize << "\n Total blocks: " << totalBlocks;
    cslog() << "SYNC: Blocks remaining: " << blocksRemaining;

    if (blocksRemaining == 0) {
        showSyncronizationProgress(lastWrittenSequence);
        synchroFinished();
        return;
    }

    const bool useTimer = syncData_.sequencesVerificationFrequency > 1;
    const int delay = useTimer ? static_cast<int>(syncData_.sequencesVerificationFrequency) : static_cast<int>(cs::NeighboursRequestDelay);

    // already synchro start
    if (isSyncroStarted_ && !useTimer) {
        // no BigBang, but no use timer
        if (!isBigBand && timer_.isRunning()) {
            timer_.stop();
        }

        // BigBang received
        if (isBigBand && !timer_.isRunning()) {
            timer_.start(delay, Timer::Type::Standard, RunPolicy::CallQueuePolicy);
        }
    }

    if (!isSyncroStarted_) {
        isSyncroStarted_ = true;
        cs::Connector::connect(&blockChain_->storeBlockEvent, this, static_cast<void (PoolSynchronizer::*)(const csdb::Pool)>(&cs::PoolSynchronizer::onWriteBlock));
        cs::Connector::connect(&blockChain_->cachedBlockEvent, this, static_cast<void (PoolSynchronizer::*)(const cs::Sequence)>(&cs::PoolSynchronizer::onWriteBlock));
        cs::Connector::connect(&blockChain_->removeBlockEvent, this, &cs::PoolSynchronizer::onRemoveBlock);

        refreshNeighbours();
        sendBlockRequest();

        if (isBigBand || useTimer) {
            timer_.start(delay, Timer::Type::Standard, RunPolicy::CallQueuePolicy);
        }

        roundSimulation_.start(60000, cs::Timer::Type::HighPrecise, RunPolicy::CallQueuePolicy);  // 1 Min
    }
    else if (syncData_.requestRepeatRoundCount > 0) {
        roundSimulation_.restart();
        const bool isNeedRequest = checkActivity(CounterType::ROUND);
        bool isAvailable = false;

        if (syncData_.sequencesVerificationFrequency == 1) {
            isAvailable = checkActivity(CounterType::TIMER);
        }

        if (isNeedRequest || isAvailable) {
            sendBlockRequest();
        }
    }
}

void cs::PoolSynchronizer::getBlockReply(cs::PoolsBlock&& poolsBlock, std::size_t packetNum) {
    csmeta(csdebug) << "Get Block Reply <<<<<<< : count: " << poolsBlock.size() << ", seqs: [" << poolsBlock.front().sequence() << ", " << poolsBlock.back().sequence()
                    << "], id: " << packetNum;

    /// TODO Fix numeric cast from RoundNum to cs::Sequence
    cs::Sequence lastWrittenSequence = blockChain_->getLastSequence();
    const cs::Sequence oldLastWrittenSequence = lastWrittenSequence;
    const std::size_t oldCachedBlocksSize = blockChain_->getCachedBlocksSize();

    // TODO Think, do really need this here?!
    // refreshNeighbours();

    for (auto& pool : poolsBlock) {
        const auto sequence = pool.sequence();

        removeExistingSequence(sequence, SequenceRemovalAccuracy::EXACT);

        if (lastWrittenSequence > sequence) {
            continue;
        }

        if (pool.signatures().size() == 0) {
            cserror() << "PoolSyncronizer> No signatures in pool #" << pool.sequence();
            continue;
        }

        if (blockChain_->storeBlock(pool, true /*by_sync*/)) {
            blockChain_->testCachedBlocks();
            lastWrittenSequence = blockChain_->getLastSequence();
        }
    }

    if (oldCachedBlocksSize != blockChain_->getCachedBlocksSize() || oldLastWrittenSequence != lastWrittenSequence) {
        const bool isFinished = showSyncronizationProgress(lastWrittenSequence);
        if (isFinished) {
            synchroFinished();
        }
    }
}

void cs::PoolSynchronizer::sendBlockRequest() {
    if (neighbours_.empty()) {
        return;
    }

    csmeta(csdetails) << "Start";

    for (const auto& el : requestedSequences_) {
        csmeta(csdetails) << "Requested sequence: " << el.first << "(" << el.second << ")";
    }
    if (requestedSequences_.empty()) {
        csmeta(csdetails) << "Requested sequence size: 0";
    }

    bool success = false;

    for (auto& neighbour : neighbours_) {
        if (!getNeededSequences(neighbour)) {
            csmeta(csdetails) << "Neighbor: " << static_cast<int>(neighbour.index()) << " is busy";
            continue;
        }

        if (neighbour.sequences().empty()) {
            csmeta(csdetails) << "All sequences already requested";
            break;
        }

        success = true;
        sendBlock(neighbour);
    }

    if (success) {
        printNeighbours("Info:");
    }
}

bool cs::PoolSynchronizer::isSyncroStarted() const {
    return isSyncroStarted_;
}

bool cs::PoolSynchronizer::isOneBlockReply() const {
    return syncData_.oneReplyBlock;
}

bool cs::PoolSynchronizer::isFastMode() const {
    if (!isSyncroStarted_ || !syncData_.isFastMode) {
        return false;
    }

    const cs::Sequence sum = cs::Conveyer::instance().currentRoundNumber() - blockChain_->getLastSequence() - blockChain_->getCachedBlocksSize();
    return sum > static_cast<cs::Sequence>(syncData_.blockPoolsCount * 3);  // roundDifferentForSync_
}

//
// Slots
//

void cs::PoolSynchronizer::onTimeOut() {
    if (!isSyncroStarted_) {
        return;
    }

    bool isAvailable = false;

    if (isFastMode()) {
        static uint8_t fastCounter = 0;
        ++fastCounter;
        if (fastCounter > 20) {
            fastCounter = 0;
            csmeta(csdetails) << "OnTimeOut Fast: " << syncData_.sequencesVerificationFrequency * 20;
            isAvailable = checkActivity(cs::PoolSynchronizer::CounterType::ROUND);
        }
    }

    if (!isAvailable) {
        csmeta(csdetails) << "OnTimeOut: " << syncData_.sequencesVerificationFrequency;
        isAvailable = checkActivity(cs::PoolSynchronizer::CounterType::TIMER);
    }

    if (isAvailable) {
        sendBlockRequest();
    }
}

void cs::PoolSynchronizer::onRoundSimulation() {
    csmeta(csdetails) << "on round simulation";

    bool isAvailable = checkActivity(cs::PoolSynchronizer::CounterType::ROUND);

    if (isAvailable) {
        sendBlockRequest();
    }
}

void cs::PoolSynchronizer::onWriteBlock(const csdb::Pool pool) {
    onWriteBlock(pool.sequence());
}

void cs::PoolSynchronizer::onWriteBlock(const cs::Sequence sequence) {
    removeExistingSequence(sequence, SequenceRemovalAccuracy::EXACT);
}

void cs::PoolSynchronizer::onRemoveBlock(const cs::Sequence sequence) {
    csmeta(csdetails) << sequence;
    removeExistingSequence(sequence, SequenceRemovalAccuracy::UPPER_BOUND);
}

//
// Service
//

bool cs::PoolSynchronizer::showSyncronizationProgress(const cs::Sequence lastWrittenSequence) const {
    const cs::RoundNumber globalSequence = cs::Conveyer::instance().currentRoundNumber();

    if (!globalSequence) {
        csmeta(cswarning) << "Current round number: 0";
        return false;
    }

    const std::size_t cachedBlocksSize = blockChain_->getCachedBlocksSize();
    const float last = float(lastWrittenSequence + cachedBlocksSize);
    const float global = float(globalSequence - 1);
    const float maxValue = 100.0f;
    const uint32_t syncStatus = static_cast<uint32_t>(std::min(((last / global) * maxValue), maxValue));
    const uint32_t remaining = static_cast<uint32_t>(global - last);

    ProgressBar bar;
    std::cout << "\n";
    cslog() << "SYNC: Blocks remaining: " << remaining;
    csdebug() << "SYNC: Cached blocks size in blockchain: " << cachedBlocksSize;
    cslog() << "SYNC: " << bar.string(syncStatus) << "\n";

    return remaining == 0;
}

bool cs::PoolSynchronizer::checkActivity(const CounterType counterType) {
    refreshNeighbours();

    if (neighbours_.empty()) {
        csmeta(csdetails) << "Neighbours count is 0";
        return false;
    }

    csmeta(csdetails) << counterType;
    bool isNeedRequest = false;

    switch (counterType) {
        case CounterType::ROUND:
            for (auto& neighbour : neighbours_) {
                neighbour.increaseRoundCounter();
                if (!isNeedRequest && isAvailableRequest(neighbour)) {
                    isNeedRequest = true;
                }
            }
            csmeta(csdetails) << "isNeedRequest: " << isNeedRequest;
            printNeighbours("Activity Round:");
            break;

        case CounterType::TIMER:
            for (auto& neighbour : neighbours_) {
                isNeedRequest = neighbour.sequences().empty();
                if (isNeedRequest) {
                    break;
                }
            }
            csmeta(csdetails) << "isNeedRequest: " << isNeedRequest;
            break;
    }

    return isNeedRequest;
}

void cs::PoolSynchronizer::sendBlock(const NeighboursSetElemet& neighbour) {
    ConnectionPtr target = getConnection(neighbour);

    if (!target) {
        csmeta(cserror) << "Target is not valid";
        return;
    }

    std::size_t packet = 0;
    const auto& sequences = neighbour.sequences();

    for (const auto& sequence : sequences) {
        if (!requestedSequences_.count(sequence)) {
            requestedSequences_.emplace(std::make_pair(sequence, 0));
        }
        packet = ++(requestedSequences_.at(sequence));
    }

    cslog() << "SYNC: requesting for " << sequences.size() << " blocks [" << sequences.front() << ", " << sequences.back()
        << "] from " << target->getOut() << ", repeat " << packet;

    emit sendRequest(target, sequences, packet);
}

bool cs::PoolSynchronizer::getNeededSequences(NeighboursSetElemet& neighbour) {
    const bool isLastPacket = isLastRequest();
    if (isLastPacket && !requestedSequences_.empty()) {
        csmeta(csdetails) << "Is last packet: requested sequences: [" << requestedSequences_.begin()->first << ", " << requestedSequences_.rbegin()->first << "]";

        const auto& sequences = neighbour.sequences();
        if (!sequences.empty() && requestedSequences_.find(sequences.front()) != requestedSequences_.end()) {
            csmeta(csdetails) << "Is last packet: this neighbour is already requested";
            if (isAvailableRequest(neighbour)) {
                neighbour.resetRoundCounter();
                return true;
            }
            return false;
        }

        neighbour.reset();
        const int nhIdx = static_cast<int>(neighbour.index());
        for (const auto& [sequence, packet] : requestedSequences_) {
            (void)packet;
            neighbour.addSequences(sequence);
            csmeta(csdetails) << "Is last packet: nh: " << nhIdx << ", add seq: " << sequence;
        }
        csmeta(csdetails) << "Needed sequences size: " << neighbour.sequences().size();
        return true;
    }

    const std::vector<BlockChain::SequenceInterval> requiredBlocks = blockChain_->getRequiredBlocks();

    if (requiredBlocks.empty()) {
        csmeta(csdebug) << "Required blocks is empty !!!";
        return true;
    }

    const cs::Sequence lastWrittenSequence = blockChain_->getLastSequence();

    // remove unnecessary sequnces
    removeExistingSequence(lastWrittenSequence, SequenceRemovalAccuracy::LOWER_BOUND);

    cs::Sequence sequence = lastWrittenSequence;

    auto isNeededHelpIt = requestedSequences_.end();
    if (syncData_.neighbourPacketsCount > 0 && !isLastPacket) {
        isNeededHelpIt = std::find_if(requestedSequences_.begin(), requestedSequences_.end(), [this](const auto& pair) { return pair.second >= syncData_.neighbourPacketsCount; });
    }

    // if storage requested sequences is impty
    if (requestedSequences_.empty()) {
        sequence = lastWrittenSequence;
        csmeta(csdetails) << "From blockchain: " << sequence;
    }
    // Needed help another neighbour
    else if (isNeededHelpIt != requestedSequences_.end()) {
        sequence = isNeededHelpIt->first;

        csmeta(csdetails) << "From needed help: " << sequence;

        auto needyNeighbour = std::find_if(neighbours_.begin(), neighbours_.end(),
                                           [sequence](const NeighboursSetElemet& el) { return (!el.sequences().empty() && el.sequences().front() == sequence); });

        if (needyNeighbour == neighbours_.end()) {
            csmeta(cserror) << "Needy neighbour is not valid";
            return false;
        }

        if (neighbour.sequences() == needyNeighbour->sequences()) {
            return true;
        }

        if (!neighbour.sequences().empty() && sequence != neighbour.sequences().front()) {
            for (const auto& seq : neighbour.sequences()) {
                requestedSequences_.erase(seq);
            }
            neighbour.reset();
        }

        neighbour.setSequences(needyNeighbour->sequences());
        return true;
    }
    // Repeat request
    else if (isAvailableRequest(neighbour)) {
        if (!neighbour.sequences().empty()) {
            csmeta(csdetails) << "From repeat request: [" << neighbour.sequences().front() << ", " << neighbour.sequences().back() << "]";
        }

        neighbour.resetRoundCounter();
        return true;
    }
    else {
        sequence = std::max(requestedSequences_.rbegin()->first, lastWrittenSequence);
        csmeta(csdetails) << "From other: " << sequence;
    }

    if (!neighbour.sequences().empty()) {
        return false;
    }

    neighbour.resetSequences();

    for (std::size_t i = 0; i < syncData_.blockPoolsCount; ++i) {
        ++sequence;

        // max sequence
        if (requiredBlocks.back().second != 0 && sequence > requiredBlocks.back().second) {
            csmeta(csdetails) << "Max sequence reached";
            break;
        }

        for (std::size_t j = 1; j < requiredBlocks.size(); ++j) {
            // Within a valid pair
            if (sequence > requiredBlocks[j].first && sequence < requiredBlocks[j].second) {
                csmeta(csdetails) << "Check sequence interval: seq: " << sequence << ", Within a valid pair (" << j << "): [" << requiredBlocks[j].first << ", "
                                  << requiredBlocks[j].second << "]";
                break;
            }
            // Between pairs
            if (sequence > requiredBlocks[j - 1].second && sequence < requiredBlocks[j].first) {
                sequence = requiredBlocks[j].first;
                csmeta(csdetails) << "Between pairs: " << sequence;
                break;
            }
        }

        csmeta(csdetails) << "Add sequence for request: " << sequence;

        neighbour.addSequences(sequence);
    }

    return true;
}

void cs::PoolSynchronizer::checkNeighbourSequence(const cs::Sequence sequence, const SequenceRemovalAccuracy accuracy) {
    if (neighbours_.empty() || neighbours_.front().sequences().empty()) {
        return;
    }

    csmeta(csdetails) << sequence;

    bool success = false;

    for (auto& neighbour : neighbours_) {
        success |= neighbour.removeSequnce(sequence, accuracy);

        if (neighbour.sequences().empty()) {
            neighbour.resetRoundCounter();
        }
    }

    if (success) {
        std::sort(neighbours_.begin(), neighbours_.end());
        csmeta(csdetails) << "Remove success sequence: " << sequence;
        printNeighbours("Check seq:");
    }
}

void cs::PoolSynchronizer::removeExistingSequence(const cs::Sequence sequence, const SequenceRemovalAccuracy accuracy) {
    csmeta(csdetails) << "sequence: " << sequence << ", accuracy: " << accuracy;
    checkNeighbourSequence(sequence, accuracy);

    if (!requestedSequences_.empty()) {
        switch (accuracy) {
            case SequenceRemovalAccuracy::EXACT: {
                auto it = requestedSequences_.find(sequence);
                if (it != requestedSequences_.end()) {
                    requestedSequences_.erase(it);
                }
                break;
            }
            case SequenceRemovalAccuracy::LOWER_BOUND:
                requestedSequences_.erase(requestedSequences_.begin(), requestedSequences_.upper_bound(sequence));
                break;
            case SequenceRemovalAccuracy::UPPER_BOUND:
                requestedSequences_.erase(requestedSequences_.lower_bound(sequence), requestedSequences_.end());
                break;
        }
    }
}

void cs::PoolSynchronizer::refreshNeighbours() {
    const uint8_t neededNeighboursCount = static_cast<uint8_t>(transport_->getNeighboursCountWithoutSS());
    const uint8_t nSize = static_cast<uint8_t>(neighbours_.size());

    if (nSize == neededNeighboursCount) {
        return;
    }

    csmeta(csdetails) << "Neighbours count without ss: " << static_cast<int>(neededNeighboursCount);

    const uint8_t allNeighboursCount = static_cast<uint8_t>(transport_->getNeighboursCount());

    // Add new neighbours
    if (nSize < neededNeighboursCount) {
        for (uint8_t i = nSize; i < allNeighboursCount; ++i) {
            ConnectionPtr neighbour = transport_->getConnectionByNumber(i);
            if (neighbour && !neighbour->isSignal && neighbour->lastSeq) {
                auto isAlreadyHave = std::find_if(neighbours_.begin(), neighbours_.end(), [=](const auto& el) { return el.index() == i; });

                if (isAlreadyHave == neighbours_.end()) {
                    neighbours_.emplace_back(NeighboursSetElemet(i, neighbour->key, syncData_.blockPoolsCount));
                }
            }
        }
        csmeta(csdetails) << "Neighbours saved count is: " << neighbours_.size();
        return;
    }

    // refresh neighbours index
    std::size_t currentNh = 0;
    for (uint8_t i = 0; i < allNeighboursCount; ++i) {
        ConnectionPtr neighbour = transport_->getConnectionByNumber(i);
        if (neighbour && !neighbour->isSignal) {
            neighbours_[currentNh].setIndex(i);
            neighbours_[currentNh].setPublicKey(neighbour->key);
            ++currentNh;
        }
    }

    // remove extra neighbour
    for (uint8_t i = neededNeighboursCount; i < nSize; ++i) {
        const auto& seqs = neighbours_.back().sequences();
        for (const auto& seq : seqs) {
            bool isAvailable = true;

            if (neighbours_.size() > 1) {
                auto res = std::find_if(neighbours_.begin(), neighbours_.end() - 1,
                                        [seq](const NeighboursSetElemet& el) { return std::find(el.sequences().begin(), el.sequences().end(), seq) != el.sequences().end(); });
                if (res != neighbours_.end() - 1) {
                    isAvailable = false;
                }
            }

            if (isAvailable) {
                requestedSequences_.erase(seq);
            }
        }
        neighbours_.pop_back();
    }

    csmeta(csdetails) << "Neighbours saved count is: " << neighbours_.size();
    printNeighbours("Refresh:");
}

bool cs::PoolSynchronizer::isLastRequest() const {
    const auto sum = cs::Conveyer::instance().currentRoundNumber() - blockChain_->getLastSequence() - blockChain_->getCachedBlocksSize();
    return sum <= syncData_.blockPoolsCount;
}

bool cs::PoolSynchronizer::isAvailableRequest(const cs::PoolSynchronizer::NeighboursSetElemet& nh) const {
    const auto value = nh.roundCounter();

    if (value != 0) {
        return ((value % syncData_.requestRepeatRoundCount) == 0);
    }

    return false;
}

void cs::PoolSynchronizer::synchroFinished() {
    cs::Connector::disconnect(&blockChain_->storeBlockEvent, this, static_cast<void (PoolSynchronizer::*)(const csdb::Pool)>(&cs::PoolSynchronizer::onWriteBlock));
    cs::Connector::disconnect(&blockChain_->cachedBlockEvent, this, static_cast<void (PoolSynchronizer::*)(const cs::Sequence)>(&cs::PoolSynchronizer::onWriteBlock));
    cs::Connector::disconnect(&blockChain_->removeBlockEvent, this, &cs::PoolSynchronizer::onRemoveBlock);

    if (timer_.isRunning()) {
        timer_.stop();
    }
    if (roundSimulation_.isRunning()) {
        roundSimulation_.stop();
    }
    isSyncroStarted_ = false;
    requestedSequences_.clear();
    neighbours_.clear();

    csmeta(csdebug) << "Synchro finished";
}

ConnectionPtr cs::PoolSynchronizer::getConnection(const NeighboursSetElemet& neighbour) const {
    ConnectionPtr target = transport_->getConnectionByKey(neighbour.publicKey());

    if (!target) {
        target = transport_->getConnectionByNumber(neighbour.index());
    }

    return target;
}

void cs::PoolSynchronizer::printNeighbours(const std::string& funcName) const {
    for (const auto& neighbour : neighbours_) {
        ConnectionPtr target = getConnection(neighbour);

        if (target) {
            csmeta(csdebug) << funcName << " Neighbour: " << target->getOut() << ", " << neighbour;
        }
        else {
            csmeta(csdebug) << funcName << " Neighbour index: " << neighbour.index() << ", does not contained in transport. Neighbours сount: " << transport_->getNeighboursCount()
                            << ", neighbour key: " << cs::Utils::byteStreamToHex(neighbour.publicKey().data(), neighbour.publicKey().size());
        }
    }
}
```
# ..\node\csnode\src\roundstat.cpp 
```cpp 
#include <csnode/roundstat.hpp>
#include <lib/system/logger.hpp>
#include <sstream>

namespace cs {
RoundStat::RoundStat()
: totalReceivedTransactions_(0)
, totalAcceptedTransactions_(0)
, deferredTransactionsCount_(0)
, totalDurationMs_(0)
, node_start_round(0)
, start_skip_rounds(2) {
}

void RoundStat::onRoundStart(RoundNumber round) {
    // minimal statistics, skip 0 & 1 rounds because of possibility extra timeouts
    if (start_skip_rounds > 0) {
        start_skip_rounds--;
        node_start_round = round;
        startPointMs_ = std::chrono::steady_clock::now();
        totalDurationMs_ = 0;
    }
    else {
        using namespace std::chrono;
        auto new_duration_ms = duration_cast<milliseconds>(steady_clock::now() - startPointMs_).count();
        auto last_round_ms = cs::numeric_cast<size_t>(new_duration_ms) - totalDurationMs_;
        totalDurationMs_ = cs::numeric_cast<size_t>(new_duration_ms);
        size_t cnt_r = 1;
        if (round > node_start_round) {
            cnt_r = round - node_start_round;
        }
        auto ave_round_ms = totalDurationMs_ / cnt_r;

        // shortest_rounds.insert(last_round_ms);
        // longest_rounds.insert(last_round_ms);

        // TODO: use more intelligent output formatting
        std::ostringstream os;
        constexpr size_t in_minutes = 5 * 60 * 1000;
        constexpr size_t in_seconds = 10 * 1000;

        os << " last round ";

        if (last_round_ms > in_minutes) {
            os << "> " << last_round_ms / 60000 << "min";
        }
        else if (last_round_ms > in_seconds) {
            os << "> " << last_round_ms / 1000 << "sec";
        }
        else {
            os << last_round_ms << "ms";
        }

        os << ", average round ";

        if (ave_round_ms > in_seconds) {
            os << "> " << ave_round_ms / 1000 << "sec";
        }
        else {
            os << ave_round_ms << "ms";
        }

        os << ", "
           //<< totalReceivedTransactions_ << " viewed transactions, "
           << WithDelimiters(totalAcceptedTransactions_) << " stored transactions.";
        cslog() << os.str();
    }
}

void RoundStat::onReadBlock(csdb::Pool block, bool* /*should_stop*/) {
    totalAcceptedTransactions_ += block.transactions_count();
}

void RoundStat::onStoreBlock(csdb::Pool block) {
    totalAcceptedTransactions_ += block.transactions_count();
}

}  // namespace cs
```
# ..\node\csnode\src\transactionspacket.cpp 
```cpp 
#include "csnode/transactionspacket.hpp"

#include <lz4.h>
#include <csdb/csdb.hpp>
#include <csdb/internal/utils.hpp>
#include <src/binary_streams.hpp>
#include <src/priv_crypto.hpp>

namespace cs {
//
// Static interface
//

TransactionsPacketHash TransactionsPacketHash::fromString(const ::std::string& str) {
    if (str.empty()) {
        return TransactionsPacketHash();
    }

    TransactionsPacketHash res;
    const cs::Bytes hash = ::csdb::internal::from_hex(str);

    if (::csdb::priv::crypto::hash_size == hash.size()) {
        res.m_bytes = hash;
    }

    return res;
}

TransactionsPacketHash TransactionsPacketHash::fromBinary(const cs::Bytes& data) {
    const size_t size = data.size();
    TransactionsPacketHash hash;

    if (::csdb::priv::crypto::hash_size == size) {
        hash.m_bytes = data;
    }

    return hash;
}

TransactionsPacketHash TransactionsPacketHash::fromBinary(cs::Bytes&& data) {
    const size_t size = data.size();
    TransactionsPacketHash hash;

    if (::csdb::priv::crypto::hash_size == size) {
        hash.m_bytes = std::move(data);
    }

    return hash;
}

TransactionsPacketHash TransactionsPacketHash::calcFromData(const cs::Bytes& data) {
    TransactionsPacketHash resHash;
    resHash.m_bytes = ::csdb::priv::crypto::calc_hash(data);
    return resHash;
}

//
// Interface
//

bool TransactionsPacketHash::isEmpty() const noexcept {
    return m_bytes.empty();
}

size_t TransactionsPacketHash::size() const noexcept {
    return m_bytes.size();
}

std::string TransactionsPacketHash::toString() const noexcept {
    return csdb::internal::to_hex(m_bytes.begin(), m_bytes.end());
}

const cs::Bytes& TransactionsPacketHash::toBinary() const noexcept {
    return m_bytes;
}

bool TransactionsPacketHash::operator==(const TransactionsPacketHash& other) const noexcept {
    return m_bytes == other.m_bytes;
}

bool TransactionsPacketHash::operator!=(const TransactionsPacketHash& other) const noexcept {
    return !operator==(other);
}

bool TransactionsPacketHash::operator<(const TransactionsPacketHash& other) const noexcept {
    return m_bytes < other.m_bytes;
}

//
// Static interface
//

TransactionsPacket TransactionsPacket::fromBinary(const cs::Bytes& data) {
    return fromByteStream(reinterpret_cast<const char*>(data.data()), data.size());
}

TransactionsPacket TransactionsPacket::fromByteStream(const char* data, size_t size) {
    ::csdb::priv::ibstream is(data, size);

    TransactionsPacket res;

    if (!res.get(is)) {
        return TransactionsPacket();
    }
    res.makeHash();

    return res;
}

TransactionsPacket::TransactionsPacket(TransactionsPacket&& packet)
: m_hash(std::move(packet.m_hash))
, m_transactions(std::move(packet.m_transactions))
, m_signatures(std::move(packet.m_signatures)) {
    packet.m_hash = TransactionsPacketHash();
    packet.m_transactions.clear();
}

TransactionsPacket& TransactionsPacket::operator=(const TransactionsPacket& packet) {
    if (this == &packet) {
        return *this;
    }

    m_hash = packet.m_hash;
    m_transactions = packet.m_transactions;
    m_signatures = packet.m_signatures;

    return *this;
}

//
// Interface
//

cs::Bytes TransactionsPacket::toBinary(Serialization options) const noexcept {
    ::csdb::priv::obstream os;
    put(os, options);
    return os.buffer();
}

bool TransactionsPacket::makeHash() {
    bool isEmpty = isHashEmpty();

    if (isEmpty) {
        m_hash = TransactionsPacketHash::calcFromData(toBinary(Serialization::Transactions));
    }

    return isEmpty;
}

bool TransactionsPacket::isHashEmpty() const noexcept {
    return m_hash.isEmpty();
}

const TransactionsPacketHash& TransactionsPacket::hash() const noexcept {
    return m_hash;
}

size_t TransactionsPacket::transactionsCount() const noexcept {
    return m_transactions.size();
}

bool TransactionsPacket::addTransaction(const csdb::Transaction& transaction) {
    if (!transaction.is_valid() || !isHashEmpty()) {
        return false;
    }

    m_transactions.push_back(transaction);
    return true;
}

bool TransactionsPacket::addSignature(const cs::Byte index, const cs::Signature& signature) {
    auto iter = std::find_if(m_signatures.begin(), m_signatures.end(), [&](const auto& element) { return index == element.first; });

    if (iter != m_signatures.end()) {
        return false;
    }

    m_signatures.push_back(std::make_pair(index, signature));
    return true;
}

const cs::BlockSignatures& TransactionsPacket::signatures() const noexcept {
    return m_signatures;
}

const std::vector<csdb::Transaction>& TransactionsPacket::transactions() const noexcept {
    return m_transactions;
}

std::vector<csdb::Transaction>& TransactionsPacket::transactions() {
    return m_transactions;
}

void TransactionsPacket::clear() noexcept {
    m_transactions.clear();
}

//
// Service
//

void TransactionsPacket::put(::csdb::priv::obstream& os, Serialization options) const {
    if (options & Serialization::Transactions) {
        os.put(m_transactions.size());

        for (const auto& it : m_transactions) {
            os.put(it);
        }
    }

    if (options & Serialization::Signatures) {
        os.put(m_signatures.size());

        for (const auto& it : m_signatures) {
            os.put(it.first);
            os.put(it.second);
        }
    }
}

bool TransactionsPacket::get(::csdb::priv::ibstream& is) {
    std::size_t transactionsCount = 0;

    if (!is.get(transactionsCount)) {
        return false;
    }

    m_transactions.clear();
    m_transactions.reserve(transactionsCount);

    for (std::size_t i = 0; i < transactionsCount; ++i) {
        csdb::Transaction transaction;

        if (!is.get(transaction)) {
            return false;
        }

        m_transactions.push_back(transaction);
    }

    std::size_t signaturesCount = 0;

    if (!is.get(signaturesCount)) {
        return false;
    }
    m_signatures.clear();
    m_signatures.reserve(signaturesCount);

    for (std::size_t i = 0; i < signaturesCount; ++i) {
        cs::Byte index;
        cs::Signature signature;

        if (!is.get(index)) {
            return false;
        }
        if (!is.get(signature)) {
            return false;
        }
        m_signatures.push_back(std::make_pair(index, signature));
    }

    return true;
}
}  // namespace cs
```
# ..\node\csnode\src\transactionsvalidator.cpp 
```cpp 
#include <csnode/transactionsvalidator.hpp>

#include <map>
#include <vector>
#ifdef _MSC_VER
#include <intrin.h>
#endif

#include <client/params.hpp>
#include <csdb/amount.hpp>
#include <csdb/amount_commission.hpp>
#include <lib/system/logger.hpp>
#include <smartcontracts.hpp>
#include <solvercontext.hpp>
#include <walletscache.hpp>

namespace {
const uint8_t kInvalidMarker = 0;
const uint8_t kValidMarker = 1;
const char* kLogPrefix = "Validator: ";
}  // namespace

namespace cs {
TransactionsValidator::TransactionsValidator(WalletsState& walletsState, const Config& config)
: config_(config)
, walletsState_(walletsState)
, cntRemovedTrxs_(0) {
    negativeNodes_.reserve(config_.initialNegNodesNum_);
}

void TransactionsValidator::reset(size_t transactionsNum) {
    trxList_.clear();
    trxList_.resize(transactionsNum, WalletsState::noInd_);
    negativeNodes_.clear();
    cntRemovedTrxs_ = 0;
}

bool TransactionsValidator::validateTransaction(SolverContext& context, const Transactions& trxs, size_t trxInd) {
    if (!validateTransactionAsSource(context, trxs, trxInd)) {
        return false;
    }
    return validateTransactionAsTarget(trxs[trxInd]);
}

bool TransactionsValidator::validateNewStateAsSource(SolverContext& context, const csdb::Transaction& trx) {
    auto& smarts = context.smart_contracts();
    if (smarts.is_closed_smart_contract(trx.target())) {
        cslog() << kLogPrefix << __func__ << ": reject smart new_state transaction, related contract is closed";
        rejectedNewStates_.push_back(smarts.absolute_address(trx.source()));
        return false;
    }
    csdb::Transaction initTransaction = WalletsCache::findSmartContractInitTrx(trx, context.blockchain());
    if (!initTransaction.is_valid()) {
        cslog() << kLogPrefix << __func__ << ": reject new_state transaction, starter transaction is not found";
        rejectedNewStates_.push_back(smarts.absolute_address(trx.source()));
        return false;
    }
    csdb::UserField feeField = trx.user_field(trx_uf::new_state::Fee);
    if (!feeField.is_valid()) {
        cslog() << kLogPrefix << __func__ << ": reject new_state transaction, execution fee is not set properly";
        rejectedNewStates_.push_back(smarts.absolute_address(trx.source()));
        return false;
    }
    csdb::Amount feeForExecution(feeField.value<csdb::Amount>());
    if ((csdb::Amount(initTransaction.max_fee().to_double()) - csdb::Amount(initTransaction.counted_fee().to_double())) <
        csdb::Amount(trx.counted_fee().to_double()) + feeForExecution) {
        cslog() << kLogPrefix << __func__ << ": reject new_state transaction, fee is not enough"
                << "\nInit Transaction max fee = " << initTransaction.max_fee().to_double() << "\nInit Transaction counted fee = " << initTransaction.counted_fee().to_double()
                << "\nNew State transaction counted fee = " << trx.counted_fee().to_double() << "\nNew State transaction exec fee = " << feeForExecution.to_double();
        rejectedNewStates_.push_back(smarts.absolute_address(trx.source()));
        return false;
    }
    WalletsState::WalletId initTrxId{};
    WalletsState::WalletData& initTrxWallState = walletsState_.getData(initTransaction.source(), initTrxId);
    csdb::Amount newBalance = initTrxWallState.balance_ + csdb::Amount(initTransaction.max_fee().to_double()) - csdb::Amount(initTransaction.counted_fee().to_double()) -
                              trx.amount() - feeForExecution - csdb::Amount(trx.counted_fee().to_double());

    initTrxWallState.balance_ = newBalance;
    walletsState_.setModified(initTrxId);

    if (initTrxWallState.balance_ < zeroBalance_) {
        cslog() << kLogPrefix << __func__ << ": reject new_state transaction, initier is out of funds";
        rejectedNewStates_.push_back(smarts.absolute_address(trx.source()));
        return false;
    }
    return true;
}

bool TransactionsValidator::validateCommonAsSource(SolverContext& context, const Transactions& trxs, size_t trxInd, WalletsState::WalletData& wallState) {
    auto& smarts = context.smart_contracts();
    const auto trx = trxs[trxInd];
    csdb::Amount newBalance;

    if (trx.source() == trx.target()) {
        cslog() << kLogPrefix << __func__ << ": reject transaction[" << trxInd << "], source equals to target";
        return false;
    }
    const double max_fee = trx.max_fee().to_double();
    const double counted_fee = trx.counted_fee().to_double();
    if (csdb::Amount(max_fee) < csdb::Amount(counted_fee)) {
        cslog() << kLogPrefix << __func__ << ": reject transaction[" << trxInd << "], max fee (" << max_fee
            << ") is less than counted fee (" << counted_fee << ")";
        return false;
    }

    if (SmartContracts::is_executable(trx)) {
        newBalance = wallState.balance_ - trx.amount() - csdb::Amount(trx.max_fee().to_double());
    }
    else {
        if (smarts.is_known_smart_contract(trx.source())) {
            bool ok = false;
            for (const auto& t : trxs) {
                if (SmartContracts::is_new_state(t) &&
                    std::find(rejectedNewStates_.begin(), rejectedNewStates_.end(), context.smart_contracts().absolute_address(t.source())) == rejectedNewStates_.end()) {
                    auto initTransaction = WalletsCache::findSmartContractInitTrx(t, context.blockchain());
                    if (initTransaction.is_valid() && smarts.absolute_address(initTransaction.target()) == smarts.absolute_address(trx.source())) {
                        auto it = payableMaxFees_.find(smarts.absolute_address(initTransaction.source()));
                        csdb::Amount leftFromMaxFee;
                        if (it == payableMaxFees_.end()) {
                            leftFromMaxFee = csdb::Amount(initTransaction.max_fee().to_double() - csdb::Amount(trx.counted_fee().to_double()));
                        }
                        else {
                            leftFromMaxFee = it->second - csdb::Amount(trx.counted_fee().to_double());
                        }
                        if (leftFromMaxFee < zeroBalance_) {
                            cslog() << kLogPrefix << __func__ << ": reject contract emitted transaction, out of fee in starter transaction";
                            return false;
                        }
                        ok = true;
                        payableMaxFees_.insert(std::make_pair(smarts.absolute_address(initTransaction.source()), leftFromMaxFee));
                    }
                }
            }
            if (!ok) {
                cslog() << kLogPrefix << __func__ << ": reject contract emitted transaction, new_state not found in block";
                return false;
            }
            newBalance = wallState.balance_ - trx.amount();
        }
        else {
            if (smarts.is_known_smart_contract(trx.target())) {
                newBalance = wallState.balance_ - trx.amount() - csdb::Amount(trx.max_fee().to_double());
            }
            else {
                newBalance = wallState.balance_ - trx.amount() - csdb::Amount(trx.counted_fee().to_double());
            }
        }
    }
    if (smarts.is_known_smart_contract(trx.target()) && csdb::Amount(trx.max_fee().to_double()) > wallState.balance_) {
        cslog() << kLogPrefix << "transaction[" << trxInd << "] balance = " << wallState.balance_.to_double() << ", max_fee = " << trx.max_fee().to_double();
    }
    wallState.balance_ = newBalance;
    return true;
}

bool TransactionsValidator::validateTransactionAsSource(SolverContext& context, const Transactions& trxs, size_t trxInd) {
    const auto& trx = trxs[trxInd];
    WalletsState::WalletId walletId{};
    WalletsState::WalletData& wallState = walletsState_.getData(trx.source(), walletId);
    walletsState_.setModified(walletId);

    if (!wallState.trxTail_.isAllowed(trx.innerID())) {
        csdebug() << kLogPrefix << "reject transaction, duplicated or incorrect innerID " << trx.innerID() << ", allowed " << wallState.trxTail_.printRange();
        if (SmartContracts::is_new_state(trx)) {
            rejectedNewStates_.push_back(context.smart_contracts().absolute_address(trx.source()));
        }
        return false;
    }

    if (SmartContracts::is_new_state(trx)) {
        csdebug() << kLogPrefix << __func__ << ": smart new_state transaction[" << trxInd << "] included in consensus";
        if (!validateNewStateAsSource(context, trx)) {
            return false;
        }
    }
    else {
        if (!validateCommonAsSource(context, trxs, trxInd, wallState)) {
            return false;
        }
    }

    if (wallState.balance_ < zeroBalance_) {
        csdebug() << kLogPrefix << "transaction[" << trxInd << "] results to potentially negative balance " << wallState.balance_.to_double();
        // will be checked in rejected smarts
        if (context.smart_contracts().is_known_smart_contract(trx.source())) {
            return false;
        }
        // will be validated by graph
        negativeNodes_.push_back(&wallState);
    }

    wallState.trxTail_.push(trx.innerID());
    trxList_[trxInd] = wallState.lastTrxInd_;
    wallState.lastTrxInd_ = static_cast<decltype(wallState.lastTrxInd_)>(trxInd);

    return true;
}

bool TransactionsValidator::validateTransactionAsTarget(const csdb::Transaction& trx) {
    WalletsState::WalletId walletId{};
    WalletsState::WalletData& wallState = walletsState_.getData(trx.target(), walletId);

    wallState.balance_ = wallState.balance_ + trx.amount();

    walletsState_.setModified(walletId);
    return true;
}

size_t TransactionsValidator::checkRejectedSmarts(SolverContext& context, const Transactions& trxs, CharacteristicMask& maskIncluded) {
    using rejectedSmart = std::pair<csdb::Transaction, size_t>;
    auto& smarts = context.smart_contracts();
    std::vector<csdb::Transaction> newStates;
    std::vector<rejectedSmart> rejectedSmarts;
    size_t maskSize = maskIncluded.size();
    size_t i = 0;
    size_t restoredCounter = 0;

    for (const auto& t : trxs) {
        if (i < maskSize && smarts.is_known_smart_contract(t.source()) && !SmartContracts::is_new_state(t)) {
            WalletsState::WalletId id{};
            WalletsState::WalletData& wallState = walletsState_.getData(t.source(), id);
            if (wallState.balance_ < zeroBalance_) {
                rejectedSmarts.push_back(std::make_pair(t, i));
            }
        }
        else if (i < maskSize && SmartContracts::is_new_state(t) && *(maskIncluded.cbegin() + i) == kValidMarker) {
            newStates.push_back(t);
        }
        ++i;
    }

    for (const auto& state : newStates) {
        csdb::Transaction initTransaction = WalletsCache::findSmartContractInitTrx(state, context.blockchain());
        auto it = std::find_if(rejectedSmarts.cbegin(), rejectedSmarts.cend(),
                               [&](const auto& o) { return (smarts.absolute_address(o.first.source()) == smarts.absolute_address(initTransaction.target())); });
        if (it != rejectedSmarts.end()) {
            WalletsState::WalletId walletId{};
            WalletsState::WalletData& wallState = walletsState_.getData(it->first.source(), walletId);
            wallState.balance_ += initTransaction.amount();
            if (wallState.balance_ >= zeroBalance_) {
                restoredCounter += makeSmartsValid(context, rejectedSmarts, it->first.source(), maskIncluded);
            }
        }
    }

    return restoredCounter;
}

size_t TransactionsValidator::makeSmartsValid(SolverContext& context, RejectedSmarts& smarts, const csdb::Address& source, CharacteristicMask& maskIncluded) {
    size_t maskSize = maskIncluded.size();
    auto& s = context.smart_contracts();
    size_t restoredCounter = 0;
    for (size_t i = 0; i < smarts.size(); ++i) {
        if (s.absolute_address(smarts[i].first.source()) == s.absolute_address(source) && smarts[i].second < maskSize) {
            maskIncluded[smarts[i].second] = kValidMarker;
            ++restoredCounter;
            csdebug() << kLogPrefix << "balance of transation[" << smarts[i].second << "] source is replenished by other transaction";

            WalletsState::WalletId walletId{};
            WalletsState::WalletData& wallState = walletsState_.getData(smarts[i].first.source(), walletId);
            wallState.trxTail_.push(smarts[i].first.innerID());
            trxList_[smarts[i].second] = wallState.lastTrxInd_;
            wallState.lastTrxInd_ = static_cast<decltype(wallState.lastTrxInd_)>(smarts[i].second);
            walletsState_.setModified(walletId);
        }
    }
    return restoredCounter;
}

void TransactionsValidator::validateByGraph(SolverContext& context, CharacteristicMask& maskIncluded, const Transactions& trxs) {
    while (!negativeNodes_.empty()) {
        Node& currNode = *negativeNodes_.back();
        negativeNodes_.pop_back();

        if (currNode.balance_ >= zeroBalance_) {
            continue;
        }

        removeTransactions(context, currNode, trxs, maskIncluded);
    }
}

void TransactionsValidator::removeTransactions(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded) {
    if (removeTransactions_PositiveOne(context, node, trxs, maskIncluded)) {
        return;
    }
    if (removeTransactions_PositiveAll(context, node, trxs, maskIncluded)) {
        return;
    }
    if (removeTransactions_NegativeOne(context, node, trxs, maskIncluded)) {
        return;
    }
    if (removeTransactions_NegativeAll(context, node, trxs, maskIncluded)) {
        return;
    }

    csdebug() << "removeTransactions: Failed to make balance non-negative ";
}

bool TransactionsValidator::removeTransactions_PositiveOne(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded) {
    if (node.balance_ >= zeroBalance_)
        return true;

    const csdb::Amount absBalance = -node.balance_;
    TransactionIndex* prevNext = &node.lastTrxInd_;
    auto& smarts = context.smart_contracts();

    for (TransactionIndex trxInd = *prevNext; trxInd != WalletsState::noInd_; trxInd = *prevNext) {
        const csdb::Transaction& trx = trxs[trxInd];

        csdb::Amount trxCost = trx.amount().to_double();
        if (smarts.is_known_smart_contract(trx.target())) {
            trxCost += csdb::Amount(trx.max_fee().to_double());
        }
        else {
            trxCost += csdb::Amount(trx.counted_fee().to_double());
        }

        if (trxCost < absBalance) {
            prevNext = &trxList_[trxInd];
            continue;
        }

        WalletsState::WalletId walletId{};
        Node& destNode = walletsState_.getData(trx.target(), walletId);

        const bool isTrxPositive = (trx.amount() <= destNode.balance_);

        if (!isTrxPositive) {
            prevNext = &trxList_[trxInd];
            continue;
        }

        maskIncluded[trxInd] = kInvalidMarker;

        if (smarts.is_known_smart_contract(trx.target())) {
            node.balance_ = node.balance_ + trx.amount() + csdb::Amount(trx.max_fee().to_double());
        }
        else {
            node.balance_ = node.balance_ + trx.amount() + csdb::Amount(trx.counted_fee().to_double());
        }
        destNode.balance_ = destNode.balance_ - trx.amount();

        *prevNext = trxList_[trxInd];
        trxList_[trxInd] = WalletsState::noInd_;

        ++cntRemovedTrxs_;

        return true;
    }

    return false;
}

bool TransactionsValidator::removeTransactions_PositiveAll(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded) {
    if (node.balance_ >= zeroBalance_)
        return true;

    TransactionIndex* prevNext = &node.lastTrxInd_;
    auto& smarts = context.smart_contracts();

    for (TransactionIndex trxInd = *prevNext; trxInd != WalletsState::noInd_; trxInd = *prevNext) {
        const csdb::Transaction& trx = trxs[trxInd];

        WalletsState::WalletId walletId{};
        Node& destNode = walletsState_.getData(trx.target(), walletId);
        const bool isTrxPositive = (trx.amount() <= destNode.balance_);

        if (!isTrxPositive) {
            prevNext = &trxList_[trxInd];
            continue;
        }

        maskIncluded[trxInd] = kInvalidMarker;

        if (smarts.is_known_smart_contract(trx.target())) {
            node.balance_ = node.balance_ + trx.amount() + csdb::Amount(trx.max_fee().to_double());
        }
        else {
            node.balance_ = node.balance_ + trx.amount() + csdb::Amount(trx.counted_fee().to_double());
        }
        destNode.balance_ = destNode.balance_ - trx.amount();

        *prevNext = trxList_[trxInd];
        trxList_[trxInd] = WalletsState::noInd_;

        ++cntRemovedTrxs_;

        if (node.balance_ >= zeroBalance_) {
            return true;
        }
    }

    return false;
}

bool TransactionsValidator::removeTransactions_NegativeOne(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded) {
    if (node.balance_ >= zeroBalance_)
        return true;

    const csdb::Amount absBalance = -node.balance_;
    TransactionIndex* prevNext = &node.lastTrxInd_;
    auto& smarts = context.smart_contracts();

    for (TransactionIndex trxInd = *prevNext; trxInd != WalletsState::noInd_; trxInd = *prevNext) {
        const csdb::Transaction& trx = trxs[trxInd];
        csdb::Amount trxCost = trx.amount().to_double();
        if (smarts.is_known_smart_contract(trx.target())) {
            trxCost += csdb::Amount(trx.max_fee().to_double());
        }
        else {
            trxCost += csdb::Amount(trx.counted_fee().to_double());
        }

        if (trxCost < absBalance) {
            prevNext = &trxList_[trxInd];
            continue;
        }

        WalletsState::WalletId walletId{};
        Node& destNode = walletsState_.getData(trx.target(), walletId);

        maskIncluded[trxInd] = kInvalidMarker;

        if (smarts.is_known_smart_contract(trx.target())) {
            node.balance_ = node.balance_ + trx.amount() + csdb::Amount(trx.max_fee().to_double());
        }
        else {
            node.balance_ = node.balance_ + trx.amount() + csdb::Amount(trx.counted_fee().to_double());
        }
        destNode.balance_ = destNode.balance_ - trx.amount();

        *prevNext = trxList_[trxInd];
        trxList_[trxInd] = WalletsState::noInd_;

        ++cntRemovedTrxs_;

        if (destNode.balance_ < zeroBalance_)
            negativeNodes_.push_back(&destNode);

        return true;
    }
    return false;
}

bool TransactionsValidator::removeTransactions_NegativeAll(SolverContext& context, Node& node, const Transactions& trxs, CharacteristicMask& maskIncluded) {
    if (node.balance_ >= zeroBalance_)
        return true;

    TransactionIndex* prevNext = &node.lastTrxInd_;
    auto& smarts = context.smart_contracts();

    for (TransactionIndex trxInd = *prevNext; trxInd != WalletsState::noInd_; trxInd = *prevNext) {
        const csdb::Transaction& trx = trxs[trxInd];

        WalletsState::WalletId walletId{};
        Node& destNode = walletsState_.getData(trx.target(), walletId);

        maskIncluded[trxInd] = kInvalidMarker;

        if (smarts.is_known_smart_contract(trx.target())) {
            node.balance_ = node.balance_ + trx.amount() + csdb::Amount(trx.max_fee().to_double());
        }
        else {
            node.balance_ = node.balance_ + trx.amount() + csdb::Amount(trx.counted_fee().to_double());
        }
        destNode.balance_ = destNode.balance_ - trx.amount();

        *prevNext = trxList_[trxInd];
        trxList_[trxInd] = WalletsState::noInd_;

        ++cntRemovedTrxs_;

        if (destNode.balance_ < zeroBalance_)
            negativeNodes_.push_back(&destNode);

        if (node.balance_ >= zeroBalance_)
            return true;
    }

    return false;
}
}  // namespace cs
```
# ..\node\csnode\src\walletscache.cpp 
```cpp 
#include <algorithm>
#include <blockchain.hpp>
#include <csdb/amount_commission.hpp>
#include <csnode/walletscache.hpp>
#include <csnode/walletsids.hpp>
#include <lib/system/logger.hpp>
#include <solver/smartcontracts.hpp>

using namespace std;

namespace {
const uint8_t kUntrustedMarker = 255;

}  // namespace

namespace cs {
void WalletsCache::convert(const csdb::Address& address, WalletData::Address& walletAddress) {
    walletAddress = address.public_key();
}

void WalletsCache::convert(const WalletData::Address& walletAddress, csdb::Address& address) {
    address = csdb::Address::from_public_key(walletAddress);
}

WalletsCache::WalletsCache(const Config& config, csdb::Address genesisAddress, csdb::Address startAddress, WalletsIds& walletsIds)
: config_(config)
, walletsIds_(walletsIds)
, genesisAddress_(genesisAddress)
, startAddress_(startAddress) {
    wallets_.reserve(config.initialWalletsNum_);
}

WalletsCache::~WalletsCache() {
    for (auto el : wallets_)
        delete el;
}

std::unique_ptr<WalletsCache::Initer> WalletsCache::createIniter() {
    return std::unique_ptr<Initer>(new Initer(*this));
}

std::unique_ptr<WalletsCache::Updater> WalletsCache::createUpdater() {
    return std::unique_ptr<Updater>(new Updater(*this));
}

// Initer
WalletsCache::Initer::Initer(WalletsCache& data)
: ProcessorBase(data) {
    walletsSpecial_.reserve(data_.config_.initialWalletsNum_);
}

void WalletsCache::Initer::loadPrevBlock(csdb::Pool& curr, const cs::ConfidantsKeys& confidants, const BlockChain& blockchain) {
    load(curr, confidants, blockchain);
}

// Updater
WalletsCache::Updater::Updater(WalletsCache& data)
: ProcessorBase(data) {
    modified_.resize(data.wallets_.size(), false);
}

void WalletsCache::Updater::loadNextBlock(csdb::Pool& curr, const cs::ConfidantsKeys& confidants, const BlockChain& blockchain) {
    modified_.reset();
    load(curr, confidants, blockchain);
}

void WalletsCache::ProcessorBase::invokeReplenishPayableContract(const csdb::Transaction& transaction) {
    csdb::Address wallAddress = transaction.target();
    if (wallAddress == data_.genesisAddress_ || wallAddress == data_.startAddress_) {
        return;
    }
    WalletId id{};
    if (!findWalletId(wallAddress, id)) {
        cserror() << "Cannot find target wallet, target is " << wallAddress.to_string();
        return;
    }
    WalletData& wallData = getWalletData(id, wallAddress);
    wallData.balance_ -= transaction.amount();
    setModified(id);
    data_.smartPayableTransactions_.push_back(transaction);

    if (!SmartContracts::is_executable(transaction)) {
        WalletId sourceId{};
        csdb::Address sourceAddress = transaction.source();
        if (!findWalletId(sourceAddress, sourceId)) {
            cserror() << "Cannot find source wallet, source is " << sourceAddress.to_string();
            return;
        }
        WalletData& sourceWallData = getWalletData(sourceId, sourceAddress);
        sourceWallData.balance_ += csdb::Amount(transaction.counted_fee().to_double()) - csdb::Amount(transaction.max_fee().to_double());
        setModified(sourceId);
    }
}

void WalletsCache::ProcessorBase::smartSourceTransactionReleased(const csdb::Transaction& smartSourceTrx, const csdb::Transaction& initTrx) {
    csdb::Address smartSourceAddress = smartSourceTrx.source();
    csdb::Address initAddress = initTrx.source();
    auto countedFee = csdb::Amount(smartSourceTrx.counted_fee().to_double());
    WalletId smartId{};
    WalletId initId{};
    if (!findWalletId(smartSourceAddress, smartId)) {
        cserror() << "Cannot find source wallet, source is " << smartSourceAddress.to_string();
        return;
    }
    if (!findWalletId(initAddress, initId)) {
        cserror() << "Cannot find source wallet, source is " << initAddress.to_string();
        return;
    }
    WalletData& smartWallData = getWalletData(smartId, smartSourceAddress);
    smartWallData.balance_ += countedFee;
    WalletData& initWallData = getWalletData(initId, initAddress);
    initWallData.balance_ -= countedFee;

    setModified(smartId);
    setModified(initId);
}

void WalletsCache::ProcessorBase::rollbackReplenishPayableContract(const csdb::Transaction& transaction, const csdb::Amount& execFee) {
    csdb::Address wallAddress = transaction.source();
    if (wallAddress == data_.genesisAddress_ || wallAddress == data_.startAddress_) {
        return;
    }

    WalletId id{};
    if (!findWalletId(wallAddress, id)) {
        cserror() << "Cannot find source wallet, source is " << wallAddress.to_string();
        return;
    }

    WalletData& wallData = getWalletData(id, wallAddress);
    wallData.balance_ += transaction.amount() + csdb::Amount(transaction.max_fee().to_double()) - csdb::Amount(transaction.counted_fee().to_double());

    if (SmartContracts::is_executable(transaction)) {
        data_.closedSmarts_.push_back(transaction);
    }
    else {
        for (auto it = data_.smartPayableTransactions_.begin(); it != data_.smartPayableTransactions_.end(); it++) {
            if (it->source() == transaction.source() && it->innerID() == transaction.innerID()) {
                data_.smartPayableTransactions_.erase(it);
                wallData.balance_ -= execFee;
                break;
            }
        }
    }

    setModified(id);
}

// ProcessorBase
void WalletsCache::ProcessorBase::load(csdb::Pool& pool, const cs::ConfidantsKeys& confidants, const BlockChain& blockchain) {
    csdb::Pool::Transactions& transactions = pool.transactions();
    csdb::Amount totalAmountOfCountedFee = 0;
#ifdef MONITOR_NODE
    auto wrWall = pool.writer_public_key();

    WalletData::Address addr;
    std::copy(wrWall.begin(), wrWall.end(), addr.begin());

    auto it_writer = data_.trusted_info_.find(addr);
    if (it_writer == data_.trusted_info_.end()) {
        auto res = data_.trusted_info_.insert(std::make_pair(addr, TrustedData()));
        it_writer = res.first;
    }
    ++it_writer->second.times;

    WalletData::Address addr_trusted;
    for (const auto& it : confidants) {
        std::copy(it.begin(), it.end(), addr_trusted.begin());
        auto it_trusted = data_.trusted_info_.find(addr_trusted);
        if (it_trusted == data_.trusted_info_.end()) {
            const auto res = data_.trusted_info_.insert(std::make_pair(addr_trusted, TrustedData()));
            it_trusted = res.first;
        }
        ++it_trusted->second.times_trusted;
    }
#endif

    for (auto itTrx = transactions.begin(); itTrx != transactions.end(); ++itTrx) {
        itTrx->set_time(pool.get_time());
        totalAmountOfCountedFee += load(*itTrx, blockchain);
        if (SmartContracts::is_new_state(*itTrx)) {
            fundConfidantsWalletsWithExecFee(*itTrx, blockchain);
        }
    }
#ifdef MONITOR_NODE
    it_writer->second.totalFee += totalAmountOfCountedFee;
#endif

    if (totalAmountOfCountedFee > csdb::Amount(0)) {
        fundConfidantsWalletsWithFee(totalAmountOfCountedFee, confidants, cs::Utils::bitsToMask(pool.numberTrusted(), pool.realTrusted()));
    }

    [[maybe_unused]] auto timeStamp = atoll(pool.user_field(0).value<std::string>().c_str());
#ifdef MONITOR_NODE
    setWalletTime(wrWall, timeStamp);
#endif
}
#ifdef MONITOR_NODE
bool WalletsCache::ProcessorBase::setWalletTime(const WalletData::Address& address, const uint64_t& p_timeStamp) {
    for (auto& it : data_.wallets_) {
        if (it != nullptr && it->address_ == address) {
            it->createTime_ = p_timeStamp;
            return true;
        }
    }
    return false;
}
#endif

void WalletsCache::ProcessorBase::fundConfidantsWalletsWithFee(const csdb::Amount& totalFee, const cs::ConfidantsKeys& confidants, const std::vector<uint8_t>& realTrusted) {
    if (!confidants.size()) {
        cslog() << "WALLETS CACHE>> NO CONFIDANTS";
        return;
    }
    int32_t realTrustedNumber = 0;
    for (const auto& trustedMarker : realTrusted) {
        if (trustedMarker != kUntrustedMarker) {
            ++realTrustedNumber;
        }
    }
    csdb::Amount feeToEachConfidant = totalFee / realTrustedNumber;
    csdb::Amount payedFee = 0;
    int32_t numPayedTrusted = 0;
    for (size_t i = 0; i < confidants.size(); ++i) {
        if (i < realTrusted.size() && realTrusted[i] != kUntrustedMarker) {
            WalletId confidantId{};
            csdb::Address confidantAddress = csdb::Address::from_public_key(confidants[i]);
            if (!findWalletId(confidantAddress, confidantId)) {
                cserror() << "Cannot find confidant wallet, source is " << confidantAddress.to_string();
                return;
            }
            WalletData& walletData = getWalletData(confidantId, confidantAddress);
            walletData.balance_ += feeToEachConfidant;
            payedFee += feeToEachConfidant;
            ++numPayedTrusted;
            if (numPayedTrusted == (realTrustedNumber - 1)) {
                feeToEachConfidant = totalFee - payedFee;
            }
            setModified(confidantId);
        }
    }
}

void WalletsCache::ProcessorBase::fundConfidantsWalletsWithExecFee(const csdb::Transaction& transaction, const BlockChain& blockchain) {
    if (!SmartContracts::is_new_state(transaction)) {
        cswarning() << __func__ << ": transaction is not new state";
        return;
    }
    if (isClosedSmart(transaction)) {
        cserror() << "This transaction must be blocked in consensus";
        return;
    }
    SmartContractRef smartRef(transaction.user_field(trx_uf::new_state::RefStart));
    if (!smartRef.is_valid()) {
        cserror() << __func__ << ": incorrect reference to starter transaction in new state";
        return;
    }
    csdb::Pool pool = blockchain.loadBlock(smartRef.sequence);
    if (!pool.is_valid()) {
        cserror() << __func__ << ": invalid pool";
        return;
    }
    const ConfidantsKeys& confidants = pool.confidants();
    const std::vector<uint8_t> realTrusted = cs::Utils::bitsToMask(pool.numberTrusted(), pool.realTrusted());
    int32_t realTrustedNumber = 0;  // int32_t due to csdb::Amount operator/
    for (const auto& trustedMarker : realTrusted) {
        if (trustedMarker != kUntrustedMarker) {
            ++realTrustedNumber;
        }
    }
    csdb::Amount feeToEachConfidant = transaction.user_field(trx_uf::new_state::Fee).value<csdb::Amount>() / realTrustedNumber;
    csdb::Amount payedFee = 0;
    int32_t numPayedTrusted = 0;
    for (size_t i = 0; i < confidants.size(); ++i) {
        if (i < realTrusted.size() && realTrusted[i] != kUntrustedMarker) {
            WalletId confidantId{};
            csdb::Address confidantAddress = csdb::Address::from_public_key(confidants[i]);
            if (!findWalletId(confidantAddress, confidantId)) {
                cserror() << "Cannot find confidant wallet, source is " << confidantAddress.to_string();
                return;
            }
            WalletData& walletData = getWalletData(confidantId, confidantAddress);
            walletData.balance_ += feeToEachConfidant;
            payedFee += feeToEachConfidant;
            ++numPayedTrusted;
            if (numPayedTrusted == (realTrustedNumber - 1)) {
                feeToEachConfidant = transaction.user_field(trx_uf::new_state::Fee).value<csdb::Amount>() - payedFee;
            }
            setModified(confidantId);
        }
    }
}

double WalletsCache::ProcessorBase::load(const csdb::Transaction& tr, const BlockChain& blockchain) {
    loadTrxForTarget(tr);
    return loadTrxForSource(tr, blockchain);
}

double WalletsCache::ProcessorBase::loadTrxForSource(const csdb::Transaction& tr, const BlockChain& blockchain) {
    csdb::Address wallAddress;

    bool smartIniter = false;
    if (SmartContracts::is_new_state(tr)) {
        wallAddress = findSmartContractIniter(tr, blockchain);
        smartIniter = true;
    }
    else {
        wallAddress = tr.source();
    }

    if (wallAddress == data_.genesisAddress_ || wallAddress == data_.startAddress_)
        return 0;

    WalletId id{};
    if (!findWalletId(wallAddress, id)) {
        cserror() << "Cannot find source wallet, source is " << wallAddress.to_string();
        return 0;
    }
    WalletData& wallData = getWalletData(id, tr.source());

    if (SmartContracts::is_executable(tr)) {
        wallData.balance_ -= csdb::Amount(tr.max_fee().to_double());
        checkClosedSmart(tr);
    }
    else if (SmartContracts::is_new_state(tr)) {
        csdb::Transaction initTransaction = findSmartContractInitTrx(tr, blockchain);
        if (isClosedSmart(initTransaction)) {
            cserror() << "This transaction must be blocked in consensus!";
            wallData.balance_ -= csdb::Amount(initTransaction.max_fee().to_double()) + csdb::Amount(initTransaction.counted_fee().to_double());
        }
        if (SmartContracts::is_executable(initTransaction)) {
            wallData.balance_ += csdb::Amount(initTransaction.max_fee().to_double()) - csdb::Amount(initTransaction.counted_fee().to_double()) -
                                 csdb::Amount(tr.counted_fee().to_double()) - csdb::Amount(tr.user_field(trx_uf::new_state::Fee).value<csdb::Amount>());
        }
        else {
            checkSmartWaitingForMoney(initTransaction, tr);
        }
        //
        WalletId id_s{};
        if (!findWalletId(tr.source(), id_s)) {
            cserror() << "Cannot find source wallet, source is " << wallAddress.to_string();
            return 0;
        }

		WalletData& wallData_s = getWalletData(id_s, tr.source());
		++wallData_s.transNum_;
        wallData_s.trxTail_.push(tr.innerID());

#ifdef MONITOR_NODE              
        wallData_s.lastTransaction_ = tr.id();
#endif
        setModified(id_s);
        //
    }
    else {
        wallData.balance_ -= csdb::Amount(tr.counted_fee().to_double());
    }

    if (!smartIniter) {
        wallData.balance_ -= tr.amount();
		++wallData.transNum_;
        wallData.trxTail_.push(tr.innerID());

#ifdef MONITOR_NODE        
        setWalletTime(wallData.address_, tr.get_time());
#endif

#ifdef TRANSACTIONS_INDEX
        wallData.lastTransaction_ = tr.id();
#endif
    }

    setModified(id);
    return tr.counted_fee().to_double();
}

bool WalletsCache::ProcessorBase::isClosedSmart(const csdb::Transaction& transaction) {
    for (auto& smart : data_.closedSmarts_) {
        if (smart.target() == transaction.target()) {
            return true;
        }
    }
    return false;
}

void WalletsCache::ProcessorBase::checkClosedSmart(const csdb::Transaction& transaction) {
    for (auto it = data_.closedSmarts_.begin(); it != data_.closedSmarts_.end(); ++it) {
        if (it->target() == transaction.target()) {
            data_.closedSmarts_.erase(it);
        }
    }
}

void WalletsCache::ProcessorBase::checkSmartWaitingForMoney(const csdb::Transaction& initTransaction, const csdb::Transaction& newStateTransaction) {
    if (newStateTransaction.user_field(trx_uf::new_state::Value).value<std::string>().empty()) {
        return rollbackReplenishPayableContract(initTransaction, csdb::Amount(newStateTransaction.user_field(trx_uf::new_state::Fee).value<csdb::Amount>()));
    }
    bool waitingSmart = false;
    for (auto it = data_.smartPayableTransactions_.begin(); it != data_.smartPayableTransactions_.end(); it++) {
        if (it->source() == initTransaction.source() && it->innerID() == initTransaction.innerID()) {
            data_.smartPayableTransactions_.erase(it);
            waitingSmart = true;
            break;
        }
    }

    if (waitingSmart) {
        csdb::Address wallAddress = initTransaction.target();
        csdb::Address wallAddressIniter = initTransaction.source();
        if (wallAddress == data_.genesisAddress_ || wallAddress == data_.startAddress_ || wallAddressIniter == data_.genesisAddress_ || wallAddressIniter == data_.startAddress_) {
            return;
        }
        WalletId id{};
        WalletId sourceId{};
        if (!findWalletId(wallAddress, id)) {
            cserror() << "Cannot find target wallet, target is " << wallAddress.to_string();
            return;
        }
        if (!findWalletId(wallAddressIniter, sourceId)) {
            cserror() << "Cannot find source wallet, source is " << wallAddressIniter.to_string();
            return;
        }
        WalletData& wallData = getWalletData(id, wallAddress);
        WalletData& wallDataIniter = getWalletData(sourceId, wallAddressIniter);
        wallDataIniter.balance_ -= csdb::Amount(newStateTransaction.user_field(trx_uf::new_state::Fee).value<csdb::Amount>());
        wallData.balance_ += initTransaction.amount();
        setModified(id);
        setModified(sourceId);
    }
}

csdb::Address WalletsCache::findSmartContractIniter(const csdb::Transaction& tr, const BlockChain& blockchain) {
    csdb::Transaction t = findSmartContractInitTrx(tr, blockchain);
    if (t.is_valid()) {
        return t.source();
    }
    return csdb::Address{};
}

csdb::Transaction WalletsCache::findSmartContractInitTrx(const csdb::Transaction& tr, const BlockChain& blockchain) {
    if (!SmartContracts::is_new_state(tr)) {
        cserror() << "Wallets cache: incorrect new_state transaction to get starter";
        return csdb::Transaction{};
    }
    SmartContractRef smartRef(tr.user_field(trx_uf::new_state::RefStart));
    if (!smartRef.is_valid()) {
        cserror() << "Wallets cache: incorrect reference to starter transaction in new_state";
        return csdb::Transaction{};
    }
    csdb::Pool pool = blockchain.loadBlock(smartRef.sequence);
    if (!pool.is_valid()) {
        cserror() << "Wallets cache: failed load block with starter for new_state";
        return csdb::Transaction{};
    }
    auto& transactions = pool.transactions();
    if (transactions.size() > smartRef.transaction) {
        csdb::Transaction trWithIniter = pool.transactions()[smartRef.transaction];
        if (trWithIniter.id() == smartRef.getTransactionID()) {
            return trWithIniter;
        }
    }
    cserror() << "Wallets cache: incorrect starter transaction for new_state";
    return csdb::Transaction{};
}

void WalletsCache::ProcessorBase::loadTrxForTarget(const csdb::Transaction& tr) {
    csdb::Address wallAddress = tr.target();

    if (wallAddress == data_.genesisAddress_ || wallAddress == data_.startAddress_)
        return;
    WalletId id{};
    if (!findWalletId(wallAddress, id)) {
        cserror() << "Cannot find target wallet, target is " << wallAddress.to_string();
        return;
    }

    WalletData& wallData = getWalletData(id, tr.target());

    wallData.balance_ += tr.amount();
    setModified(id);

    if (tr.source() != tr.target())  // Already counted in loadTrxForSource
        ++wallData.transNum_;

#ifdef MONITOR_NODE
    setWalletTime(wallData.address_, tr.get_time());
#endif

#ifdef TRANSACTIONS_INDEX
    wallData.lastTransaction_ = tr.id();
#endif
}

bool WalletsCache::Initer::findWalletId(const csdb::Address& address, WalletId& id) {
    if (!data_.walletsIds_.special().findAnyOrInsertSpecial(address, id))
        return false;
    return true;
}

bool WalletsCache::Updater::findWalletId(const csdb::Address& address, WalletId& id) {
    if (!data_.walletsIds_.normal().find(address, id))
        return false;
    return true;
}

WalletsCache::WalletData& WalletsCache::ProcessorBase::getWalletData(Data& wallets, WalletId id, const csdb::Address& address) {
    id = WalletsIds::Special::makeNormal(id);

    if (id >= wallets.size())
        wallets.resize(id + 1);

    if (!wallets[id]) {
        wallets[id] = new WalletData{};
        convert(address, wallets[id]->address_);
    }

    return *wallets[id];
}

WalletsCache::WalletData& WalletsCache::Initer::getWalletData(WalletId id, const csdb::Address& address) {
    if (WalletsIds::Special::isSpecial(id))
        return ProcessorBase::getWalletData(walletsSpecial_, id, address);
    else
        return ProcessorBase::getWalletData(data_.wallets_, id, address);
}

WalletsCache::WalletData& WalletsCache::Updater::getWalletData(WalletId id, const csdb::Address& address) {
    return ProcessorBase::getWalletData(data_.wallets_, id, address);
}

void WalletsCache::Initer::setModified(WalletId) {
}

void WalletsCache::Updater::setModified(WalletId id) {
    modified_.resize(data_.wallets_.size());
    if (id >= modified_.size()) {
        cserror() << "id >= modified_.size: id=" << id << " modified_.size=" << modified_.size();
        return;
    }
    modified_.set(id);
}

bool WalletsCache::Initer::moveData(WalletId srcIdSpecial, WalletId destIdNormal) {
    if (!WalletsIds::Special::isSpecial(srcIdSpecial))
        return false;
    srcIdSpecial = WalletsIds::Special::makeNormal(srcIdSpecial);

    if (srcIdSpecial >= walletsSpecial_.size())
        return false;
    if (!walletsSpecial_[srcIdSpecial]) {
        cserror() << "Src wallet data should not be empty";
        return false;
    }

    if (destIdNormal >= data_.wallets_.size())
        data_.wallets_.resize(destIdNormal + 1);
    if (data_.wallets_[destIdNormal]) {
        cserror() << "Dest wallet data should be empty";
        //        return false; // examine it
    }
    data_.wallets_[destIdNormal] = walletsSpecial_[srcIdSpecial];
    walletsSpecial_[srcIdSpecial] = nullptr;
    return true;
}

bool WalletsCache::Initer::isFinishedOk() const {
    for (const auto& ptr : walletsSpecial_) {
        if (ptr) {
            cserror() << "Some new wallet was not added to block";
            return false;
        }
    }
    return true;
}

const WalletsCache::WalletData* WalletsCache::Updater::findWallet(WalletId id) const {
    if (id >= data_.wallets_.size())
        return nullptr;
    return data_.wallets_[id];
}

void WalletsCache::iterateOverWallets(const std::function<bool(const WalletData::Address&, const WalletData&)> func) {
    /*for (const auto& wdp : data_) {
      if (!func(wdp.first, wdp.second))
        break;
    }*/

    for (const auto& wdp : wallets_) {
        if (wdp != nullptr && !func(wdp->address_, *wdp))
            break;
    }
}

#ifdef MONITOR_NODE
void WalletsCache::iterateOverWriters(const std::function<bool(const WalletData::Address&, const TrustedData&)> func) {
    for (const auto& wrd : trusted_info_) {
        if (!func(wrd.first, wrd.second))
            break;
    }
}
#endif

/*void WalletsCache::load(csdb::Pool& curr, Mode mode)
{
  PoolHash poolHash;
  convert(curr.hash(), poolHash);
  //csdebug() << __FUNCTION__ << ": mode=" << mode << " poolHash=" << poolHash << " trxNum=" << curr.transactions_count();

  const uint64_t timeStamp = atoll(curr.user_field(0).value<std::string>().c_str());

  auto* walDataPtr = getWalletData(curr.writer_public_key(), timeStamp);
  WalletsCache::WalletData& walWriter = *walDataPtr;
#ifdef MONITOR_NODE
  auto wrWall = curr.writer_public_key();
  auto wrWrIt = writers_.find(curr.writer_public_key());
  if (wrWrIt == writers_.end()) {
    auto res = writers_.insert(std::make_pair(curr.writer_public_key(), TrustedData()));
    wrWrIt = res.first;
  }

  ++wrWrIt->second.times;
#endif

  for (size_t i = 0; i < curr.transactions_count(); i++)
  {
    csdb::Transaction tr = curr.transaction(i);
#ifdef MONITOR_NODE
    wrWrIt->second.totalFee += tr.counted_fee();
#endif
    load(tr, mode, poolHash, walWriter, timeStamp);
  }
}*/

}  // namespace cs
```
# ..\node\csnode\src\walletsids.cpp 
```cpp 
#include <csnode/walletsids.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>
#include <limits>

using namespace std;

namespace cs {

WalletsIds::WalletsIds()
: nextId_(0) {
    special_.reset(new Special(*this));
    norm_.reset(new Normal(*this));
}

WalletsIds::Normal::Normal(WalletsIds& norm)
: norm_(norm) {
}

bool WalletsIds::Normal::insert(const WalletAddress& address, WalletId id) {
    if (address.is_wallet_id()) {
        if (id != address.wallet_id()) {
            cserror() << "Wrong address";
        }
        return false;
    }
    else if (address.is_public_key()) {
        std::pair<Data::const_iterator, bool> res = norm_.data_.insert(std::make_pair(address, id));
        if (res.second && id >= norm_.nextId_) {
            if (id >= numeric_limits<WalletId>::max() / 2)
                throw runtime_error("idNormal >= numeric_limits<WalletId>::max() / 2");

            norm_.nextId_ = id + 1;
        }
        return res.second;
    }
    cserror() << "Wrong address";
    return false;
}

bool WalletsIds::Normal::find(const WalletAddress& address, WalletId& id) const {
    if (address.is_wallet_id()) {
        id = address.wallet_id();
        return true;
    }
    else if (address.is_public_key()) {
        Data::const_iterator it = norm_.data_.find(address);
        if (it == norm_.data_.end())
            return false;
        id = it->second;
        return true;
    }
    cserror() << "Wrong address";
    return false;
}

bool WalletsIds::Normal::findaddr(const WalletId& id, WalletAddress& address) const {
    bool flgfind = false;
    for (auto& it : norm_.data_) {
        if (it.second == id) {
            flgfind = true;
            address = it.first;
            break;
        }
    }
    if (flgfind)
        return true;

    cserror() << "Wrong WalletId";
    return false;
}

bool WalletsIds::Normal::get(const WalletAddress& address, WalletId& id) {
    if (address.is_wallet_id()) {
        id = address.wallet_id();
        return false;
    }
    else if (address.is_public_key()) {
        std::pair<Data::const_iterator, bool> res = norm_.data_.insert(std::make_pair(address, norm_.nextId_));
        if (res.second) {
            if (norm_.nextId_ >= numeric_limits<WalletId>::max() / 2)
                throw runtime_error("nextId_ >= numeric_limits<WalletId>::max() / 2");
            ++norm_.nextId_;
        }
        id = res.first->second;
        return res.second;
    }
    cserror() << "Wrong address";
    return false;
}

bool WalletsIds::Normal::remove(const WalletAddress& address) {
    if (address.is_wallet_id()) {
        cserror() << __func__ << ": wrong address type";
        return false;
    }
    csdebug() << "Keys before erasing address " << address.to_string();
    for (auto& it : norm_.data_) {
        csdebug() << it.second << " - " << it.first.to_string();
    }
    norm_.data_.erase(address);
    if (norm_.nextId_ > 0) {
        --norm_.nextId_;
    }
    csdebug() << "Keys after erasing";
    for (auto& it : norm_.data_) {
        csdebug() << it.second << " - " << it.first.to_string();
    }
    return true;
}

WalletsIds::WalletId WalletsIds::Special::makeSpecial(WalletId id) {
    return (id | maskSpecial_);
}

WalletsIds::WalletId WalletsIds::Special::makeNormal(WalletId id) {
    return (id & ~maskSpecial_);
}

bool WalletsIds::Special::isSpecial(WalletId id) {
    return (id & maskSpecial_) != 0;
}

WalletsIds::Special::Special(WalletsIds& norm)
: norm_(norm)
, nextIdSpecial_(makeSpecial(0)) {
}

bool WalletsIds::Special::insertNormal(const WalletAddress& address, WalletId idNormal, WalletId& idSpecial) {
    idSpecial = noSpecial_;

    if (address.is_wallet_id()) {
        if (idNormal != address.wallet_id()) {
            cserror() << "Wrong address";
        }
        return false;
    }
    else if (address.is_public_key()) {
        std::pair<Data::iterator, bool> res = norm_.data_.insert(std::make_pair(address, idNormal));

        const bool isInserted = res.second;
        auto& value = res.first->second;

        if (!isInserted) {
            if (!isSpecial(value))
                return false;
            idSpecial = value;
            value = idNormal;
        }

        if (idNormal >= norm_.nextId_) {
            if (idNormal >= numeric_limits<WalletId>::max() / 2)
                throw runtime_error("idNormal >= numeric_limits<WalletId>::max() / 2");

            norm_.nextId_ = idNormal + 1;
        }
        return true;
    }
    cserror() << "Wrong address";
    return false;
}

bool WalletsIds::Special::findAnyOrInsertSpecial(const WalletAddress& address, WalletId& id) {
    if (address.is_wallet_id()) {
        id = address.wallet_id();
        return true;
    }
    else if (address.is_public_key()) {
        std::pair<Data::const_iterator, bool> res = norm_.data_.insert(std::make_pair(address, nextIdSpecial_));
        if (res.second) {
            if (nextIdSpecial_ == numeric_limits<WalletId>::max())
                throw runtime_error("nextIdSpecial_ == numeric_limits<WalletId>::max()");
            ++nextIdSpecial_;
        }
        id = res.first->second;
        return true;
    }
    cserror() << "Wrong address";
    return false;
}

}  // namespace cs
```
# ..\node\csnode\src\walletspools.cpp 
```cpp 
#include <algorithm>

#include <boost/functional/hash.hpp>

#include <csnode/walletsids.hpp>
#include <csnode/walletspools.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>

using namespace std;

namespace std {
template <typename T>
struct hash<vector<T>> {
    using Vec = vector<T>;
    size_t operator()(const Vec& vec) const {
        return boost::hash_range(vec.begin(), vec.end());
    }
};
}  // namespace std

namespace cs {
namespace {

class WalletsPoolsImpl {
public:
    using WalletData = WalletsPools::WalletData;
    using WalletId = WalletsPools::WalletId;
    using PoolHash = WalletsPools::PoolHash;

public:
    WalletsPoolsImpl(csdb::Address genesisAddress, csdb::Address startAddress, const WalletsIds& walletsIds);
    ~WalletsPoolsImpl();

    void addWallet(WalletId id);

    template <Direction Dir>
    void load(csdb::Pool& curr);

    const WalletData* findWallet(WalletId id) const;

private:
    template <Direction Dir>
    void load(csdb::Transaction& tr, const PoolHash& poolHash);

    template <Direction Dir>
    void loadTrxForSource(csdb::Transaction& tr, const PoolHash& poolHash);

    template <Direction Dir>
    void loadTrxForTarget(csdb::Transaction& tr, const PoolHash& poolHash);

    bool findWalletId(const csdb::Address& address, WalletId& id) const;
    WalletData* findWalletData(WalletId id);

    template <Direction Dir>
    void addPoolHash(WalletData& walData, const PoolHash& poolHash);

private:
    const csdb::Address genesisAddress_;
    const csdb::Address startAddress_;
    const WalletsIds& walletsIds_;

    using Data = std::unordered_map<WalletId, WalletData>;
    Data data_;
};

WalletsPoolsImpl::WalletsPoolsImpl(csdb::Address genesisAddress, csdb::Address startAddress, const WalletsIds& walletsIds)
: genesisAddress_(genesisAddress)
, startAddress_(startAddress)
, walletsIds_(walletsIds) {
    /*csdebug() << __FUNCTION__ << ": sizeof(PoolHash)=" << sizeof(PoolHash) << " alignof(PoolHash)=" << alignof(PoolHash);
    csdebug() << __FUNCTION__ << ": sizeof(WalletData::PoolHashData)=" << sizeof(WalletData::PoolHashData) << "
    alignof(WalletData::PoolHashData)=" << alignof(WalletData::PoolHashData); csdebug() << __FUNCTION__ << ":
    sizeof(WalletData::PoolsHashes)=" << sizeof(WalletData::PoolsHashes) << " alignof(WalletData::PoolsHashes)=" <<
    alignof(WalletData::PoolsHashes); csdebug() << __FUNCTION__ << ": sizeof(WalletData)=" << sizeof(WalletData) << "
    alignof(WalletData)=" << alignof(WalletData);*/
}

WalletsPoolsImpl::~WalletsPoolsImpl() {
}

template <Direction Dir>
void WalletsPoolsImpl::load(csdb::Pool& curr) {
    PoolHash poolHash;
    WalletsPools::convert(curr.hash(), poolHash);
    // csdebug() << __FUNCTION__ << ": mode=" << mode << " poolHash=" << poolHash << " trxNum=" <<
    // curr.transactions_count();

    for (size_t i = 0; i < curr.transactions_count(); i++) {
        csdb::Transaction tr = curr.transaction(i);
        load<Dir>(tr, poolHash);
    }
}

template <Direction Dir>
void WalletsPoolsImpl::load(csdb::Transaction& tr, const PoolHash& poolHash) {
    loadTrxForSource<Dir>(tr, poolHash);
    loadTrxForTarget<Dir>(tr, poolHash);
}

template <Direction Dir>
void WalletsPoolsImpl::loadTrxForSource(csdb::Transaction& tr, const PoolHash& poolHash) {
    csdb::Address wallAddress = tr.source();

    if (wallAddress == genesisAddress_ || wallAddress == startAddress_)
        return;
    WalletId id{};
    if (!findWalletId(wallAddress, id)) {
        cserror() << "Cannot find source wallet";
        return;
    }
    auto* walData = findWalletData(id);
    if (!walData)
        return;

    addPoolHash<Dir>(*walData, poolHash);
}

template <Direction Dir>
void WalletsPoolsImpl::loadTrxForTarget(csdb::Transaction& tr, const PoolHash& poolHash) {
    csdb::Address wallAddress = tr.target();

    if (wallAddress == genesisAddress_ || wallAddress == startAddress_)
        return;
    WalletId id{};
    if (!findWalletId(wallAddress, id)) {
        cserror() << "Cannot find target wallet";
        return;
    }
    auto* walData = findWalletData(id);
    if (!walData)
        return;

    addPoolHash<Dir>(*walData, poolHash);
}

bool WalletsPoolsImpl::findWalletId(const csdb::Address& address, WalletId& id) const {
    if (!walletsIds_.normal().find(address, id))
        return false;
    return true;
}

WalletsPoolsImpl::WalletData* WalletsPoolsImpl::findWalletData(WalletId id) {
    auto it = data_.find(id);
    if (it == data_.end())
        return nullptr;
    return &it->second;
}

void WalletsPoolsImpl::addWallet(WalletId id) {
    (void)data_.emplace(id, WalletData());
}

template <>
void WalletsPoolsImpl::addPoolHash<Direction::PrevBlock>(WalletData& walData, const PoolHash& poolHash) {
    bool isHashEqual = (!walData.poolsHashes_.empty() && walData.poolsHashes_.front().poolHash == poolHash);

    if (!isHashEqual && !walData.poolsHashes_.full()) {
        walData.poolsHashes_.push_front(WalletData::PoolHashData{poolHash, 0});
        isHashEqual = true;
    }
    if (isHashEqual && walData.poolsHashes_.front().trxNum < WalletData::PoolHashData::maxTrxNum) {
        ++walData.poolsHashes_.front().trxNum;
    }
}

template <>
void WalletsPoolsImpl::addPoolHash<Direction::NextBlock>(WalletData& walData, const PoolHash& poolHash) {
    bool isHashEqual = (!walData.poolsHashes_.empty() && walData.poolsHashes_.back().poolHash == poolHash);

    if (!isHashEqual) {
        if (walData.poolsHashes_.full())
            walData.poolsHashes_.pop_front();
        walData.poolsHashes_.push_back(WalletData::PoolHashData{poolHash, 0});
        isHashEqual = true;
    }
    if (isHashEqual && walData.poolsHashes_.back().trxNum < WalletData::PoolHashData::maxTrxNum) {
        ++walData.poolsHashes_.back().trxNum;
    }
}

const WalletsPoolsImpl::WalletData* WalletsPoolsImpl::findWallet(WalletId id) const {
    auto itWalData = data_.find(id);
    if (itWalData == data_.end())
        return nullptr;
    return &itWalData->second;
}

}  // namespace

WalletsPools::WalletsPools(csdb::Address genesisAddress, csdb::Address startAddress, const WalletsIds& walletsIds)
: impl_(new WalletsPoolsImpl(genesisAddress, startAddress, walletsIds)) {
}

WalletsPools::~WalletsPools() {
    WalletsPoolsImpl* impl = (WalletsPoolsImpl*)impl_;
    delete impl;
}

void WalletsPools::addWallet(WalletId id) {
    WalletsPoolsImpl* impl = (WalletsPoolsImpl*)impl_;
    impl->addWallet(id);
}

void WalletsPools::loadPrevBlock(csdb::Pool& curr) {
    WalletsPoolsImpl* impl = (WalletsPoolsImpl*)impl_;
    impl->load<Direction::PrevBlock>(curr);
}

void WalletsPools::loadNextBlock(csdb::Pool& curr) {
    WalletsPoolsImpl* impl = (WalletsPoolsImpl*)impl_;
    impl->load<Direction::NextBlock>(curr);
}

const WalletsPools::WalletData* WalletsPools::findWallet(WalletId id) const {
    WalletsPoolsImpl* impl = (WalletsPoolsImpl*)impl_;
    return impl->findWallet(id);
}

void WalletsPools::convert(const csdb::PoolHash& poolHashDb, PoolHash& poolHashCache) {
    const cs::Bytes& phVec = poolHashDb.to_binary();
    copy(phVec.begin(), phVec.end(), poolHashCache.begin());
}

void WalletsPools::convert(const PoolHash& poolHashCache, csdb::PoolHash& poolHashDb) {
    cs::Bytes hashBytes(poolHashCache.begin(), poolHashCache.end());
    poolHashDb = csdb::PoolHash::from_binary(std::move(hashBytes));
}

}  // namespace cs
```
# ..\node\csnode\src\walletsstate.cpp 
```cpp 
#include <csnode/blockchain.hpp>
#include <csnode/walletsstate.hpp>

using namespace std;

namespace cs {

WalletsState::WalletsState(const BlockChain& blockchain, size_t initialWalletsNum /*=*/)
: blockchain_(blockchain)
, wallExisting_(blockchain, initialWalletsNum) {
}

WalletsState::WalletsExisting::WalletsExisting(const BlockChain& blockchain, size_t initialWalletsNum /*=*/)
: blockchain_(blockchain) {
    modified_.resize(initialWalletsNum, true);
    storage_.resize(initialWalletsNum);
    for (auto& el : storage_)
        el = new WalletData{};
}

WalletsState::WalletsExisting::~WalletsExisting() {
    for (auto& el : storage_)
        delete el;
    storage_.clear();
}

void WalletsState::WalletsExisting::updateFromSource() {
    blockchain_.getModifiedWallets(toCopy_);
    modified_.resize(toCopy_.size(), false);
    toCopy_ |= modified_;
    modified_.reset();

    if (storage_.size() < toCopy_.size())
        storage_.resize(toCopy_.size());
}

bool WalletsState::WalletsExisting::updateFromSource(const WalletId& id) {
    if (id >= storage_.size())
        return false;

    BlockChain::WalletData walletData{};
    if (!blockchain_.findWalletData(id, walletData))
        return false;

    if (storage_[id]) {
        storage_[id]->lastTrxInd_ = noInd_;
        storage_[id]->balance_ = walletData.balance_;
        storage_[id]->trxTail_ = walletData.trxTail_;
    }
    else {
        storage_[id] = new WalletData{noInd_, walletData.balance_, walletData.trxTail_};
    }
    toCopy_.reset(id);
    return true;
}

WalletsState::WalletData* WalletsState::WalletsExisting::getData(const WalletId& id) {
    if (id >= toCopy_.size())
        return nullptr;
    if (toCopy_[id] && !updateFromSource(id))
        return nullptr;
    return storage_[id];
}

void WalletsState::WalletsExisting::setModified(const WalletId& id) {
    if (id < modified_.size())
        modified_.set(id);
}

void WalletsState::WalletsNew::clear() {
    storage_.clear();
}

WalletsState::WalletData& WalletsState::WalletsNew::getData(const WalletAddress& address) {
    auto res = storage_.insert(make_pair(address, WalletData{noInd_}));
    return res.first->second;
}

void WalletsState::updateFromSource() {
    wallNew_.clear();
    wallExisting_.updateFromSource();
}

WalletsState::WalletData& WalletsState::getData(const WalletAddress& address, WalletId& id) {
    id = noWalletId_;

    if (blockchain_.findWalletId(address, id)) {
        WalletData* res = wallExisting_.getData(id);
        if (res)
            return *res;
    }
    return wallNew_.getData(address);
}

void WalletsState::setModified(const WalletId& id) {
    wallExisting_.setModified(id);
}
}  // namespace cs
```
# ..\node\lib\include\lib\system\allocators.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef ALLOCATORS_HPP
#define ALLOCATORS_HPP
#include <atomic>
#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <thread>

#include "cache.hpp"
#include "logger.hpp"
#include "utils.hpp"

/* First of all, here is a base unmovable smart pointer to a memory
   region.
   Requirements for the underlying type:
   - MemRegion::Allocator is a typename for the pointer creator
   - MemRegion::get() returns a pointer to the allocated memory (void*)
   - MemRegion::use() / MemRegion::unuse() increments / decrements the
     usage counter (and supposably frees the memory if it gets to zero)
     in a thread-safe sort of way */
template <typename MemRegion>
class MemPtr {
public:
    using PtrType = typename MemRegion::Type*;
    using ConstPtrType = const typename MemRegion::Type*;

    MemPtr() {
    }

    ~MemPtr() {
        if (ptr_) {
            ptr_->unuse();
        }
    }

    MemPtr(const MemPtr& rhs)
    : ptr_(rhs.ptr_) {
        if (ptr_) {
            ptr_->use();
        }
    }

    MemPtr(MemPtr&& rhs) noexcept
    : ptr_(rhs.ptr_) {
        rhs.ptr_ = nullptr;
    }

    MemPtr& operator=(const MemPtr& rhs) {
        if (ptr_ != rhs.ptr_) {
            if (ptr_) {
                ptr_->unuse();
            }

            ptr_ = rhs.ptr_;

            if (ptr_) {
                ptr_->use();
            }
        }

        return *this;
    }

    MemPtr& operator=(MemPtr&& rhs) {
        if (ptr_ != rhs.ptr_) {
            if (ptr_) {
                ptr_->unuse();
            }

            ptr_ = rhs.ptr_;
            rhs.ptr_ = nullptr;
        }
        else if (rhs.ptr_ != nullptr) {
            rhs.ptr_->unuse();
            rhs.ptr_ = nullptr;
        }

        return *this;
    }

    PtrType get() {
        return ptr_->get();
    }

    ConstPtrType get() const {
        return ptr_->get();
    }

    PtrType operator*() {
        return get();
    }

    ConstPtrType operator*() const {
        return get();
    }

    PtrType operator->() {
        return get();
    }

    ConstPtrType operator->() const {
        return get();
    }

    size_t size() const {
        return ptr_->size();
    }

    explicit operator bool() const {
        return ptr_;
    }

    bool isNull() const {
        return !static_cast<bool>(*this);
    }

    bool operator!=(const MemPtr& rhs) const {
        return ptr_ != rhs.ptr_;
    }

private:
    MemPtr(MemRegion* region)
    : ptr_(region) {
        ptr_->use();
    }

    MemRegion* ptr_ = nullptr;

    friend typename MemRegion::Allocator;
    friend class Network;
};

/* Now, RegionAllocator provides a basic allocation strategy, where we
   malloc() several memory pages of predefined size and a page can be
   reused if and only if all of its memory has been unuse()d.
   Thread safety: one allocator, many users */
class RegionAllocator;

struct RegionPage {
    RegionAllocator* allocator;

    __cacheline_aligned std::atomic<RegionPage*> next = {nullptr};
    __cacheline_aligned std::atomic<uint32_t> usedSize = {0};

    uint8_t* regions;

    uint8_t* usedEnd;
    uint32_t sizeLeft;

    ~RegionPage() {
        ::operator delete(regions, std::align_val_t{cache_linesize});
    }
};

class Region {
public:
    using Allocator = RegionAllocator;
    using Type = void;

    void use() {
        users_.fetch_add(1, std::memory_order_acq_rel);
    }

    inline void unuse();

    void* get() {
        return data_;
    }
    const void* get() const {
        return data_;
    }

    uint32_t size() const {
        return size_;
    }

private:
    Region(RegionPage* page, void* data, const uint32_t size)
    : page_(page)
    , data_(data)
    , size_(size) {
    }

    Region(const Region&) = delete;
    Region(Region&&) = delete;
    Region& operator=(const Region&) = delete;
    Region& operator=(Region&&) = delete;

    __cacheline_aligned std::atomic<uint32_t> users_ = {0};
    RegionPage* page_;

    void* data_;
    uint32_t size_;

    friend class RegionAllocator;
    friend class Network;
};

using RegionPtr = MemPtr<Region>;

/* ActivePage points to a page with some free memory.
   - If its free memory isn't enough to complete an alloc request,
     ActivePage->nextPage becomes the next ActivePage;
   - If there is no ActivePage->nextPage, we allocate another page.
   - Whenever memory is freed on a page, if it is now empty, it
     becomes the ActivePage->nextPage */
class RegionAllocator {
public:
    const uint32_t PageSize;

    RegionAllocator(const uint32_t _pageSize, const uint32_t _initPages = 10)
    : PageSize(_pageSize) {
        activePage_ = allocatePage();
        auto lastPage = activePage_;

        for (uint32_t i = 1; i < _initPages; ++i) {
            lastPage->next.store(allocatePage());
            lastPage = lastPage->next;
        }

        lastPage->next.store(nullptr);
    }

    RegionAllocator(const RegionAllocator&) = delete;
    RegionAllocator(RegionAllocator&&) = delete;
    RegionAllocator& operator=(const RegionAllocator&) = delete;
    RegionAllocator& operator=(RegionAllocator&&) = delete;

    /* Assumptions:
     - allocateNext and shrinkLast are only called from the thread
       that constructed the object
     - shrinkLast is called before the last allocation gets unuse()d */
    RegionPtr allocateNext(const uint32_t size) {
        uint32_t regSize = size + sizeof(Region);
        regSize += (-(int)regSize) & 0x3f;

        if (!activePage_->usedSize.load(std::memory_order_acquire)) {
            activePage_->sizeLeft = PageSize;
            activePage_->usedEnd = activePage_->regions;
        }

        if (activePage_->sizeLeft < regSize) {
            if (!activePage_->next.load(std::memory_order_acquire)) {
                auto newPage = allocatePage();
                insertAfterActive(newPage);
            }

            activePage_ = activePage_->next.load(std::memory_order_acquire);
            activePage_->sizeLeft = PageSize;
            activePage_->usedEnd = activePage_->regions;
        }

        // So there is enough left
        lastReg_ = new (activePage_->usedEnd) Region(activePage_, activePage_->usedEnd + sizeof(Region), size);
        activePage_->usedEnd += regSize;
        activePage_->sizeLeft -= regSize;

        activePage_->usedSize.fetch_add(regSize, std::memory_order_acq_rel);

        return RegionPtr(lastReg_);
    }

    void shrinkLast(const uint32_t size) {
        assert(lastReg_->size_ >= size);
        int32_t prevSize = lastReg_->size_ + sizeof(Region);
        prevSize += (-prevSize) & 0x3f;
        int32_t newSize = size + sizeof(Region);
        newSize += (-newSize) & 0x3f;
        int32_t diff = prevSize - newSize;

        lastReg_->size_ = size;
        lastReg_->page_->sizeLeft += diff;
        lastReg_->page_->usedEnd -= diff;

        activePage_->usedSize.fetch_sub(diff, std::memory_order_acq_rel);
    }

#ifdef TESTING
    uint32_t getPagesNum() const {
        return pagesNum_;
    }
#endif

private:
    // Can be called from any thread using the allocated memory
    void freeMem(Region* region) {
        auto page = region->page_;
        region->~Region();

        uint32_t toSub = region->size_ + sizeof(Region);
        toSub += (-(int)toSub) & 0x3f;

        if (page->usedSize.fetch_sub(toSub, std::memory_order_acq_rel) == toSub) {
            // Since it was us who freed up all the memory, we're the only
            // ones accessing *page...
            if (activePage_ == page) {
                return;
            }

            // ... as long as it's not active, of course
            insertAfterActive(page);
        }
    }

    RegionPage* allocatePage() {
        RegionPage* result = new RegionPage();

        result->allocator = this;
        result->regions = static_cast<uint8_t *>(::operator new(PageSize, std::align_val_t{cache_linesize}));

#ifdef TESTING
        ++pagesNum_;
#endif

        return result;
    }

    void insertAfterActive(RegionPage* page) {
        auto actNext = activePage_->next.load(std::memory_order_acquire);
        do {
            page->next.store(actNext, std::memory_order_relaxed);
        } while (!activePage_->next.compare_exchange_strong(actNext, page, std::memory_order_acquire, std::memory_order_relaxed));
    }

    RegionPage* activePage_;
    Region* lastReg_;

#ifdef TESTING
    uint32_t pagesNum_ = 0;
#endif

    friend class Region;
};

inline void Region::unuse() {
    if (users_.fetch_sub(1, std::memory_order_acq_rel) == 1) {
        page_->allocator->freeMem(this);
    }
}

/* Not, TypedAllocator is a completely different thing. It allocates
   big chunks of data, uses it for objects of fixed size and keeps
   track of freed objects for reuse. */
template <typename T>
class TypedAllocator;

template <typename T>
class TypedSlot {
public:
    using Allocator = TypedAllocator<T>;
    using Type = T;

    template <typename... Args>
    TypedSlot(Allocator* allocator, Args&&... args)
    : allocator_(allocator)
    , element_(std::forward<Args>(args)...) {
    }

    void use() {
        users_.fetch_add(1, std::memory_order_acq_rel);
    }

    inline void unuse();

    T* get() {
        return &element_;
    }
    const T* get() const {
        return &element_;
    }

    uint32_t size() const {
        return sizeof(T);
    }

private:
    std::atomic<uint32_t> users_ = {0};
    Allocator* allocator_;
    T element_;

    friend Allocator;
};

template <typename T>
class TypedAllocator {
public:
    const uint32_t PageSize;
    using PtrType = MemPtr<TypedSlot<T>>;
    using IntType = TypedSlot<T>;

    TypedAllocator(const uint32_t _pageSize)
    : PageSize(_pageSize) {
        allocateNextPage();
    }

    template <typename... Args>
    PtrType emplace(Args&&... args) {
        IntType** place = freeChunksLast_.load(std::memory_order_acquire);
        do {
            if (!place) {
                cs::Lock l(allocFlag_);

                place = freeChunksLast_.load(std::memory_order_relaxed);
                if (place)
                    continue;

                place = allocateNextPage();
            }
        } while (!freeChunksLast_.compare_exchange_strong(place, (place == freeChunks_ ? nullptr : (place - 1)), std::memory_order_release, std::memory_order_relaxed));
        return new (*place) IntType(this, std::forward<Args>(args)...);
    }

    void remove(IntType* toFree) {
        toFree->~IntType();
        {
            cs::Lock l(freeFlag_);
            IntType** place = freeChunksLast_.load(std::memory_order_acquire);
            IntType** nextPlace;

            do {
                nextPlace = place ? place + 1 : freeChunks_;
                *nextPlace = toFree;
            } while (!freeChunksLast_.compare_exchange_strong(place, nextPlace, std::memory_order_release, std::memory_order_relaxed));
        }
    }

private:
    // Assumption: the flag is captured and freeChunksLast = nullptr
    IntType** allocateNextPage() {
        ++pages_;

        IntType* page = reinterpret_cast<IntType*>(new uint8_t[sizeof(IntType) * PageSize]);

        delete[] freeChunks_;
        freeChunks_ = reinterpret_cast<IntType**>(new uint8_t[sizeof(IntType*) * PageSize * pages_]);

        IntType** chunkPtr = static_cast<IntType**>(freeChunks_) + PageSize;
        IntType* pageEnd = static_cast<IntType*>(page) + PageSize;

        for (IntType* ptr = page; ptr != pageEnd; ++ptr) {
            *(--chunkPtr) = ptr;
        }

        auto newChunks = static_cast<IntType**>(freeChunks_) + PageSize - 1;
        freeChunksLast_.store(newChunks, std::memory_order_release);

        return newChunks;
    }

    uint32_t pages_ = 0;
    cs::SpinLock allocFlag_{ATOMIC_FLAG_INIT};

    IntType** freeChunks_ = nullptr;
    std::atomic<IntType**> freeChunksLast_ = {nullptr};
    cs::SpinLock freeFlag_{ATOMIC_FLAG_INIT};
};

template <typename T>
inline void TypedSlot<T>::unuse() {
    if (users_.fetch_sub(1, std::memory_order_acq_rel) == 1) {
        allocator_->remove(this);
    }
}

#endif  // ALLOCATORS_HPP
```
# ..\node\lib\include\lib\system\cache.hpp 
```cpp 
#ifndef CACHE_HPP
#define CACHE_HPP

constexpr unsigned cache_linesize = 64;

#ifdef _MSC_VER
#define __cacheline_aligned
#else
#define __cacheline_aligned alignas(cache_linesize)
#endif

#endif  // CACHE_H
```
# ..\node\lib\include\lib\system\common.hpp 
```cpp 
#ifndef COMMON_HPP
#define COMMON_HPP

#include <mutex>
#include <shared_mutex>
#include <string>

#include <boost/smart_ptr/detail/spinlock.hpp>

#include <cscrypto/cscrypto.hpp>

constexpr std::size_t kHashLength = cscrypto::kHashSize;
constexpr std::size_t kPublicKeyLength = cscrypto::kPublicKeySize;
constexpr std::size_t kPrivateKeyLength = cscrypto::kPrivateKeySize;
constexpr std::size_t kSignatureLength = cscrypto::kSignatureSize;

constexpr double kMinFee = 0.0001428 * 3.0;

namespace cs {
// key node type
using RoundNumber = uint64_t;
using Sequence = RoundNumber;

using Byte = cscrypto::Byte;

// dynamic vector of bytes
using Bytes = cscrypto::Bytes;
using BytesView = cscrypto::BytesView;

// static byte array
template <std::size_t size>
using ByteArray = cscrypto::ByteArray<size>;

// common data structures
using PublicKey = cscrypto::PublicKey;
using Signature = cscrypto::Signature;
using Hash = cscrypto::Hash;
using PrivateKey = cscrypto::PrivateKey;

using ConfidantSignature = std::pair<Byte, Signature>;
using BlockSignatures = std::vector<ConfidantSignature>;

// sync types
using SharedMutex = std::shared_mutex;
using SpinLock = boost::detail::spinlock;

// RAII locks
template <typename T>
class Lock : public std::lock_guard<T> {
public:
    explicit inline Lock(T& lockable) noexcept
    : std::lock_guard<T>(lockable) {
    }
};

template <typename T>
class SharedLock : public std::shared_lock<T> {
public:
    explicit inline SharedLock(T& lockable) noexcept
    : std::shared_lock<T>(lockable) {
    }
};

// aliasing, C++ 17 scoped lock, C++ 17 constructor template parameters deduction
template <typename... T>
class ScopedLock {
public:
    explicit inline ScopedLock(T&... locables) noexcept
    : lock_(locables...) {
    }

private:
    std::scoped_lock<T...> lock_;
};
}  // namespace cs
#endif  // COMMON_HPP
```
# ..\node\lib\include\lib\system\concurrent.hpp 
```cpp 
#ifndef CONCURRENT_HPP
#define CONCURRENT_HPP

#include <assert.h>
#include <condition_variable>
#include <functional>
#include <future>
#include <list>
#include <memory>
#include <thread>
#include <type_traits>
#include <unordered_map>

#include <lib/system/cache.hpp>
#include <lib/system/common.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/signals.hpp>

#include <boost/asio/post.hpp>
#include <boost/asio/thread_pool.hpp>

namespace cs {
enum class RunPolicy : cs::Byte {
    CallQueuePolicy,
    ThreadPolicy
};

enum class WatcherState : cs::Byte {
    Idle,
    Running,
    Compeleted
};

// aliasing
using Threads = boost::asio::thread_pool;

// returns instance of boost thread pool
class ThreadPool {
public:
    ThreadPool() = delete;
    ~ThreadPool() = default;

    static Threads& instance() noexcept {
        static Threads threadPool(std::thread::hardware_concurrency());
        return threadPool;
    }
};

template <typename T>
class FutureWatcher;
class Concurrent;

// concurrent private helper
class Worker {
private:
    template <typename Func>
    static void execute(cs::RunPolicy policy, Func&& function) {
        if (policy == cs::RunPolicy::CallQueuePolicy) {
            CallsQueue::instance().insert(std::forward<Func>(function));
        }
        else {
            function();
        }
    }

    template <typename Func>
    static void execute(Func&& function) {
        auto& threadPool = ThreadPool::instance();
        boost::asio::post(threadPool, std::forward<Func>(function));
    }

    template <typename Func>
    static void run(Func&& function) {
        std::thread thread(std::forward<Func>(function));
        thread.detach();
    }

    template <typename T>
    friend class FutureBase;

    template <typename T>
    friend class FutureWatcher;
    friend class Concurrent;
};

// future entity
template <typename T>
using Future = std::future<T>;

template <typename Result>
class FutureBase {
    friend class Concurrent;

public:
    using Id = uint64_t;

protected:
    FutureBase() {
        ++producedId;

        id_ = producedId;
        state_ = WatcherState::Idle;
        policy_ = RunPolicy::ThreadPolicy;
    }

    FutureBase(FutureBase&) = delete;
    ~FutureBase() = default;

    explicit FutureBase(const RunPolicy policy, Future<Result>&& future)
    : FutureBase() {
        future_ = std::move(future);
        policy_ = policy;
    }

    FutureBase(FutureBase&& watcher) noexcept
    : future_(std::move(watcher.future_))
    , policy_(watcher.policy_)
    , state_(watcher.state_)
    , id_(watcher.id_) {
    }

    FutureBase& operator=(FutureBase&& watcher) noexcept {
        if (state_ == WatcherState::Running) {
            cserror() << csname() << "Trying to use operator= in watcher running state";
        }

        future_ = std::move(watcher.future_);
        policy_ = watcher.policy_;
        id_ = watcher.id_;

        return *this;
    }

public:
    // returns current watcher state, if watcher never watched runnable entity
    // then his state is Idle
    WatcherState state() const noexcept {
        return state_;
    }

    Id id() const noexcept {
        return id_;
    }

protected:
    using CompletedSignal = cs::Signal<void(Id)>;

    Future<Result> future_;
    RunPolicy policy_;
    WatcherState state_ = WatcherState::Idle;
    Id id_;

    inline static Id producedId = 0;
    constexpr static std::chrono::milliseconds kAwaiterTime{10};

    void setCompletedState() {
        future_ = Future<Result>();
        state_ = WatcherState::Compeleted;

        emit completed(id_);
    }

    template <typename Func>
    void callSignal(Func&& func) {
        Worker::execute(policy_, std::forward<Func>(func));
    }

    template <typename Awaiter>
    void await(const Awaiter& awaiter) {
        if (cs::Connector::callbacks(&awaiter) != 0) {
            return;
        }

        std::this_thread::sleep_for(kAwaiterTime);
    }

protected signals:

    // internal utility signal, clients should used finished/failed signlas from FutureWatcher
    CompletedSignal completed;
};

// object to get future result from concurrent
// and generate signal when finished
template <typename Result>
class FutureWatcher : public FutureBase<Result> {
public:
    using FinishSignal = cs::Signal<void(const Result&)>;
    using FailedSignal = cs::Signal<void()>;

    explicit FutureWatcher(RunPolicy policy, Future<Result>&& future)
    : FutureBase<Result>(policy, std::move(future)) {
        watch();
    }

    FutureWatcher() = default;
    ~FutureWatcher() = default;
    FutureWatcher(FutureWatcher&&) = default;

    FutureWatcher& operator=(FutureWatcher&& watcher) {
        FutureBase<Result>::operator=(std::move(watcher));

        watch();
        return *this;
    }

protected:
    using Super = FutureBase<Result>;

    void watch() {
        auto closure = [=] {
            try {
                Result result = Super::future_.get();

                auto lambda = [this, res = std::move(result)]() {
                    Super::await(finished);
                    emit finished(std::move(res));

                    Super::setCompletedState();
                };

                Super::callSignal(std::bind(std::move(lambda)));
            }
            catch (std::exception& e) {
                Super::await(failed);

                cserror() << "Concurrent execution with " << typeid(Result).name() << " failed, " << e.what();
                emit failed();
            }
        };

        Super::state_ = WatcherState::Running;
        Worker::execute(std::move(closure));
    }

public signals:
    FinishSignal finished;
    FailedSignal failed;
};

template <>
class FutureWatcher<void> : public FutureBase<void> {
public:
    using FinishSignal = cs::Signal<void()>;
    using FailedSignal = cs::Signal<void()>;

    explicit FutureWatcher(RunPolicy policy, Future<void>&& future)
    : FutureBase<void>(policy, std::move(future)) {
        watch();
    }

    FutureWatcher() = default;
    ~FutureWatcher() = default;
    FutureWatcher(FutureWatcher&& watcher) = default;

    FutureWatcher& operator=(FutureWatcher&& watcher) noexcept {
        FutureBase<void>::operator=(std::move(watcher));

        watch();
        return *this;
    }

protected:
    using Super = FutureBase<void>;

    void watch() {
        auto closure = [=] {
            try {
                Super::future_.get();

                auto signal = [=] {
                    Super::await(finished);
                    emit finished();

                    Super::setCompletedState();
                };

                Super::callSignal(std::move(signal));
            }
            catch (std::exception& e) {
                Super::await(failed);

                cserror() << "Concurrent execution with void result failed, " << e.what();
                emit failed();
            }
        };

        Super::state_ = WatcherState::Running;
        Worker::execute(std::move(closure));
    }

public signals:
    FinishSignal finished;
    FailedSignal failed;
};

// safe pointer to watcher
template <typename T>
using FutureWatcherPtr = std::shared_ptr<FutureWatcher<T>>;

class Concurrent {
    template<typename T>
    using Executions = std::list<T>;

public:
    // runs function in another thread, returns future watcher
    // than generates finished signal by run policy
    // you should not store watcher, it does by run method, just use finished/failed signal to subscribe
    template <typename Func, typename... Args>
    static FutureWatcherPtr<std::invoke_result_t<std::decay_t<Func>, std::decay_t<Args>...>> run(RunPolicy policy, Func&& function, Args&&... args) {
        using ReturnType = std::invoke_result_t<std::decay_t<Func>, std::decay_t<Args>...>;
        using WatcherType = FutureWatcher<ReturnType>;

        // running executions
        static Executions<FutureWatcherPtr<ReturnType>> executions;
        using ExecutionsIterator = typename decltype(executions)::iterator;

        // run async and store it at executions
        auto watcher = std::make_shared<WatcherType>(policy, std::async(std::launch::async, std::forward<Func>(function), std::forward<Args>(args)...));

        {
            cs::Lock lock(executionsMutex_);
            executions.push_back(watcher);
        }

        // watcher will be removed after lambda called
        cs::Connector::connect(&watcher->completed, [](typename FutureWatcher<ReturnType>::Id id) {
            ExecutionsIterator iter;

            {
                cs::Lock lock(executionsMutex_);
                iter = std::find_if(executions.begin(), executions.end(), [=](const auto& watcher) {
                    return (watcher->id() == id) && (watcher->state() == WatcherState::Compeleted);
                });
            }

            if (iter != executions.end()) {
                cs::Concurrent::run([=]() {
                    cs::Lock lock(executionsMutex_);
                    executions.erase(iter);
                });
            }
        });

        return watcher;
    }

    // runs function entity in thread pool
    template <typename Func>
    static void run(Func&& function) {
        Worker::execute(std::forward<Func>(function));
    }

    // runs non-binded function in thread pool
    template <typename Func, typename... Args>
    static void run(Func&& func, Args&&... args) {
        Concurrent::run(std::bind(std::forward<Func>(func), std::forward<Args>(args)...));
    }

    // calls std::function after ms time in another thread
    static void runAfter(const std::chrono::milliseconds& ms, cs::RunPolicy policy, std::function<void()> callBack) {
        auto timePoint = std::chrono::steady_clock::now() + ms;
        Worker::run(std::bind(&Concurrent::runAfterHelper, timePoint, policy, std::move(callBack)));
    }

    template <typename Func>
    static void execute(cs::RunPolicy policy, Func&& function) {
        Worker::execute(policy, std::forward<Func>(function));
    }

private:
    static void runAfterHelper(const std::chrono::steady_clock::time_point& timePoint, cs::RunPolicy policy, std::function<void()> callBack) {
        std::this_thread::sleep_until(timePoint);
        Worker::execute(policy, std::move(callBack));
    }

    inline static std::mutex executionsMutex_;
};

template <typename T>
inline bool operator<(const FutureWatcher<T>& lhs, const FutureWatcher<T>& rhs) {
    return lhs.id() < rhs.id();
}

template <typename T>
inline bool operator==(const FutureWatcher<T>& watcher, uint64_t value) {
    return watcher.id() == value;
}

// for api threading
template <typename S>
struct WorkerQueue {
private:
    using tids_t = std::list<std::tuple<>>;
    tids_t tids_;
    std::unordered_map<std::thread::id, typename tids_t::iterator> tidMap_;

    std::condition_variable_any conditionalVariable_;
    cs::SpinLock lock_{ATOMIC_FLAG_INIT};
    S state_;

	const unsigned int WAIT_SECONDS_TIME{ 30 };

public:
    inline WorkerQueue() noexcept
    : lock_() {
    }

    S getState() const {
        return state_;
    }

    void getPosition() {
        cs::Lock lock(lock_);
        auto tid = std::this_thread::get_id();
        tidMap_[tid] = tids_.insert(tids_.end(), std::make_tuple());
    }

    template <typename T>
    bool waitTillFront(const T& t) {
        std::unique_lock lock(lock_);
        auto res = conditionalVariable_.wait_for(lock, std::chrono::seconds(WAIT_SECONDS_TIME), [&]() { return t(state_); });
        tidMap_.erase(std::this_thread::get_id());
        conditionalVariable_.notify_all();
		return res;
    }

    void yield() {
        std::unique_lock lock(lock_);

        auto tid = std::this_thread::get_id();
        auto tit = tidMap_.find(tid);

        if (tit == tidMap_.end()) {
            return;
        }

        bool needNotifyAll = tit->second == tids_.begin();
        tids_.erase(tit->second);

        tidMap_.erase(tit);

        if (needNotifyAll) {
            conditionalVariable_.notify_all();
        }
    }

    template <typename State>
    void updateState(const State& state) {
        cs::Lock lock(lock_);
        state_ = state(state_);
        conditionalVariable_.notify_all();
    }
};

// what is sweet spot?
struct SweetSpot {
private:
    std::condition_variable_any conditionalVariable_;
    cs::SpinLock lock_{ATOMIC_FLAG_INIT};
    bool occupied_ = false;

public:
    inline SweetSpot() noexcept
    : lock_() {
    }

    void occupy() {
        std::unique_lock lock(lock_);

        conditionalVariable_.wait(lock, [this]() {
            auto res = !occupied_;
            occupied_ = true;
            return res;
        });
    }

    void leave() {
        cs::Lock lock(lock_);
        occupied_ = false;
        conditionalVariable_.notify_one();
    }
};

template <typename T>
struct SpinLockedRef;

template <typename T>
struct SpinLockable {
    using LockedType = T;

    template <typename... Args>
    SpinLockable(Args&&... args)
    : t(std::forward<Args>(args)...) {
    }

private:
    __cacheline_aligned std::atomic_flag af = ATOMIC_FLAG_INIT;
    T t;

    friend struct SpinLockedRef<T>;
};

template <typename T>
struct SpinLockedRef {
private:
    SpinLockable<T>* lockable_;

public:
    SpinLockedRef(SpinLockable<T>& lockable)
    : lockable_(&lockable) {
        while (this->lockable_->af.test_and_set(std::memory_order_acquire));
    }

    ~SpinLockedRef() {
        if (lockable_) {
            lockable_->af.clear(std::memory_order_release);
        }
    }

    SpinLockedRef(const SpinLockedRef&) = delete;
    SpinLockedRef(SpinLockedRef&& other)
    : lockable_(other.lockable_) {
        other.lockable_ = nullptr;
    }

    explicit operator T*() {
        return &(lockable_->t);
    }

    T* operator->() {
        return static_cast<T*>(*this);
    }

    T& operator*() {
        return lockable_->t;
    }
};

template <typename T>
SpinLockedRef<T> lockedReference(SpinLockable<T>& lockable) {
    return SpinLockedRef<T>(lockable);
}
}  // namespace cs
#endif  //  CONCURRENT_HPP
```
# ..\node\lib\include\lib\system\hash.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef HASH_HPP
#define HASH_HPP

#include <lib/system/common.hpp>
#include "utils.hpp"

inline cs::Hash generateHash(const void* data, size_t length) {
    return cscrypto::calculateHash(reinterpret_cast<const uint8_t*>(data), length);
}

template <>
inline uint16_t getHashIndex(const cs::Hash& hash) {
    constexpr const size_t border = kHashLength / 2;

    uint16_t result = 0;
    auto byte = reinterpret_cast<uint8_t*>(&result);

    for (size_t i = 0; i < border; ++i) {
        *byte ^= hash[i];
    }

    ++byte;

    for (size_t i = border; i < kHashLength; ++i) {
        *byte ^= hash[i];
    }

    return result;
}

#endif  // HASH_HPP
```
# ..\node\lib\include\lib\system\logger.hpp 
```cpp 
#ifndef LOGGER_HPP
#define LOGGER_HPP

#include <boost/log/expressions/keyword.hpp>  // include prior trivial.hpp for "Severity" attribute support in config Filter=
#include <boost/log/sources/global_logger_storage.hpp>
#include <boost/log/sources/severity_channel_logger.hpp>
#include <boost/log/trivial.hpp>
#include <boost/log/utility/manipulators/dump.hpp>
#include <boost/log/utility/setup/settings.hpp>

#include <sstream>

/*
 * \brief Just a syntax shugar over Boost::Log v2.
 * So you can use all the power of boost \link https://www.boost.org/doc/libs/1_67_0/libs/log/doc/html/index.html
 *
 * Logging can be configured easily with configuration file.
 * \link
 * https://www.boost.org/doc/libs/1_67_0/libs/log/doc/html/log/detailed/utilities.html#log.detailed.utilities.setup.settings_file
 *
 * Severity levels: trace < debug < info < warning < error < fatal
 *
 * Supported configuration formats: ini, json, xml
 *
 * Configuration ini example:
 * [Core]
 * Filter="%Severity% >= info"
 */

namespace logging = boost::log;

namespace logger {
using severity_level = logging::trivial::severity_level;

void initialize(const logging::settings& settings);
void cleanup();

template <typename T = logging::trivial::logger>
inline auto& getLogger() {
    return T::get();
}

// <None> logger is used to eliminate logger code from build
BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT(None, logging::trivial::logger::logger_type)

template <typename T = logging::trivial::logger>
constexpr bool useLogger() {
    return true;
}
template <>
constexpr bool useLogger<None>() {
    return false;
}

// Logger with channel "file", to support legacy csfile()
BOOST_LOG_INLINE_GLOBAL_LOGGER_CTOR_ARGS(File, logging::sources::severity_channel_logger_mt<severity_level>, (logging::keywords::channel = "file"))
}  // namespace logger

#define _LOG_SEV(level, ...)               \
    if (!logger::useLogger<__VA_ARGS__>()) \
        ;                                  \
    else                                   \
        BOOST_LOG_SEV(logger::getLogger<__VA_ARGS__>(), logger::severity_level::level)

#define cstrace(...)                       \
    if (!logger::useLogger<__VA_ARGS__>()) \
        ;                                  \
    else                                   \
        BOOST_LOG_SEV(logger::getLogger<__VA_ARGS__>(), logger::severity_level::trace) << __FILE__ << ":" << __func__ << ":" << __LINE__ << " "

// set Filter="%Severity% >= trace" in config to view this level messages:
#define csdetails(...) _LOG_SEV(trace, __VA_ARGS__)

#define csdebug(...) _LOG_SEV(debug, __VA_ARGS__)

#define csinfo(...) _LOG_SEV(info, __VA_ARGS__)

#define cswarning(...) _LOG_SEV(warning, __VA_ARGS__)

#define cserror(...) _LOG_SEV(error, __VA_ARGS__)

#define csfatal(...) _LOG_SEV(fatal, __VA_ARGS__)

// alias
#define cslog(...) csinfo(__VA_ARGS__)

template <typename N>
class WithDelimiters
{
public:

    WithDelimiters(N value) {
        val_ = value;
    }

    std::string to_string() {
        std::ostringstream os;
        // the locale is responsible for calling the matching delete from its own destructor for facet arg
        os.imbue(std::locale(std::locale::classic(), new WithDelimiters::NumFormatter()));
        os << val_;
        return os.str();
    }

private:
    N val_;

    class NumFormatter : public std::numpunct<char>
    {
    protected:
        virtual char do_thousands_sep() const { return '\''; }
        virtual std::string do_grouping() const { return "\03"; }
    };

};

template <typename N>
std::ostream& operator<<(std::ostream& os, WithDelimiters<N> value) {
    os << value.to_string();
    return os;
}


#endif  // LOGGER_HPP
```
# ..\node\lib\include\lib\system\metastorage.hpp 
```cpp 
#ifndef METASTORAGE_HPP
#define METASTORAGE_HPP

#include <boost/circular_buffer.hpp>
#include <lib/system/common.hpp>
#include <optional>

/// nested namespace
namespace cs::values {
constexpr std::size_t kDefaultMetaStorageMaxSize = 100; // equals to Consensus::MaxRoundsCancelContract to strongly prevent duplicated new_state transactions
}

namespace cs {
///
/// @brief Class for storage meta information with
/// common interface and dependency of round number.
///
template <typename T>
class MetaStorage {
public:
    ///
    /// @brief Represents meta element with storage
    /// of round and generated (instantiated) meta class.
    ///
    struct MetaElement {
        cs::RoundNumber round = 0;
        T meta;

        MetaElement() = default;
        MetaElement(cs::RoundNumber number, T&& value) noexcept
        : round(number)
        , meta(std::move(value)) {
        }

        MetaElement(cs::RoundNumber number, const T& value) noexcept
        : round(number)
        , meta(value) {
        }

        bool operator==(const MetaElement& element) const {
            return round == element.round;
        }

        bool operator!=(const MetaElement& element) const {
            return !((*this) == element);
        }
    };

    /// element type
    using Element = MetaStorage<T>::MetaElement;

    // default initialization
    inline MetaStorage() noexcept
    : buffer_(cs::values::kDefaultMetaStorageMaxSize) {
    }

    // storage interface

    ///
    /// @brief Resizes circular storage buffer.
    ///
    void resize(std::size_t size) {
        buffer_.resize(size);
    }

    ///
    /// @brief Returns current circular buffer size
    ///
    std::size_t size() const {
        return buffer_.size();
    }

    ///
    /// @brief Appends meta element to buffer.
    /// @param element Created from outside rvalue.
    /// @return Returns true if append is success, otherwise returns false.
    ///
    bool append(MetaElement&& value) {
        const auto iterator = std::find(buffer_.begin(), buffer_.end(), value);
        const auto result = (iterator == buffer_.end());

        if (result) {
            buffer_.push_back(std::move(value));
        }

        return result;
    }

    ///
    /// @brief Appends meta element to buffer.
    /// @return Returns true if append is success, otherwise returns false.
    ///
    bool append(const MetaElement& value) {
        MetaElement element = {value.round, value.meta};

        return append(std::move(element));
    }

    ///
    /// @brief Appends value with round key.
    /// @param round Current round to add as a key.
    /// @param value Movable value created from outside.
    /// @return Returns true if append is success, otherwise returns false.
    ///
    bool append(RoundNumber round, T&& value) {
        MetaElement element = {round, std::move(value)};

        return append(std::move(element));
    }

    ///
    /// @brief Returns contains meta storage this round or not.
    ///
    bool contains(RoundNumber round) {
        const auto iterator = std::find_if(buffer_.begin(), buffer_.end(), [=](const MetaElement& value) {
            return value.round == round;
        });

        return iterator != buffer_.end();
    }

    ///
    /// @brief Returns copy of meta element if this round exists at storage, otherwise returns nothing.
    /// @param round Round number to get element from storage.
    /// @return Returns optional parameter with T type.
    ///
    std::optional<T> value(RoundNumber round) const {
        const auto iterator = std::find_if(buffer_.begin(), buffer_.end(), [=](const MetaElement& value) {
            return value.round == round;
        });

        if (iterator != buffer_.end()) {
            return std::make_optional<T>(iterator->meta);
        }

        return std::nullopt;
    }

    ///
    /// @brief Returns and removes meta element if it's exists at round parameter.
    /// @param round Round number to get element from storage.
    /// @return Returns meta element of storage if found, otherwise returns nothing.
    ///.
    std::optional<T> extract(RoundNumber round) {
        const auto iterator = std::find_if(buffer_.begin(), buffer_.end(), [=](const MetaElement& value) {
            return value.round == round;
        });

        if (iterator == buffer_.end()) {
            return std::nullopt;
        }

        MetaElement result = std::move(*iterator);
        buffer_.erase(iterator);

        return std::make_optional<T>(std::move(result.meta));
    }

    ///
    /// @brief Returns pointer to existing element, otherwise returns nullptr.
    /// @param round Round of searching element.
    /// @return Reference to element.
    /// @warning Before using this methods use contains(round) to check element existing, or check pointer on nullptr.
    ///
    T* get(RoundNumber round) {
        const auto iterator = std::find_if(buffer_.begin(), buffer_.end(), [=](const MetaElement& value) {
            return round == value.round;
        });

        if (iterator == buffer_.end()) {
            return nullptr;
        }

        return &(iterator->meta);
    }

    ///
    /// @brief Returns reference to last round meta storage.
    /// @warning Use only if elements exists.
    ///
    const T& last() const {
        auto iterator = end();
        --iterator;

        return iterator->meta;
    }

    ///
    /// @brief Returns max round meta element.
    /// @warning Use only if elements exists.
    ///
    const T& max() const {
        const MetaElement* element = nullptr;
        cs::RoundNumber maxRound = 0;

        std::for_each(buffer_.begin(), buffer_.end(), [&](const MetaElement& value) {
            if (maxRound <= value.round) {
                maxRound = value.round;
                element = &value;
            }
        });

        return element->meta;
    }

    ///
    /// @brief Returns const begin interator of circular buffer.
    ///
    auto begin() const {
        return buffer_.begin();
    }

    ///
    /// @brief Returns const end interator of circular buffer.
    ///
    auto end() const {
        return buffer_.end();
    }

private:
    boost::circular_buffer<MetaElement> buffer_;
};
}  // namespace cs

#endif  // METASTORAGE_HPP
```
# ..\node\lib\include\lib\system\progressbar.hpp 
```cpp 
#ifndef PROGRESSBAR_HPP
#define PROGRESSBAR_HPP

#include <sstream>

class ProgressBar {
    using Progress = unsigned int;

public:
    ProgressBar(const ProgressBar&) = default;
    ProgressBar(ProgressBar&&) = default;
    ProgressBar& operator=(const ProgressBar&) = default;
    ProgressBar& operator=(ProgressBar&&) = default;

    /// @brief ProgressBar
    /// @param completeSymbol symbol that mark completed progress
    /// @param incompleteSymbol symbol that mark incompleted bar ticks
    /// @param totalProgressLimit in other words total progress percentage of completion
    /// @param barWidthInSymbols displayed real width of progress bar in symbols
    explicit ProgressBar(char completeSymbol = '#', char incompleteSymbol = '_', unsigned totalProgressLimit = 100, unsigned barWidthInSymbols = 50);
    ~ProgressBar();

    /// @brief string
    /// @param ticks current completed progress in ticks
    /// @return symbolic (std::string) progress representation
    std::string string(Progress ticks);

    char completeSymbol;
    char incompleteSymbol;
    Progress totalTicks;
    Progress barWidth;
};

#endif  // PROGRESSBAR_HPP
```
# ..\node\lib\include\lib\system\queues.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef QUEUES_HPP
#define QUEUES_HPP
#include <atomic>
#include <cstdint>
#include <thread>

#include "cache.hpp"
#include "logger.hpp"

/* Fixed Uniform Queue (FUQueue) is a simple lock-free queue that
   allows many writers and many readers */
template <typename T, std::size_t MaxSize, uint32_t BackOffTreshold = 1000>
class FUQueue {
public:
    struct Element {
        enum class State : uint8_t {
            Empty,
            New,
            Read,
            Write
        };

        __cacheline_aligned std::atomic<State> lockState{State::Empty};
        T element;
    };

    Element* lockRead() {
        return lock(/*[*/ readingBarrier_, writingBarrier_ /*]*/,
                    /*if*/ Element::State::New,
                    /*then set to*/ Element::State::Read,
                    /*or spin while*/ Element::State::Write);
    }

    void unlockRead(Element* ptr) {
        unlock(ptr,
               /*change from*/ Element::State::Read,
               /*to*/ Element::State::Empty,
               /*and move*/ readingBarrier_);
    }

    Element* lockWrite() {
        return lock(/*[*/ writingBarrier_, readingBarrier_ /*]*/,
                    /*if*/ Element::State::Empty,
                    /*then set to*/ Element::State::Write,
                    /*or spin while*/ Element::State::Read);
    }

    void unlockWrite(Element* ptr) {
        unlock(ptr,
               /*change from*/ Element::State::Write,
               /*to*/ Element::State::New,
               /*and move*/ writingBarrier_);
    }

private:
    Element* nextPtr(Element* ptr) {
        if (++ptr == end) {
            ptr = elements;
        }

        return ptr;
    }

    Element* lock(std::atomic<Element*>& leftBarr, std::atomic<Element*>& rightBarr, typename Element::State targetState, typename Element::State newState,
                  typename Element::State spinState) {
        auto target = leftBarr.load(std::memory_order_acquire);
        typename Element::State state = targetState;

        uint32_t attempts = 0;
        while (!target->lockState.compare_exchange_strong(state, newState, std::memory_order_acq_rel)) {
            if (++attempts == BackOffTreshold) {
                attempts = 0;
                std::this_thread::yield();
            }

            if (state != spinState && target != rightBarr.load(std::memory_order_acquire)) {
                auto nextTarget = nextPtr(target);
                leftBarr.compare_exchange_strong(target, nextPtr(target), std::memory_order_acq_rel, std::memory_order_relaxed);
                target = nextTarget;
            }

            state = targetState;
        }

        return target;
    }

    void unlock(Element* ptr, typename Element::State oldState, typename Element::State newState, std::atomic<Element*>& movingBar) {
        (void)(oldState);
        ptr->lockState.store(newState, std::memory_order_release);
        movingBar.compare_exchange_strong(ptr, nextPtr(ptr), std::memory_order_acq_rel, std::memory_order_relaxed);
    }

    Element elements[MaxSize];
    Element* end = elements + MaxSize;

    __cacheline_aligned std::atomic<Element*> readingBarrier_ = {elements};
    __cacheline_aligned std::atomic<Element*> writingBarrier_ = {elements};
};

#endif  // QUEUES_HPP
```
# ..\node\lib\include\lib\system\random.hpp 
```cpp 
#ifndef RANDOM_HPP
#define RANDOM_HPP

#include <random>
#include <algorithm>

namespace cs {
class Random {
    // random value generation helper
    template <typename R, typename T>
    static R randomValueImpl(T min, T max) {
        static std::random_device randomDevice;
        static std::mt19937 generator(randomDevice());

        if constexpr (std::is_integral_v<T>) {
            std::uniform_int_distribution<> dist(min, max);
            return static_cast<R>(dist(generator));
        }
        else {
            std::uniform_real_distribution<> distribution(min, max);
            return static_cast<R>(distribution(generator));
        }
    }

public:
    ///
    /// Generates random value from random generator [min, max] for integer type
    ///
    template <typename R>
    inline static R generateValue(int min, int max) {
        return randomValueImpl<R, decltype(min)>(min, max);
    }

    ///
    /// Generates random value from random generator [min, max] for floating point type
    ///
    template <typename R>
    inline static R generateValue(double min, double max) {
        return randomValueImpl<R, decltype(min)>(min, max);
    }

    template <typename RandomIterator, typename Generator>
    static void shuffle(RandomIterator first, RandomIterator last, Generator&& rng) {
        // shuffle [first, last) using random function rng
        auto uFirst = first;
        const auto uLast = last;

        if (uFirst == uLast) {
            return;
        }

        using diff = typename std::iterator_traits<RandomIterator>::difference_type;
        using udiff = typename std::make_unsigned<diff>::type;

        udiff bits = 8 * sizeof(udiff);
        udiff bmask = udiff(-1);

        auto target = uFirst;
        diff targetIndex = 1;

        for (; ++target != uLast; ++targetIndex) {
            // randomly place an element from [first, target] at target
            diff off;  // = rng(static_cast<_Diff>(targetIndex + 1));
            diff index = targetIndex + 1;

            for (;;) {
                // try a sample random value
                udiff ret = 0;   // random bits
                udiff mask = 0;  // 2^N - 1, _Ret is within [0, mask]

                while (mask < udiff(index - 1)) {
                    // need more random bits
                    ret <<= bits - 1;  // avoid full shift
                    ret <<= 1;

                    udiff _Get_bits;
                    // return a random value within [0, bmask]
                    for (;;) {
                        // repeat until random value is in range
                        udiff _Val = rng();

                        if (_Val <= bmask) {
                            _Get_bits = _Val;
                            break;
                        }
                    }

                    ret |= _Get_bits;
                    mask <<= bits - 1;  // avoid full shift
                    mask <<= 1;
                    mask |= bmask;
                }

                // _Ret is [0, mask], index - 1 <= mask, return if unbiased
                if (ret / index < mask / index || mask % index == udiff(index - 1)) {
                    off = static_cast<diff>(ret % index);
                    break;
                }
            }

            std::iter_swap(target, uFirst + off);
        }
    }
};
}

#endif  //  RANDOM_HPP
```
# ..\node\lib\include\lib\system\reflection.hpp 
```cpp 
#ifndef REFLECTION_HPP
#define REFLECTION_HPP

#include <utility>
#include <string>
#include <vector>
#include <type_traits>

#define cswatch(x) cslog() << (#x) << " is " << (x)
#define csunused(x) (void)(x)

// compile time and rtti reflection in action, works only in methods.
// if class/struct is not polimorphic - compile-time reflection, otherwise - run-time.
#define className typeid(*this).name
#define classNameString() std::string(className()) + std::literals::string_literals::operator""s(" ")

#define funcName() __func__

// pseudo definitions
#define csname() className() << "> "
#define csfunc() funcName() << "(): "

#define csreflection() className() << ", method " << csfunc()
#define csmeta(...) __VA_ARGS__() << csreflection()

namespace cs {

// vector
template <typename T>
struct IsVector : std::false_type {};

template <typename T, typename A>
struct IsVector<std::vector<T, A>> : std::true_type {};

template <typename T>
constexpr bool isVector() {
    return IsVector<T>::value;
}

// pair
template <typename T>
struct IsPair : std::false_type {};

template <typename T, typename A>
struct IsPair<std::pair<T, A>> : std::true_type {};

template <typename T>
constexpr bool isPair() {
    return IsPair<T>::value;
}

}

#endif  //  REFLECTION_HPP
```
# ..\node\lib\include\lib\system\scopeguard.hpp 
```cpp 
#ifndef SCOPE_GUARD_HPP
#define SCOPE_GUARD_HPP

#include <utility>
#include <lib/system/logger.hpp>

namespace cs {
struct ScopeGuardBase {
    ScopeGuardBase()
    : isActive_(true) {
    }

    ScopeGuardBase(ScopeGuardBase&& rhs)
    : isActive_(rhs.isActive_) {
        rhs.dismiss();
    }

    void dismiss() noexcept {
        isActive_ = false;
    }

protected:
    ~ScopeGuardBase() = default;
    bool isActive_;
};

template <class Func>
struct ScopeGuard : public ScopeGuardBase {
    ScopeGuard() = delete;
    ScopeGuard(const ScopeGuard&) = delete;

    ScopeGuard(Func f) noexcept
    : ScopeGuardBase()
    , func_(std::move(f)) {
    }

    ScopeGuard(ScopeGuard&& rhs) noexcept
    : ScopeGuardBase(std::move(rhs))
    , func_(std::move(rhs.func_)) {
    }

    ~ScopeGuard() noexcept {
        if (isActive_) {
            try {
                func_();
            }
            catch (...) {
                cserror() << "Scope guard callable exception, " << typeid(Func).name() << " func type";
            }
        }
    }

    ScopeGuard& operator=(const ScopeGuard&) = delete;

private:
    Func func_;
};

template <class Fun>
ScopeGuard<Fun> scopeGuard(Fun f) {
    return ScopeGuard<Fun>(std::move(f));
}
}  // namespace cs

#endif
```
# ..\node\lib\include\lib\system\signals.hpp 
```cpp 
#ifndef SIGNALS_HPP
#define SIGNALS_HPP

#include <lib/system/utils.hpp>

#include <functional>
#include <vector>

#define signals
#define slots
#define emit

namespace cs {
using ObjectPointer = void*;

// signal - slot controling entity
class Connector;

class ISignal {
public:
    virtual ~ISignal() = default;
    virtual void drop(void* object) = 0;
};

namespace cshelper {
class ConnectorForwarder {
public:
    template <typename Object>
    static void disconnect(const ISignal* signal, const Object& object);
};
}  // namespace cshelper

class IConnectable {
public:
    virtual ~IConnectable() {
        for (auto signal : signals_) {
            if (signal != nullptr) {
                cshelper::ConnectorForwarder::disconnect(signal, this);
            }
        }
    }

private:
    std::vector<ISignal*> signals_;
    friend class Connector;
};

///
/// Base preudo signal
///
template <typename T>
class Signal;

///
/// Signal needed specialization
///
template <typename Return, typename... InArgs>
class Signal<Return(InArgs...)> : public ISignal {
public:
    using Argument = std::function<Return(InArgs...)>;
    using Signature = Return(InArgs...);
    using Slots = std::vector<std::pair<ObjectPointer, Argument>>;

    ///
    /// @brief Generates signal.
    /// @param args Any count of template parameters.
    ///
    template <typename... Args>
    inline void operator()(Args&&... args) const {
        for ([[maybe_unused]] auto& [obj, func] : slots_) {
            csunused(obj);
            if (func) {
                func(std::forward<Args>(args)...);
            }
        }
    }

    Signal() = default;
    Signal(const Signal&) = delete;
    Signal& operator=(const Signal&) = delete;

    Signal(Signal&& signal) noexcept
    : slots_(std::move(signal.slots_)) {
        signal.slots_.clear();
    }

    Signal& operator=(Signal&& signal) noexcept {
        slots_ = std::move(signal.slots_);
        signal.slots_.clear();

        return *this;
    }

    ~Signal() {
        (*this) = nullptr;
    }

private:
    // adds slot to signal
    template <typename T>
    auto& add(T&& s, ObjectPointer obj = nullptr) {
        Argument arg = std::move(s);

        if (!arg) {
            return *this;
        }

        slots_.push_back(std::make_pair(obj, std::move(arg)));
        return *this;
    }

    // clears all signal slots
    auto& operator=(void* ptr) {
        if (ptr == nullptr) {
            slots_.clear();
        }

        return *this;
    }

    std::size_t size() const noexcept {
        return slots_.size();
    }

    Slots& content() noexcept {
        return slots_;
    }

    const Slots& content() const noexcept {
        return slots_;
    }

    virtual void drop(void* object) override final {
        for (auto iterator = slots_.begin(); iterator != slots_.end();) {
            if (iterator->first == ObjectPointer(object)) {
                iterator = slots_.erase(iterator);
            }
            else {
                ++iterator;
            }
        }
    }

    // all connected slots
    Slots slots_;

    friend class Connector;

    template <typename T>
    friend class Signal;
};

///
/// Signal for function prototype
///
template <typename T>
class Signal<std::function<T>> : public ISignal {
public:
    using Argument = std::function<T>;
    using Signature = T;
    using Slots = std::vector<std::pair<ObjectPointer, Argument>>;

    ///
    /// @brief Generates signal.
    /// @param args Any count of template parameters.
    ///
    template <typename... Args>
    inline void operator()(Args&&... args) const {
        signal_(std::forward<Args>(args)...);
    }

    // creation
    Signal() = default;
    Signal(const Signal&) = delete;
    Signal& operator=(const Signal&) = delete;

    Signal(Signal&& signal) noexcept
    : signal_(std::move(signal.signal_)) {
    }

    Signal& operator=(Signal&& signal) noexcept {
        signal_ = std::move(signal.signal_);
        return *this;
    }

    ~Signal() {
        (*this) = nullptr;
    }

private:
    // adds slot to signal
    template <typename U>
    auto& add(U&& s, ObjectPointer obj = nullptr) {
        signal_.add(std::forward<U>(s), obj);
        return *this;
    }

    // clears all slots
    auto& operator=(void* ptr) {
        signal_ = ptr;
        return *this;
    }

    std::size_t size() const noexcept {
        return signal_.size();
    }

    Slots& content() noexcept {
        return signal_.content();
    }

    const Slots& content() const noexcept {
        return signal_.content();
    }

    virtual void drop(void* object) override final {
        signal_.drop(object);
    }

    Signal<Signature> signal_;
    friend class Connector;
};

namespace cshelper {
template <typename T>
struct GetArguments : GetArguments<decltype(&T::operator())> {};

template <typename T, typename... Args>
struct GetArguments<T (*)(Args...)> : std::integral_constant<unsigned, sizeof...(Args)> {};

template <typename T, typename C, typename... Args>
struct GetArguments<T (C::*)(Args...)> : std::integral_constant<unsigned, sizeof...(Args)> {};

template <typename T, typename C, typename... Args>
struct GetArguments<T (C::*)(Args...) const> : std::integral_constant<unsigned, sizeof...(Args)> {};

// bindings
template <int>
class CheckArgs {
public:
    template <typename T, typename Slot>
    void connect(const T& slotObj, Slot&& slot);
};

template <>
class CheckArgs<0> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj);
    }
};

template <>
class CheckArgs<1> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1);
    }
};

template <>
class CheckArgs<2> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2);
    }
};

template <>
class CheckArgs<3> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);
    }
};

template <>
class CheckArgs<4> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4);
    }
};

template <>
class CheckArgs<5> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5);
    }
};

template <>
class CheckArgs<6> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5,
                         std::placeholders::_6);
    }
};

template <>
class CheckArgs<7> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5,
                         std::placeholders::_6, std::placeholders::_7);
    }
};

template <>
class CheckArgs<8> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5,
                         std::placeholders::_6, std::placeholders::_7, std::placeholders::_8);
    }
};

template <>
class CheckArgs<9> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5,
                         std::placeholders::_6, std::placeholders::_7, std::placeholders::_8, std::placeholders::_9);
    }
};

template <>
class CheckArgs<10> {
public:
    template <typename T, typename Slot>
    auto connect(const T& slotObj, Slot&& slot) {
        return std::bind(std::forward<Slot>(slot), slotObj, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5,
                         std::placeholders::_6, std::placeholders::_7, std::placeholders::_8, std::placeholders::_9, std::placeholders::_10);
    }
};
}  // namespace Args

///
/// Signal - slot connection entity
///
class Connector {
    template <typename Object>
    static ObjectPointer checkConnection(const ISignal* signal, const Object& object, std::true_type) {
        IConnectable* connectable = static_cast<IConnectable*>(object);
        connectable->signals_.push_back(const_cast<ISignal*>(signal));

        return ObjectPointer(connectable);
    }

    template <typename Object>
    static ObjectPointer checkConnection(const ISignal*, const Object& object, std::false_type) {
        return ObjectPointer(object);
    }

public:
    explicit Connector() = delete;
    Connector(const Connector&) = delete;
    Connector& operator=(const Connector&) = delete;
    Connector(Connector&&) = delete;
    Connector& operator=(Connector&&) = delete;

    ~Connector() = default;

    ///
    /// @brief Connects signal pointer with lambda or function.
    /// @param signal Any signal pointer.
    /// @param slot Function or lambda/closure.
    ///
    template <template <typename> typename Signal, typename T>
    static void connect(const Signal<T>* signal, typename Signal<T>::Argument slot) {
        cs::Lock lock(mutex_);
        const_cast<Signal<T>*>(signal)->add(slot);
    }

    ///
    /// @brief Connects const signal pointer with objects method.
    /// @param signal Any const signal pointer.
    /// @param slotObj Pointer to slot object.
    /// @param slot Method pointer.
    ///
    template <template <typename> typename Signal, typename T, typename Object, typename Slot>
    static void connect(const Signal<T>* signal, const Object& slotObj, Slot&& slot) {
        constexpr int size = cshelper::GetArguments<Slot>();

        cs::Lock lock(mutex_);
        auto obj = cs::Connector::checkConnection(static_cast<const ISignal*>(signal), slotObj, std::is_base_of<IConnectable, std::remove_pointer_t<Object>>());
        const_cast<Signal<T>*>(signal)->add(cshelper::CheckArgs<size>().connect(slotObj, std::forward<Slot>(slot)), obj);
    }

    ///
    /// @brief Connects two signals with earch other.
    /// @param lhs Any const signal1 pointer.
    /// @param rhs Any const signal2 pointer.
    ///
    template <template <typename> typename Signal, typename T>
    inline static void connect(const Signal<T>* lhs, const Signal<T>* rhs) {
        if (lhs == rhs) {
            return;
        }

        auto closure = [=](auto... args) -> void {
            if (rhs) {
                (*rhs)(std::forward<decltype(args)>(args)...);
            }
        };

        std::function<typename Signal<T>::Signature> func = closure;
        cs::Connector::connect(lhs, std::move(func));
    }

    ///
    /// @brief Disconnects signal with objcts slots.
    /// @return Returns true if disconnection is okay and same object/method
    /// was found at content.
    /// @param signal Any signal object.
    /// @param slotObj Any object that consider slot.
    /// @param slot T prototype slot.
    ///
    template <template <typename> typename Signal, typename T, typename Object, typename Slot>
    static bool disconnect(const Signal<T>* signal, const Object& slotObj, Slot&& slot) {
        if (!slotObj) {
            return false;
        }

        constexpr int size = cshelper::GetArguments<Slot>();
        std::function<T> binder = cshelper::CheckArgs<size>().connect(slotObj, std::forward<Slot>(slot));

        cs::Lock lock(mutex_);
        auto& content = const_cast<Signal<T>*>(signal)->content();
        auto iterator = std::find_if(content.begin(), content.end(), [&](const auto& pair) {
            auto& [object, function] = pair;

            if (object) {
                if (object == (slotObj)) {
                    return function.target_type().hash_code() == binder.target_type().hash_code();
                }
            }

            return false;
        });

        if (iterator != content.end()) {
            content.erase(iterator);
            return true;
        }

        return false;
    }

    ///
    /// @brief Disconnects signal pointer with lambda or function.
    /// @param signal Any signal pointer.
    /// @param slot Function or lambda/closure.
    ///
    template <template <typename> typename Signal, typename T>
    static bool disconnect(const Signal<T>* signal, typename Signal<T>::Argument slot) {
        cs::Lock lock(mutex_);
        auto& content = const_cast<Signal<T>*>(signal)->content();
        auto iterator = std::find_if(content.begin(), content.end(), [&](const auto& pair) {
            auto& [object, function] = pair;

            if (!object) {
                return function.target_type().hash_code() == slot.target_type().hash_code();
            }

            return false;
        });

        if (iterator != content.end()) {
            content.erase(iterator);
            return true;
        }

        return false;
    }

    ///
    /// @brief Drops all signal connections.
    /// @param signal Any signal object.
    ///
    template <template <typename> typename Signal, typename T>
    static bool disconnect(const Signal<T>* signal) {
        cs::Lock lock(mutex_);
        auto signalPtr = const_cast<Signal<T>*>(signal);
        *(signalPtr) = nullptr;

        return signalPtr->content().empty();
    }

    ///
    /// @brief Drops all slots for object from signal interface.
    ///
    template <typename Object, typename = std::enable_if_t<std::is_pointer_v<Object> && std::is_class_v<std::remove_pointer_t<Object>>>>
    static void disconnect(const ISignal* signal, const Object& object) {
        cs::Lock lock(mutex_);
        const_cast<ISignal*>(signal)->drop(ObjectPointer(object));
    }

    ///
    /// @brief Drops all slots from subscribed object.
    /// @param signal. Searched cntent from this signal.
    /// @param object. Drops all slots with this object.
    ///
    template <template <typename> typename Signal, typename T, typename Object,
              typename = std::enable_if_t<std::is_pointer_v<Object> && std::is_class_v<std::remove_pointer_t<Object>>>>
    static void disconnect(const Signal<T>* signal, const Object& object) {
        cs::Connector::disconnect(static_cast<ISignal*>(signal), object);
    }

    ///
    /// @brief Returns signal callbacks size.
    /// @return Returns any signal object callbacks count.
    ///
    template <template <typename> typename Signal, typename T>
    static std::size_t callbacks(const Signal<T>* signal) {
        cs::Lock lock(mutex_);
        return signal->size();
    }

private:
    inline static std::mutex mutex_;
};

// forward realization
template <typename Object>
inline void cshelper::ConnectorForwarder::disconnect(const ISignal* signal, const Object& object) {
    cs::Connector::disconnect(signal, object);
}

}  // namespace cs

#endif  // SIGNALS_HPP
```
# ..\node\lib\include\lib\system\structures.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef STRUCTURES_HPP
#define STRUCTURES_HPP
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <functional>

#include "allocators.hpp"
#include "cache.hpp"

/* Containers */
template <typename BufferType>
class FixedBufferIterator {
public:
    FixedBufferIterator& operator++() {
        ptr_ = fcb_->incrementPtr(ptr_);
        circ_ = true;
        return *this;
    }

    bool operator!=(const FixedBufferIterator& rhs) {
        return ptr_ != rhs.ptr_ || circ_ != rhs.circ_;
    }

    typename BufferType::value_type& operator*() {
        return *ptr_;
    }
    typename BufferType::value_type* operator->() {
        return ptr_;
    }

private:
    typename BufferType::value_type* ptr_ = nullptr;
    bool circ_ = false;
    BufferType const* fcb_;

    friend BufferType;
};

template <typename T, uint32_t Size>
class FixedCircularBuffer {
public:
    using value_type = T;
    using const_iterator = FixedBufferIterator<FixedCircularBuffer>;

    FixedCircularBuffer()
    : elements_(reinterpret_cast<T*>(new uint8_t[sizeof(T) * Size])) {
    }

    ~FixedCircularBuffer() {
        clear();
        delete[] reinterpret_cast<uint8_t*>(elements_);
    }

    FixedCircularBuffer(const FixedCircularBuffer&) = delete;
    FixedCircularBuffer(FixedCircularBuffer&& rhs)
    : elements_(rhs.elements_)
    , head_(rhs.head_)
    , tail_(rhs.tail_)
    , size_(rhs.size_) {
        rhs.size_ = 0;
        rhs.elements_ = rhs.head_ = rhs.tail_ = nullptr;
    }

    FixedCircularBuffer& operator=(const FixedCircularBuffer&) = delete;
    FixedCircularBuffer& operator=(FixedCircularBuffer&&) = delete;

    template <typename... Args>
    T& emplace(Args&&... args) {
        T* place;
        if (size_ < Size) {
            place = tail_;
            tail_ = incrementPtr(tail_);
            ++size_;
        }
        else {
            head_->~T();
            place = head_;
            tail_ = head_ = incrementPtr(head_);
        }

        return *(new (place) T(std::forward<Args>(args)...));
    }

    const_iterator end() const {
        const_iterator ci;
        if (size_) {
            ci.circ_ = true;
        }
        ci.ptr_ = tail_;
        return ci;
    }

    const_iterator begin() const {
        const_iterator ci;
        ci.ptr_ = head_;
        ci.fcb_ = this;
        return ci;
    }

    T* frontPtr() const {
        return head_;
    }
    T* backPtr() const {
        return tail_;
    }

    void clear() {
        for (uint32_t i = size_; i > 0; --i) {
            head_->~T();
            head_ = incrementPtr(head_);
        }

        head_ = tail_ = elements_;
        size_ = 0;
    }

    void remove(T* toRem) {
        toRem->~T();
        --size_;

        if (toRem >= head_) {
            std::memmove(head_ + 1, head_, (toRem - head_) * sizeof(T));
            ++head_;
        }
        else {
            std::memmove(toRem, toRem + 1, (tail_ - toRem - 1) * sizeof(T));
            --tail_;
        }
    }

    uint32_t size() const {
        return size_;
    }

private:
    T* incrementPtr(T* ptr) const {
        if (++ptr == end_) {
            ptr = elements_;
        }

        return ptr;
    }

    T* elements_;

    T* head_ = elements_;
    T* tail_ = elements_;

    const T* end_ = elements_ + Size;

    uint32_t size_ = 0;
    friend const_iterator;
};

template <typename T, size_t Capacity>
class FixedVector {
public:
    FixedVector()
    : elements_(reinterpret_cast<T*>(new uint8_t[sizeof(T) * Capacity]))
    , end_(elements_) {
    }

    ~FixedVector() {
        for (auto ptr = elements_; ptr != end_; ++ptr) {
            ptr->~T();
        }

        delete[] reinterpret_cast<uint8_t*>(elements_);
    }

    FixedVector(const FixedVector&) = delete;
    FixedVector(FixedVector&& rhs)
    : elements_(rhs.elements_)
    , end_(rhs.end_) {
        rhs.elements_ = nullptr;
        rhs.end_ = nullptr;
    }

    FixedVector& operator=(const FixedVector&) = delete;
    FixedVector& operator=(FixedVector&&) = delete;

    template <typename... Args>
    T& emplace(Args&&... args) {
        return *(new (end_++) T(std::forward<Args>(args)...));
    }

    T* begin() const {
        return elements_;
    }
    T* end() const {
        return end_;
    }

    void remove(T* element) {
        element->~T();

        std::memmove(static_cast<void*>(element), static_cast<const void*>(element + 1), sizeof(T) * (end_ - element - 1));
        --end_;
    }

    uint32_t size() const {
        return static_cast<uint32_t>(end() - elements_);
    }

    bool contains(T* ptr) const {
        return begin() <= ptr && ptr < end();
    }

private:
    T* elements_;
    T* end_;
};

/* A simple queue-like counting hash-map of fixed size. Not
   thread-safe. */
template <typename ResultType, typename ArgType>
inline ResultType getHashIndex(const ArgType&);

template <typename KeyType, typename ArgType, typename IndexType = uint16_t, uint32_t MaxSize = 100000>
class FixedHashMap {
public:
    struct Element {
        Element *up, *down = nullptr;
        Element** bucket;

        KeyType key;
        ArgType data = {};

        ArgType& operator*() {
            return data;
        }

        Element(const KeyType& _key, Element** _bucket)
        : bucket(_bucket)
        , key(_key) {
        }
    };
    using ElementPtr = Element*;

    FixedHashMap() {
        static_assert(MaxSize >= 2, "Your member is too small");

        const size_t bucketsSize = 1 << (sizeof(IndexType) * 8);
        buckets_ = new ElementPtr[bucketsSize];
        std::memset(buckets_, 0, bucketsSize * sizeof(ElementPtr));
    }

    FixedHashMap(const FixedHashMap&) = delete;
    FixedHashMap(FixedHashMap&& rhs)
    : buffer_(std::move(rhs.buffer_))
    , buckets_(rhs.buckets_) {
        rhs.buckets_ = nullptr;
    }

    ~FixedHashMap() {
        delete[] buckets_;
    }

    ArgType& tryStore(const KeyType& key) {
        Element** myBucket;
        auto foundElement = getElt(key, &myBucket);

        if (foundElement) {
            return foundElement->data;
        }

        // Element not found, add a new one
        if (buffer_.size() == MaxSize) {
            preparePopLeft();
        }

        Element& newComer = buffer_.emplace(key, myBucket);
        newComer.up = *myBucket;

        if (newComer.up) {
            newComer.up->down = &newComer;
        }

        *myBucket = &newComer;
        return newComer.data;
    }

    auto begin() {
        return buffer_.begin();
    }
    auto end() {
        return buffer_.end();
    }

private:
    Element* getElt(const KeyType& key, Element*** bucket) {
        const IndexType idx = getHashIndex<IndexType, KeyType>(key);
        *bucket = buckets_ + idx;

        Element* eltInBucket = **bucket;
        while (eltInBucket) {
            if (eltInBucket->key == key) {
                return eltInBucket;
            }

            eltInBucket = eltInBucket->up;
        }

        return nullptr;
    }

    void preparePopLeft() {
        auto toRemove = buffer_.frontPtr();

        if (toRemove->down) {
            toRemove->down->up = toRemove->up;
        }
        else {
            *(toRemove->bucket) = toRemove->up;
        }

        if (toRemove->up) {
            toRemove->up->down = toRemove->down;
        }
    }

    FixedCircularBuffer<Element, MaxSize> buffer_;
    Element** buckets_;
};

class CallsQueue {
public:
    struct Call {
        __cacheline_aligned std::atomic<Call*> next;
        std::function<void()> func;
    };

    static CallsQueue& instance() {
        static CallsQueue inst;
        return inst;
    }

    // Called from a single thread
    inline void callAll();
    inline void insert(std::function<void()>);

private:
    CallsQueue() {
    }
    __cacheline_aligned std::atomic<Call*> head_ = {nullptr};
};

inline void CallsQueue::callAll() {
    Call* startHead = head_.load(std::memory_order_relaxed);

    if (!startHead) {
        return;
    }

    Call* newHead = startHead;
    head_.compare_exchange_strong(newHead, nullptr, std::memory_order_relaxed, std::memory_order_relaxed);
    Call* elt = startHead;

    do {
        elt->func();
        Call* rem = elt;
        elt = rem->next.load(std::memory_order_relaxed);
        delete rem;
    } while (elt);

    if (newHead != startHead) {
        do {
            Call* next = newHead->next.load(std::memory_order_relaxed);
            if (next == startHead)
                break;
            newHead = next;
        } while (true);

        newHead->next.store(nullptr, std::memory_order_relaxed);
    }
}

inline void CallsQueue::insert(std::function<void()> f) {
    Call* newElt = new Call;
    newElt->func = f;

    Call* head = head_.load(std::memory_order_relaxed);
    do {
        newElt->next.store(head, std::memory_order_relaxed);
    } while (!head_.compare_exchange_weak(head, newElt, std::memory_order_acquire, std::memory_order_relaxed));
}

template <size_t Length>
struct FixedString {
    FixedString() {
        std::memset(str, 0, Length);
    }

    FixedString(const char* src) {
        std::memcpy(str, src, Length);
    }

    bool operator==(const FixedString& rhs) const {
        return std::memcmp(str, rhs.str, Length) == 0;
    }

    bool operator!=(const FixedString& rhs) const {
        return !(*this == rhs);
    }

    bool operator<(const FixedString& rhs) const {
        return std::memcmp(str, rhs.str, Length) < 0;
    }

    char* data() {
        return str;
    }

    const char* data() const {
        return str;
    }

    size_t size() const {
        return Length;
    }

    char* begin() {
        return str;
    }

    char* end() {
        return str + Length;
    }

    const char* begin() const {
        return str;
    }

    const char* end() const {
        return str + Length;
    }

    char& operator[](size_t index) {
        return str[index];
    }

    const char& operator[](size_t index) const {
        return str[index];
    }

    char str[Length];
};

template <uint32_t MaxSize>
class CharFunc {
public:
    CharFunc(uint32_t realSize) {
        const uint32_t bNum = realSize / 8;
        std::memset(bytes_, 0, (bNum + ((bNum * 8) != realSize)));
    }

    CharFunc()
    : CharFunc(MaxSize) {
    }

    bool checkPos(uint32_t id) const {
        uint32_t mask;
        const uint32_t& byte = getByte(id, mask);
        return byte & mask;
    }

    void setPos(uint32_t id, bool val) {
        uint32_t mask;
        uint32_t& byte = getByte(id, mask);

        if (val) {
            byte |= mask;
        }
        else {
            byte &= ~mask;
        }
    }

private:
    uint32_t& getByte(uint32_t id, uint32_t& mask) {
        const uint32_t oneElt = sizeof(uint32_t) * 8;
        uint32_t pos = id / oneElt;
        mask = 1 << (id - pos * oneElt);
        return bytes_[pos];
    }

    const uint32_t& getByte(uint32_t id, uint32_t& mask) const {
        return const_cast<CharFunc*>(this)->getByte(id, mask);
    }

    constexpr static uint32_t getMyBytesLength() {
        const uint32_t oneElt = sizeof(uint32_t) * 8;
        const uint32_t mS = MaxSize / oneElt;
        return mS + ((mS * oneElt) != MaxSize);
    }

    uint32_t bytes_[getMyBytesLength()];
};

#endif  // __STRUCTURES_HPP
```
# ..\node\lib\include\lib\system\timer.hpp 
```cpp 
#ifndef TIMER_HPP
#define TIMER_HPP

#include <atomic>
#include <chrono>
#include <functional>
#include <memory>
#include <thread>
#include <vector>

#include <lib/system/concurrent.hpp>

namespace cs {
using TimerCallbackSignature = void();
using TimerCallback = std::function<TimerCallbackSignature>;
using TimeOutSignal = cs::Signal<TimerCallbackSignature>;

class Timer;
using TimerPtr = std::shared_ptr<Timer>;

///
/// Represents standard timer that calls callbacks every msec with time correction.
/// @brief Timer emits time out signal by run policy.
///
class Timer {
public:
    enum : unsigned int {
        RangeDeltaInPercents = 10,
        HighPreciseTimerSleepTimeMs = 1
    };

    enum class Type : cs::Byte {
        Standard,
        HighPrecise
    };

    Timer();
    ~Timer();

    void start(int msec, Type type = Type::Standard, RunPolicy policy = RunPolicy::ThreadPolicy);
    void stop();
    void restart();

    bool isRunning() const;
    Type type() const;

    static void singleShot(int msec, cs::RunPolicy policy, TimerCallback callback);
    static TimerPtr create();

public signals:

    // generates when timer ticks
    TimeOutSignal timeOut;

protected:
    // timer main loop
    void loop();
    void preciseLoop();

    // timer rehabilitation when timer degradate
    void rehabilitation();
    void call();

private:
    bool isRunning_;
    bool isRehabilitation_;
    std::atomic<bool> interruption_;

    std::thread timerThread_;
    Type type_;
    std::atomic<RunPolicy> policy_;

    unsigned int allowDifference_;
    std::chrono::milliseconds ms_;
    std::atomic<int64_t> ns_;

    std::chrono::milliseconds realMs_;
    std::chrono::time_point<std::chrono::system_clock> rehabilitationStartValue_;
};
}  // namespace cs

#endif  //  TIMER_HPP
```
# ..\node\lib\include\lib\system\utils.hpp 
```cpp 
#ifndef UTILS_HPP
#define UTILS_HPP

#include <algorithm>
#include <array>
#include <cassert>
#include <chrono>
#include <cstdlib>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <memory>
#include <ostream>
#include <random>
#include <sstream>
#include <string>
#include <thread>

#ifdef _MSC_VER
#include <intrin.h>
#else
#include <x86intrin.h>
#endif

#include <time.h>

#include <boost/numeric/conversion/cast.hpp>

#include <lib/system/common.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/structures.hpp>
#include <lib/system/reflection.hpp>

using namespace std::literals::string_literals;

namespace cs {
enum class Direction : uint8_t {
    PrevBlock,
    NextBlock
};

inline std::ostream& operator<<(std::ostream& os, Direction dir) {
    switch (dir) {
        case Direction::PrevBlock:
            return os << "Previous Block";

        case Direction::NextBlock:
            return os << "Next Block";

        default:
            return os << "Wrong dir=" << static_cast<int64_t>(dir);
    }
}

inline std::ostream& printHex(std::ostream& os, const char* bytes, size_t num) {
    static char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

    for (size_t i = 0; i < num; i++) {
        os << hex[(bytes[i] >> 4) & 0x0F];
        os << hex[bytes[i] & 0x0F];
    }

    return os;
}

template <typename T, size_t Size>
inline static std::ostream& operator<<(std::ostream& os, const std::array<T, Size>& address) {
    printHex(os, reinterpret_cast<const char*>(&*address.begin()), address.size());
    return os;
}

///
/// Static utils helper class
///
class Utils {
public:
    ///
    /// Fills hash with first size of symbols
    ///
    inline static void fillHash(std::string& hash, uint32_t size, char symbol = '0') {
        for (decltype(size) i = 0; i < size; ++i) {
            hash[i] = symbol;
        }
    }

    ///
    /// Returns current time in string representation
    ///
    static std::string formattedCurrentTime() {
        auto now = std::chrono::system_clock::now();
        auto in_time_t = std::chrono::system_clock::to_time_t(now);

        struct tm result;
        std::stringstream ss;
#ifndef _WINDOWS
        ss << std::put_time(localtime_r(&in_time_t, &result), "%H:%M:%S");
#else
        localtime_s(&result, &in_time_t);
        ss << std::put_time(&result, "%H:%M:%S");
#endif
        return ss.str();
    }

    ///
    /// Inserts value to char array by index
    ///
    template <typename T>
    inline static void insertToArray(char* data, uint32_t index, T&& value) {
        char* ptr = reinterpret_cast<char*>(&value);

        for (uint32_t i = index, k = 0; i < index + sizeof(T); ++i, ++k) {
            *(data + i) = *(ptr + k);
        }
    }

    ///
    /// Returns value from char array
    ///
    template <typename T>
    inline static T getFromArray(char* data, size_t index) {
        return *(reinterpret_cast<T*>(data + index));
    }

    ///
    /// Represents type T as byte string
    ///
    template <typename T>
    inline static std::string addressToString(T address) {
        std::string str;
        str.resize(sizeof(T));

        cs::Utils::insertToArray(str.data(), 0, address);

        return str;
    }

    ///
    /// Returns all file data as string
    ///
    inline static std::string readAllFileData(std::ifstream& file) {
        return std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    }

    ///
    /// Converts char array data to hex into std::string
    ///
    inline static std::string toHex(char* data, std::size_t size) {
        assert(data != nullptr);

        std::stringstream ss;

        for (std::size_t i = 0; i < size; ++i) {
            ss << std::hex << static_cast<int>(data[i]);
        }

        return ss.str();
    }

    ///
    /// Converts char array data to hex into std::string
    ///
    template <size_t size>
    inline static std::string toHex(const char (&data)[size]) {
        return Utils::toHex(static_cast<char*>(data), size);
    }

    ///
    /// Clears memory
    ///
    template <typename T>
    inline static void clearMemory(T& object) {
        static_assert(std::is_copy_assignable_v<T> || std::is_trivially_copyable_v<T>, "T type should be trivially copyable or has user copy assign operator");
        std::memset(&object, 0, sizeof(T));
    }

    ///
    /// Converts string to hex
    ///
    static std::string stringToHex(const std::string& input) {
        static const char* const lut = "0123456789ABCDEF";
        std::size_t len = input.length();

        std::string output;
        output.reserve(2 * len);

        for (size_t i = 0; i < len; ++i) {
            const unsigned char c = static_cast<unsigned char>(input[i]);

            output.push_back(lut[c >> 4]);
            output.push_back(lut[c & 15]);
        }

        return output;
    }

    ///
    /// Converts hex to string
    ///
    static std::string hexToString(const std::string& input) {
        static const char* const lut = "0123456789ABCDEF";
        std::size_t len = input.length();

        if (len & 1) {
            throw std::invalid_argument("odd length");
        }

        std::string output;
        output.reserve(len / 2);

        for (std::size_t i = 0; i < len; i += 2) {
            char a = input[i];
            const char* p = std::lower_bound(lut, lut + 16, a);

            if (*p != a) {
                throw std::invalid_argument("not a hex digit");
            }

            char b = input[i + 1];
            const char* q = std::lower_bound(lut, lut + 16, b);

            if (*q != b) {
                throw std::invalid_argument("not a hex digit");
            }

            output.push_back(static_cast<char>(((p - lut) << 4) | (q - lut)));
        }

        return output;
    }

    ///
    /// Converts const char data pointer to hex
    ///
    inline static std::string byteStreamToHex(const char* stream, const std::size_t length) {
        static const std::string map = "0123456789ABCDEF";

        std::string result;
        result.reserve(length * 2);

        for (std::size_t i = 0; i < length; ++i) {
            result.push_back(map[static_cast<uint8_t>(stream[i]) >> 4]);
            result.push_back(map[static_cast<uint8_t>(stream[i]) & static_cast<uint8_t>(15)]);
        }

        return result;
    }

    ///
    /// Converts const unsigned char data pointer to hex
    ///
    inline static std::string byteStreamToHex(const unsigned char* stream, const std::size_t length) {
        return cs::Utils::byteStreamToHex(reinterpret_cast<const char*>(stream), length);
    }

    inline static uint64_t maskToBits(const cs::Bytes& mask) {
        if (mask.size() > 64) {
            cserror() << "The mask number is larger than the alloowed value";
        }

        uint64_t addition = 1;
        uint64_t value = 0;

        for (auto& it : mask) {
            if (it != 255U) {
                value += addition;
            }
            addition *= 2;
        }

        return value;
    }

    inline static cs::Bytes bitsToMask(uint8_t size, uint64_t value) {
        cs::Bytes mask;
        mask.reserve(static_cast<size_t>(size));

        uint64_t valCopy = value;

        for (cs::Byte i = 0; i < size; ++i) {
            if (valCopy % 2 == 1U) {
                mask.push_back(0U);
            }
            else {
                mask.push_back(255U);
            }

            valCopy /= 2U;
        }

        return mask;
    }

    inline static cs::Byte maskValue(uint64_t value) {
#ifdef _MSC_VER
        cs::Byte cnt = static_cast<cs::Byte>(__popcnt64(value));
#else
        cs::Byte cnt = static_cast<cs::Byte>(__builtin_popcountl(value));
#endif
        return cnt;
    }

    ///
    /// Convert container bytes to hex
    ///
    template <typename T>
    static std::string byteStreamToHex(const T& entity) {
        return cs::Utils::byteStreamToHex(entity.data(), entity.size());
    }

public:
    ///
    /// Returns current time point as string representation
    ///
    static std::string currentTimestamp() {
        auto now = std::chrono::system_clock::now();
        return std::to_string(std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count());
    }

    ///
    /// Splits vector on equals parts
    ///
    template <typename T>
    static std::vector<std::vector<T>> splitVector(const std::vector<T>& vector, std::size_t parts) {
        std::vector<std::vector<T>> result;

        std::size_t length = vector.size() / parts;
        std::size_t remain = vector.size() % parts;

        std::size_t begin = 0;
        std::size_t end = 0;

        for (std::size_t i = 0; i < std::min(parts, vector.size()); ++i) {
            end += (remain > 0) ? (length + !!(remain--)) : length;

            result.push_back(std::vector<T>(vector.begin() + begin, vector.begin() + end));

            begin = end;
        }

        return result;
    }
};

///
/// Conversion between numeric types with checks based on boost::numeric_cast in DEBUG build
///
template <typename Target, typename Source>
inline auto numeric_cast(Source arg) {
#ifndef NDEBUG
    return boost::numeric_cast<Target>(arg);
#else
    return static_cast<Target>(arg);
#endif
}

template <typename T>
constexpr T getMax(const T&) {
    return std::numeric_limits<T>::max();
}

template <typename T>
constexpr T getMin(const T&) {
    return std::numeric_limits<T>::min();
}

constexpr int getMax(const bool) {
    return static_cast<int>(std::numeric_limits<bool>::max());
}

constexpr int getMin(const bool) {
    return static_cast<int>(std::numeric_limits<bool>::min());
}

template <typename TBytes>
inline constexpr cs::BytesView bytesView_cast(const TBytes& bytes) {
    static_assert(std::is_same_v<typename TBytes::value_type, cs::Byte>, "Only bytes storages can use bytesView_cast func");
    return cs::BytesView(bytes.data(), bytes.size());
}

class Console {
public:
    template <typename... Args>
    static void writeLine(Args&&... args) {
        (std::cout << ... << std::forward<Args>(args)) << std::endl;
    }
};
}  // namespace cs

inline constexpr cs::Byte operator"" _b(unsigned long long arg) noexcept {
    return static_cast<cs::Byte>(arg);
}

inline constexpr char operator"" _i8(unsigned long long arg) noexcept {
    return static_cast<signed char>(arg);
}

inline constexpr unsigned short operator"" _u16(unsigned long long arg) noexcept {
    return static_cast<unsigned short>(arg);
}

inline constexpr short operator"" _i16(unsigned long long arg) noexcept {
    return static_cast<short>(arg);
}

inline constexpr std::size_t operator"" _sz(unsigned long long arg) noexcept {
    return static_cast<std::size_t>(arg);
}

#endif  //  UTILS_HPP
```
# ..\node\lib\src\lib\system\logger.cpp 
```cpp 
#include <lib/system/logger.hpp>

#include <boost/log/core.hpp>
#include <boost/log/utility/setup/common_attributes.hpp>
#include <boost/log/utility/setup/filter_parser.hpp>
#include <boost/log/utility/setup/formatter_parser.hpp>
#include <boost/log/utility/setup/from_settings.hpp>

namespace logger {
void initialize(const logging::settings& settings) {
    logging::add_common_attributes();

    // formatters
    logging::register_simple_formatter_factory<severity_level, char>(logging::trivial::tag::severity::get_name());
    // filters
    logging::register_simple_filter_factory<severity_level>(logging::trivial::tag::severity::get_name());

    logging::init_from_settings(settings);
}

void cleanup() {
    logging::core::get()->remove_all_sinks();
}
}  // namespace logger
```
# ..\node\lib\src\lib\system\progressbar.cpp 
```cpp 
#include "lib/system/progressbar.hpp"

#include <iostream>
#include <rang.hpp>

ProgressBar::ProgressBar(char completeSymbol, char incompleteSymbol, unsigned totalProgressLimit, unsigned barWidthInSymbols)
: completeSymbol(completeSymbol)
, incompleteSymbol(incompleteSymbol)
, totalTicks(totalProgressLimit)
, barWidth(barWidthInSymbols) {
    rang::setControlMode(rang::control::Force);
    rang::setWinTermMode(rang::winTerm::Ansi);
#ifdef _WINDOWS
    // FIXME: it's a temporary hack to turn on ANSI sequences on windows terminal
    // because bar outputs progress to _any_ stream, so we need to force ansi
    rang::rang_implementation::setWinTermAnsiColors(std::cout.rdbuf());
#endif
}

ProgressBar::~ProgressBar() {
    rang::setControlMode(rang::control::Auto);
    rang::setWinTermMode(rang::winTerm::Auto);
}

std::string ProgressBar::string(ProgressBar::Progress ticks) {
    float progress = float(ticks) / totalTicks;
    auto pos = unsigned(barWidth * progress);

    std::string completed(pos, completeSymbol);
    std::string incompleted(barWidth - pos, incompleteSymbol);

    std::stringstream result;
    result << rang::bg::blue << rang::fg::blue << completed;
    result << rang::bg::gray << rang::fg::gray << incompleted;
    result << rang::bg::reset << rang::fg::reset << rang::style::reset;
    result << " " << (progress * 100.0f) << "%";

    result.flush();
    result << std::endl;

    return result.str();
}
```
# ..\node\lib\src\lib\system\timer.cpp 
```cpp 
#include "lib/system/timer.hpp"

cs::Timer::Timer()
: isRunning_(false)
, isRehabilitation_(true)
, interruption_(false)
, ms_(std::chrono::milliseconds(0)) {
}

cs::Timer::~Timer() {
    if (isRunning()) {
        stop();
    }
}

void cs::Timer::start(int msec, Type type, RunPolicy policy) {
    interruption_ = false;
    isRunning_ = true;

    type_ = type;
    policy_.store(policy, std::memory_order_release);

    ms_ = std::chrono::milliseconds(msec);
    ns_ = 0;

    timerThread_ = (type_ == Type::Standard) ? std::thread(&Timer::loop, this) : std::thread(&Timer::preciseLoop, this);

    realMs_ = ms_;
    allowDifference_ = static_cast<unsigned int>(msec) * RangeDeltaInPercents / 100;
}

void cs::Timer::stop() {
    interruption_ = true;

    if (timerThread_.joinable()) {
        timerThread_.join();
        isRunning_ = false;
    }
}

void cs::Timer::restart() {
    if (isRunning_) {
        if (type_ == Type::Standard) {
            stop();
            start(static_cast<int>(ms_.count()), type_, policy_);
        }
        else {
            ns_ = 0;
        }
    }
}

bool cs::Timer::isRunning() const {
    return isRunning_;
}

cs::Timer::Type cs::Timer::type() const {
    return type_;
}

void cs::Timer::singleShot(int msec, cs::RunPolicy policy, cs::TimerCallback callback) {
    cs::Concurrent::runAfter(std::chrono::milliseconds(msec), policy, std::move(callback));
}

cs::TimerPtr cs::Timer::create() {
    return std::make_shared<Timer>();
}

void cs::Timer::loop() {
    while (!interruption_) {
        if (isRehabilitation_) {
            isRehabilitation_ = false;
            rehabilitationStartValue_ = std::chrono::system_clock::now();
        }

        std::this_thread::sleep_for(ms_);

        rehabilitation();
        call();
    }
}

void cs::Timer::preciseLoop() {
    std::chrono::high_resolution_clock::time_point previousTimePoint = std::chrono::high_resolution_clock::now();

    while (!interruption_) {
        auto now = std::chrono::high_resolution_clock::now();
        auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(now - previousTimePoint);
        ns_ += ns.count();

        auto needMsInNs = std::chrono::duration_cast<std::chrono::nanoseconds>(ms_);

        if (needMsInNs.count() <= ns_) {
            ns_ = 0;
            call();
        }

        previousTimePoint = now;
        std::this_thread::sleep_for(std::chrono::milliseconds(HighPreciseTimerSleepTimeMs));
    }
}

void cs::Timer::rehabilitation() {
    isRehabilitation_ = true;

    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - rehabilitationStartValue_);
    auto difference = duration - realMs_;

    if (difference >= realMs_) {
        ms_ = std::chrono::milliseconds(0);
    }
    else {
        if (difference.count() > allowDifference_) {
            ms_ = realMs_ - (difference % realMs_);
        }
        else {
            if (ms_ != realMs_) {
                ms_ = realMs_;
            }
        }
    }
}

void cs::Timer::call() {
    auto policy = policy_.load(std::memory_order_acquire);

    if (policy == RunPolicy::ThreadPolicy) {
        emit timeOut();
    }
    else {
        CallsQueue::instance().insert([=] {
            emit timeOut();
        });
    }
}
```
# ..\node\net\include\net\logger.hpp 
```cpp 
#pragma once

#include <client/params.hpp>

#include <lib/system/logger.hpp>

#include <boost/log/sources/global_logger_storage.hpp>
#include <boost/log/sources/severity_channel_logger.hpp>

namespace logger {
#ifndef LOG_NET
    using Net = None;
#else
    BOOST_LOG_INLINE_GLOBAL_LOGGER_CTOR_ARGS(
      Net,
      logging::sources::severity_channel_logger_mt<severity_level>,
      (logging::keywords::channel = "net")
    );
#endif // LOG_NET
} // namespace logger
```
# ..\node\net\include\net\neighbourhood.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef NEIGHBOURHOOD_HPP
#define NEIGHBOURHOOD_HPP

#include <boost/asio.hpp>

#include <lib/system/allocators.hpp>
#include <lib/system/cache.hpp>
#include <lib/system/common.hpp>

#include "packet.hpp"

namespace ip = boost::asio::ip;

class Network;
class Transport;

class BlockChain;

const uint32_t MaxMessagesToKeep = 128;
const uint32_t MaxResendTimes = 8;
const cs::Sequence MaxSyncAttempts = 8;

const cs::Sequence BlocksToSync = 16;
const uint32_t WarnsBeforeRefill = 8;

struct Connection;
struct RemoteNode {
    __cacheline_aligned std::atomic<uint64_t> packets = {0};

    __cacheline_aligned std::atomic<uint32_t> strikes = {0};
    __cacheline_aligned std::atomic<bool> blackListed = {ATOMIC_FLAG_INIT};

    void addStrike() {
        strikes.fetch_add(1, std::memory_order_relaxed);
    }

    void setBlackListed(bool b) {
        blackListed.store(b, std::memory_order_relaxed);
    }

    bool isBlackListed() {
        return blackListed.load(std::memory_order_relaxed);
    }

    __cacheline_aligned std::atomic<Connection*> connection = {nullptr};
};

using RemoteNodePtr = MemPtr<TypedSlot<RemoteNode>>;

struct Connection {
    typedef uint64_t Id;

    Connection() = default;

    Connection(Connection&& rhs)
    : id(rhs.id)
    , lastBytesCount(rhs.lastBytesCount.load(std::memory_order_relaxed))
    , lastPacketsCount(rhs.lastPacketsCount)
    , attempts(rhs.attempts)
    , key(rhs.key)
    , in(std::move(rhs.in))
    , specialOut(rhs.specialOut)
    , out(std::move(rhs.out))
    , node(std::move(rhs.node))
    , isSignal(rhs.isSignal)
    , connected(rhs.connected)
    , msgRels(std::move(rhs.msgRels)) {
    }

    Connection(const Connection&) = delete;
    ~Connection() {
    }

    const ip::udp::endpoint& getOut() const {
        return specialOut ? out : in;
    }

    Id id = 0;

    static const uint32_t BytesLimit = 1 << 20;
    mutable std::atomic<uint32_t> lastBytesCount = {0};

    uint64_t lastPacketsCount = 0;
    uint32_t attempts = 0;

    cs::PublicKey key;
    ip::udp::endpoint in;

    bool specialOut = false;
    ip::udp::endpoint out;

    RemoteNodePtr node;

    bool isSignal = false;
    bool connected = false;

    bool isRequested = false;
    uint32_t syncNeighbourRetries = 0;

    struct MsgRel {
        uint32_t acceptOrder = 0;
        bool needSend = true;
    };

    FixedHashMap<cs::Hash, MsgRel, uint16_t, MaxMessagesToKeep> msgRels;

    cs::Sequence syncSeqs[BlocksToSync] = {0};
    cs::Sequence syncSeqsRetries[BlocksToSync] = {0};
    cs::Sequence lastSeq = 0;

    bool operator!=(const Connection& rhs) const {
        return id != rhs.id || key != rhs.key || in != rhs.in || specialOut != rhs.specialOut || (specialOut && out != rhs.out);
    }
};

using ConnectionPtr = MemPtr<TypedSlot<Connection>>;
using Connections = std::vector<ConnectionPtr>;

class Neighbourhood {
public:
    const static uint32_t MinConnections = 1;
    const static uint32_t MaxConnections = 1024;
    const static uint32_t MaxNeighbours = 256;
    const static uint32_t MinNeighbours = 3;
    const static uint32_t MaxConnectAttempts = 64;

    explicit Neighbourhood(Transport*);

    void sendByNeighbours(const Packet*);

    void establishConnection(const ip::udp::endpoint&);
    void addSignalServer(const ip::udp::endpoint& in, const ip::udp::endpoint& out, RemoteNodePtr);

    void gotRegistration(Connection&&, RemoteNodePtr);
    void gotConfirmation(const Connection::Id& my, const Connection::Id& real, const ip::udp::endpoint&, const cs::PublicKey&, RemoteNodePtr);
    void gotRefusal(const Connection::Id&);

    void resendPackets();
    void checkPending(const uint32_t maxNeighbours);
    void checkSilent();
    void checkNeighbours();

    void refreshLimits();

    bool canHaveNewConnection();

    void neighbourHasPacket(RemoteNodePtr, const cs::Hash&, const bool isDirect);
    void neighbourSentPacket(RemoteNodePtr, const cs::Hash&);
    void neighbourSentRenounce(RemoteNodePtr, const cs::Hash&);

    void redirectByNeighbours(const Packet*);
    void pourByNeighbours(const Packet*, const uint32_t packNum);

    uint32_t size() const;
    uint32_t getNeighboursCountWithoutSS() const;

    // no thread safe
    Connections getNeigbours() const;
    Connections getNeighboursWithoutSS() const;

    // uses to iterate connections
    std::unique_lock<cs::SpinLock> getNeighboursLock() const;

    // thread safe
    void forEachNeighbour(std::function<void(ConnectionPtr)> func);
    void forEachNeighbourWithoutSS(std::function<void(ConnectionPtr)> func);

    void pingNeighbours();
    bool isPingDone();
    bool validateConnectionId(RemoteNodePtr, const Connection::Id, const ip::udp::endpoint&, const cs::PublicKey&, const cs::Sequence);

    ConnectionPtr getConnection(const RemoteNodePtr);
    ConnectionPtr getNextRequestee(const cs::Hash&);
    ConnectionPtr getNextSyncRequestee(const cs::Sequence seq, bool& alreadyRequested);
    ConnectionPtr getNeighbour(const std::size_t number);
    ConnectionPtr getRandomSyncNeighbour();
    ConnectionPtr getNeighbourByKey(const cs::PublicKey&);

    void resetSyncNeighbours();
    void releaseSyncRequestee(const cs::Sequence seq);
    void registerDirect(const Packet*, ConnectionPtr);

private:
    struct BroadPackInfo {
        Packet pack;

        uint32_t attempts = 0;
        bool sentLastTime = false;

        Connection::Id receivers[MaxNeighbours];
        Connection::Id* recEnd = receivers;
    };

    struct DirectPackInfo {
        Packet pack;

        ConnectionPtr receiver;
        bool received = false;

        uint32_t attempts = 0;
    };

    bool isNewConnectionAvailable() const;
    bool dispatch(BroadPackInfo&);
    bool dispatch(DirectPackInfo&);

    ConnectionPtr getConnection(const ip::udp::endpoint&);

    void connectNode(RemoteNodePtr, ConnectionPtr);
    void disconnectNode(ConnectionPtr*);

    int getRandomSyncNeighbourNumber(const std::size_t attemptCount = 0);

    Transport* transport_;

    TypedAllocator<Connection> connectionsAllocator_;

    mutable cs::SpinLock nLockFlag_{ATOMIC_FLAG_INIT};
    FixedVector<ConnectionPtr, MaxNeighbours> neighbours_;

    mutable cs::SpinLock mLockFlag_{ATOMIC_FLAG_INIT};
    FixedHashMap<ip::udp::endpoint, ConnectionPtr, uint16_t, MaxConnections> connections_;

    struct SenderInfo {
        uint32_t totalSenders = 0;
        uint32_t reaskTimes = 0;
        ConnectionPtr prioritySender;
    };

    FixedHashMap<cs::Hash, SenderInfo, uint16_t, MaxMessagesToKeep> msgSenders_;
    FixedHashMap<cs::Hash, BroadPackInfo, uint16_t, 10000> msgBroads_;
    FixedHashMap<cs::Hash, DirectPackInfo, uint16_t, 10000> msgDirects_;
};

#endif  // NEIGHBOURHOOD_HPP
```
# ..\node\net\include\net\network.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef NETWORK_HPP
#define NETWORK_HPP

#ifdef __APPLE__
#include <sys/event.h>
#endif
#include <boost/asio.hpp>

#include <client/config.hpp>
#include <lib/system/cache.hpp>
#include "pacmans.hpp"

using io_context = boost::asio::io_context;

class Transport;

class Network {
public:
    explicit Network(const Config&, Transport*);
    ~Network();

    bool isGood() const {
        return good_;
    }

    ip::udp::endpoint resolve(const EndpointData&);

    void sendInit();
    void sendDirect(const Packet&, const ip::udp::endpoint&);

    bool resendFragment(const cs::Hash&, const uint16_t, const ip::udp::endpoint&);
    void registerMessage(Packet*, const uint32_t size);

    Network(const Network&) = delete;
    Network(Network&&) = delete;
    Network& operator=(const Network&) = delete;
    Network& operator=(Network&&) = delete;

    enum ThreadStatus {
        NonInit,
        Failed,
        Success
    };

private:
    void readerRoutine(const Config&);
    void writerRoutine(const Config&);
    void processorRoutine();
    inline void processTask(TaskPtr<IPacMan>&);

    ip::udp::socket* getSocketInThread(const bool, const EndpointData&, std::atomic<ThreadStatus>&, const bool useIPv6);

    bool good_;
    bool stopReaderRoutine = false;
    bool stopWriterRoutine = false;
    bool stopProcessorRoutine = false;

    io_context context_;
    ip::udp::resolver resolver_;

    IPacMan iPacMan_;
    OPacMan oPacMan_;

    Transport* transport_;

    FixedHashMap<cs::Hash, uint32_t, uint16_t, 100000> packetMap_;

    // Only needed in a one-socket configuration
    __cacheline_aligned std::atomic<bool> singleSockOpened_ = {false};
    __cacheline_aligned std::atomic<ip::udp::socket*> singleSock_ = {nullptr};
    std::atomic<bool> initFlag_ = {false};

    __cacheline_aligned std::atomic<ThreadStatus> readerStatus_ = {NonInit};
    __cacheline_aligned std::atomic<ThreadStatus> writerStatus_ = {NonInit};

    std::thread readerThread_;
    std::thread writerThread_;
    std::thread processorThread_;

    PacketCollector collector_;
#ifdef __linux__
    int readerEventfd_;
    int writerEventfd_;
#elif WIN32
    HANDLE readerEvent_ = nullptr;
    HANDLE writerEvent_ = nullptr;
#elif __APPLE__
    int readerKq_;
    int writerKq_;
    struct kevent readerEvent_;
    struct kevent writerEvent_;
#endif
#if defined(WIN32) || defined(__APPLE__)
    std::atomic<int> readerTaskCount_ = 0;
    std::atomic<int> writerTaskCount_ = 0;
    std::atomic_flag readerLock = ATOMIC_FLAG_INIT;
    std::atomic_flag writerLock = ATOMIC_FLAG_INIT;
#endif
};

#endif  // NETWORK_HPP
```
# ..\node\net\include\net\packet.hpp 
```cpp 
#ifndef PACKET_HPP
#define PACKET_HPP

#include <boost/asio.hpp>

#include <cscrypto/cscrypto.hpp>
#include <lib/system/allocators.hpp>
#include <lib/system/common.hpp>
#include <lib/system/hash.hpp>
#include <lib/system/logger.hpp>
#include "lib/system/utils.hpp"

#include <lz4.h>

#include <iostream>
#include <memory>

/*
    Static min memory usage (see types below):

    1 fragment = 1'024 b
    1 message = 80 b * 4'096 fragments = 327'680 b
    1 collector = 2'048 messages * 327'680 b = 671'088'640 b
*/

namespace ip = boost::asio::ip;

enum BaseFlags : uint8_t {
    NetworkMsg = 1,
    Fragmented = 1 << 1,
    Broadcast = 1 << 2,  // send packet to Neighbours, Neighbours can resend it to others
    Compressed = 1 << 3,
    Encrypted = 1 << 4,
    Signed = 1 << 5,
    Neighbours = 1 << 6,  // send packet to Neighbours only, Neighbours _cant_ resend it
};

enum Offsets : uint32_t {
    FragmentId = 1,
    FragmentsNum = 3,
    IdWhenFragmented = 5,
    IdWhenSingle = 1,
    SenderWhenFragmented = 13,
    SenderWhenSingle = 9,
    AddresseeWhenFragmented = cscrypto::kPublicKeySize + SenderWhenFragmented,
    AddresseeWhenSingle = cscrypto::kPublicKeySize + SenderWhenSingle
};

enum MsgTypes : uint8_t {
    RoundTableSS,
    Transactions,
    FirstTransaction,
    NewBlock,
    BlockHash,
    BlockRequest,
    RequestedBlock,
    FirstStage,
    SecondStage,
    ThirdStage,
    FirstStageRequest,
    SecondStageRequest,
    ThirdStageRequest,
    RoundTableRequest,
    RoundTableReply,
    TransactionPacket,
    TransactionsPacketRequest,
    TransactionsPacketReply,
    NewCharacteristic,
    WriterNotification,
    FirstSmartStage,
    SecondSmartStage,
    RoundTable = 22,
    ThirdSmartStage,
    SmartFirstStageRequest,
    SmartSecondStageRequest,
    SmartThirdStageRequest,
    HashReply,
    RejectedContracts,
    RoundPackRequest,
    BigBang = 35,
    NodeStopRequest = 255
};

class Packet {
public:
    static const uint32_t MaxSize = 1024;
    static const uint32_t MaxFragments = 4096;

    static const uint32_t SmartRedirectTreshold = 10000;

    static const char* messageTypeToString(MsgTypes messageType);

    Packet() = default;
    explicit Packet(RegionPtr&& data)
    : data_(std::move(data)) {
    }

    Packet(const Packet&) = default;
    Packet& operator=(const Packet&) = default;

    bool isNetwork() const {
        return checkFlag(BaseFlags::NetworkMsg);
    }
    bool isFragmented() const {
        return checkFlag(BaseFlags::Fragmented);
    }
    bool isBroadcast() const {
        return checkFlag(BaseFlags::Broadcast);
    }

    bool isCompressed() const {
        return checkFlag(BaseFlags::Compressed);
    }
    bool isNeighbors() const {
        return checkFlag(BaseFlags::Neighbours);
    }

    const cs::Hash& getHash() const {
        if (!hashed_) {
            hash_ = generateHash(data_.get(), data_.size());
            hashed_ = true;
        }
        return hash_;
    }

    bool addressedToMe(const cs::PublicKey& myKey) const {
        return isNetwork() || isNeighbors() || (isBroadcast() && !(getSender() == myKey)) || getAddressee() == myKey;
    }

    const cs::PublicKey& getSender() const {
        return getWithOffset<cs::PublicKey>(isFragmented() ? Offsets::SenderWhenFragmented : Offsets::SenderWhenSingle);
    }
    const cs::PublicKey& getAddressee() const {
        return getWithOffset<cs::PublicKey>(isFragmented() ? Offsets::AddresseeWhenFragmented : Offsets::AddresseeWhenSingle);
    }

    const uint64_t& getId() const {
        return getWithOffset<uint64_t>(isFragmented() ? Offsets::IdWhenFragmented : Offsets::IdWhenSingle);
    }

    const cs::Hash& getHeaderHash() const;
    bool isHeaderValid() const;

    const uint16_t& getFragmentId() const {
        return getWithOffset<uint16_t>(Offsets::FragmentId);
    }
    const uint16_t& getFragmentsNum() const {
        return getWithOffset<uint16_t>(Offsets::FragmentsNum);
    }

    MsgTypes getType() const {
        return getWithOffset<MsgTypes>(getHeadersLength());
    }
    cs::RoundNumber getRoundNum() const {
        return getWithOffset<cs::RoundNumber>(getHeadersLength() + 1);
    }

    void* data() {
        return data_.get();
    }
    const void* data() const {
        return data_.get();
    }

    size_t size() const {
        return data_.size();
    }

    const uint8_t* getMsgData() const {
        return static_cast<const uint8_t*>(data_.get()) + getHeadersLength();
    }
    size_t getMsgSize() const {
        return size() - getHeadersLength();
    }

    uint32_t getHeadersLength() const;
    void recalculateHeadersLength();

    explicit operator bool() {
        return !data_.isNull();
    }

    boost::asio::mutable_buffer encode(boost::asio::mutable_buffer tempBuffer) {
        if (data_.size() == 0) {
            cswarning() << "Encoding empty packet";
            return boost::asio::buffer(tempBuffer.data(), 0);
        }

        if (isCompressed()) {
            static_assert(sizeof(BaseFlags) == sizeof(char), "BaseFlags should be char sized");
            const size_t headerSize = getHeadersLength();

            // Packet::MaxSize is a part of implementation magic(
            assert(tempBuffer.size() == Packet::MaxSize);

            char* source = static_cast<char*>(data_.get());
            char* dest = static_cast<char*>(tempBuffer.data());

            // copy header
            std::copy(source, source + headerSize, dest);

            int sourceSize = static_cast<int>(data_.size() - headerSize);
            int destSize = static_cast<int>(tempBuffer.size() - headerSize);

            int compressedSize = LZ4_compress_default(source + headerSize, dest + headerSize, sourceSize, destSize);

            if ((compressedSize > 0) && (compressedSize < sourceSize)) {
                return boost::asio::buffer(dest, static_cast<size_t>(compressedSize) + headerSize);
            }
            else {
                csdebug() << "Skipping packet compression, rawSize = " << sourceSize << ", compressedSize = " << compressedSize;
                *source &= ~BaseFlags::Compressed;
            }
        }

        char* source = static_cast<char*>(data_.get());
        char* dest = static_cast<char*>(tempBuffer.data());
        std::copy(source, source + data_.size(), dest);
        return boost::asio::buffer(dest, data_.size());
    }

    size_t decode(size_t packetSize = 0) {
        if (packetSize == 0) {
            return 0;
        }

        if (isCompressed()) {
            static_assert(sizeof(BaseFlags) == sizeof(char), "BaseFlags should be char sized");
            const size_t headerSize = getHeadersLength();

            assert(headerSize <= packetSize);
            if (headerSize > packetSize) {
                cserror() << "Malformed compressed packet detected";
                return 0;
            }
            if (headerSize == packetSize) {
                cserror() << "Data is empty in compressed packet";
                return 0;
            }

            // It's a part of implementation magic(
            // eg. <IPackMan> allocates Packet::MaxSize packet implicitly
            assert(data_.size() == Packet::MaxSize);

            char* source = static_cast<char*>(data_.get());
            char dest[Packet::MaxSize];

            int sourceSize = static_cast<int>(packetSize - headerSize);
            int destSize = static_cast<int>(sizeof(dest) - headerSize);

            auto uncompressedSize = LZ4_decompress_safe(source + headerSize, dest, sourceSize, destSize);

            if ((uncompressedSize > 0) && (uncompressedSize <= destSize)) {
                std::copy(dest, dest + uncompressedSize, source + headerSize);
                *source &= ~BaseFlags::Compressed;
                packetSize = static_cast<size_t>(uncompressedSize) + headerSize;
            }
            else {
                cserror() << "Decoding malformed packet content";
                return 0;
            }
        }

        return packetSize;
    }

    // returns true if is not fragmented or has valid fragmebtation data
    bool hasValidFragmentation() const {
        if (isFragmented()) {
            const auto fragment = getFragmentId();
            const auto count = getFragmentsNum();
            if (count == 0 || fragment >= MaxFragments || count >= MaxFragments || fragment >= count) {
                return false;
            }
        }
        return true;
    }

private:
    bool checkFlag(const BaseFlags flag) const {
        return (*static_cast<const uint8_t*>(data_.get()) & flag) != 0;
    }

    uint32_t calculateHeadersLength() const;

    template <typename T>
    const T& getWithOffset(const uint32_t offset) const {
        return *(reinterpret_cast<const T*>(static_cast<const uint8_t*>(data_.get()) + offset));
    }

private:
    RegionPtr data_;
    friend class Network;

    mutable bool hashed_ = false;
    mutable cs::Hash hash_;

    mutable bool headerHashed_ = false;
    mutable cs::Hash headerHash_;

    mutable uint32_t headersLength_ = 0;

    friend class IPacMan;
    friend class Message;
};

using PacketPtr = Packet*;

class Message {
public:
    Message() = default;

    Message(Message&&) = default;
    Message& operator=(Message&&) = default;

    Message(const Message&) = delete;
    Message& operator=(const Message&) = delete;

    ~Message();

    bool isComplete() const {
        return packetsLeft_ == 0;
    }

    const Packet& getFirstPack() const {
        return *packets_;
    }

    const uint8_t* getFullData() const {
        if (!fullData_) {
            composeFullData();
        }
        return static_cast<const uint8_t*>(fullData_.get()) + packets_->getHeadersLength();
    }

    size_t getFullSize() const {
        if (!fullData_) {
            composeFullData();
        }
        return fullData_.size() - packets_->getHeadersLength();
    }

    Packet extractData() const {
        if (!fullData_)
            composeFullData();
        Packet result(std::move(fullData_));
        result.headersLength_ = packets_->getHeadersLength();
        return result;
    }

    // scans array of future fragments and clears all dirty elements, scans only the first maxFragment elements
    // return cleared elements count
    size_t clearFragments() {
        return clearBuffer(0, maxFragment_);
    }

    // scans array of future fragments and clears all dirty elements, scans only unused behind the maxFragment elements
    // return cleared elements count
    size_t clearUnused() {
        return clearBuffer(maxFragment_, Packet::MaxFragments);
    }

private:
    size_t clearBuffer(size_t from, size_t to);

    static RegionAllocator allocator_;

    void composeFullData() const;

    cs::SpinLock pLock_{ATOMIC_FLAG_INIT};

    uint32_t packetsLeft_;
    uint32_t packetsTotal_ = 0;

    uint16_t maxFragment_ = 0;
    Packet packets_[Packet::MaxFragments];

    cs::Hash headerHash_;

    mutable RegionPtr fullData_;

    friend class PacketCollector;
    friend class Transport;
    friend class Network;
};

using MessagePtr = MemPtr<TypedSlot<Message>>;

class PacketCollector {
public:
    static const uint32_t MaxParallelCollections = 1024;

    PacketCollector()
    : msgAllocator_(MaxParallelCollections + 1) {
    }

    MessagePtr getMessage(const Packet&, bool&);

private:
    TypedAllocator<Message> msgAllocator_;

    cs::SpinLock mLock_{ATOMIC_FLAG_INIT};
    FixedHashMap<cs::Hash, MessagePtr, uint16_t, MaxParallelCollections> map_;

    Message lastMessage_;
    friend class Network;
};

std::ostream& operator<<(std::ostream& os, const Packet& packet);

#endif  // PACKET_HPP
```
# ..\node\net\include\net\packetvalidator.hpp 
```cpp 
#ifndef PACKETVALIDATOR_HPP
#define PACKETVALIDATOR_HPP

#include <net/transport.hpp>

namespace cs {
class PacketValidator {
public:
    static PacketValidator& instance();

    bool validate(const Packet& pack);
    bool validate(const Message& msg);

    const cs::PublicKey& getStarterKey() const {
        return starterKey_;
    }

private:
    cs::PublicKey starterKey_;

    PacketValidator();

    bool validate(MsgTypes msg, const uint8_t* data, size_t size);
    bool validateFirstFragment(MsgTypes msg, const uint8_t* data, size_t size);

    bool validateStarterSignature(const uint8_t* data, size_t size);

    bool validateRegistration(size_t size);
    bool validateStarterRegistration(const Packet& pack);
    bool validateStopRequest(const uint8_t* data, size_t size);
};
}  // namespace cs

#endif // PACKETVALIDATOR_HPP
```
# ..\node\net\include\net\pacmans.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef PACMANS_HPP
#define PACMANS_HPP

#include <atomic>
#include <boost/asio.hpp>
#include <list>
#include <mutex>

#include "packet.hpp"

namespace ip = boost::asio::ip;

template <typename Pacman>
class TaskPtr {
public:
    TaskPtr(TaskPtr&& rhs)
    : it_(rhs.it_)
    , owner_(rhs.owner_) {
        valid_ = true;
        rhs.valid_ = false;
    }

    TaskPtr(const TaskPtr&) = delete;
    TaskPtr& operator=(const TaskPtr&) = delete;
    TaskPtr& operator=(TaskPtr&&) = delete;

    ~TaskPtr() {
        if (valid_) {
            owner_->releaseTask(it_);
            //      valid_ = false;
        }
    }

    typename Pacman::Task* operator->() {
        return &(static_cast<typename Pacman::Task&>(*it_));
    }
    const typename Pacman::Task* operator->() const {
        return &(static_cast<typename Pacman::Task&>(*it_));
    }

private:
    TaskPtr() {
    }

    typename Pacman::TaskIterator it_;
    Pacman* owner_;
    bool valid_ = true;

    friend Pacman;
};

template <typename Task>
struct TaskBody {
    operator Task&() {
        return *reinterpret_cast<Task*>(data);
    }

    char data[sizeof(Task)];
};

class IPacMan {
public:
    IPacMan()
    : allocator_(1 << 20) {
    }

    struct Task {
        ip::udp::endpoint sender;
        size_t size;
        Packet pack;
    };

    Task& allocNext();
    void enQueueLast();

    TaskPtr<IPacMan> getNextTask();

    using TaskIterator = std::list<TaskBody<Task>>::iterator;
    void releaseTask(TaskIterator&);
    void rejectLast();

private:
    std::list<TaskBody<Task>> queue_;
    std::mutex mutex_;
    std::atomic<size_t> size_ = {0};
    RegionAllocator allocator_;
};

class OPacMan {
public:
    struct Task {
        ip::udp::endpoint endpoint;
        Packet pack;
    };

    Task* allocNext();
    void enQueueLast();

    TaskPtr<OPacMan> getNextTask();

    using TaskIterator = std::list<TaskBody<Task>>::iterator;
    void releaseTask(TaskIterator&);

private:
    std::list<TaskBody<Task>> queue_;
    std::mutex mutex_;
    std::atomic<size_t> size_ = {0};
};

#endif  // PACMANS_HPP
```
# ..\node\net\include\net\transport.hpp 
```cpp 
/* Send blaming letters to @yrtimd */
#ifndef TRANSPORT_HPP
#define TRANSPORT_HPP

#include <boost/asio.hpp>
#include <csignal>

#include <client/config.hpp>

#include <csnode/node.hpp>
#include <csnode/packstream.hpp>

#include <lib/system/allocators.hpp>
#include <lib/system/cache.hpp>
#include <lib/system/common.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/signals.hpp>

#include <net/network.hpp>

#include "neighbourhood.hpp"
#include "packet.hpp"
#include "pacmans.hpp"

inline volatile std::sig_atomic_t gSignalStatus = 0;

using ConnectionId = uint64_t;
using Tick = uint64_t;
using PingSignal = cs::Signal<void(cs::Sequence, const cs::PublicKey&)>;

enum class NetworkCommand : uint8_t {
    Registration = 2,
    ConfirmationRequest,
    ConfirmationResponse,
    RegistrationConfirmed,
    RegistrationRefused,
    Ping,
    PackInform,
    PackRequest,
    PackRenounce,
    BlockSyncRequest,
    SSRegistration = 1,
    SSFirstRound = 31,
    SSRegistrationRefused = 25,
    SSPingWhiteNode = 32,
    SSLastBlock = 34,
    SSReRegistration = 36,
    SSSpecificBlock = 37,
};

enum class RegistrationRefuseReasons : uint8_t {
    Unspecified,
    LimitReached,
    BadId,
    BadClientVersion,
    Timeout,
    BadResponse,
    IncompatibleBlockchain
};

enum class SSBootstrapStatus : uint8_t {
    Empty,
    Requested,
    RegisteredWait,
    Complete,
    Denied
};

template <>
uint16_t getHashIndex(const ip::udp::endpoint&);

class Transport {
public:
    Transport(const Config& config, Node* node)
    : config_(config)
    , sendPacksFlag_()
    , remoteNodes_(maxRemoteNodes_ + 1)
    , netPacksAllocator_(1 << 24, 1)
    , myPublicKey_(node->getNodeIdKey())
    , oLock_()
    , oPackStream_(&netPacksAllocator_, node->getNodeIdKey())
    , uLock_()
    , net_(new Network(config, this))
    , node_(node)
    , nh_(this) {
        good_ = net_->isGood();
    }

    ~Transport();

    void run();

    inline static volatile std::sig_atomic_t gSignalStatus = 0;

    static void stop() {
        Transport::gSignalStatus = 1;
    }

    static const char* networkCommandToString(NetworkCommand command);

    RemoteNodePtr getPackSenderEntry(const ip::udp::endpoint&);

    void processNetworkTask(const TaskPtr<IPacMan>&, RemoteNodePtr&);
    void processNodeMessage(const Message&);
    void processNodeMessage(const Packet&);

    void addTask(Packet*, const uint32_t packNum, bool incrementWhenResend = false);
    void clearTasks();

    const cs::PublicKey& getMyPublicKey() const {
        return myPublicKey_;
    }

    bool isGood() const {
        return good_;
    }

    void sendBroadcast(const Packet* pack) {
        nh_.sendByNeighbours(pack);
    }

    bool sendDirect(const Packet*, const Connection&);
    void deliverDirect(const Packet*, const uint32_t, ConnectionPtr);
    void deliverBroadcast(const Packet*, const uint32_t);

    void gotPacket(const Packet&, RemoteNodePtr&);
    void redirectPacket(const Packet&, RemoteNodePtr&);
    bool shouldSendPacket(const Packet&);

    void refillNeighbourhood();
    void processPostponed(const cs::RoundNumber);

    void sendRegistrationRequest(Connection&);
    void sendRegistrationConfirmation(const Connection&, const Connection::Id);
    void sendRegistrationRefusal(const Connection&, const RegistrationRefuseReasons);
    void sendPackRenounce(const cs::Hash&, const Connection&);
    void sendPackInform(const Packet&, const Connection&);
    void sendPackInform(const Packet& pack, RemoteNodePtr&);

    void sendPingPack(const Connection&);

    void registerMessage(MessagePtr);

    // neighbours interface
    uint32_t getNeighboursCount();
    uint32_t getNeighboursCountWithoutSS();
    uint32_t getMaxNeighbours() const;
    ConnectionPtr getSyncRequestee(const cs::Sequence seq, bool& alreadyRequested);
    ConnectionPtr getConnectionByKey(const cs::PublicKey& pk);
    ConnectionPtr getConnectionByNumber(const std::size_t number);
    ConnectionPtr getRandomNeighbour();

    std::unique_lock<cs::SpinLock> getNeighboursLock() const;

    // thread safe negihbours methods
    void forEachNeighbour(std::function<void(ConnectionPtr)> func);
    void forEachNeighbourWithoudSS(std::function<void(ConnectionPtr)> func);

    // no thread safe
    const Connections getNeighbours() const;
    const Connections getNeighboursWithoutSS() const;

    void syncReplied(const cs::Sequence seq);
    bool isPingDone();
    void resetNeighbours();

public signals:
    PingSignal pingReceived;

private:
    void registerTask(Packet* pack, const uint32_t packNum, const bool);
    void postponePacket(const cs::RoundNumber, const MsgTypes, const Packet&);

    // Dealing with network connections
    bool parseSSSignal(const TaskPtr<IPacMan>&);

    void dispatchNodeMessage(const MsgTypes, const cs::RoundNumber, const Packet&, const uint8_t* data, size_t);

    /* Network packages processing */
    bool gotRegistrationRequest(const TaskPtr<IPacMan>&, RemoteNodePtr&);

    bool gotRegistrationConfirmation(const TaskPtr<IPacMan>&, RemoteNodePtr&);

    bool gotRegistrationRefusal(const TaskPtr<IPacMan>&, RemoteNodePtr&);

    bool gotSSRegistration(const TaskPtr<IPacMan>&, RemoteNodePtr&);
    bool gotSSReRegistration();
    bool gotSSRefusal(const TaskPtr<IPacMan>&);
    bool gotSSDispatch(const TaskPtr<IPacMan>&);
    bool gotSSPingWhiteNode(const TaskPtr<IPacMan>&);
    bool gotSSLastBlock(const TaskPtr<IPacMan>&, cs::Sequence, const csdb::PoolHash&, bool canBeTrusted);

    bool gotPackInform(const TaskPtr<IPacMan>&, RemoteNodePtr&);
    bool gotPackRenounce(const TaskPtr<IPacMan>&, RemoteNodePtr&);
    bool gotPackRequest(const TaskPtr<IPacMan>&, RemoteNodePtr&);

    bool gotPing(const TaskPtr<IPacMan>&, RemoteNodePtr&);

    void askForMissingPackages();
    void requestMissing(const cs::Hash&, const uint16_t, const uint64_t);

    /* Actions */
    bool good_;
    Config config_;

    static const uint32_t maxPacksQueue_ = 2048;
    static const uint32_t maxRemoteNodes_ = 4096;

    cs::SpinLock sendPacksFlag_{ATOMIC_FLAG_INIT};

    struct PackSendTask {
        Packet pack;
        uint32_t resendTimes = 0;
        bool incrementId;
    };

    FixedCircularBuffer<PackSendTask, maxPacksQueue_> sendPacks_;

    TypedAllocator<RemoteNode> remoteNodes_;

    FixedHashMap<ip::udp::endpoint, RemoteNodePtr, uint16_t, maxRemoteNodes_> remoteNodesMap_;

    RegionAllocator netPacksAllocator_;
    cs::PublicKey myPublicKey_;

    cs::IPackStream iPackStream_;

    cs::SpinLock oLock_{ATOMIC_FLAG_INIT};
    cs::OPackStream oPackStream_;

    // SS Data
    SSBootstrapStatus ssStatus_ = SSBootstrapStatus::Empty;
    ip::udp::endpoint ssEp_;

    // Registration data
    Packet regPack_;
    uint64_t* regPackConnId_;
    bool acceptRegistrations_ = false;

    struct PostponedPacket {
        cs::RoundNumber round;
        MsgTypes type;
        Packet pack;

        PostponedPacket(const cs::RoundNumber r, const MsgTypes t, const Packet& p)
        : round(r)
        , type(t)
        , pack(p) {
        }
    };

    static constexpr uint32_t posponedBufferSize_ = 1024;
    using PPBuf = FixedCircularBuffer<PostponedPacket, posponedBufferSize_>;

    PPBuf postponedPacketsFirst_;
    PPBuf postponedPacketsSecond_;

    static constexpr uint32_t posponedPointerBufferSize_ = 2;
    PPBuf* postponed_[posponedPointerBufferSize_] = {&postponedPacketsFirst_, &postponedPacketsSecond_};

    cs::SpinLock uLock_{ATOMIC_FLAG_INIT};
    FixedCircularBuffer<MessagePtr, PacketCollector::MaxParallelCollections> uncollected_;

    cs::Sequence maxBlock_ = 0;
    cs::Sequence maxBlockCount_;

    Network* net_;
    Node* node_;

    Neighbourhood nh_;

    static constexpr uint32_t fragmentsFixedMapSize_ = 10000;
    FixedHashMap<cs::Hash, cs::RoundNumber, uint16_t, fragmentsFixedMapSize_> fragOnRound_;

public:
    inline static size_t cntDirtyAllocs = 0;
    inline static size_t cntCorruptedFragments = 0;
    inline static size_t cntExtraLargeNotSent = 0;
};

#endif  // TRANSPORT_HPP
```
# ..\node\net\src\neighbourhood.cpp 
```cpp 
/* Send blaming letters to @yrtimd */
#include "neighbourhood.hpp"
#include "transport.hpp"

#include <cscrypto/cscrypto.hpp>
#include <csnode/blockchain.hpp>
#include <lib/system/random.hpp>

Neighbourhood::Neighbourhood(Transport* net)
: transport_(net)
, connectionsAllocator_(MaxConnections + 1)
, nLockFlag_()
, mLockFlag_() {
}

template <typename T>
T getSecureRandom() {
    T result;
    cscrypto::fillBufWithRandomBytes(static_cast<void*>(&result), sizeof(T));
    return result;
}

bool Neighbourhood::dispatch(Neighbourhood::BroadPackInfo& bp) {
    bool result = false;

    if (bp.sentLastTime) {
        return true;
    }

    if (bp.attempts > MaxResendTimes || !transport_->shouldSendPacket(bp.pack)) {
        return result;
    }

    bool sent = false;

    for (auto& nb : neighbours_) {
        bool found = false;
        for (auto ptr = bp.receivers; ptr != bp.recEnd; ++ptr) {
            if (*ptr == nb->id) {
                found = true;
                break;
            }
        }

        if (!found) {
            if (!nb->isSignal || (!bp.pack.isNetwork() && (bp.pack.getType() == MsgTypes::RoundTable || bp.pack.getType() == MsgTypes::BlockHash))) {
                sent = transport_->sendDirect(&(bp.pack), **nb) || sent;
            }

            // Assume the SS got this
            if (nb->isSignal) {
                *(bp.recEnd++) = nb->id;
            }
            else {
                result = true;
            }
        }
    }

    if (sent) {
        ++bp.attempts;
        bp.sentLastTime = true;
    }

    return result;
}

bool Neighbourhood::dispatch(Neighbourhood::DirectPackInfo& dp) {
    if (dp.received || dp.attempts > MaxResendTimes) {
        return false;
    }

    if (transport_->sendDirect(&(dp.pack), **dp.receiver)) {
        ++dp.attempts;
    }

    return true;
}

void Neighbourhood::sendByNeighbours(const Packet* pack) {
    cs::Lock lock(nLockFlag_);

    if (pack->isNeighbors()) {
        for (auto& nb : neighbours_) {
            auto& bp = msgDirects_.tryStore(pack->getHash());

            bp.pack = *pack;
            bp.receiver = nb;

            transport_->sendDirect(pack, **nb);
        }
    }
    else {
        auto& bp = msgBroads_.tryStore(pack->getHash());

        if (!bp.pack) {
            bp.pack = *pack;
        }

        dispatch(bp);
    }
}

bool Neighbourhood::canHaveNewConnection() {
    cs::Lock lock(nLockFlag_);
    return neighbours_.size() < MaxNeighbours;
}

void Neighbourhood::checkPending(const uint32_t) {
    cs::Lock lock(mLockFlag_);
    for (auto conn = connections_.begin(); conn != connections_.end(); ++conn) {
        // Attempt to reconnect if the connection hasn't been established yet
        if (!(**conn)->connected && (**conn)->attempts < MaxConnectAttempts) {
            transport_->sendRegistrationRequest(****conn);
        }
    }
}

void Neighbourhood::refreshLimits() {
    cs::Lock lock(nLockFlag_);
    for (auto conn = neighbours_.begin(); conn != neighbours_.end(); ++conn) {
        for (cs::Sequence i = 0; i < BlocksToSync; ++i) {
            if (++((*conn)->syncSeqsRetries[i]) >= MaxSyncAttempts) {
                (*conn)->syncSeqs[i] = 0;
                (*conn)->syncSeqsRetries[i] = 0;
            }
        }

        (*conn)->lastBytesCount.store(0, std::memory_order_relaxed);
    }
}

void Neighbourhood::checkSilent() {
    static uint32_t refillCount = 0;

    bool needRefill = true;
    cs::ScopedLock lock(mLockFlag_, nLockFlag_);

    for (auto conn = neighbours_.begin(); conn != neighbours_.end(); ++conn) {
        if (!(*conn)->node) {
            ConnectionPtr tc = *conn;
            csunused(tc);
            disconnectNode(conn);
            --conn;
            continue;
        }

        if ((*conn)->isSignal) {
            continue;
        }

        const auto packetsCount = (*(*conn)->node)->packets.load(std::memory_order_relaxed);

        if (packetsCount == (*conn)->lastPacketsCount) {
            cswarning() << "Node " << (*conn)->in << " stopped responding";

            ConnectionPtr tc = *conn;
            Connection* c = *tc;
            tc->node->connection.compare_exchange_strong(c, nullptr, std::memory_order_release, std::memory_order_relaxed);

            disconnectNode(conn);
            --conn;
        }
        else {
            needRefill = false;
            (*conn)->lastPacketsCount = packetsCount;
        }
    }

    if (needRefill) {
        ++refillCount;
        if (refillCount >= WarnsBeforeRefill) {
            refillCount = 0;
            transport_->refillNeighbourhood();
        }
    }
    else {
        refillCount = 0;
    }
}

void Neighbourhood::checkNeighbours() {
    uint32_t size = 0;

    {
        cs::Lock lock(nLockFlag_);
        size = neighbours_.size();
    }

    if (size < MinNeighbours) {
        transport_->refillNeighbourhood();
    }
}

template <typename Vec>
static ConnectionPtr* findInVec(const Connection::Id& id, Vec& vec) {
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if ((*it)->id == id) {
            return it;
        }
    }

    return nullptr;
}

template <typename Vec>
static ConnectionPtr* findInMap(const Connection::Id& id, Vec& vec) {
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (it->data->id == id) {
            return &(it->data);
        }
    }

    return nullptr;
}

static ip::udp::endpoint getIndexingEndpoint(const ip::udp::endpoint& ep) {
    if (ep.address().is_v6()) {
        return ep;
    }

    return ip::udp::endpoint(ip::make_address_v6(ip::v4_mapped, ep.address().to_v4()), ep.port());
}

ConnectionPtr Neighbourhood::getConnection(const ip::udp::endpoint& ep) {
    cswarning() << "Getting connection";
    auto& conn = connections_.tryStore(getIndexingEndpoint(ep));

    if (!conn) {
        conn = connectionsAllocator_.emplace();
        conn->in = ep;
    }

    return conn;
}

void Neighbourhood::establishConnection(const ip::udp::endpoint& ep) {
    cswarning() << "Establishing connection to " << ep;

    cs::Lock lp(mLockFlag_);
    auto conn = getConnection(ep);

    if (!conn->id) {
        conn->id = getSecureRandom<Connection::Id>();
    }

    if (!conn->connected) {
        transport_->sendRegistrationRequest(**conn);
    }
}

uint32_t Neighbourhood::size() const {
    cs::Lock lock(nLockFlag_);
    return neighbours_.size();
}

uint32_t Neighbourhood::getNeighboursCountWithoutSS() const {
    cs::Lock lock(nLockFlag_);
    uint32_t count = 0;

    for (auto& nb : neighbours_) {
        if (!nb->isSignal) {
            ++count;
        }
    }

    return count;
}

Connections Neighbourhood::getNeigbours() const {
    Connections connections;
    connections.reserve(neighbours_.size());

    std::copy(std::begin(neighbours_), std::end(neighbours_), std::back_inserter(connections));
    return connections;
}

Connections Neighbourhood::getNeighboursWithoutSS() const {
    Connections connections;
    connections.reserve(neighbours_.size());

    std::copy_if(std::begin(neighbours_), std::end(neighbours_), std::back_inserter(connections), [&](const ConnectionPtr neighbour) { return (!neighbour->isSignal); });

    return connections;
}

std::unique_lock<cs::SpinLock> Neighbourhood::getNeighboursLock() const {
    return std::unique_lock<cs::SpinLock>(nLockFlag_);
}

void Neighbourhood::forEachNeighbour(std::function<void(ConnectionPtr)> func) {
    cs::Lock lock(nLockFlag_);
    for (const ConnectionPtr& connection : neighbours_) {
        if (connection) {
            func(connection);
        }
    }
}

void Neighbourhood::forEachNeighbourWithoutSS(std::function<void(ConnectionPtr)> func) {
    cs::Lock lock(nLockFlag_);
    for (const ConnectionPtr& connection : neighbours_) {
        if (connection && !connection->isSignal) {
            func(connection);
        }
    }
}

void Neighbourhood::addSignalServer(const ip::udp::endpoint& in, const ip::udp::endpoint& out, RemoteNodePtr node) {
    cs::ScopedLock scopeLock(mLockFlag_, nLockFlag_);

    if ((*node)->connection.load(std::memory_order_relaxed)) {
        cserror() << "Connection with the SS node has already been established";
        return;
    }

    ConnectionPtr conn = getConnection(out);
    if (!conn->id) {
        conn->id = getSecureRandom<Connection::Id>();
    }

    conn->in = in;

    if (in != out) {
        conn->specialOut = true;
        conn->out = out;
    }

    conn->isSignal = true;
    connectNode(node, conn);
}

/* Assuming both the mutexes have been locked */
void Neighbourhood::connectNode(RemoteNodePtr node, ConnectionPtr conn) {
    Connection* connection = nullptr;
    while (!node->connection.compare_exchange_strong(connection, *conn, std::memory_order_release, std::memory_order_relaxed));

    if (connection) {
        auto connPtr = findInVec(connection->id, neighbours_);
        if (connPtr) {
            disconnectNode(connPtr);
        }
    }

    conn->node = node;

    if (conn->connected) {
        return;
    }

    conn->connected = true;
    conn->attempts = 0;

    if (!isNewConnectionAvailable()) {
        cswarning() << "Can not add neighbour, neighbours size is equal to max possible neighbours";
        return;
    }

    neighbours_.emplace(conn);
}

void Neighbourhood::disconnectNode(ConnectionPtr* connPtr) {
    (*connPtr)->connected = false;
    (*connPtr)->node = RemoteNodePtr();
    neighbours_.remove(connPtr);
}

void Neighbourhood::gotRegistration(Connection&& conn, RemoteNodePtr node) {
    cs::ScopedLock scopedLock(mLockFlag_, nLockFlag_);
    ConnectionPtr& connPtr = connections_.tryStore(getIndexingEndpoint(conn.getOut()));

    if (!connPtr) {
        connPtr = connectionsAllocator_.emplace(std::move(conn));
    }
    else {
        if (conn.id < connPtr->id) {
            connPtr->id = conn.id;
        }

        connPtr->key = conn.key;

        connPtr->in = conn.in;
        connPtr->specialOut = conn.specialOut;
        connPtr->out = conn.out;
    }

    connectNode(node, connPtr);

    // check if transport available
    if (!transport_->isGood()) {
        cserror() << "Transport is not available!";
        return;
    }

    transport_->sendRegistrationConfirmation(**connPtr, conn.id);
}

void Neighbourhood::gotConfirmation(const Connection::Id& my, const Connection::Id& real, const ip::udp::endpoint& ep, const cs::PublicKey& pk, RemoteNodePtr node) {
    cs::ScopedLock scopedLock(mLockFlag_, nLockFlag_);
    ConnectionPtr* connPtr = findInMap(my, connections_);

    if (!connPtr) {
        cswarning() << "Connection with ID " << my << " not found";
        return;
    }

    if (ep != (*connPtr)->in) {
        (*connPtr)->out = (*connPtr)->in;
        (*connPtr)->specialOut = true;
        (*connPtr)->in = ep;
    }

    (*connPtr)->key = pk;

    if (my != real) {
        (*connPtr)->id = real;
    }

    connectNode(node, *connPtr);
}

bool Neighbourhood::validateConnectionId(RemoteNodePtr node, const Connection::Id id, const ip::udp::endpoint& ep, const cs::PublicKey& pk, const cs::Sequence lastSeq) {
    cs::ScopedLock scopedLock(mLockFlag_, nLockFlag_);

    bool result = true;
    auto realPtr = findInMap(id, connections_);
    auto nConn = node->connection.load(std::memory_order_relaxed);

    if (!realPtr) {
        if (nConn) {
            cswarning() << "[NET] got ping from " << ep << " but the remote node is bound to " << nConn->getOut();
            transport_->sendRegistrationRequest(*nConn);
            nConn->lastSeq = lastSeq;
        }
        else {
            cswarning() << "[NET] got ping from " << ep << " but no connection bound, sending refusal";

            Connection conn;
            conn.id = id;
            conn.in = ep;
            conn.specialOut = false;
            transport_->sendRegistrationRefusal(conn, RegistrationRefuseReasons::BadId);
        }

        result = !result;
    }
    else if (realPtr->get() != nConn) {
        if (nConn) {
            cswarning() << "[NET] got ping from " << ep << " introduced as " << (*realPtr)->getOut() << " but the remote node is bound to " << nConn->getOut();
            transport_->sendRegistrationRequest(*nConn);
        }
        else {
            cswarning() << "[NET] got ping from " << ep << " introduced as " << (*realPtr)->getOut() << " and there is no bindings, sending reg";
        }

        (*realPtr)->lastSeq = lastSeq;
        (*realPtr)->key = pk;

        connectNode(node, *realPtr);
        transport_->sendRegistrationRequest(***realPtr);
    }
    else {
        (*realPtr)->lastSeq = lastSeq;
    }

    return result;
}

void Neighbourhood::gotRefusal(const Connection::Id& id) {
    cs::ScopedLock scopedLock(mLockFlag_, nLockFlag_);
    auto realPtr = findInMap(id, connections_);

    if (realPtr) {
        transport_->sendRegistrationRequest(***realPtr);
    }
}

void Neighbourhood::neighbourHasPacket(RemoteNodePtr node, const cs::Hash& hash, const bool isDirect) {
    cs::Lock lock(nLockFlag_);
    auto conn = node->connection.load(std::memory_order_relaxed);

    if (!conn) {
        return;
    }

    if (isDirect) {
        auto& dp = msgDirects_.tryStore(hash);
        dp.received = true;
    }
    else {
        auto& bp = msgBroads_.tryStore(hash);

        for (auto ptr = bp.receivers; ptr != bp.recEnd; ++ptr) {
            if (*ptr == conn->id) {
                return;
            }
        }

        if ((bp.recEnd - bp.receivers) < MaxNeighbours) {
            *(bp.recEnd++) = conn->id;
        }
    }
}

void Neighbourhood::neighbourSentPacket(RemoteNodePtr node, const cs::Hash& hash) {
    cs::Lock lock(nLockFlag_);
    auto connection = node->connection.load(std::memory_order_acquire);

    if (!connection) {
        return;
    }

    Connection::MsgRel& rel = connection->msgRels.tryStore(hash);
    SenderInfo& sInfo = msgSenders_.tryStore(hash);

    rel.needSend = false;

    if (!sInfo.prioritySender) {
        // First time
        auto connPtr = findInVec(connection->id, neighbours_);

        if (connPtr) {
            sInfo.prioritySender = *connPtr;

            rel.acceptOrder = sInfo.totalSenders++;

            for (auto& nb : neighbours_) {
                if (nb->id != connection->id) {
                    transport_->sendPackRenounce(hash, **nb);
                }
            }
        }
    }
    else if (*sInfo.prioritySender != connection) {
        if (!rel.acceptOrder) {
            rel.acceptOrder = ++sInfo.totalSenders;
        }

        transport_->sendPackRenounce(hash, *connection);
    }
}

void Neighbourhood::neighbourSentRenounce(RemoteNodePtr node, const cs::Hash& hash) {
    cs::Lock lock(nLockFlag_);
    auto connection = node->connection.load(std::memory_order_acquire);

    if (connection) {
        SenderInfo& si = msgSenders_.tryStore(hash);
        Connection::MsgRel& rel = connection->msgRels.tryStore(hash);
        rel.acceptOrder = si.totalSenders++;
        rel.needSend = false;
    }
}

void Neighbourhood::redirectByNeighbours(const Packet* pack) {
    cs::Lock lock(nLockFlag_);

    for (auto& nb : neighbours_) {
        Connection::MsgRel& rel = nb->msgRels.tryStore(pack->getHeaderHash());
        if (rel.needSend) {
            transport_->sendDirect(pack, **nb);
        }
    }
}

void Neighbourhood::pourByNeighbours(const Packet* pack, const uint32_t packNum) {
    if (packNum <= Packet::SmartRedirectTreshold) {
        const auto end = pack + packNum;
        for (auto ptr = pack; ptr != end; ++ptr) {
            sendByNeighbours(ptr);
        }

        return;
    }

    {
        cs::Lock lock(nLockFlag_);
        for (auto& nb : neighbours_) {
            transport_->sendPackRenounce(pack->getHeaderHash(), **nb);
        }
    }

    ConnectionPtr* conn;
    static uint32_t i = 0;
    uint32_t tr = 0;
    const Packet* packEnd = pack + packNum;

    while (true) {
        {
            cs::Lock lock(nLockFlag_);

            if (i >= neighbours_.size()) {
                i = 0;
            }

            conn = neighbours_.begin() + i;
            ++i;
        }

        Connection::MsgRel& rel = (*conn)->msgRels.tryStore(pack->getHeaderHash());

        if (!rel.needSend) {
            continue;
        }

        for (auto p = pack; p != packEnd; ++p) {
            transport_->sendDirect(p, ***conn);
        }

        if (++tr == 2) {
            break;
        }
    }
}

void Neighbourhood::pingNeighbours() {
    cs::Lock lock(nLockFlag_);

    for (auto& nb : neighbours_) {
        transport_->sendPingPack(**nb);
    }
}

bool Neighbourhood::isPingDone() {
    cs::Lock lock(nLockFlag_);

    for (auto& nb : neighbours_) {
        if (nb->lastSeq) {
            return true;
        }
    }

    return false;
}

void Neighbourhood::resendPackets() {
    cs::Lock lock(nLockFlag_);
    uint32_t cnt1 = 0;
    uint32_t cnt2 = 0;

    for (auto& bp : msgBroads_) {
        if (!bp.data.pack) {
            continue;
        }

        if (!dispatch(bp.data)) {
            bp.data.pack = Packet();
        }
        else {
            ++cnt1;
        }

        bp.data.sentLastTime = false;
    }

    for (auto& dp : msgDirects_) {
        if (!dp.data.pack) {
            continue;
        }

        if (!dispatch(dp.data)) {
            dp.data.pack = Packet();
        }
        else {
            ++cnt2;
        }
    }
}

ConnectionPtr Neighbourhood::getConnection(const RemoteNodePtr node) {
    cs::Lock lock(nLockFlag_);
    Connection* conn = node->connection.load(std::memory_order_acquire);

    if (!conn) {
        return ConnectionPtr();
    }

    auto cPtr = findInVec(conn->id, neighbours_);

    if (cPtr) {
        return *cPtr;
    }

    return ConnectionPtr();
}

ConnectionPtr Neighbourhood::getNextRequestee(const cs::Hash& hash) {
    cs::Lock lock(nLockFlag_);

    SenderInfo& si = msgSenders_.tryStore(hash);
    ++si.reaskTimes;

    if (si.totalSenders < si.reaskTimes) {
        si.reaskTimes = 0;
        return si.prioritySender;
    }

    for (auto& nb : neighbours_) {
        if (nb->isSignal) {
            continue;
        }

        Connection::MsgRel& rel = nb->msgRels.tryStore(hash);

        if (rel.acceptOrder == si.reaskTimes) {
            return nb;
        }
    }

    return si.prioritySender;
}

ConnectionPtr Neighbourhood::getNextSyncRequestee(const cs::Sequence seq, bool& alreadyRequested) {
    cs::Lock lock(nLockFlag_);

    alreadyRequested = false;
    ConnectionPtr candidate;

    for (auto& nb : neighbours_) {
        if (nb->isSignal || nb->lastSeq < seq) {
            continue;
        }

        for (cs::Sequence i = 0; i < BlocksToSync; ++i) {
            if (nb->syncSeqs[i] == seq) {
                if (nb->syncSeqsRetries[i] < MaxSyncAttempts) {
                    alreadyRequested = true;
                    return nb;
                }

                nb->syncSeqs[i] = 0;
                nb->syncSeqsRetries[i] = 0;
                break;
            }
            else if (!candidate && !nb->syncSeqs[i]) {
                candidate = nb;
                break;
            }
        }
    }

    if (candidate) {
        for (cs::Sequence i = 0; i < BlocksToSync; ++i) {
            if (!candidate->syncSeqs[i]) {
                candidate->syncSeqs[i] = seq;
                candidate->syncSeqsRetries[i] = cs::Random::generateValue<cs::Sequence>(1, MaxSyncAttempts / 2);
                break;
            }
        }
    }

    return candidate;
}

ConnectionPtr Neighbourhood::getNeighbour(const std::size_t number) {
    cs::Lock lock(nLockFlag_);

    if (number >= neighbours_.size()) {
        return ConnectionPtr();
    }

    ConnectionPtr candidate = *(neighbours_.begin() + number);

    if (!candidate) {
        return ConnectionPtr();
    }

    return candidate;
}

ConnectionPtr Neighbourhood::getRandomSyncNeighbour() {
    cs::Lock lock(nLockFlag_);

    const int candidateNumber = getRandomSyncNeighbourNumber();

    if (candidateNumber < 0) {
        return ConnectionPtr();
    }

    ConnectionPtr candidate = *(neighbours_.begin() + candidateNumber);

    if (!candidate->syncNeighbourRetries) {
        candidate->syncNeighbourRetries = cs::Random::generateValue<uint32_t>(1, MaxSyncAttempts * 3);
    }

    --(candidate->syncNeighbourRetries);

    if (candidate->syncNeighbourRetries == 0) {
        candidate->isRequested = true;
    }

    return candidate;
}

ConnectionPtr Neighbourhood::getNeighbourByKey(const cs::PublicKey& pk) {
    cs::Lock lock(nLockFlag_);

    for (auto& nb : neighbours_) {
        if (nb->key == pk) {
            return nb;
        }
    }

    return ConnectionPtr();
}

void Neighbourhood::resetSyncNeighbours() {
    for (auto& nb : neighbours_) {
        nb->isRequested = false;
        nb->syncNeighbourRetries = 0;
    }
}

void Neighbourhood::registerDirect(const Packet* packPtr, ConnectionPtr conn) {
    cs::ScopedLock scopedLock(mLockFlag_, nLockFlag_);

    auto& bp = msgDirects_.tryStore(packPtr->getHash());
    bp.pack = *packPtr;
    bp.receiver = conn;
}

bool Neighbourhood::isNewConnectionAvailable() const {
    return neighbours_.size() < MaxNeighbours;
}

void Neighbourhood::releaseSyncRequestee(const cs::Sequence seq) {
    cs::Lock lock(nLockFlag_);

    for (auto& nb : neighbours_) {
        for (cs::Sequence i = 0; i < BlocksToSync; ++i) {
            if (nb->syncSeqs[i] == seq) {
                nb->syncSeqs[i] = 0;
                nb->syncSeqsRetries[i] = 0;
                break;
            }
        }
    }
}

int Neighbourhood::getRandomSyncNeighbourNumber(const std::size_t attemptCount) {
    if (neighbours_.size() == 0) {
        cslog() << "Neighbourhood, no neighbours";
        return -1;
    }

    const size_t neighbourCount = static_cast<size_t>(neighbours_.size() - 1U);

    if (attemptCount > (neighbourCount * 3)) {
        int index = 0;
        for (const auto& nb : neighbours_) {
            if (nb->isSignal || nb->isRequested) {
                ++index;
            }
            else {
                return index;
            }
        }
        return -1;
    }

    const int randomNumber = cs::Random::generateValue<int>(0, static_cast<int>(neighbourCount));
    const ConnectionPtr nb = *(neighbours_.begin() + randomNumber);

    if (!nb) {
        return -1;
    }

    if (nb->isSignal || nb->isRequested) {
        return getRandomSyncNeighbourNumber(attemptCount + 1);
    }

    return randomNumber;
}
```
# ..\node\net\src\network.cpp 
```cpp 
/* Send blaming letters to @yrtimd */
#include <chrono>
#include <lib/system/utils.hpp>
#include <net/logger.hpp>
#include <thread>

#ifdef __linux__
#include <sys/eventfd.h>
#include <sys/poll.h>
#include <sys/socket.h>
#include <unistd.h>
#include <array>
#include <vector>
#endif

#ifdef __APPLE__
#include <sys/time.h>
#endif

#include <net/packetvalidator.hpp>
#include "network.hpp"
#include "transport.hpp"

#include <set>

// disables 10052, 10054 win socket errors
#if defined(WIN32)
#define DISABLE_WIN_SOCKET_ERRORS
#endif

using boost::asio::buffer;

const ip::udp::socket::message_flags NO_FLAGS = 0;

static ip::udp::socket bindSocket(io_context& context, Network* net, const EndpointData& data, bool ipv6 = true) {
    try {
        ip::udp::socket sock(context, ipv6 ? ip::udp::v6() : ip::udp::v4());

        if (ipv6) {
            sock.set_option(ip::v6_only(false));
        }

        sock.set_option(ip::udp::socket::reuse_address(true));
#ifndef __APPLE__
        sock.set_option(ip::udp::socket::send_buffer_size(1 << 23));
        sock.set_option(ip::udp::socket::receive_buffer_size(1 << 23));
#endif

#ifdef DISABLE_WIN_SOCKET_ERRORS
        BOOL bNewBehavior = FALSE;
        DWORD dwBytesReturned = 0;

        WSAIoctl(sock.native_handle(), SIO_UDP_CONNRESET, &bNewBehavior, sizeof(bNewBehavior), nullptr, 0, &dwBytesReturned, nullptr, nullptr);
        WSAIoctl(sock.native_handle(), SIO_UDP_NETRESET, &bNewBehavior, sizeof(bNewBehavior), nullptr, 0, &dwBytesReturned, nullptr, nullptr);
#endif
        if (data.ipSpecified) {
            auto ep = net->resolve(data);
            sock.bind(ep);
        }
        else {
            sock.bind(ip::udp::endpoint(ipv6 ? ip::udp::v6() : ip::udp::v4(), data.port));
        }

        return sock;
    }
    catch (boost::system::system_error& e) {
        cserror() << "Cannot bind socket on " << e.what();
        return ip::udp::socket(context);
    }
}  //  bindSocket

ip::udp::endpoint Network::resolve(const EndpointData& data) {
    return ip::udp::endpoint(data.ip, data.port);
}

ip::udp::socket* Network::getSocketInThread(const bool openOwn, const EndpointData& epd, std::atomic<Network::ThreadStatus>& status, const bool ipv6) {
    ip::udp::socket* result = nullptr;

    if (openOwn) {
        result = new ip::udp::socket(bindSocket(context_, this, epd, ipv6));

        if (!result->is_open()) {
            result = nullptr;
        }
    }
    else {
        while (!singleSockOpened_.load())
            ;
        result = singleSock_.load();
    }

    status.store(result ? ThreadStatus::Success : ThreadStatus::Failed);

    return result;
}  // resolve

void Network::readerRoutine(const Config& config) {
    ip::udp::socket* sock = getSocketInThread(config.hasTwoSockets(), config.getInputEndpoint(), readerStatus_, config.useIPv6());

    if (!sock) {
        return;
    }

    while (!initFlag_.load()) {
        using namespace std::chrono_literals;
        std::this_thread::sleep_for(1s);
    }

    boost::system::error_code lastError;
    size_t packetSize;

    while (stopReaderRoutine == false) {  // changed from true
        auto& task = iPacMan_.allocNext();

        if (stopReaderRoutine) {
            return;
        }

        std::atomic_thread_fence(std::memory_order_acq_rel);
        while (!task.pack.data_.ptr_) {
            cslog() << "net: invalid input packet!!!!!!!!!";
        }
        packetSize = sock->receive_from(buffer(task.pack.data(), Packet::MaxSize), task.sender, NO_FLAGS, lastError);
        while (!task.pack.data_.ptr_) {
            cslog() << "net: invalid input packet!!!!!!!!!";
        }

        if (!lastError) {
            task.size = task.pack.decode(packetSize);  // try to decode first

            bool reject = false;
            if (task.size == 0) {
                cswarning() << "Ignore incorrect packet fragment, drop";
                reject = true;
            }
            else if (!task.pack.hasValidFragmentation()) {
                cswarning() << "Incorrect fragment identity in message or too many fragments, drop (" << task.pack.getFragmentId() << " from " << task.pack.getFragmentsNum()
                            << "), sender " << task.sender;
                reject = true;
            }

            if (reject) {
                iPacMan_.rejectLast();
            }
            else {
                iPacMan_.enQueueLast();

#ifdef LOG_NET
                csdebug(logger::Net) << "<-- " << packetSize << " bytes from " << task.sender << " " << task.pack;
#endif
            }
#ifdef __linux__
            static uint64_t one = 1;
            [[maybe_unused]] auto res = write(readerEventfd_, &one, sizeof(uint64_t));
#endif
#if defined(WIN32) || defined(__APPLE__)
            while (readerLock.test_and_set(std::memory_order_acquire))  // acquire lock
                ;                                                       // spin
            readerTaskCount_.fetch_add(1, std::memory_order_relaxed);
#ifdef WIN32
            SetEvent(readerEvent_);
#else
            kevent(readerKq_, &readerEvent_, 1, NULL, 0, NULL);
#endif
            readerLock.clear(std::memory_order_release);  // release lock
#endif
        }
        else {
            cserror() << "Cannot receive packet. Error " << lastError;
            iPacMan_.rejectLast();
        }
    }

    cswarning() << "readerRoutine STOPPED!!!\n";
}

[[maybe_unused]]
static inline void sendPack(ip::udp::socket& sock, TaskPtr<OPacMan>& task, const ip::udp::endpoint& ep) {
    boost::system::error_code lastError;
    size_t size = 0;
    size_t encodedSize = 0;

    uint32_t cnt = 0;

    // net code was built on this constant (Packet::MaxSize)
    // and is used it implicitly in a lot of places(
    char packetBuffer[Packet::MaxSize];
    boost::asio::mutable_buffer encodedPacket = task->pack.encode(buffer(packetBuffer, sizeof(packetBuffer)));
    encodedSize = encodedPacket.size();
    do {
        size = sock.send_to(encodedPacket, ep, NO_FLAGS, lastError);

        if (++cnt == 10) {
            cnt = 0;
            std::this_thread::yield();
        }
    } while (lastError == boost::asio::error::would_block);

    if (lastError || size < encodedSize) {
        cserror() << "Cannot send packet. Error " << lastError;
    }
#ifdef LOG_NET
    else {
        csdebug(logger::Net) << "--> " << size << " bytes to " << ep << " " << task->pack;
    }
#endif
}

void Network::writerRoutine(const Config& config) {
    ip::udp::socket* sock = getSocketInThread(config.hasTwoSockets(), config.getOutputEndpoint(), writerStatus_, config.useIPv6());

    if (!sock) {
        return;
    }
#ifdef __linux__
    std::vector<struct mmsghdr> msg;
    std::vector<struct iovec> iovecs;
    std::vector<std::array<char, Packet::MaxSize>> packets_buffer;
    std::vector<boost::asio::mutable_buffer> encoded_packets;
    std::vector<ip::udp::endpoint> endpoints;
#endif
    while (stopWriterRoutine == false) {  // changed from true
#ifdef __linux__
        uint64_t tasks;
        auto s = read(writerEventfd_, &tasks, sizeof(uint64_t));
        if (s != sizeof(uint64_t)) {
            continue;
        }

        if (tasks > 200) {
            cslog() << "strange: too many tasks " << tasks;
        }

        msg.resize(tasks);
        std::fill(msg.begin(), msg.end(), mmsghdr{});

        iovecs.resize(tasks);
        std::fill(iovecs.begin(), iovecs.end(), iovec{});

        packets_buffer.resize(tasks);

        endpoints.resize(tasks);
        encoded_packets.clear();

        uint64_t j = 0;

        for (uint64_t i = 0; i < tasks; i++) {
            auto task = oPacMan_.getNextTask();

            std::atomic_thread_fence(std::memory_order_acquire);

            while (!task->pack.data_.ptr_) {
                cslog() << "net: invalid packet for send!!!!!!!!!";
            }

            encoded_packets.emplace_back(task->pack.encode(buffer(packets_buffer[j].data(), Packet::MaxSize)));
            endpoints[j] = task->endpoint;

            iovecs[j].iov_base = encoded_packets[j].data();
            iovecs[j].iov_len = encoded_packets[j].size();

            msg[j].msg_hdr.msg_iov = &iovecs[j];
            msg[j].msg_hdr.msg_iovlen = 1;
            msg[j].msg_hdr.msg_name = endpoints[j].data();
            msg[j].msg_hdr.msg_namelen = static_cast<decltype(msg[j].msg_hdr.msg_namelen)>(endpoints[j].size());

            ++j;
        }

        if (j == 0) {
            continue;
        }

        tasks = j;

        int sended = 0;
        struct mmsghdr* messages = msg.data();

        do {
            sended = sendmmsg(sock->native_handle(), messages, static_cast<unsigned int>(tasks), 0);

            if (sended < 0) {
                cslog() << "sendmmsg errno = " << errno;

                if (errno != EAGAIN) {
                    break;
                }
            }

            messages += sended;
            tasks -= static_cast<decltype(tasks)>(sended);

        } while (tasks);
#endif
#if defined(WIN32) || defined(__APPLE__)
#ifdef WIN32
        WaitForSingleObject(writerEvent_, INFINITE);
#else
        struct kevent event;
        kevent(writerKq_, NULL, 0, &event, 1, NULL);
#endif
        while (writerLock.test_and_set(std::memory_order_acquire))  // acquire lock
            ;                                                       // spin
        int tasks = writerTaskCount_;
        writerTaskCount_ = 0;
        writerLock.clear(std::memory_order_release);  // release lock

        for (int i = 0; i < tasks; i++) {
            auto task = oPacMan_.getNextTask();
            while (!task->pack.data_.ptr_) {
                cslog() << "net: invalid packet!!!!!!!!!";
            }
            sendPack(*sock, task, task->endpoint);
        }
#endif
    }

    cswarning() << "writerRoutine STOPPED!!!\n";
}

// Processors
void Network::processorRoutine() {
    CallsQueue& externals = CallsQueue::instance();
#ifdef __linux__
    struct pollfd pfd {};
    pfd.fd = readerEventfd_;
    pfd.events = POLLIN;
    constexpr int timeout = 50;  // 50ms
#elif __APPLE__
    struct timespec timeout {
        0, 50000000
    };                                             // 50ms
#endif

    while (stopProcessorRoutine == false) {
        externals.callAll();
#ifdef __linux__
        uint64_t tasks;

        while (true) {
            int ret = poll(&pfd, 1, timeout);

            if (ret != 0) {
                break;
            }

            externals.callAll();
        }

        if (auto s = read(readerEventfd_, &tasks, sizeof(uint64_t)); s != sizeof(uint64_t)) {
            continue;
        }

        for (uint64_t i = 0; i < tasks; i++) {
            auto task = iPacMan_.getNextTask();

            while (!task->pack.data_.ptr_) {
                cslog() << "net: invalid packet processor!!!!!!!!!";
            }

            processTask(task);
        }
#endif
#if defined(WIN32) || defined(__APPLE__)
#ifdef WIN32
        while (true) {
            auto ret = WaitForSingleObject(readerEvent_, 50);  // timeout 50ms
            if (ret != WAIT_TIMEOUT)
                break;
            externals.callAll();
        };
#else
        while (true) {
            struct kevent event;
            int ret = kevent(readerKq_, NULL, 0, &event, 1, &timeout);
            if (ret)
                break;
            externals.callAll();
        }
#endif
        while (readerLock.test_and_set(std::memory_order_acquire))  // acquire lock
            ;                                                       // spin
        int tasks = readerTaskCount_;
        readerTaskCount_ = 0;
        readerLock.clear(std::memory_order_release);  // release lock

        for (int i = 0; i < tasks; i++) {
            auto task = iPacMan_.getNextTask();
            processTask(task);
        }
#endif
    }
    cswarning() << "processorRoutine STOPPED!!!\n";
}

inline void Network::processTask(TaskPtr<IPacMan>& task) {
    auto remoteSender = transport_->getPackSenderEntry(task->sender);

    if (!(task->pack.isHeaderValid())) {
        static constexpr size_t limit = 100;
        auto size = (task->pack.size() <= limit) ? task->pack.size() : limit;

        cswarning() << "Header is not valid: " << cs::Utils::byteStreamToHex(static_cast<const char*>(task->pack.data()), size);
        remoteSender->addStrike();
        return;
    }

    // Pure network processing, prior blacklist inspection to allow re-registration
    if (task->pack.isNetwork()) {
        if (cs::PacketValidator::instance().validate(task->pack)) {
            transport_->processNetworkTask(task, remoteSender);
        }
        return;
    }

    // test blacklist, the only way to remove from the list is to re-register again
    if (remoteSender->isBlackListed()) {
        csdebug() << "Message is ignored from blacklisted " << task->sender;
        return;
    }

    // Non-network data
    uint32_t& recCounter = packetMap_.tryStore(task->pack.getHash());
    if (!recCounter && task->pack.addressedToMe(transport_->getMyPublicKey())) {
        if (task->pack.isFragmented() || task->pack.isCompressed()) {
            bool newFragmentedMsg = false;
            MessagePtr msg = collector_.getMessage(task->pack, newFragmentedMsg);
            transport_->gotPacket(task->pack, remoteSender);

            if (newFragmentedMsg) {
                transport_->registerMessage(msg);
            }

            if (msg && msg->isComplete()) {
                if (cs::PacketValidator::instance().validate(**msg)) {
                    transport_->processNodeMessage(**msg);
                }
            }
        }
        else {
            if (cs::PacketValidator::instance().validate(task->pack)) {
                transport_->processNodeMessage(task->pack);
            }
        }
    }

    transport_->redirectPacket(task->pack, remoteSender);
    ++recCounter;
}

void Network::sendDirect(const Packet& p, const ip::udp::endpoint& ep) {
    auto qePtr = oPacMan_.allocNext();

    if (ep.size() > 16) {
        cslog() << "endpoint address too big " << ep.size();
        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(ep.data());
        for (size_t i = 0; i < ep.size(); i++) {
            cslog() << *ptr++;
        }
    }
    qePtr->endpoint = ep;
    qePtr->pack = p;

    oPacMan_.enQueueLast();
#ifdef __linux__
    static uint64_t one = 1;
    [[maybe_unused]] auto res = write(writerEventfd_, &one, sizeof(uint64_t));
#endif
#if defined(WIN32) || defined(__APPLE__)
    while (writerLock.test_and_set(std::memory_order_acquire))  // acquire lock
        ;                                                       // spin
    writerTaskCount_.fetch_add(1, std::memory_order_relaxed);
#ifdef WIN32
    SetEvent(writerEvent_);
#else
    kevent(writerKq_, &writerEvent_, 1, NULL, 0, NULL);
#endif
    writerLock.clear(std::memory_order_release);  // release lock
#endif
}

Network::Network(const Config& config, Transport* transport)
: resolver_(context_)
, transport_(transport) {
#ifdef __linux__
    readerEventfd_ = eventfd(0, 0);
    if (readerEventfd_ == -1) {
        good_ = false;
        return;
    }

    writerEventfd_ = eventfd(0, 0);
    if (writerEventfd_ == -1) {
        good_ = false;
        return;
    }
#elif WIN32
    writerEvent_ = CreateEvent(nullptr,            // default security attributes
                               FALSE,              // automatic-reset event
                               FALSE,              // initial state is nonsignaled
                               TEXT("WriteEvent")  // object name
    );

    if (writerEvent_ == nullptr) {
        good_ = false;
        return;
    }

    readerEvent_ = CreateEvent(nullptr,           // default security attributes
                               FALSE,             // automatic-reset event
                               FALSE,             // initial state is nonsignaled
                               TEXT("ReadEvent")  // object name
    );

    if (writerEvent_ == nullptr) {
        good_ = false;
        return;
    }
#elif __APPLE__
    readerKq_ = kqueue();
    if (readerKq_ == -1) {
        good_ = false;
        return;
    }

    EV_SET(&readerEvent_, 0, EVFILT_USER, EV_ADD | EV_DISPATCH | EV_DISABLE, NOTE_FFCOPY | NOTE_TRIGGER, 0, NULL);
    int ret = kevent(readerKq_, &readerEvent_, 1, NULL, 0, NULL);

    if (ret == -1 || (readerEvent_.flags & EV_ERROR)) {
        good_ = false;
        return;
    }

    EV_SET(&readerEvent_, 0, EVFILT_USER, EV_DISPATCH | EV_ENABLE, NOTE_FFCOPY | NOTE_TRIGGER, 0, NULL);

    writerKq_ = kqueue();
    if (writerKq_ == -1) {
        good_ = false;
        return;
    }

    EV_SET(&writerEvent_, 0, EVFILT_USER, EV_ADD | EV_DISPATCH | EV_DISABLE, NOTE_FFCOPY | NOTE_TRIGGER, 0, NULL);
    ret = kevent(writerKq_, &writerEvent_, 1, NULL, 0, NULL);

    if (ret == -1 || (writerEvent_.flags & EV_ERROR)) {
        good_ = false;
        return;
    }

    EV_SET(&writerEvent_, 0, EVFILT_USER, EV_DISPATCH | EV_ENABLE, NOTE_FFCOPY | NOTE_TRIGGER, 0, NULL);
#endif
    readerThread_ = std::thread(&Network::readerRoutine, this, config);
    writerThread_ = std::thread(&Network::writerRoutine, this, config);
    processorThread_ = std::thread(&Network::processorRoutine, this);

    if (!config.hasTwoSockets()) {
        auto sockPtr = new ip::udp::socket(bindSocket(context_, this, config.getInputEndpoint(), config.useIPv6()));

        if (!sockPtr->is_open()) {
            good_ = false;
            return;
        }

        singleSock_.store(sockPtr);
        singleSockOpened_.store(true);
    }

    while (readerStatus_.load() == ThreadStatus::NonInit)
        ;
    while (writerStatus_.load() == ThreadStatus::NonInit)
        ;

    good_ = (readerStatus_.load() == ThreadStatus::Success && writerStatus_.load() == ThreadStatus::Success);

    if (!good_) {
        cserror() << "Cannot start the network: error binding sockets";
    }
}

bool Network::resendFragment(const cs::Hash& hash, const uint16_t id, const ip::udp::endpoint& ep) {
    MessagePtr msg;

    {
        cs::Lock lock(collector_.mLock_);
        msg = collector_.map_.tryStore(hash);
    }

    if (!msg) {
        return false;
    }

    {
        cs::Lock l(msg->pLock_);
        if (id < msg->packetsTotal_ && *(msg->packets_ + id)) {
            sendDirect(*(msg->packets_ + id), ep);
            return true;
        }
    }

    return false;
}

void Network::sendInit() {
    initFlag_.store(true);
}

void Network::registerMessage(Packet* pack, const uint32_t size) {
    if (size >= Packet::MaxFragments) {
        cserror() << "Too much fragments in message to send (" << size << "), ignore";
        return;
    }

    MessagePtr msg;

    {
        cs::Lock l(collector_.mLock_);
        msg = collector_.msgAllocator_.emplace();
    }

    msg->packetsLeft_ = 0;
    msg->packetsTotal_ = size;
    msg->headerHash_ = pack->getHeaderHash();

    auto packEnd = msg->packets_ + size;
    auto rPtr = pack;
    for (auto wPtr = msg->packets_; wPtr != packEnd; ++wPtr, ++rPtr) {
        *wPtr = *rPtr;
    }

    {
        cs::Lock l(collector_.mLock_);
        collector_.map_.tryStore(pack->getHeaderHash()) = msg;
    }
}

Network::~Network() {
    stopReaderRoutine = true;

    if (readerThread_.joinable()) {
        readerThread_.join();
    }

    stopWriterRoutine = true;

    if (writerThread_.joinable()) {
        writerThread_.join();
    }

    stopProcessorRoutine = true;

    if (processorThread_.joinable()) {
        processorThread_.join();
    }

    delete singleSock_.load();
}
```
# ..\node\net\src\packet.cpp 
```cpp 
#include <lz4.h>

#include <lib/system/utils.hpp>
#include "packet.hpp"
#include "transport.hpp"  // for NetworkCommand

RegionAllocator Message::allocator_(1 << 26, 4);

enum Lengths {
    FragmentedHeader = 36
};

const char* Packet::messageTypeToString(MsgTypes messageType) {
    switch (messageType) {
        case RoundTableSS:
            return "RoundTableSS";
        case Transactions:
            return "Transactions";
        case FirstTransaction:
            return "FirstTransaction";
        case NewBlock:
            return "NewBlock";
        case BlockHash:
            return "BlockHash";
        case BlockRequest:
            return "BlockRequest";
        case RequestedBlock:
            return "RequestedBlock";
        case FirstStage:
            return "FirstStage";
        case SecondStage:
            return "SecondStage";
        case ThirdStage:
            return "ThirdStage";
        case FirstStageRequest:
            return "FirstStageRequest";
        case SecondStageRequest:
            return "SecondStageRequest";
        case ThirdStageRequest:
            return "ThirdStageRequest";
        case RoundTableRequest:
            return "RoundTableRequest";
        case RoundTableReply:
            return "RoundTableReply";
        case TransactionPacket:
            return "TransactionPacket";
        case TransactionsPacketRequest:
            return "TransactionsPacketRequest";
        case TransactionsPacketReply:
            return "TransactionsPacketReply";
        case NewCharacteristic:
            return "NewCharacteristic";
        case WriterNotification:
            return "WriterNotification";
        case FirstSmartStage:
            return "FirstSmartStage";
        case SecondSmartStage:
            return "SecondSmartStage";
        case RoundTable:
            return "RoundTable";
        case ThirdSmartStage:
            return "ThirdSmartStage";
        case SmartFirstStageRequest:
            return "SmartFirstStageRequest";
        case SmartSecondStageRequest:
            return "SmartSecondStageRequest";
        case SmartThirdStageRequest:
            return "SmartThirdStageRequest";
        case HashReply:
            return "HashReply";
        case BigBang:
            return "BigBang";
        case NodeStopRequest:
            return "NodeStopRequest";
        case RejectedContracts:
            return "RejectedContracts";
        default:
            return "Unknown";
    }
}

const cs::Hash& Packet::getHeaderHash() const {
    if (!headerHashed_) {
        headerHash_ = generateHash(static_cast<const char*>(data_.get()) + Offsets::FragmentsNum, Lengths::FragmentedHeader);
        headerHashed_ = true;
    }
    return headerHash_;
}

bool Packet::isHeaderValid() const {
    if (isFragmented()) {
        if (isNetwork()) {
            cserror() << "Network packet is fragmented";
            return false;
        }

        const auto& frNum = getFragmentsNum();
        const auto& frId = getFragmentId();

        if (!hasValidFragmentation()) {
            cserror() << "Packet " << Packet::messageTypeToString(this->getType()) << " has invalid header: frId(" << frId << ") >= frNum(" << frNum << ")";
            return false;
        }
    }

    if (size() <= getHeadersLength()) {
        cserror() << "Packet size (" << size() << ") <= header length (" << getHeadersLength() << ")" << (isNetwork() ? ", network" : "") << (isFragmented() ? ", fragmeted" : "")
                  << ", type " << Packet::messageTypeToString(getType()) << "(" << static_cast<int>(getType()) << ")";
        return false;
    }

    return true;
}

uint32_t Packet::getHeadersLength() const {
    if (!headersLength_) {
        headersLength_ = calculateHeadersLength();
    }

    return headersLength_;
}

uint32_t Packet::calculateHeadersLength() const {
    uint32_t length = sizeof(BaseFlags);  // Flags

    if (isFragmented()) {
        length += sizeof(uint16_t) + sizeof(uint16_t);  // Min fragments & all fragments
    }

    if (!isNetwork()) {
        length += kPublicKeyLength + sizeof(getId());  // Sender key + ID

        if (!isBroadcast() && !isNeighbors()) {
            length += kPublicKeyLength;  // Receiver key
        }
    }

    return length;
}

void Packet::recalculateHeadersLength() {
    headersLength_ = calculateHeadersLength();
}

MessagePtr PacketCollector::getMessage(const Packet& pack, bool& newFragmentedMsg) {
    if (!pack.isFragmented()) {
        return MessagePtr();
    }
    
    if (!pack.hasValidFragmentation()) {
        return MessagePtr();
    }

    newFragmentedMsg = false;

    MessagePtr* msgPtr;
    MessagePtr msg;

    {
        cs::Lock l(mLock_);
        msgPtr = &map_.tryStore(pack.getHeaderHash());
    }

    if (!*msgPtr) {  // First time
        *msgPtr = msg = msgAllocator_.emplace();
        msg->packetsLeft_ = pack.getFragmentsNum();
        msg->packetsTotal_ = pack.getFragmentsNum();
        msg->headerHash_ = pack.getHeaderHash();
        // to ensure not to contain dirty fragments in buffer (prevent goodPlace below from to be incorrect):
        msg->clearFragments();
        newFragmentedMsg = true;
    }
    else {
        msg = *msgPtr;
    }

    {
        cs::Lock lock(msg->pLock_);
        auto goodPlace = msg->packets_ + pack.getFragmentId(); // valid fragmentation has already been tested

        if (!*goodPlace) {
            msg->maxFragment_ = std::max(pack.getFragmentsNum(), msg->maxFragment_);
            --msg->packetsLeft_;
            *goodPlace = pack;
        }

        if (msg->packetsTotal_ >= 20) {
            if (msg->packetsLeft_ != 0) {
                // the 1st fragment contains full info:
                if (pack.getFragmentId() == 0) {
                    csdetails() << "COLLECT> recv pack " << Packet::messageTypeToString(pack.getType()) << " of " << msg->packetsTotal_ << ", round " << pack.getRoundNum();
                }
                csdetails() << "COLLECT> ready " << msg->packetsTotal_ - msg->packetsLeft_ << " / " << msg->packetsTotal_;
            }
            else {
                csdetails() << "COLLECT> done (" << msg->packetsTotal_ << ") " << Packet::messageTypeToString(msg->getFirstPack().getType()) << ", round "
                            << msg->getFirstPack().getRoundNum();
            }
        }
    }

    return msg;
}

/* WARN: All the cases except FRAG + COMPRESSED have bugs in them */
void Message::composeFullData() const {
    if (getFirstPack().isFragmented()) {
        const Packet* pack = packets_;
        uint32_t headersLength = pack->getHeadersLength();
        uint32_t totalSize = headersLength;

        for (uint32_t i = 0; i < packetsTotal_; ++i, ++pack) {
            totalSize += static_cast<uint32_t>((pack->size() - headersLength));
        }

        fullData_ = allocator_.allocateNext(totalSize);

        uint8_t* data = static_cast<uint8_t*>(fullData_.get());
        pack = packets_;

        for (uint32_t i = 0; i < packetsTotal_; ++i, ++pack) {
            uint32_t headerSize = static_cast<uint32_t>((i == 0) ? 0 : headersLength);

            uint32_t cSize = cs::numeric_cast<uint32_t>(pack->size()) - headerSize;
            auto source = (reinterpret_cast<const char*>(pack->data())) + headerSize;

            std::copy(source, source + cSize, data);
            data += cSize;
        }
    }
}

// scans array of future fragments and clears all dirty elements, scans all elements
size_t Message::clearBuffer(size_t from, size_t to) {
    if (to <= from || to >= Packet::MaxFragments) {
        return 0;
    }
    size_t cnt = 0;
    for (size_t i = from; i < to; i++) {
        // Packet's operator bool redirects call to Packet::data_::operator bool
        if (packets_[i]) {
            csdebug() << "Net: potential heap corruption prevented in message.packets_[" << i << "]";
            packets_[i] = Packet{};
            ++cnt;
        }
    }
    return cnt;
}

Message::~Message() {
    /*auto pEnd = packets_ + packetsTotal_;
    for (auto ptr = packets_; ptr != pEnd; ++ptr)
      if (ptr) ptr->~Packet();

      memset(packets_, 0, sizeof(Packet*) * packetsTotal_);*/

    //DEBUG: prevent corruption after heap is damaged,
    // assume maxFragment "points" behind the last fragment,
    // idea is to avoid call to MemPtr<> destructor on incorrect object
    size_t cnt = clearUnused();
    if (cnt > 0) {
        csdebug() << "Net: memory corruption prevented, invalid fragments (" << cnt << ") is behind the max of " << maxFragment_ << " and cannot been destructed";
        Transport::cntCorruptedFragments += cnt;
    }
}

class PacketFlags {
public:
    PacketFlags(const Packet& packet)
    : packet_(packet) {
    }

    std::ostream& operator()(std::ostream& os) const {
        uint8_t n = 0;

        if (packet_.isNetwork()) {
            os << "net";
            ++n;
        }

        if (packet_.isFragmented()) {
            os << (n ? ", " : "") << "fragmented(" << packet_.getFragmentsNum() << ")";
            ++n;
        }

        if (packet_.isCompressed()) {
            os << (n ? ", " : "") << "compressed";
            ++n;
        }

        if (packet_.isNeighbors()) {
            os << (n ? ", " : "") << "neighbors";
            ++n;
        }

        return os;
    }

private:
    const Packet& packet_;
};

std::ostream& operator<<(std::ostream& os, const PacketFlags& packetFlags) {
    return packetFlags(os);
}

std::ostream& operator<<(std::ostream& os, const Packet& packet) {
    if (!packet.isHeaderValid()) {
        os << "Invalid packet header";
        return os;
    }

    if (packet.isNetwork()) {
        const uint8_t* data = packet.getMsgData();
        os << Transport::networkCommandToString(static_cast<NetworkCommand>(*data)) << "(" << int(*data) << "), ";
        os << "flags: " << PacketFlags(packet);
        return os;
    }

    if (packet.isFragmented()) {
        if (packet.getFragmentId() == 0) {
            os << Packet::messageTypeToString(packet.getType()) << "(" << packet.getType() << "), ";
            os << "round " << packet.getRoundNum() << ", ";
        }
        else {
            os << "fragment id: " << packet.getFragmentId() << ", ";
        }
    }

    os << "flags: " << PacketFlags(packet);
    os << ", id: " << packet.getId() << std::endl;
    os << "Sender:\t\t" << cs::Utils::byteStreamToHex(packet.getSender().data(), packet.getSender().size());

    if (!packet.isBroadcast()) {
        os << std::endl;
        os << "Addressee:\t" << cs::Utils::byteStreamToHex(packet.getAddressee().data(), packet.getAddressee().size());
    }

    return os;
}
```
# ..\node\net\src\packetvalidator.cpp 
```cpp 
#include <base58.h>
#include <lib/system/logger.hpp>
#include <net/packetvalidator.hpp>
#include <net/transport.hpp>

namespace cs {
/*private*/
PacketValidator::PacketValidator() {
    starterKey_ = cs::Zero::key;
}

/*static*/
PacketValidator& PacketValidator::instance() {
    static PacketValidator inst;
    return inst;
}

bool PacketValidator::validate(const Packet& pack) {
    bool result = (pack.isHeaderValid() && (pack.getHeadersLength() < pack.size()));
    if (result) {
        if (pack.isNetwork()) {
            if (pack.isFragmented() || pack.getMsgSize() < 1) {
                result = false;
            }
            else {
                NetworkCommand cmd = (NetworkCommand) * (uint8_t*)pack.getMsgData();
                switch (cmd) {
                    case NetworkCommand::Registration:
                        result = validateRegistration(pack.getMsgSize());
                        break;
                    case NetworkCommand::SSRegistration:
                        result = validateStarterRegistration(pack);
                        break;
                    default:
                        break;
                }
            }
        }
        else {
            if (pack.isFragmented()) {
                if (pack.getFragmentsNum() > 1) {
                    // unable validate fragmented pack
                    result = true;
                }
                else {
                    result = validateFirstFragment(pack.getType(), pack.getMsgData(), pack.getMsgSize());
                }
            }
            else {
                result = validate(pack.getType(), pack.getMsgData(), pack.getMsgSize());
            }
        }
    }
    if (!result) {
        cswarning() << "Net: packet " << pack << " is not validated";
    }
    return result;
}

bool PacketValidator::validate(const Message& msg) {
    if (!msg.isComplete()) {
        return false;
    }
    if (!msg.getFirstPack().hasValidFragmentation()) {
        return false;
    }
    return validate(msg.getFirstPack());

    // require to compose full message to validate:
    // MsgTypes type = msg.getFirstPack().getType();
    // return validate(type, msg.getFullData(), msg.getFullSize());
}

bool PacketValidator::validate(MsgTypes msg, const uint8_t* data, size_t size) {
    switch (msg) {
        case MsgTypes::BigBang:
            // still cannot validate signature, parsing required
            break;
        case MsgTypes::NodeStopRequest:
            return validateStopRequest(data, size);
        default:
            break;
    }
    return true;
}

bool PacketValidator::validateFirstFragment(MsgTypes /*msg*/, const uint8_t* /*data*/, size_t /*size*/) {
    return true;
}

bool PacketValidator::validateStarterSignature(const uint8_t* data, size_t size) {
    if (std::equal(starterKey_.cbegin(), starterKey_.cend(), cs::Zero::key.cbegin())) {
        return false;  // no SS key registered
    }
    const size_t full_data_size = size - 1;  // the 1st byte is unsigned msg type
    if (full_data_size <= cscrypto::kSignatureSize) {
        return false;  // no signed data
    }
    const size_t signed_data_size = full_data_size - cscrypto::kSignatureSize;
    const cscrypto::Byte* data_ptr = data + 1;  // the 1st byte is unsigned msg type
    const cscrypto::Byte* signature_ptr = data_ptr + signed_data_size;
    return cscrypto::verifySignature(signature_ptr, starterKey_.data(), data_ptr, signed_data_size);
}

bool PacketValidator::validateStarterRegistration(const Packet& pack) {
    if (!std::equal(starterKey_.cbegin(), starterKey_.cend(), cs::Zero::key.cbegin())) {
        // re-registration with another SS is disabled for now
        return true;
    }

    constexpr int MinPayloadSize = sizeof(MsgTypes) + cscrypto::kPublicKeySize;
    if (pack.getMsgSize() >= MinPayloadSize) {
        const uint8_t* pdata = pack.getMsgData() + 1;
        std::copy(pdata, pdata + cscrypto::kPublicKeySize, starterKey_.data());
        cslog() << "starter registration key " << cs::Utils::byteStreamToHex(starterKey_.data(), starterKey_.size()) << " ("
                << EncodeBase58(starterKey_.data(), starterKey_.data() + starterKey_.size()) << ')';
    }
    else {
        // SS key is must have
        return false;
    }

    // if size > MinRegistrationSize then Transport::parseSSSignal() will work
    // some more validation may be placed here

    return true;
}

bool PacketValidator::validateStopRequest(const uint8_t* data, size_t size) {
    constexpr size_t payload_size = sizeof(MsgTypes) + sizeof(cs::RoundNumber) + sizeof(uint16_t);  // type + rNum + version
    if (size != payload_size + cscrypto::kSignatureSize) {
        return false;  // incorrect packet size
    }
    return validateStarterSignature(data, size);
}

bool PacketValidator::validateRegistration(size_t size) {
    constexpr size_t hdr = 1 + 2 + 8;  // command Registration + version + bch_uuid
    constexpr size_t ip6 = 1 + 16;
    constexpr size_t ip4 = 1 + 4;
    constexpr size_t noip = 1;
    constexpr size_t port = 2;
    constexpr size_t id_key = sizeof(uint64_t) + sizeof(cs::PublicKey);
    constexpr size_t expected[] = {hdr + ip6 + port + id_key, hdr + ip6 + id_key, hdr + ip4 + port + id_key, hdr + ip4 + id_key, hdr + noip + port + id_key, hdr + noip + id_key};
    constexpr size_t cnt_expected = sizeof(expected) / sizeof(expected[0]);
    for (size_t i = 0; i < cnt_expected; ++i) {
        if (expected[i] == size) {
            return true;
        }
    }
    return false;
}

}  // namespace cs
```
# ..\node\net\src\pacmans.cpp 
```cpp 
/* Send blaming letters to @yrtimd */
#include "pacmans.hpp"

IPacMan::Task& IPacMan::allocNext() {
    std::lock_guard<std::mutex> lock(mutex_);
    queue_.emplace_back();
    auto end = queue_.end();
    Task& task = *(--end);
    new (&task) Task();
    task.pack.data_ = allocator_.allocateNext(Packet::MaxSize);
    return task;
}

void IPacMan::enQueueLast() {
    Task& task = queue_.back();
    allocator_.shrinkLast(static_cast<uint32_t>(task.size));
    size_.fetch_add(1, std::memory_order_acq_rel);
}

void IPacMan::rejectLast() {
    std::lock_guard<std::mutex> lock(mutex_);
    Task& task = queue_.back();
    task.~Task();
    queue_.pop_back();
}

TaskPtr<IPacMan> IPacMan::getNextTask() {
    while (!size_.load(std::memory_order_acquire)) {
        std::this_thread::yield();
    }
    std::lock_guard<std::mutex> lock(mutex_);
    TaskPtr<IPacMan> result;
    result.owner_ = this;
    result.it_ = queue_.begin();
    return result;
}

void IPacMan::releaseTask(TaskIterator& it) {
    Task& task = *it;
    task.~Task();
    std::lock_guard<std::mutex> lock(mutex_);
    queue_.erase(it);
    size_.fetch_sub(1, std::memory_order_acq_rel);
}

OPacMan::Task* OPacMan::allocNext() {
    std::lock_guard<std::mutex> lock(mutex_);
    queue_.emplace_back();
    auto end = queue_.end();
    Task& task = *(--end);
    new (&task) Task();
    return &task;
}

void OPacMan::enQueueLast() {
    size_.fetch_add(1, std::memory_order_acq_rel);
}

TaskPtr<OPacMan> OPacMan::getNextTask() {
    while (!size_.load(std::memory_order_acquire)) {
        std::this_thread::yield();
    }
    std::lock_guard<std::mutex> lock(mutex_);
    TaskPtr<OPacMan> result;
    result.owner_ = this;
    result.it_ = queue_.begin();
    return result;
}

void OPacMan::releaseTask(TaskIterator& it) {
    Task& task = *it;
    task.~Task();
    std::lock_guard<std::mutex> lock(mutex_);
    queue_.erase(it);
    size_.fetch_sub(1, std::memory_order_acq_rel);
}
```
# ..\node\net\src\transport.cpp 
```cpp 
/* Send blaming letters to @yrtimd */
#include <csnode/conveyer.hpp>
#include <csnode/packstream.hpp>

#include <lib/system/allocators.hpp>
#include <lib/system/utils.hpp>

#include "network.hpp"
#include "transport.hpp"

// Signal transport to stop and stop Node
static void stopNode() noexcept(false) {
    Node::requestStop();
    // Transport::stop();
}

// Called periodically to poll the signal flag.
void pollSignalFlag() {
    if (gSignalStatus == 1) {
        gSignalStatus = 0;
        try {
            stopNode();
        }
        catch (...) {
            cserror() << "Poll signal error!";
            std::raise(SIGABRT);
        }
    }
}

// Extern function dfined in main.cpp to poll and handle signal status.
extern void pollSignalFlag();

enum RegFlags : uint8_t {
    UsingIPv6 = 1,
    RedirectIP = 1 << 1,
    RedirectPort = 1 << 2
};

enum Platform : uint8_t {
    Linux,
    MacOS,
    Windows
};

namespace {
// Packets formation

void addMyOut(const Config& config, cs::OPackStream& stream, const uint8_t initFlagValue = 0) {
    uint8_t regFlag = 0;
    if (!config.isSymmetric()) {
        if (config.getAddressEndpoint().ipSpecified) {
            regFlag |= RegFlags::RedirectIP;
            if (config.getAddressEndpoint().ip.is_v6()) {
                regFlag |= RegFlags::UsingIPv6;
            }
        }

        regFlag |= RegFlags::RedirectPort;
    }
    else if (config.hasTwoSockets()) {
        regFlag |= RegFlags::RedirectPort;
    }

    uint8_t* flagChar = stream.getCurrentPtr();

    if (!config.isSymmetric()) {
        if (config.getAddressEndpoint().ipSpecified) {
            stream << config.getAddressEndpoint().ip;
        }
        else {
            uint8_t c = 0_b;
            stream << c;
        }

        stream << config.getAddressEndpoint().port;
    }
    else if (config.hasTwoSockets()) {
        stream << 0_b << config.getInputEndpoint().port;
    }
    else {
        stream << 0_b;
    }

    *flagChar |= initFlagValue | regFlag;
}

void formRegPack(const Config& config, cs::OPackStream& stream, uint64_t** regPackConnId, const cs::PublicKey& pk, uint64_t uuid) {
    stream.init(BaseFlags::NetworkMsg);
    stream << NetworkCommand::Registration << NODE_VERSION << uuid;

    addMyOut(config, stream);
    *regPackConnId = reinterpret_cast<uint64_t*>(stream.getCurrentPtr());

    stream << static_cast<ConnectionId>(0) << pk;
}

void formSSConnectPack(const Config& config, cs::OPackStream& stream, const cs::PublicKey& pk, uint64_t uuid) {
    stream.init(BaseFlags::NetworkMsg);
    stream << NetworkCommand::SSRegistration
#ifdef _WIN32
        << Platform::Windows
#elif __APPLE__
        << Platform::MacOS
#else
        << Platform::Linux
#endif
        << NODE_VERSION << uuid;

    uint8_t flag = (config.getNodeType() == NodeType::Router) ? 8 : 0;
    addMyOut(config, stream, flag);

    stream << pk;
}
}  // namespace

Transport::~Transport() {
    delete net_;
}

void Transport::run() {
    net_->sendInit();
    acceptRegistrations_ = config_.getNodeType() == NodeType::Router;

    {
        cs::Lock lock(oLock_);
        oPackStream_.init(BaseFlags::NetworkMsg);
        formRegPack(config_, oPackStream_, &regPackConnId_, myPublicKey_, node_->getBlockChain().uuid());
        regPack_ = *(oPackStream_.getPackets());
        oPackStream_.clear();
    }

    refillNeighbourhood();

    // Okay, now let's get to business
    uint32_t ctr = 0;
    cswarning() << "+++++++>>> Transport Run Task Start <<<+++++++++++++++";

    // Check if thread is requested to stop ?
    while (Transport::gSignalStatus == 0) {
        ++ctr;

        bool askMissing = true;
        bool resendPacks = ctr % 10 == 0;
        bool sendPing = ctr % 20 == 0;
        bool refreshLimits = ctr % 20 == 0;
        bool checkPending = ctr % 100 == 0;
        bool checkSilent = ctr % 150 == 0;

        if (askMissing) {
            askForMissingPackages();
        }

        if (checkPending) {
            nh_.checkPending(config_.getMaxNeighbours());
        }

        if (checkSilent) {
            nh_.checkSilent();
            nh_.checkNeighbours();
        }

        if (resendPacks) {
            nh_.resendPackets();
        }

        if (sendPing) {
            nh_.pingNeighbours();
        }

        if (refreshLimits) {
            nh_.refreshLimits();
        }

        pollSignalFlag();
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }

    cswarning() << "[Transport::run STOPED!]";
}

const char* Transport::networkCommandToString(NetworkCommand command) {
    switch (command) {
    case NetworkCommand::Registration:
        return "Registration";
    case NetworkCommand::ConfirmationRequest:
        return "ConfirmationRequest";
    case NetworkCommand::ConfirmationResponse:
        return "ConfirmationResponse";
    case NetworkCommand::RegistrationConfirmed:
        return "RegistrationConfirmed";
    case NetworkCommand::RegistrationRefused:
        return "RegistrationRefused";
    case NetworkCommand::Ping:
        return "Ping";
    case NetworkCommand::PackInform:
        return "PackInform";
    case NetworkCommand::PackRequest:
        return "PackRequest";
    case NetworkCommand::PackRenounce:
        return "PackRenounce";
    case NetworkCommand::BlockSyncRequest:
        return "BlockSyncRequest";
    case NetworkCommand::SSRegistration:
        return "SSRegistration";
    case NetworkCommand::SSFirstRound:
        return "SSFirstRound";
    case NetworkCommand::SSRegistrationRefused:
        return "SSRegistrationRefused";
    case NetworkCommand::SSPingWhiteNode:
        return "SSPingWhiteNode";
    case NetworkCommand::SSLastBlock:
        return "SSLastBlock";
    case NetworkCommand::SSReRegistration:
        return "SSReRegistration";
    case NetworkCommand::SSSpecificBlock:
        return "SSSpecificBlock";
    default:
        return "Unknown";
    }
}

template <>
uint16_t getHashIndex(const ip::udp::endpoint& ep) {
    uint16_t result = ep.port();

    if (ep.protocol() == ip::udp::v4()) {
        uint32_t address = ep.address().to_v4().to_uint();
        uint16_t lowBits = static_cast<uint16_t>(address);
        uint16_t highBits = address >> (sizeof(uint16_t) * CHAR_BIT);
        result ^= lowBits ^ highBits;
    }
    else {
        auto bytes = ep.address().to_v6().to_bytes();
        auto ptr = reinterpret_cast<uint8_t*>(&result);
        auto bytesPtr = bytes.data();
        for (size_t i = 0; i < 8; ++i) {
            *ptr ^= *(bytesPtr++);
        }

        ++ptr;

        for (size_t i = 8; i < 16; ++i) {
            *ptr ^= *(bytesPtr++);
        }
    }

    return result;
}

RemoteNodePtr Transport::getPackSenderEntry(const ip::udp::endpoint& ep) {
    auto& rn = remoteNodesMap_.tryStore(ep);

    if (!rn) {  // Newcomer
        rn = remoteNodes_.emplace();
    }

    rn->packets.fetch_add(1, std::memory_order_relaxed);
    return rn;
}

bool Transport::sendDirect(const Packet* pack, const Connection& conn) {
    uint32_t nextBytesCount = static_cast<uint32_t>(conn.lastBytesCount.load(std::memory_order_relaxed) + pack->size());
    if (nextBytesCount <= config_.getConnectionBandwidth()) {
        conn.lastBytesCount.fetch_add(static_cast<uint32_t>(pack->size()), std::memory_order_relaxed);
        net_->sendDirect(*pack, conn.getOut());
        return true;
    }

    return false;
}

void Transport::deliverDirect(const Packet* pack, const uint32_t size, ConnectionPtr conn) {
    if (size >= Packet::MaxFragments) {
        ++Transport::cntExtraLargeNotSent;
        return;
    }
    const auto packEnd = pack + size;
    for (auto ptr = pack; ptr != packEnd; ++ptr) {
        nh_.registerDirect(ptr, conn);
        sendDirect(ptr, **conn);
    }
}

void Transport::deliverBroadcast(const Packet* pack, const uint32_t size) {
    if (size >= Packet::MaxFragments) {
        ++Transport::cntExtraLargeNotSent;
        return;
    }
    const auto packEnd = pack + size;
    for (auto ptr = pack; ptr != packEnd; ++ptr) {
        sendBroadcast(ptr);
    }
}

// Processing network packages

void Transport::processNetworkTask(const TaskPtr<IPacMan>& task, RemoteNodePtr& sender) {
    iPackStream_.init(task->pack.getMsgData(), task->pack.getMsgSize());

    NetworkCommand cmd;
    iPackStream_ >> cmd;

    if (!iPackStream_.good()) {
        return sender->addStrike();
    }

    if (cmd != NetworkCommand::Registration) {
        if (sender->isBlackListed()) {
            csdebug() << "Network command is ignored from blacklisted " << task->sender;
            return;
        }
    }

    bool result = true;

    switch (cmd) {
        case NetworkCommand::Registration:
            result = gotRegistrationRequest(task, sender);
            break;
        case NetworkCommand::ConfirmationRequest:
            break;
        case NetworkCommand::ConfirmationResponse:
            break;
        case NetworkCommand::RegistrationConfirmed:
            result = gotRegistrationConfirmation(task, sender);
            break;
        case NetworkCommand::RegistrationRefused:
            result = gotRegistrationRefusal(task, sender);
            break;
        case NetworkCommand::Ping:
            gotPing(task, sender);
            break;
        case NetworkCommand::SSRegistration:
            gotSSRegistration(task, sender);
            break;
        case NetworkCommand::SSReRegistration:
            gotSSReRegistration();
            break;
        case NetworkCommand::SSFirstRound:
            gotSSDispatch(task);
            break;
        case NetworkCommand::SSRegistrationRefused:
            gotSSRefusal(task);
            break;
        case NetworkCommand::SSPingWhiteNode:
            gotSSPingWhiteNode(task);
            break;
        case NetworkCommand::SSLastBlock:
            gotSSLastBlock(task, node_->getBlockChain().getLastSequence(), node_->getBlockChain().getLastHash(), node_->canBeTrusted());
            break;
        case NetworkCommand::SSSpecificBlock: {
            cs::RoundNumber round = 0;
            iPackStream_ >> round;

            gotSSLastBlock(task, round, node_->getBlockChain().getHashBySequence(round), node_->canBeTrusted());

            break;
        }

        case NetworkCommand::PackInform:
            gotPackInform(task, sender);
            break;
        case NetworkCommand::PackRenounce:
            // gotPackRenounce(task, sender);
            break;
        case NetworkCommand::PackRequest:
            // gotPackRequest(task, sender);
            break;
        default:
            result = false;
            cswarning() << "Unexpected network command";
    }

    if (!result) {
        sender->addStrike();
    }
}

void Transport::refillNeighbourhood() {
    // TODO: check this algorithm when all list nodes are dead
    if (config_.getBootstrapType() == BootstrapType::IpList) {
        for (auto& ep : config_.getIpList()) {
            if (!nh_.canHaveNewConnection()) {
                cswarning() << "Connections limit reached";
                break;
            }

            cslog() << "Creating connection to " << ep.ip;
            nh_.establishConnection(net_->resolve(ep));
        }
    }

    if (config_.getBootstrapType() == BootstrapType::SignalServer || config_.getNodeType() == NodeType::Router) {
        // Connect to SS logic
        ssEp_ = net_->resolve(config_.getSignalServerEndpoint());
        cslog() << "Connecting to Signal Server on " << ssEp_;

        {
            cs::Lock lock(oLock_);
            formSSConnectPack(config_, oPackStream_, myPublicKey_, node_->getBlockChain().uuid());
            ssStatus_ = SSBootstrapStatus::Requested;
            net_->sendDirect(*(oPackStream_.getPackets()), ssEp_);
        }
    }
}

bool Transport::parseSSSignal(const TaskPtr<IPacMan>& task) {
    iPackStream_.init(task->pack.getMsgData(), task->pack.getMsgSize());
    iPackStream_.safeSkip<uint8_t>(1);
    iPackStream_.safeSkip<cscrypto::PublicKey>(1);

    cs::RoundNumber rNum = 0;
    iPackStream_ >> rNum;

    auto trStart = iPackStream_.getCurrentPtr();

    uint8_t numConf;
    iPackStream_ >> numConf;

    if (!iPackStream_.good()) {
        return false;
    }

    iPackStream_.safeSkip<cs::PublicKey>(numConf + 1);

    auto trFinish = iPackStream_.getCurrentPtr();
    node_->getRoundTableSS(trStart, cs::numeric_cast<size_t>(trFinish - trStart), rNum);

    uint8_t numCirc;
    iPackStream_ >> numCirc;

    if (!iPackStream_.good()) {
        return false;
    }

    uint32_t ctr = nh_.size();

    if (config_.getBootstrapType() == BootstrapType::SignalServer) {
        for (uint8_t i = 0; i < numCirc; ++i) {
            EndpointData ep;
            ep.ipSpecified = true;
            cs::PublicKey key;

            iPackStream_ >> ep.ip >> ep.port >> key;

            if (!iPackStream_.good()) {
                return false;
            }

            ++ctr;

            if (!std::equal(key.cbegin(), key.cend(), config_.getMyPublicKey().cbegin())) {
                if (ctr <= config_.getMaxNeighbours()) {
                    nh_.establishConnection(net_->resolve(ep));
                }
            }

            if (!nh_.canHaveNewConnection()) {
                break;
            }
        }
    }

    ssStatus_ = SSBootstrapStatus::Complete;
    return true;
}

constexpr const uint32_t StrippedDataSize = sizeof(cs::RoundNumber) + sizeof(MsgTypes);
void Transport::processNodeMessage(const Message& msg) {
    auto type = msg.getFirstPack().getType();
    auto rNum = msg.getFirstPack().getRoundNum();

    switch (node_->chooseMessageAction(rNum, type, msg.getFirstPack().getSender())) {
        case Node::MessageActions::Process:
            return dispatchNodeMessage(type, rNum, msg.getFirstPack(), msg.getFullData() + StrippedDataSize, msg.getFullSize() - StrippedDataSize);
        case Node::MessageActions::Postpone:
            return postponePacket(rNum, type, msg.extractData());
        case Node::MessageActions::Drop:
            return;
    }
}

constexpr cs::RoundNumber getRoundTimeout(const MsgTypes type) {
    switch (type) {
        case MsgTypes::FirstSmartStage:
        case MsgTypes::SecondSmartStage:
        case MsgTypes::ThirdSmartStage:
        case MsgTypes::RejectedContracts:
            return 100;
        default:
            return 5;
    }
}

bool Transport::shouldSendPacket(const Packet& pack) {
    if (pack.isNetwork()) {
        return false;
    }

    const cs::RoundNumber currentRound = cs::Conveyer::instance().currentRoundNumber();

    if (!pack.isFragmented()) {
        return (pack.getRoundNum() + getRoundTimeout(pack.getType())) >= currentRound;
    }

    auto& rn = fragOnRound_.tryStore(pack.getHeaderHash());

    if (pack.getFragmentId() == 0) {
        rn = pack.getRoundNum() + getRoundTimeout(pack.getType());
    }

    return !rn || rn >= currentRound;
}

void Transport::processNodeMessage(const Packet& pack) {
    auto type = pack.getType();
    auto rNum = pack.getRoundNum();

    switch (node_->chooseMessageAction(rNum, type, pack.getSender())) {
        case Node::MessageActions::Process:
            return dispatchNodeMessage(type, rNum, pack, pack.getMsgData() + StrippedDataSize, pack.getMsgSize() - StrippedDataSize);
        case Node::MessageActions::Postpone:
            return postponePacket(rNum, type, pack);
        case Node::MessageActions::Drop:
            return;
    }
}

inline void Transport::postponePacket(const cs::RoundNumber rNum, const MsgTypes type, const Packet& pack) {
    (*postponed_)->emplace(rNum, type, pack);
}

void Transport::processPostponed(const cs::RoundNumber rNum) {
    auto& ppBuf = *postponed_[1];
    for (auto& pp : **postponed_) {
        if (pp.round > rNum) {
            ppBuf.emplace(std::move(pp));
        }
        else if (pp.round == rNum) {
            dispatchNodeMessage(pp.type, pp.round, pp.pack, pp.pack.getMsgData() + StrippedDataSize, pp.pack.getMsgSize() - StrippedDataSize);
        }
    }

    (*postponed_)->clear();

    postponed_[1] = *postponed_;
    postponed_[0] = &ppBuf;

    csdebug() << "TRANSPORT> POSTPHONED finished, round " << rNum;
}

void Transport::dispatchNodeMessage(const MsgTypes type, const cs::RoundNumber rNum, const Packet& firstPack, const uint8_t* data, size_t size) {
    if (size == 0) {
        cserror() << "Bad packet size, why is it zero?";
        return;
    }

    // cut my packs
    if (firstPack.getSender() == node_->getNodeIdKey()) {
        csdebug() << "TRANSPORT> Ignore own packs";
        return;
    }

    // never cut packets
    switch (type) {
        case MsgTypes::BlockRequest:
            return node_->getBlockRequest(data, size, firstPack.getSender());
        case MsgTypes::RequestedBlock:
            return node_->getBlockReply(data, size);
        case MsgTypes::BigBang:  // any round (in theory) may be set
            return node_->getBigBang(data, size, rNum);
        case MsgTypes::RoundTableRequest:  // old-round node may ask for round info
            return node_->getRoundTableRequest(data, size, rNum, firstPack.getSender());
        case MsgTypes::NodeStopRequest:
            return node_->getNodeStopRequest(rNum, data, size);
        case MsgTypes::RoundTable:
            return node_->getRoundTable(data, size, rNum, firstPack.getSender());
        case MsgTypes::RoundTableSS:
            return node_->getRoundTableSS(data, size, rNum);
        default:
            break;
    }

    // cut slow packs
    if ((rNum + getRoundTimeout(type)) < cs::Conveyer::instance().currentRoundNumber()) {
        csdebug() << "TRANSPORT> Ignore old packs, round " << rNum << ", type " << Packet::messageTypeToString(type) << ", fragments " << firstPack.getFragmentsNum();
        return;
    }

    if (type == MsgTypes::ThirdSmartStage) {
        csdebug() << "+++++++++++++++++++  ThirdSmartStage arrived +++++++++++++++++++++";
    }

    // packets which transport may cut
    switch (type) {
        case MsgTypes::BlockHash:
            return node_->getHash(data, size, rNum, firstPack.getSender());
        case MsgTypes::HashReply:
            return node_->getHashReply(data, size, rNum, firstPack.getSender());
        case MsgTypes::TransactionPacket:
            return node_->getTransactionsPacket(data, size);
        case MsgTypes::TransactionsPacketRequest:
            return node_->getPacketHashesRequest(data, size, rNum, firstPack.getSender());
        case MsgTypes::TransactionsPacketReply:
            return node_->getPacketHashesReply(data, size, rNum, firstPack.getSender());
        case MsgTypes::FirstStage:
            return node_->getStageOne(data, size, firstPack.getSender());
        case MsgTypes::SecondStage:
            return node_->getStageTwo(data, size, firstPack.getSender());
        case MsgTypes::FirstStageRequest:
            return node_->getStageRequest(type, data, size, firstPack.getSender());
        case MsgTypes::SecondStageRequest:
            return node_->getStageRequest(type, data, size, firstPack.getSender());
        case MsgTypes::ThirdStageRequest:
            return node_->getStageRequest(type, data, size, firstPack.getSender());
        case MsgTypes::ThirdStage:
            return node_->getStageThree(data, size);
        case MsgTypes::FirstSmartStage:
            return node_->getSmartStageOne(data, size, rNum, firstPack.getSender());
        case MsgTypes::SecondSmartStage:
            return node_->getSmartStageTwo(data, size, rNum, firstPack.getSender());
        case MsgTypes::ThirdSmartStage:
            return node_->getSmartStageThree(data, size, rNum, firstPack.getSender());
        case MsgTypes::SmartFirstStageRequest:
            return node_->getSmartStageRequest(type, data, size, firstPack.getSender());
        case MsgTypes::SmartSecondStageRequest:
            return node_->getSmartStageRequest(type, data, size, firstPack.getSender());
        case MsgTypes::SmartThirdStageRequest:
            return node_->getSmartStageRequest(type, data, size, firstPack.getSender());
        case MsgTypes::RejectedContracts:
            return node_->getSmartReject(data, size, rNum, firstPack.getSender());
        case MsgTypes::RoundTableReply:
            return node_->getRoundTableReply(data, size, firstPack.getSender());
        case MsgTypes::RoundPackRequest:
            return node_->getRoundPackRequest(data, size, rNum, firstPack.getSender());
        default:
            cserror() << "TRANSPORT> Unknown message type " << Packet::messageTypeToString(type) << " pack round " << rNum;
            break;
    }
}

void Transport::registerTask(Packet* pack, const uint32_t packNum, const bool incrementWhenResend) {
    auto end = pack + packNum;

    for (auto ptr = pack; ptr != end; ++ptr) {
        cs::Lock lock(sendPacksFlag_);
        PackSendTask pst;
        pst.pack = *ptr;
        pst.incrementId = incrementWhenResend;
        sendPacks_.emplace(pst);
    }
}

void Transport::addTask(Packet* pack, const uint32_t packNum, bool incrementWhenResend) {
    if (packNum >= Packet::MaxFragments) {
        ++Transport::cntExtraLargeNotSent;
        return;
    }
    nh_.pourByNeighbours(pack, packNum);
    if (packNum > 1) {
        net_->registerMessage(pack, packNum);
    }
    registerTask(pack, 1, incrementWhenResend);
}

void Transport::clearTasks() {
    cs::Lock lock(sendPacksFlag_);
    sendPacks_.clear();
}

uint32_t Transport::getNeighboursCount() {
    return nh_.size();
}

uint32_t Transport::getNeighboursCountWithoutSS() {
    return nh_.getNeighboursCountWithoutSS();
}

uint32_t Transport::getMaxNeighbours() const {
    return config_.getMaxNeighbours();
}

ConnectionPtr Transport::getSyncRequestee(const cs::Sequence seq, bool& alreadyRequested) {
    return nh_.getNextSyncRequestee(seq, alreadyRequested);
}

ConnectionPtr Transport::getConnectionByKey(const cs::PublicKey& pk) {
    return nh_.getNeighbourByKey(pk);
}

ConnectionPtr Transport::getConnectionByNumber(const std::size_t number) {
    return nh_.getNeighbour(number);
}

ConnectionPtr Transport::getRandomNeighbour() {
    csdebug() << "Transport> Get random neighbour for Sync";
    return nh_.getRandomSyncNeighbour();
}

std::unique_lock<cs::SpinLock> Transport::getNeighboursLock() const {
    return nh_.getNeighboursLock();
}

void Transport::forEachNeighbour(std::function<void(ConnectionPtr)> func) {
    nh_.forEachNeighbour(std::move(func));
}

void Transport::forEachNeighbourWithoudSS(std::function<void(ConnectionPtr)> func) {
    nh_.forEachNeighbourWithoutSS(std::move(func));
}

const Connections Transport::getNeighbours() const {
    return nh_.getNeigbours();
}

const Connections Transport::getNeighboursWithoutSS() const {
    return nh_.getNeighboursWithoutSS();
}

void Transport::syncReplied(const cs::Sequence seq) {
    return nh_.releaseSyncRequestee(seq);
}

bool Transport::isPingDone() {
    return nh_.isPingDone();
}

void Transport::resetNeighbours() {
    csdebug() << "Transport> Reset neighbours";
    return nh_.resetSyncNeighbours();
}

/* Sending network tasks */
void Transport::sendRegistrationRequest(Connection& conn) {

    RemoteNodePtr ptr = getPackSenderEntry(conn.getOut());
    if (ptr->isBlackListed()) {
        return;
    }

    cslog() << "Sending registration request to " << (conn.specialOut ? conn.out : conn.in);

    cs::Lock lock(oLock_);
    Packet req(netPacksAllocator_.allocateNext(cs::numeric_cast<uint32_t>(regPack_.size())));
    *regPackConnId_ = conn.id;
    memcpy(req.data(), regPack_.data(), regPack_.size());

    ++(conn.attempts);
    sendDirect(&req, conn);
}

void Transport::sendRegistrationConfirmation(const Connection& conn, const Connection::Id requestedId) {
    cslog() << "Confirming registration with " << conn.getOut();

    cs::Lock lock(oLock_);
    oPackStream_.init(BaseFlags::NetworkMsg);
    oPackStream_ << NetworkCommand::RegistrationConfirmed << requestedId << conn.id << myPublicKey_;

    sendDirect(oPackStream_.getPackets(), conn);
    oPackStream_.clear();
}

void Transport::sendRegistrationRefusal(const Connection& conn, const RegistrationRefuseReasons reason) {
    cslog() << "Refusing registration with " << conn.in;

    cs::Lock lock(oLock_);
    oPackStream_.init(BaseFlags::NetworkMsg);
    oPackStream_ << NetworkCommand::RegistrationRefused << conn.id << reason;

    sendDirect(oPackStream_.getPackets(), conn);
    oPackStream_.clear();
}

// Requests processing
bool Transport::gotRegistrationRequest(const TaskPtr<IPacMan>& task, RemoteNodePtr& sender) {
    cslog() << "Got registration request from " << task->sender;

    NodeVersion vers;
    uint64_t remote_uuid = 0;
    iPackStream_ >> vers >> remote_uuid;

    if (!iPackStream_.good()) {
        return false;
    }

    Connection conn;
    conn.in = task->sender;
    auto& flags = iPackStream_.peek<uint8_t>();

    if (flags & RegFlags::RedirectIP) {
        boost::asio::ip::address addr;
        iPackStream_ >> addr;

        conn.out.address(addr);
        conn.specialOut = true;
    }
    else {
        conn.specialOut = false;
        iPackStream_.skip<uint8_t>();
    }

    if (flags & RegFlags::RedirectPort) {
        Port port = Port();
        iPackStream_ >> port;

        if (!conn.specialOut) {
            conn.specialOut = true;
            conn.out.address(task->sender.address());
        }
        conn.out.port(port);
    }
    else if (conn.specialOut) {
        conn.out.port(task->sender.port());
    }

    if (vers != NODE_VERSION) {
        sendRegistrationRefusal(conn, RegistrationRefuseReasons::BadClientVersion);
        return true;
    }

    RemoteNodePtr ptr = getPackSenderEntry(conn.getOut());
    uint64_t local_uuid = node_->getBlockChain().uuid();
    if (local_uuid != 0 && remote_uuid != 0 && local_uuid != remote_uuid) {
        sendRegistrationRefusal(conn, RegistrationRefuseReasons::IncompatibleBlockchain);
        ptr->setBlackListed(true);
        return true;
    }
    else {
        ptr->setBlackListed(false);
    }

    iPackStream_ >> conn.id;
    iPackStream_ >> conn.key;

    if (!iPackStream_.good() || !iPackStream_.end()) {
        return false;
    }

    nh_.gotRegistration(std::move(conn), sender);
    return true;
}

bool Transport::gotRegistrationConfirmation(const TaskPtr<IPacMan>& task, RemoteNodePtr& sender) {
    cslog() << "Got registration confirmation from " << task->sender;

    ConnectionId myCId;
    ConnectionId realCId;
    cs::PublicKey key;
    iPackStream_ >> myCId >> realCId >> key;

    if (!iPackStream_.good()) {
        return false;
    }

    nh_.gotConfirmation(myCId, realCId, task->sender, key, sender);
    return true;
}

bool Transport::gotRegistrationRefusal(const TaskPtr<IPacMan>& task, RemoteNodePtr&) {
    cslog() << "Got registration refusal from " << task->sender;

    RegistrationRefuseReasons reason;
    Connection::Id id;
    iPackStream_ >> id >> reason;

    if (!iPackStream_.good() || !iPackStream_.end()) {
        return false;
    }

    nh_.gotRefusal(id);

    std::string reason_info;
    switch (reason) {
    case RegistrationRefuseReasons::BadClientVersion:
        reason_info = "incompatible node version";
        break;
    case RegistrationRefuseReasons::IncompatibleBlockchain:
        reason_info = "incompatible blockchain version";
        break;
    case RegistrationRefuseReasons::LimitReached:
        reason_info = "maximum connections limit on remote node is reached";
        break;
    default:
        {
            std::ostringstream os;
            os << "reason code " << static_cast<int>(reason);
            reason_info = os.str();
        }
        break;
    }
    cslog() << "Registration to " << task->sender << " refused: " << reason_info;

    return true;
}

bool Transport::gotSSRegistration(const TaskPtr<IPacMan>& task, RemoteNodePtr& rNode) {
    if (ssStatus_ != SSBootstrapStatus::Requested) {
        cswarning() << "Unexpected Signal Server response " << static_cast<int>(ssStatus_) << " instead of Requested";
        return false;
    }

    cslog() << "Connection to the Signal Server has been established";
    nh_.addSignalServer(task->sender, ssEp_, rNode);

    constexpr int MinRegistrationSize = 1 + cscrypto::kPublicKeySize;
    size_t msg_size = task->pack.getMsgSize();

    if (msg_size > MinRegistrationSize) {
        if (!parseSSSignal(task)) {
            cswarning() << "Bad Signal Server response";
        }
    }
    else {
        ssStatus_ = SSBootstrapStatus::RegisteredWait;
    }

    return true;
}

bool Transport::gotSSReRegistration() {
    cswarning() << "ReRegistration on Signal Server";

    {
        cs::Lock lock(oLock_);
        formSSConnectPack(config_, oPackStream_, myPublicKey_, node_->getBlockChain().uuid());
        net_->sendDirect(*(oPackStream_.getPackets()), ssEp_);
    }

    return true;
}

bool Transport::gotSSDispatch(const TaskPtr<IPacMan>& task) {
    if (ssStatus_ != SSBootstrapStatus::RegisteredWait) {
        cswarning() << "Unexpected Signal Server response " << static_cast<int>(ssStatus_) << " instead of RegisteredWait";
    }

    if (!parseSSSignal(task)) {
        cswarning() << "Bad Signal Server response";
    }

    return true;
}

bool Transport::gotSSRefusal(const TaskPtr<IPacMan>&) {
    uint16_t expectedVersion;
    RegistrationRefuseReasons reason;
    iPackStream_ >> expectedVersion >> reason;

    if (!iPackStream_.good() || !iPackStream_.end()) {
        return false;
    }

    cserror() << "The Starter node has refused the registration";
    switch (reason) {
    case RegistrationRefuseReasons::BadClientVersion:
        cserror() << "Your client version << " << NODE_VERSION << " is obsolete. The allowed version is " << expectedVersion << ". Please upgrade your node application";
        break;
    case RegistrationRefuseReasons::IncompatibleBlockchain:
        cserror() << "Your blockchain version is incompatible. You only may join the network with empty blockchain";
        break;
    default:
        cserror() << "The reason code is " << static_cast<int>(reason);
        break;
    }

    return true;
}

bool Transport::gotSSPingWhiteNode(const TaskPtr<IPacMan>& task) {
    Connection conn;
    conn.in = task->sender;
    conn.specialOut = false;
    sendDirect(&task->pack, conn);
    return true;
}

bool Transport::gotSSLastBlock(const TaskPtr<IPacMan>& task, cs::Sequence lastBlock, const csdb::PoolHash& lastHash, bool canBeTrusted) {
#if !defined(MONITOR_NODE) && !defined(WEB_WALLET_NODE)
    csdebug() << "TRANSPORT> Got SS Last Block: " << lastBlock;
    csunused(task);

    Connection conn;
    conn.in = net_->resolve(config_.getSignalServerEndpoint());
    conn.specialOut = false;

    cs::Lock lock(oLock_);
    oPackStream_.init(BaseFlags::NetworkMsg);
    oPackStream_ << NetworkCommand::SSLastBlock << NODE_VERSION;

    cs::Hash lastHash_;
    const auto hashBinary = lastHash.to_binary();
    std::copy(hashBinary.begin(), hashBinary.end(), lastHash_.begin());

    oPackStream_ << lastBlock << canBeTrusted << myPublicKey_ << lastHash_;

    sendDirect(oPackStream_.getPackets(), conn);
#else
    csunused(task);
    csunused(lastBlock);
    csunused(lastHash);
    csunused(canBeTrusted);
#endif
    return true;
}

void Transport::gotPacket(const Packet& pack, RemoteNodePtr& sender) {
    if (!pack.isFragmented()) {
        return;
    }

    nh_.neighbourSentPacket(sender, pack.getHeaderHash());
}

void Transport::redirectPacket(const Packet& pack, RemoteNodePtr& sender) {
    sendPackInform(pack, sender);

    if (pack.isNeighbors()) {
        return;  // Do not redirect packs
    }

    if (pack.isFragmented() && pack.getFragmentsNum() > Packet::SmartRedirectTreshold) {
        nh_.redirectByNeighbours(&pack);
    }
    else {
        nh_.neighbourHasPacket(sender, pack.getHash(), false);
        sendBroadcast(&pack);
    }
}

void Transport::sendPackInform(const Packet& pack, RemoteNodePtr& sender) {
    ConnectionPtr conn = nh_.getConnection(sender);
    if (!conn) {
        return;
    }
    sendPackInform(pack, **conn);
}

void Transport::sendPackInform(const Packet& pack, const Connection& addr) {
    cs::Lock lock(oLock_);
    oPackStream_.init(BaseFlags::NetworkMsg);
    oPackStream_ << NetworkCommand::PackInform << static_cast<cs::Byte>(pack.isNeighbors()) << pack.getHash();
    sendDirect(oPackStream_.getPackets(), addr);
    oPackStream_.clear();
}

bool Transport::gotPackInform(const TaskPtr<IPacMan>&, RemoteNodePtr& sender) {
    uint8_t isDirect = 0;
    cs::Hash hHash;
    iPackStream_ >> isDirect >> hHash;

    if (!iPackStream_.good() || !iPackStream_.end()) {
        return false;
    }

    nh_.neighbourHasPacket(sender, hHash, isDirect);
    return true;
}

void Transport::sendPackRenounce(const cs::Hash& hash, const Connection& addr) {
    cs::Lock lock(oLock_);
    oPackStream_.init(BaseFlags::NetworkMsg);

    oPackStream_ << NetworkCommand::PackRenounce << hash;

    sendDirect(oPackStream_.getPackets(), addr);
    oPackStream_.clear();
}

bool Transport::gotPackRenounce(const TaskPtr<IPacMan>&, RemoteNodePtr& sender) {
    cs::Hash hHash;

    iPackStream_ >> hHash;

    if (!iPackStream_.good() || !iPackStream_.end()) {
        return false;
    }

    nh_.neighbourSentRenounce(sender, hHash);

    return true;
}

void Transport::askForMissingPackages() {
    typename decltype(uncollected_)::const_iterator ptr;
    MessagePtr msg;
    size_t i = 0;

    // magic numbers??
    const uint64_t maxMask = 1ull << 63;

    cs::Lock lock(uLock_);
    ptr = uncollected_.begin();

    while (true) {
        if (i >= uncollected_.size()) {
            break;
        }

        msg = *ptr;
        ++ptr;
        ++i;

        {
            cs::Lock messageLock(msg->pLock_);
            const auto end = msg->packets_ + msg->packetsTotal_;

            uint16_t start = 0;
            uint64_t mask = 0;
            uint64_t req = 0;

            for (auto s = msg->packets_; s != end; ++s) {
                if (!*s) {
                    if (!mask) {
                        mask = 1;
                        start = cs::numeric_cast<uint16_t>(s - msg->packets_);
                    }
                    req |= mask;
                }

                if (mask == maxMask) {
                    requestMissing(msg->headerHash_, start, req);

                    if (s > (msg->packets_ + msg->maxFragment_) && (end - s) > 128) {
                        break;
                    }

                    mask = 0;
                }
                else {
                    mask <<= 1;
                }
            }

            if (mask) {
                requestMissing(msg->headerHash_, start, req);
            }
        }
    }
}

void Transport::requestMissing(const cs::Hash& hash, const uint16_t start, const uint64_t req) {
    Packet p;

    {
        cs::Lock lock(oLock_);
        oPackStream_.init(BaseFlags::NetworkMsg);
        oPackStream_ << NetworkCommand::PackRequest << hash << start << req;
        p = *(oPackStream_.getPackets());
        oPackStream_.clear();
    }

    ConnectionPtr requestee = nh_.getNextRequestee(hash);

    if (requestee) {
        sendDirect(&p, **requestee);
    }
}

void Transport::registerMessage(MessagePtr msg) {
    cs::Lock lock(uLock_);
    auto& ptr = uncollected_.emplace(msg);
    //DEBUG:
    Message& message = *ptr.get();
    size_t cnt = message.clearUnused();
    if (cnt > 0) {
        csdebug() << "Net: potential heap corruption detected in uncollected message fragments (" << cnt << ")";
        Transport::cntDirtyAllocs += cnt;
    }
}

bool Transport::gotPackRequest(const TaskPtr<IPacMan>&, RemoteNodePtr& sender) {
    ConnectionPtr conn = nh_.getConnection(sender);
    if (!conn) {
        return false;
    }

    auto ep = conn->specialOut ? conn->out : conn->in;

    cs::Hash hHash;
    uint16_t start = 0u;
    uint64_t req = 0u;

    iPackStream_ >> hHash >> start >> req;

    if (!iPackStream_.good() || !iPackStream_.end()) {
        return false;
    }

    uint32_t reqd = 0, snt = 0;
    uint64_t mask = 1;

    while (mask) {
        if (mask & req) {
            ++reqd;
            if (net_->resendFragment(hHash, start, ep)) {
                ++snt;
            }
        }

        ++start;
        mask <<= 1;
    }

    return true;
}

void Transport::sendPingPack(const Connection& conn) {
    cs::Sequence seq = node_->getBlockChain().getLastSequence();
    cs::Lock lock(oLock_);
    oPackStream_.init(BaseFlags::NetworkMsg);
    oPackStream_ << NetworkCommand::Ping << conn.id << seq << myPublicKey_;

#if defined(PING_WITH_BCHID)
        oPackStream_ << node_->getBlockChain().uuid();
#endif

    sendDirect(oPackStream_.getPackets(), conn);
    oPackStream_.clear();
}

bool Transport::gotPing(const TaskPtr<IPacMan>& task, RemoteNodePtr& sender) {
    Connection::Id id = 0u;
    cs::Sequence lastSeq = 0u;

    cs::PublicKey pk;
    iPackStream_ >> id >> lastSeq >> pk;

#if defined(PING_WITH_BCHID)
    uint64_t remote_bch_uuid = 0;
        iPackStream_ >> remote_bch_uuid;
        uint64_t local_bch_uuid = node_->getBlockChain().uuid();
        if (local_bch_uuid != 0 && remote_bch_uuid != 0) {
            if (local_bch_uuid != remote_bch_uuid) {
                // remote is incompatible
                return false;
            }
        }
#endif

    if (!iPackStream_.good() || !iPackStream_.end()) {
        return false;
    }


    if (lastSeq > maxBlock_) {
        maxBlock_ = lastSeq;
        maxBlockCount_ = 1;
    }

    if (nh_.validateConnectionId(sender, id, task->sender, pk, lastSeq)) {
        emit pingReceived(lastSeq, pk);
    }

    return true;
}
```
# ..\node\solver\include\solver\callsqueuescheduler.hpp 
```cpp 
#pragma once

#include <atomic>
#include <chrono>
#include <condition_variable>
#include <cstdint>
#include <functional>
#include <map>
#include <set>
#include <thread>

// template<typename TResol = std::chrono::milliseconds>
class CallsQueueScheduler {
public:
    enum class Launch {
        ///< An enum constant representing the once option: launch once, cancel if previous schedule call still is not done
        once,

        ///< An enum constant representing the periodic option: launch periodically, schedule call cancels if already
        ///< running one cycle
        periodic
    };

    using ClockType = std::chrono::steady_clock;
    using ProcType = std::function<void()>;
    using CallTag = uintptr_t;

    constexpr static CallTag no_tag = 0;
    constexpr static CallTag auto_tag = no_tag;

    /**
     * @fn  CallsQueueScheduler::CallsQueueScheduler()
     *
     * @brief   Default constructor
     *
     * @author  aae
     * @date    17.09.2018
     */

    CallsQueueScheduler()
    : _queue(compare) {
    }

    CallsQueueScheduler(const CallsQueueScheduler&) = delete;
    CallsQueueScheduler& operator=(const CallsQueueScheduler&) = delete;

    /**
     * @fn  void CallsQueueScheduler::Run();
     *
     * @brief   Runs scheduler in separate thread, is optional for call. Would be automatically called by the first
     * Insert() operation
     *
     * @author  aae
     * @date    17.09.2018
     */

    void Run();

    /**
     * @fn  void CallsQueueScheduler::Stop();
     *
     * @brief   Stops this object by clearing the queue and waits for worker thread to stop
     *
     * @author  aae
     * @date    17.09.2018
     */

    void Stop();

    /**
     * @fn  CallTag CallsQueueScheduler::Insert(ClockType::duration wait_for, const ProcType& proc, Launch scheme, bool replace_existing = false, CallTag tag = auto_tag);
     *
     * @brief Inserts new call into queue according to wait_for parameter. Do check before insert to
     *        avoid queuing of duplicated calls
     *
     * @author  aae
     * @date  17.09.2018
     *
     * @param wait_for          Time to wait before do call a procedure.
     * @param proc              The procedure to be scheduled for call.
     * @param scheme            The scheme: once - do one call, periodic - repeat calls every wait_for
     *                          period.
     * @param replace_existing  (Optional) True to replace existing scheduled calls if any, otherwise
     *                          reject new schedule.
     * @param tag               (Optional) The tag desired, must be unique through all the queue. When not specified is assigned automatically
     *
     * @return  A tag that can be used in future to remove scheduled call from queue if any, or
     *          CallsQueueScheduler::no_tag if schedule failed. If schedule rejected due to existing one
     *          returns tag of existing schedule.
     */

    CallTag Insert(ClockType::duration wait_for, const ProcType& proc, Launch scheme, bool replace_existing = false, CallTag tag = auto_tag);

    /**
     * @fn  CallTag CallsQueueScheduler::InsertOnce(uint32_t wait_for_ms, const ProcType& proc, bool replace_existing = false, CallTag tag = auto_tag)
     *
     * @brief Schedule proc to be called once
     *
     * @author  aae
     * @date  18.09.2018
     *
     * @param wait_for_ms       The wait for in milliseconds.
     * @param proc              The procedure to call.
     * @param replace_existing  (Optional) True to replace existing scheduled calls if any, otherwise
     *                          reject new schedule.
     * @param tag               (Optional) The tag desired, must be unique through all the queue. When not specified is assigned automatically
     *
     * @return  An id that can be used in future to remove scheduled call from queue if any, or
     *          CallsQueueScheduler::no_tag if schedule failed. If schedule rejected due to existing one
     *          returns tag of existing schedule.
     */

    CallTag InsertOnce(uint32_t wait_for_ms, const ProcType& proc, bool replace_existing = false, CallTag tag = auto_tag) {
        return Insert(std::chrono::milliseconds(wait_for_ms), proc, Launch::once, replace_existing, tag);
    }

    /**
     * @fn  CallTag CallsQueueScheduler::InsertPeriodic(uint32_t wait_for_ms, const ProcType& proc, bool replace_existing = false, CallTag tag = auto_tag)
     *
     * @brief Schedule periodic call of proc
     *
     * @author  aae
     * @date  18.09.2018
     *
     * @param wait_for_ms       The wait for the first call in milliseconds and period between calls.
     * @param proc              The procedure o call.
     * @param replace_existing  (Optional) True to replace existing scheduled calls if any, otherwise
     *                          reject new schedule.
     * @param tag               (Optional) The tag desired, must be unique through all the queue. When not specified is assigned automatically
     *
     * @return  An id that can be used in future to remove scheduled call from queue if any, or
     *          CallsQueueScheduler::no_tag if schedule failed. If schedule rejected due to existing one
     *          returns tag of existing schedule.
     */

    CallTag InsertPeriodic(uint32_t wait_for_ms, const ProcType& proc, bool replace_existing = false, CallTag tag = auto_tag) {
        return Insert(std::chrono::milliseconds(wait_for_ms), proc, Launch::periodic, replace_existing, tag);
    }

    /**
     * @fn  bool CallsQueueScheduler::Remove(CallTag id);
     *
     * @brief   Removes the scheduled call idenified by id.
     *
     * @author  aae
     * @date    17.09.2018
     *
     * @param   id  The identifier of call to remove. The id must be obtained by previous call to Insert()
     *
     * @return  True if it succeeds, false if it fails.
     */

    bool Remove(CallTag id);

    /**
     * @fn  void RemoveAll();
     *
     * @brief   Removes all scheduled calls from queue. Do not concern already initiated calls placed to CallsQueue
     *
     * @author  aae
     * @date    18.09.2018
     */

    void RemoveAll();

    /**
     * @fn  void CallsQueueScheduler::Clear();
     *
     * @brief   Clears the queue of scheduled calls
     *
     * @author  aae
     * @date    17.09.2018
     */

    void Clear();

    /**
     * @fn  uint32_t CallsQueueScheduler::TotalExecutedCalls() const;
     *
     * @brief   Total executed calls
     *
     * @author  aae
     * @date    17.09.2018
     *
     * @return  The total number of executed calls during work.
     */

    uint32_t TotalExecutedCalls() const {
        return _cnt_total;
    }

    /**
     * @fn  uint32_t CallsQueueScheduler::TotalBlockedOnQueue() const
     *
     * @brief   Total blocked on queue
     *
     * @author  aae
     * @date    17.09.2018
     *
     * @return  The total number of calls blocked on queue.
     */

    uint32_t TotalBlockedOnQueue() const {
        return _cnt_block_que;
    }

    /**
     * @fn  uint32_t CallsQueueScheduler::TotalBlockedOnExecute() const
     *
     * @brief   Total blocked on execute
     *
     * @author  aae
     * @date    17.09.2018
     *
     * @return  The total number of calls blocked on execute.
     */

    uint32_t TotalBlockedOnExecute() const {
        return _cnt_block_exe;
    }

private:
    /**
     * @struct  Context
     *
     * @brief   Stores all info to call, re-schedule and cancel further calls in queue.
     *
     * @author  aae
     * @date    17.09.2018
     */

    struct Context {
        /** @brief   The identifier: lets find item in queue (e.g. for remove) */
        CallTag id;

        /** @brief   The time point for scheduled execution */
        ClockType::time_point tp;

        /** @brief   The delta - time period for periodic calls */
        long long dt;

        /** @brief   The procedure to call*/
        ProcType proc;

        // support for std::find() by id
        bool operator==(const CallTag rhs) const {
            return id == rhs;
        }
    };

    // used for sort items in _queue by time to call
    std::function<bool(const Context& lhs, const Context& rhs)> compare = [](const Context& lhs, const Context& rhs) { return lhs.tp < rhs.tp; };

    // container requirements: auto sort by tp, search by id
    std::multiset<Context, decltype(compare)> _queue;
    // sync access to _queue
    std::mutex _mtx_queue;

    // process _queue and puts on time calls into CallsQueue::instance() object
    std::thread _worker;

    // signals to _worker thread that _queue was updated
    std::condition_variable _signal;
    // need by _signal
    std::mutex _mtx_signal;

    // avoids "false" signals
    bool _flag = {false};

    // flag to stop _worker thread
    std::atomic_bool _stop = {false};

    // statistics
    uint32_t _cnt_total{0};
    uint32_t _cnt_block_exe{0};
    uint32_t _cnt_block_que{0};

    // Syncing with CallsQueue (to block proc execution if this one still in queue)

    struct ExeSync {
        uint32_t queued;
        uint32_t done;
    };

    std::map<CallTag, ExeSync> _exe_sync;

    // thread procedure
    void SchedulerProc();

    // methods below are NOT thread-safe, they must be synced at point of call!

    // must be called when put the lambda in CallsQueue for execution
    void OnExeQueued(CallTag id);
    // must be called from within lambda executed by CallsQueue
    void OnExeDone(CallTag id);
    // must be called before put lambda in CallsQueue to avoid duplicated lambdas in CallsQueue
    bool CanExe(CallTag id);
    // must be called from within lambda to confirm execution
    bool ConfirmExe(CallTag id);
};
```
# ..\node\solver\include\solver\consensus.hpp 
```cpp 
#pragma once

#include <csdb/amount.hpp>
#include <cstddef>  // : for size_t
#include <cstdint>

class Consensus {
public:
    /** @brief   Set the flag to log solver-with-state messages to console*/
    constexpr static bool Log = true;

    /** @brief   True if re-select write node on timeout is enabled*/
    constexpr static bool ReSelectWriteOnTimeout = false;

    /** @brief   True if write node may to reduce desired count of hashes on big bang and spawn next round immediately*/
    constexpr static bool ReduceMinHashesOnBigBang = false;

    /** @brief   The default state timeout */
    constexpr static unsigned int DefaultStateTimeout = 5000;

    /** @brief   Maximum time in msec to wait new round after consensus achieved, after that waiting trusted nodes
     * activates */
    constexpr static unsigned int PostConsensusTimeout = 60000;

    /** @brief   The minimum trusted nodes to start consensus */
    constexpr static unsigned int MinTrustedNodes = 3;

    /** @brief   The maximum trusted nodes to take part in consensus */
    constexpr static unsigned int MaxTrustedNodes = 25;

    /** @brief   The minimum cash for trusted nodes to participate consensus */
    constexpr static csdb::Amount MinStakeValue = csdb::Amount{50000};

    /** @brief   The round when DPOS starts working */
    constexpr static uint64_t StartingDPOS = 10'000ULL;

    /** @brief   The return value means: general (Writer->General) is not selected by "generals" */
    constexpr static uint8_t GeneralNotSelected = 100;

    /** @brief   Min duration (msec) to collect hashes in stage-1 of consensus */
    constexpr static uint32_t T_min_stage1 = 170;

    /** @brief   Numbet of rounds to prevent node from consensus participation */
    constexpr static uint32_t GrayListPunishment = 100;

    /** @brief   Max duration (msec) of the whole round (SolverCore on the 1st round) */
    constexpr static uint32_t T_round = 2000;

    /** @brief   Max timeout (msec) to wait stages (Trusted-2,3) */
    constexpr static uint32_t T_stage_request = 2000;

    /** @brief   Max timeout (msec) to execute smart contract */
    constexpr static uint32_t T_smart_contract = 60000;

    /** @brief   Max time to collect transactions (PermanentWrite, SolverCore on BigBang) */
    constexpr static uint32_t T_coll_trans = 500;

    /** @brief   Max hashes count to include in stage one data */
    constexpr static size_t MaxStageOneHashes = 100;

    /** @brief   Max count of rounds to execute smart contract. After that contract is assumed failed unconditionally */
    constexpr static unsigned int MaxRoundsCancelContract = 100;

    /** @brief The maximum count of rounds to store in chain new_state transaction. If contract still is "in the executor" timeout is fixed.
     * After that 5 rounds (MaxRoundsCancelContract - MaxRoundsExecuteContract) remains to complete consensus and put timeout new_state
     * into chain, otherwise  contract is assumed failed unconditionally
     */
    constexpr static unsigned int MaxRoundsExecuteContract = 95;

    /** @brief True to disable, false to enable the trusted request to become trusted next round again */
    constexpr static bool DisableTrustedRequestNextRound = true;
};
```
# ..\node\solver\include\solver\inodestate.hpp 
```cpp 
#pragma once

#include <cstdint>
#include "result.hpp"

#include <lib/system/common.hpp>

namespace csdb {
class Pool;
class PoolHash;
class Transaction;
}  // namespace csdb
namespace cs {
class TransactionsPacket;
struct HashVector;
struct HashMatrix;
struct StageOne;
struct StageTwo;
struct StageThree;
}  // namespace cs

namespace cs {
class SolverContext;

/**
 * @class   INodeState
 *
 * @brief   An interface of a node state in terms of StateMachine pattern
 *
 * @author  aae
 * @date    01.10.2018
 */

class INodeState {
public:
    virtual ~INodeState() {
    }

    /**
     * @fn  virtual void INodeState::on(SolverContext& ) = 0;
     *
     * @brief   Called when state becomes an active
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in]  parameter1  The core context.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    virtual void on(SolverContext& context) = 0;

    /**
     * @fn  virtual void INodeState::off(SolverContext& ) = 0;
     *
     * @brief   Called when state becomes an inactive
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in]  parameter1  The core context.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    virtual void off(SolverContext& context) = 0;

    /**
     * @fn  virtual void INodeState::expired(SolverContext& ) = 0;
     *
     * @brief   Called when timeout of current state is being active expired
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in]  parameter1  The core context.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    virtual void expired(SolverContext& context) = 0;

    /**
     * @fn  virtual void INodeState::onRoundEnd(SolverContext& context, bool is_bigbang) = 0;
     *
     * @brief   Called on the current round end
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in,out]  context     The context.
     * @param           is_bigbang  True if round finished by bigbang, false if not (normal finish).
     */

    virtual void onRoundEnd(SolverContext& context, bool is_bigbang) = 0;

    /**
     * @fn  virtual Result INodeState::onRoundTable(SolverContext& context, const cs::RoundNumber round) = 0;
     *
     * @brief   Is called when the new round table is received
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in]  context The core context.
     * @param       round   The new round number.
     *
     * @return  A Result of event: Finish - core has to make a transition, Ignore - continue to work
     *          in current state, Failed - error occurs.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    virtual Result onRoundTable(SolverContext& context, const cs::RoundNumber round) = 0;

    /**
     * @fn  virtual Result INodeState::onBlock(SolverContext& context, csdb::Pool& pool, const cs::PublicKey& sender) = 0;
     *
     * @brief   Is called when new block is received.
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in]      context The core context.
     * @param [in,out]  pool    The pool.
     * @param           sender  The sender of new block.
     *
     * @return  A Result of event: Finish - core has to make a transition, Ignore - continue to work
     *          in current state, Failed - error occurs.
     */

    virtual Result onBlock(SolverContext& context, csdb::Pool& pool, const cs::PublicKey& sender) = 0;

    /**
     * @fn  virtual Result INodeState::onHash(SolverContext& context, const csdb::PoolHash & pool_hash, const
     * cs::PublicKey& sender) = 0;
     *
     * @brief   Is called when new hash is received.
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in]  context     The core context.
     * @param       pool_hash   The hash received.
     * @param       sender      The sender of hash.
     *
     * @return  A Result of event: Finish - core has to make a transition, Ignore - continue to work
     *          in current state, Failed - error occurs.
     */

    virtual Result onHash(SolverContext& context, const csdb::PoolHash& pool_hash, const cs::PublicKey& sender) = 0;

    /**
     * @fn  virtual Result INodeState::onTransaction(SolverContext& context, const csdb::Transaction& trans) = 0;
     *
     * @brief   Is called when new transaction is received.
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in]  context The core context.
     * @param       trans   The transaction received.
     *
     * @return  A Result of event: Finish - core has to make a transition, Ignore - continue to work
     *          in current state, Failed - error occurs.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    virtual Result onTransaction(SolverContext& context, const csdb::Transaction& trans) = 0;

    /**
     * @fn  virtual Result INodeState::onSyncTransactions(SolverContext& context, cs::RoundNumber round) = 0;
     *
     * @brief   Is called when new transaction list is received. The SolverCore always updates own
     *          vector before call this method.
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in]  context The core context.
     * @param       round   The round.
     *
     * @return  A Result of event: Finish - core has to make a transition, Ignore - continue to work
     *          in current state, Failed - error occurs.
     */

    virtual Result onSyncTransactions(SolverContext& context, cs::RoundNumber round) = 0;

    // Solver3 new methods

    virtual Result onStage1(SolverContext& context, const cs::StageOne& stage) = 0;
    virtual Result onStage2(SolverContext& context, const cs::StageTwo& stage) = 0;
    virtual Result onStage3(SolverContext& context, const cs::StageThree& stage) = 0;

    /**
     * @fn  virtual const char * INodeState::name() const = 0;
     *
     * @brief   Gets the name of state
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @return  A pointer to a const char.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    virtual const char* name() const = 0;
};
}  // namespace cs
```
# ..\node\solver\include\solver\result.hpp 
```cpp 
#pragma once

namespace cs {
/**
 * @enum    Result
 *
 * @brief   Values that represent results, special values to return from INodeState methods. Handled by SolverCore.
 */

enum class Result{
    ///< State completed, SolverCore has to make a transition to another state
    Finish,

    ///< SolverCore has to ignore this event, preventing transition to another state
    Ignore,

    ///< Critical error in state, SolverCore has to make a transition immediately if it is set, otherwise act as ignore
    ///< value
    Failure,

    ///< Some errors occur, but there is a possibility to retry another time to do it better
    ///< value
    Retry,

    ///< State must implement handler for the event but it has not done yet
    NotImplemented
};
}  // namespace cs
```
# ..\node\solver\include\solver\smartconsensus.hpp 
```cpp 
#pragma once
#include "callsqueuescheduler.hpp"
#include "consensus.hpp"
#include "stage.hpp"
#include "timeouttracking.hpp"

//#include <csnode/node.hpp>
//#include <solvercore.hpp>
#include <csnode/transactionspacket.hpp>

#include <algorithm>
#include <array>
#include <chrono>
#include <map>
#include <memory>
#include <optional>
#include <set>
#include <vector>

class Node;

namespace cs {
class SolverCore;
class SmartContracts;

class SmartConsensus {
public:
    /*SmartConsensus();*/

    SmartConsensus(/*Node* node*/);

    ~SmartConsensus();

    bool initSmartRound(const cs::TransactionsPacket& pack, uint8_t runCounter, Node* node, SmartContracts* smarts);
    uint8_t calculateSmartsConfNum();
    uint8_t ownSmartsConfidantNumber();

    template <class T>
    bool smartStageEnough(const std::vector<T>& smartStageStorage, const std::string& funcName);

    void startTimer(int st);
    void killTimer();
    void fakeStage(uint8_t confIndex);

    // cs::PublicKey smartAddress();
    // Solver smarts consensus methods
    // void smartStagesStorageClear(size_t cSize);

    void addSmartStageOne(cs::StageOneSmarts& stage, bool send);
    void addSmartStageTwo(cs::StageTwoSmarts& stage, bool send);
    void addSmartStageThree(cs::StageThreeSmarts& stage, bool send);

    static void sendFakeStageOne(Node * pnode, cs::PublicKeys confidants, cs::Byte confidantIndex, uint64_t smartId);
    static void sendFakeStageTwo(Node * pnode, cs::PublicKeys confidants, cs::Byte confidantIndex, uint64_t smartId);

    // void getSmartResult(const cs::TransactionsPacket pack);
    void refreshSmartStagesStorage();
    void processStages();
    std::vector <csdb::Amount> calculateFinalFee(const std::vector <csdb::Amount>& finalFee, size_t realTrustedAmount);

    bool smartStageOneEnough();
    bool smartStageTwoEnough();
    bool smartStageThreeEnough();
    cs::Sequence smartRoundNumber();

    void createFinalTransactionSet(const std::vector<csdb::Amount>& finalFees);
    size_t smartStage3StorageSize();
    void sendFinalTransactionSet();
    bool smartConfidantExist(uint8_t);
    void gotSmartStageRequest(uint8_t msgType, cs::Sequence smartRound, uint32_t startTransaction, uint8_t requesterNumber, uint8_t requiredNumber, const cs::PublicKey& requester);

    void requestSmartStages(int st);
    void requestSmartStagesNeighbors(int st);
    void markSmartOutboundNodes(int st);

    const std::vector<cs::PublicKey>& smartConfidants() const;

    TimeoutTracking timeout_request_stage;
    TimeoutTracking timeout_request_neighbors;
    TimeoutTracking timeout_force_transition;
    int timeoutStageCounter_;

    uint8_t runCounter() const {
        return runCounter_;
    }

    // uint64_t[5 bytes] + uint16_t[2 bytes] + uint8_t[1 byte]
    static inline uint64_t createId(uint64_t seq, uint16_t idx, uint8_t cnt) {
        return (((seq & 0xFFFFFFFFFF) << 24) | (uint64_t(idx) << 8) | static_cast<uint64_t>(cnt));
    }

    // smartRoundNumber[5 bytes] + smartTransaction[2 bytes] + runCounter[1 byte]
    uint64_t id() const {
        return SmartConsensus::createId(smartRoundNumber_, uint16_t(smartTransaction_), runCounter_);
    }

    static inline cs::Sequence blockPart(uint64_t id) {
        return ((id >> 24) & 0x000000FFFFFFFFFF);
    }

    static inline uint32_t transactionPart(uint64_t id) {
        return ((id >> 8) & 0x000000000000FFFF);
    }

    static inline uint32_t runCounterPart(uint64_t id) {
        return (id & 0x00000000000000FF);
    }

private:
    void fake_stage1(uint8_t from);
    void fake_stage2(uint8_t from);

    void init_zero(cs::StageOneSmarts& stage);
    void init_zero(cs::StageTwoSmarts& stage);

    CallsQueueScheduler::CallTag timer_tag_{CallsQueueScheduler::no_tag};
    CallsQueueScheduler::CallTag timer_tag() {
        if (timer_tag_ == CallsQueueScheduler::no_tag) {
            timer_tag_ = id();
        }
        return timer_tag_;
    }

    Node* pnode_;
    SmartContracts* psmarts_;

    std::vector<cs::StageOneSmarts> smartStageOneStorage_;
    std::vector<cs::StageTwoSmarts> smartStageTwoStorage_;
    std::vector<cs::StageThreeSmarts> smartStageThreeStorage_;
    std::vector<cs::StageThreeSmarts> smartStageThreeTempStorage_;
    bool smartStagesStorageRefreshed_ = false;
    std::vector<cs::PublicKey> smartConfidants_;
    uint8_t ownSmartsConfNum_ = cs::ConfidantConsts::InvalidConfidantIndex;
    cs::TransactionsPacket currentSmartTransactionPack_;
    cs::TransactionsPacket finalSmartTransactionPack_;
    std::vector <csdb::Transaction> tmpNewStates_;
    cs::StageOneSmarts st1;
    cs::StageTwoSmarts st2;
    cs::StageThreeSmarts st3;
    std::vector<int> smartUntrusted;
    std::vector<csdb::Pool::SmartSignature> solverSmartSignatures_;
    cs::Sequence smartRoundNumber_;
    uint32_t smartTransaction_;
    uint8_t runCounter_;
    bool trustedChanged_ = false;
    bool smartStageThreeSent_ = false;
    std::vector<cs::Bytes> smartStageOneMessage_;
    std::vector<cs::Bytes> smartStageTwoMessage_;
    std::vector<cs::Bytes> smartStageThreeMessage_;

    std::vector<cs::Stage> smartStageTemporary_;
    cs::Bytes smartConsensusMask;
};

}  // namespace cs
```
# ..\node\solver\include\solver\smartcontracts.hpp 
```cpp 
#pragma once

#include <csdb/address.hpp>
#include <csdb/pool.hpp>
#include <csdb/transaction.hpp>
#include <csdb/user_field.hpp>
#include <lib/system/common.hpp>
#include <lib/system/concurrent.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/signals.hpp>

#include <csnode/node.hpp>  // introduce csconnector::connector::ApiExecHandlerPtr as well

#include <list>
#include <mutex>
#include <optional>
#include <vector>

//#define DEBUG_SMARTS

class BlockChain;
class CallsQueueScheduler;

namespace csdb {
class Transaction;
}

namespace cs {

// smart contract related error codes
    namespace error {
        // timeout during operation
        constexpr uint8_t TimeExpired = 254;
        // insufficient funds to complete operation
        constexpr uint8_t OutOfFunds = 253;
        // std::exception thrown
        constexpr uint8_t StdException = 252;
        // other exception thrown
        constexpr uint8_t Exception = 251;
        // replenished contract does not implement payable()
        constexpr uint8_t UnpayableReplenish = 250; // -6
        // the trusted consensus have rejected new_state (and emitted transactions)
        constexpr uint8_t ConsensusRejected = 249; // -7
        // error in Executor::ExecuteTransaction()
        constexpr uint8_t ExecuteTransaction = 248; // -8
        // bug in SmartContracts
        constexpr uint8_t InternalBug = 247; // -9
        // executor is disconnected or unavailable, value is hard-coded in ApiExec module
        constexpr uint8_t ExecutionError = 1;
    }  // namespace error

// transactions user fields
namespace trx_uf {
    // deploy transaction fields
    namespace deploy {
        // byte-code (string)
        constexpr csdb::user_field_id_t Code = 0;
        // count of user fields
        constexpr size_t Count = 2;
    }  // namespace deploy
    // start transaction fields
    namespace start {
        // methods with args (string)
        constexpr csdb::user_field_id_t Methods = 0;
        // reference to last state transaction
        constexpr csdb::user_field_id_t RefState = 1;
        // count of user fields, may vary from 1 (source is person) to 2 (source is another contract)
        // constexpr size_t Count = {1,2};
    }  // namespace start
    // new state transaction fields
    namespace new_state {
        // new state value, new byte-code (string)
        constexpr csdb::user_field_id_t Value = ~1;  // see apihandler.cpp #9 for currently used value ~1
        // reference to start transaction
        constexpr csdb::user_field_id_t RefStart = 1;
        // fee value
        constexpr csdb::user_field_id_t Fee = 2;
        // return value
        constexpr csdb::user_field_id_t RetVal = 3;
        // count of user fields
        constexpr size_t Count = 4;
    }  // namespace new_state
    // smart-gen transaction field
    namespace smart_gen {
        // reference to start transaction
        constexpr csdb::user_field_id_t RefStart = 0;
    }  // namespace smart_gen
    // ordinary transaction field
    namespace ordinary {
        // no fields defined
    }
}  // namespace trx_uf

struct SmartContractRef {
    // block hash
    csdb::PoolHash hash;
    // block sequence
    cs::Sequence sequence;
    // transaction sequence in block, instead of ID
    size_t transaction;

    SmartContractRef()
    : sequence(std::numeric_limits<decltype(sequence)>().max())
    , transaction(std::numeric_limits<decltype(sequence)>().max()) {
    }

    SmartContractRef(const csdb::PoolHash block_hash, cs::Sequence block_sequence, size_t transaction_index)
    : hash(block_hash)
    , sequence(block_sequence)
    , transaction(transaction_index) {
    }

    SmartContractRef(const csdb::UserField& user_field) {
        from_user_field(user_field);
    }

    bool is_valid() const {
        if (hash.is_empty()) {
            return false;
        }
        return (sequence != std::numeric_limits<decltype(sequence)>().max() && transaction != std::numeric_limits<decltype(sequence)>().max() && !hash.is_empty());
    }

    // "serialization" methods

    csdb::UserField to_user_field() const;
    void from_user_field(const csdb::UserField& fld);

    csdb::TransactionID getTransactionID() const {
        return csdb::TransactionID(hash, transaction);
    }
};

inline std::ostream& operator <<(std::ostream& os, const SmartContractRef& ref) {
    os << '{' << ref.sequence << '.' << ref.transaction << '}';
    return os;
}

inline bool operator==(const SmartContractRef& l, const SmartContractRef& r) {
    return (l.transaction == r.transaction && l.sequence == r.sequence /*&& l.hash == r.hash*/);
}

inline bool operator<(const SmartContractRef& l, const SmartContractRef& r) {
    if (l.sequence < r.sequence) {
        return true;
    }
    if (l.sequence > r.sequence) {
        return false;
    }
    return (l.transaction < r.transaction);
}

// helper to print <sequence,transaction>
struct RefFormatter {
    cs::Sequence seq;
    uint32_t idx;
};

// print RefFormatter to ostream as {*.*}
inline std::ostream& operator<<(std::ostream& os, const RefFormatter& format) {
    os << '{' << format.seq << '.' << format.idx << '}';
    return os;
}

struct SmartExecutionData {
    SmartContractRef contract_ref;
    csdb::Amount executor_fee;
    executor::Executor::ExecuteResult result;
    std::string error;
};

inline bool operator==(const SmartExecutionData& l, const SmartContractRef& r) {
    return (l.contract_ref == r);
}

inline bool operator==(const SmartExecutionData& l, const SmartExecutionData& r) {
    return (l.contract_ref == r.contract_ref);
}

enum class SmartContractStatus
{
    // contract is not involved in any way
    Idle,
    // is waiting until execution starts
    Waiting,
    // is executing at the moment, is able to emit transactions
    Running,
    // execution is finished, waiting for new state transaction in blockchain, no more transaction emitting is allowed
    Finished,
    // contract is closed, neither new_state nor emitting transactions are allowed, should be removed from queue
    Closed
};

// to inform subscribed slots on deploy/execute/replenish occur
// passes to every slot packet with result transactions
using SmartContractExecutedSignal = cs::Signal<void(cs::TransactionsPacket)>;

// to inform subscribed slots on deploy/execution/replenish completion or timeout
// passes to every slot the "starter" transaction
using SmartContractSignal = cs::Signal<void(const csdb::Transaction&)>;

class SmartContracts final {
public:
    explicit SmartContracts(BlockChain&, CallsQueueScheduler&);

    SmartContracts() = delete;
    SmartContracts(const SmartContracts&) = delete;

    ~SmartContracts();

    void init(const cs::PublicKey&, Node* node);

    static std::string get_error_message(uint8_t code);

    // test transaction methods

    // smart contract related transaction of any type
    static bool is_smart_contract(const csdb::Transaction&);
    // deploy or start contract
    static bool is_executable(const csdb::Transaction& tr);
    // deploy contract
    static bool is_deploy(const csdb::Transaction&);
    // start contract
    static bool is_start(const csdb::Transaction&);
    // new state of contract, result of invocation of executable transaction
    static bool is_new_state(const csdb::Transaction&);

    /* Assuming deployer.is_public_key(), not a WalletId */
    static csdb::Address get_valid_smart_address(const csdb::Address& deployer, const uint64_t trId, const api::SmartContractDeploy&);

    std::optional<api::SmartContractInvocation> get_smart_contract(const csdb::Transaction& tr) {
        cs::Lock lock(public_access_lock);
        return std::move(get_smart_contract_impl(tr));
    }

    // get & handle rejected transactions from smart contract(s)
    // usually ordinary consensus may reject smart-related transactions
    // failed list refers to rejected calls
    void on_reject(const std::vector<Node::RefExecution>& reject_list);

    csdb::Address absolute_address(const csdb::Address& optimized_address) const {
        return bc.getAddressByType(optimized_address, BlockChain::AddressType::PublicKey);
    }

    bool is_closed_smart_contract(const csdb::Address& addr) const {
        cs::Lock lock(public_access_lock);
        return get_smart_contract_status(addr) == SmartContractStatus::Closed;
    }

    bool is_known_smart_contract(const csdb::Address& addr) const {
        cs::Lock lock(public_access_lock);
        return in_known_contracts(addr);
    }

    bool is_contract_locked(const csdb::Address& addr) const {
        cs::Lock lock(public_access_lock);
        return is_locked(absolute_address(addr));
    }

    // return true if SmartContracts provide special handling for transaction, so
    // the transaction is not pass through conveyer
    // method is thread-safe to be called from API thread
    bool capture_transaction(const csdb::Transaction& t);

    CallsQueueScheduler& getScheduler();

    // flag to allow execution, also depends on executor presence
    CallsQueueScheduler& scheduler;

public
signals:
    // emits on contract execution
    SmartContractExecutedSignal signal_smart_executed;
    // emits on invocation of payable()
    SmartContractSignal signal_payable_invoke;
    // emits on invocation of payable() is failed after timeout
    SmartContractSignal signal_payable_timeout;
    // emits on every contract emitted transaction is appeared in blockchain, args are (emitted_transaction, starter_transaction):
    cs::Signal<void(const csdb::Transaction&, const csdb::Transaction&)> signal_emitted_accepted;

public slots:
    // called when execute_async() completed
    void on_execution_completed(const std::vector<SmartExecutionData>& data_list) {
        cs::Lock lock(public_access_lock);
        on_execution_completed_impl(data_list);
    }

    // called when next block is stored
    void on_store_block(const csdb::Pool& block);

    // called when next block is read from database
    void on_read_block(const csdb::Pool& block, bool* should_stop);

private:
    using trx_innerid_t = int64_t;  // see csdb/transaction.hpp near #101

    const char* PayableName = "payable";
    const char* PayableRetType = "void";
    const char* PayableArgType = "java.lang.String";
    const char* PayableNameArg0 = "amount";
    const char* PayableNameArg1 = "currency";

    const char* UsesContract = "Contract";
    const char* UsesContractAddr = "address";
    const char* UsesContractMethod = "method";

    BlockChain& bc;

    cs::PublicKey node_id;
    // be careful, may be equal to nullptr if api is not initialized (for instance, blockchain failed to load)
    csconnector::connector::ApiExecHandlerPtr exec_handler_ptr;

    // flag to allow execution, currently depends on executor presence
    bool execution_allowed;

    CallsQueueScheduler::CallTag tag_cancel_running_contract;

    enum class PayableStatus : int
    {
        Unknown = -1,
        Absent = 0,
        Implemented = 1
    };

    // defines current contract state, the contracts cache is a container of every contract state
    struct StateItem {
        // is temporary locked from execution until current execution completed
        bool is_locked{ false };
        // payable() method is implemented
        PayableStatus payable{ PayableStatus::Unknown };
        // reference to deploy transaction
        SmartContractRef ref_deploy;
        // reference to last successful execution which state is stored by item, may be equal to ref_deploy
        SmartContractRef ref_execute;
        // current state which is result of last successful execution / deploy
        std::string state;
        // using other contracts: [own_method] - [ [other_contract - its_method], ... ], ...
        std::map<std::string, std::map<csdb::Address, std::string>> uses;
    };

    // last contract's state storage
    std::map<csdb::Address, StateItem> known_contracts;

    // contract replenish transactions stored during reading from DB on stratup
    std::vector<SmartContractRef> replenish_contract;

    // specifies a one contract call
    struct ExecutionItem {
        // reference to smart in block chain (block/transaction) that spawns execution
        SmartContractRef ref_start;
        // max fee taken from contract starter transaction
        csdb::Amount avail_fee;
        // new_state fee prediction
        csdb::Amount new_state_fee;
        // current fee
        csdb::Amount consumed_fee;
        // using contracts, must store absolute addresses (keys, not ids)
        std::vector<csdb::Address> uses;
        // execution result includes contract new_state, emitted transactions if any, subsequent contracts states if any
        cs::TransactionsPacket result;

        bool operator ==(const SmartContractRef& r) const {
            return ref_start == r;
        }
    };

    // defines an item of execution queue which is a one or more simultaneous calls to specific contract
    struct QueueItem {
        // list of execution items, empty list is senceless
        std::vector<ExecutionItem> executions;
        // current status (running/waiting)
        SmartContractStatus status;
        // enqueue round
        cs::Sequence seq_enqueue;
        // start round
        cs::Sequence seq_start;
        // finish round
        cs::Sequence seq_finish;
        // smart contract wallet/pub.key absolute address
        csdb::Address abs_addr;
        // actively taking part in smart consensus, perform a call to executor
        bool is_executor;
        // is rejected by consensus
        bool is_rejected;
        // actual consensus
        std::unique_ptr<SmartConsensus> pconsensus;

        QueueItem() = default;
        
        QueueItem(const QueueItem& src) {
            status = src.status;
            seq_enqueue = src.seq_enqueue;
            seq_start = src.seq_start;
            seq_finish = src.seq_finish;
            abs_addr = src.abs_addr;
            is_executor = src.is_executor;
            is_rejected = src.is_rejected;
            if (!src.executions.empty()) {
                executions.assign(src.executions.cbegin(), src.executions.cend());
            }
        }


        QueueItem(const SmartContractRef& ref_contract, csdb::Address absolute_address, csdb::Transaction tr_start)
        : status(SmartContractStatus::Waiting)
        , seq_enqueue(0)
        , seq_start(0)
        , seq_finish(0)
        , abs_addr(absolute_address)
        , is_executor(false)
        , is_rejected(false) {

            add(ref_contract, tr_start);
        }

        // executions & pconsensus remains empty
        QueueItem fork()
        {
            QueueItem tmp;
            tmp.status = status;
            tmp.seq_enqueue = seq_enqueue;
            tmp.seq_start = seq_start;
            tmp.seq_finish = seq_finish;
            tmp.abs_addr = abs_addr;
            tmp.is_executor = is_executor;
            tmp.is_rejected = is_rejected;
            return tmp;
        }

        // add contract execution to existing exe queue item
        // caller is responsible the execution to refer to the same contract, call to other method of the same contract is allowed
        void add(const SmartContractRef& ref_contract, csdb::Transaction tr_start);
    };

    // execution queue
    // requirements: items are non-movable during the whole life cycle
    std::list<QueueItem> exe_queue;

    // is locked in all non-static public methods
    // is locked in const methods also
    mutable cs::SpinLock public_access_lock = ATOMIC_FLAG_INIT;

    using queue_iterator = std::list<QueueItem>::iterator;
    using queue_const_iterator = std::list<QueueItem>::const_iterator;
    using execution_iterator = std::vector<ExecutionItem>::iterator;
    using execution_const_iterator = std::vector<ExecutionItem>::const_iterator;

    Node* pnode;

    queue_iterator find_in_queue(const SmartContractRef& item) {
        for (auto it = exe_queue.begin(); it != exe_queue.end(); ++it) {
            if (std::find(it->executions.cbegin(), it->executions.cend(), item) != it->executions.cend()) {
                return it;
            }
        }
        return exe_queue.end();
    }

    execution_iterator find_in_queue_item(queue_iterator qit, const SmartContractRef& item) {
        auto it = qit->executions.begin();
        for (; it != qit->executions.end(); ++it) {
            if (it->ref_start == item) {
                break;
            }
        }
        return it;
    }

    queue_iterator find_first_in_queue(const csdb::Address& abs_addr) {
        auto it = exe_queue.begin();
        for (; it != exe_queue.end(); ++it) {
            if (it->abs_addr == abs_addr) {
                break;
            }
        }
        return it;
    }

    queue_const_iterator find_first_in_queue(const csdb::Address& abs_addr) const {
        auto it = exe_queue.begin();
        for (; it != exe_queue.end(); ++it) {
            if (it->abs_addr == abs_addr) {
                break;
            }
        }
        return it;
    }

    // return next element in queue, the only exception is end() which returns unmodified
    queue_iterator remove_from_queue(queue_iterator it);

    void remove_from_queue(const SmartContractRef& item);

    SmartContractStatus get_smart_contract_status(const csdb::Address& addr) const;

    void test_exe_queue();

    // true if target of transaction is smart contract which implements payable() method
    bool is_payable_target(const csdb::Transaction& tr);

    // true if transaction replenishes balance of smart contract
    bool is_replenish_contract(const csdb::Transaction& tr);

    // tests passed list of trusted nodes to contain own node
    bool contains_me(const std::vector<cs::PublicKey>& list) const {
        return (list.cend() != std::find(list.cbegin(), list.cend(), node_id));
    }

    static csdb::Transaction get_transaction(BlockChain& storage, const SmartContractRef& contract);

    // non-static variant
    csdb::Transaction get_transaction(const SmartContractRef& contract) const {
        return SmartContracts::get_transaction(bc, contract);
    }

    void enqueue(const csdb::Pool& block, size_t trx_idx);

    void on_new_state(const csdb::Pool& block, size_t trx_idx);

    // perform async execution via API to remote executor
    // returns false if execution is canceled
    bool execute_async(const std::vector<ExecutionItem>& executions);

    // makes a transaction to store new_state of smart contract invoked by src
    // caller is responsible to test src is a smart-contract-invoke transaction and proper new_id value
    csdb::Transaction create_new_state(const ExecutionItem& queue_item, int64_t new_id);

    // update in contracts table appropriate item's state
    bool update_contract_state(const csdb::Transaction& t, bool reading_db);

    // get deploy info from cached deploy transaction reference
    std::optional<api::SmartContractInvocation> find_deploy_info(const csdb::Address& abs_addr) const;

    // test if abs_addr is address of smart contract with payable() implemented;
    // may make a BLOCKING call to java executor
    bool is_payable(const csdb::Address& abs_addr);

    // test if metadata is actualized for given contract
    // may make a BLOCKING call to java executor
    bool is_metadata_actual(const csdb::Address& abs_addr) {
        const auto it = known_contracts.find(abs_addr);
        if (it != known_contracts.cend()) {
            // both uses list and defined payable means metadata is actual:
            return (!it->second.uses.empty() || it->second.payable != PayableStatus::Unknown);
        }
        return false;
    }

    // blocking call
    bool execute(/*[in,out]*/ SmartExecutionData& data);

    // blocking call
    bool update_metadata(const api::SmartContractInvocation& contract, StateItem& state);

    void add_uses_from(const csdb::Address& abs_addr, const std::string& method, std::vector<csdb::Address>& uses);

    // extracts and returns name of method executed by referenced transaction
    std::string print_executed_method(const SmartContractRef& ref);

    std::string get_executed_method_name(const SmartContractRef& ref);

    // calculates from block a one smart round costs
    csdb::Amount smart_round_fee(const csdb::Pool& block);

    // tests max fee amount and round-based timeout on executed smart contracts;
    // invoked after every new block appears in blockchain
    void test_exe_conditions(const csdb::Pool& block);

    bool in_known_contracts(const csdb::Address& addr) const {
        return (known_contracts.find(absolute_address(addr)) != known_contracts.cend());
    }

    bool is_locked(const csdb::Address& abs_addr) const {
        const auto it = known_contracts.find(abs_addr);
        if (it != known_contracts.cend()) {
            return it->second.is_locked;
        }
        // only known contracts are allowed to execute!
        return true;
    }

    void update_lock_status(const csdb::Address& abs_addr, bool value);

    void update_lock_status(const QueueItem& item, bool value) {
        update_lock_status(item.abs_addr, value);
        if (!item.executions.empty()) {
            for (const auto& execution : item.executions) {
                if (!execution.uses.empty()) {
                    for (const auto& u : execution.uses) {
                        update_lock_status(absolute_address(u), value);
                    }
                }
            }
        }
    }

    std::optional<api::SmartContractInvocation> get_smart_contract_impl(const csdb::Transaction& tr);

    void on_execution_completed_impl(const std::vector<SmartExecutionData>& data_list);

    // exe_queue item modifiers

    void update_status(QueueItem& item, cs::RoundNumber r, SmartContractStatus status);

    bool start_consensus(QueueItem& item, const cs::TransactionsPacket& pack) {
        // if re-run consensus
        uint8_t run_counter = 0;
        if (item.pconsensus) {
            run_counter = item.pconsensus->runCounter() + 1;
        }
        item.pconsensus = std::make_unique<SmartConsensus>();
        return item.pconsensus->initSmartRound(pack, run_counter, this->pnode, this);
    }

    void test_contracts_locks();

    // returns 0 if any error
    uint64_t next_inner_id(const csdb::Address& addr) const;

    // tests conditions to allow contract execution if disabled
    bool test_executor_availability();
};

}  // namespace cs
```
# ..\node\solver\include\solver\solvercontext.hpp 
```cpp 
#pragma once

#include "inodestate.hpp"
#include "solvercore.hpp"

#include <csdb/pool.hpp>

class CallsQueueScheduler;
class Node;
class BlockChain;

namespace cs {
class TransactionsPacket;
}

namespace cs {
class SolverCore;
using KeyType = cs::Bytes;

/**
 * @enum    Role
 *
 * @brief   Values that represent roles, repeats analog defined in node.hpp
 */

enum class Role {
    Normal,
    Trusted,
    Writer
};

/**
 * @class   SolverContext
 *
 * @brief   A solver context.
 *
 *          "Интерфейсный" класс для обращений из классов состояний к ядру солвера, определяет
 *          подмножество вызовов солвера, которые доступны из классов состояний, д. б.
 *          достаточным, но не избыточным одновременно.
 *
 * @author  aae
 * @date    03.10.2018
 */

class SolverContext {
public:
    SolverContext() = delete;

    explicit SolverContext(SolverCore& core)
    : core(core) {
    }

    /**
     * @fn  void SolverContext::request_role(Role role)
     *
     * @brief   Request core to activate one of predefined role (@see Role). Obviously it is achieved
     *          by switching current state. Request may be "ignored" depending on current state and
     *          content of transition table.
     *
     * @author  Alexander Avramenko
     * @date    15.10.2018
     *
     * @param   role    The role requested.
     */

    void request_role(Role role) {
        switch (role) {
            case Role::Normal:
                core.handleTransitions(SolverCore::Event::SetNormal);
                break;
            case Role::Trusted:
                core.handleTransitions(SolverCore::Event::SetTrusted);
                break;
            case Role::Writer:
                core.handleTransitions(SolverCore::Event::SetWriter);
                break;
        }
    }

    void complete_stage1() {
        core.handleTransitions(SolverCore::Event::Hashes);  // SolverCore::Event::Transactions may be used as well
    }

    void complete_stage2() {
        core.handleTransitions(SolverCore::Event::Stage1Enough);
    }

    void complete_stage3() {
        core.handleTransitions(SolverCore::Event::Stage2Enough);
    }

    void fail_stage3() {
        core.handleTransitions(SolverCore::Event::FailConsensus);
    }

    void complete_post_stage() {
        core.handleTransitions(SolverCore::Event::Stage3Enough);
    }

    void back_to_stage3() {
        core.handleTransitions(SolverCore::Event::Stage3NonComplete);
    }
    /**
     * @fn  NodeLevel SolverContext::level() const;
     *
     * @brief   Gets the current node role as set in last round table
     *
     * @author  Alexander Avramenko
     * @date    15.10.2018
     *
     * @return  A node role set in last round table.
     */

    Role role() const;

    /**
     * @fn  void SolverContext::spawn_next_round(const std::vector<PublicKey>& nodes);
     *
     * @brief   Spawn request to next round.
     *
     * @author  aae
     * @date    03.10.2018
     *
     * @param   nodes   The nodes.
     */

    bool addSignaturesToLastBlock(Signatures&& blockSignatures);

    void spawn_next_round(cs::StageThree& st3);

    void spawn_first_round() {
        // TODO: implement method
    }

    void sendRoundTable();

    void next_trusted_candidates(const std::vector<cs::PublicKey>& nodes, const std::vector<cs::TransactionsPacketHash>& hashes = std::vector<cs::TransactionsPacketHash>()) {
        core.trusted_candidates = nodes;
        core.hashes_candidates = hashes;
    }

    // Fast access methods, may be removed at the end

    /**
     * @fn	BlockChain& SolverContext::blockchain() const;
     *
     * @brief	Gets the blockchain instance
     *
     * @author	User
     * @date	09.10.2018
     *
     * @return	A reference to a BlockChain instance.
     */

    BlockChain& blockchain() const;

    /**
     * @fn    cs::WalletsState& SolverContext::wallets() const
     *
     * @brief Gets the wallets service instance
     *
     * @author    Alexander Avramenko
     * @date  07.12.2018
     *
     * @return    A reference to a cs::WalletsState instance.
     */

    cs::WalletsState& wallets() const {
        return *core.pws;
    }

    /**
     * @fn    cs::SmartContracts& SolverContext::smart_contracts() const
     *
     * @brief Smart contracts
     *
     * @author    Alexander Avramenko
     * @date  10.01.2019
     *
     * @return    A reference to the cs::SmartContracts.
     */

    cs::SmartContracts& smart_contracts() const {
        return *core.psmarts;
    }

    /**
     * @fn  CallsQueueScheduler& SolverContext::scheduler() const;
     *
     * @brief   Gets the scheduler instance.
     *
     * @author  aae
     * @date    03.10.2018
     *
     * @return  A reference to a CallsQueueScheduler.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    CallsQueueScheduler& scheduler() const {
        return core.scheduler;
    }

    // Access to common state properties.

    /**
     * @fn  const KeyType& SolverContext::public_key() const
     *
     * @brief   Public key.
     *
     * @author  Alexander Avramenko
     * @date    10.10.2018
     *
     * @return  A reference to a const KeyType public key.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    const cs::PublicKey& public_key() const {
        return core.public_key;
    }

    /**
     * @fn  const KeyType& SolverContext::private_key() const;
     *
     * @brief   Private key.
     *
     * @author  aae
     * @date    03.10.2018
     *
     * @return  A reference to a const KeyType private key.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    const cs::PrivateKey& private_key() const {
        return core.private_key;
    }

    std::string sender_description(const cs::PublicKey& sender_id);

    csdb::PoolHash spoileHash(const csdb::PoolHash& hashToSpoil, const cs::PublicKey& pKey);

    void sendHashReply(const csdb::PoolHash& hash, const cs::PublicKey& respondent);

    void add_stage1(cs::StageOne& stage, bool send);

    void add_stage2(cs::StageTwo& stage, bool send);

    void add_stage3(cs::StageThree& stage);

    const std::vector<cs::StageOne>& stage1_data() const {
        return core.stageOneStorage;
    }

    const std::vector<cs::StageTwo>& stage2_data() const {
        return core.stageTwoStorage;
    }

    const std::vector<cs::StageThree>& stage3_data() const {
        return core.stageThreeStorage;
    }

    const std::vector<cs::StageThree>& final_stage3_data() const {
        return core.trueStageThreeStorage;
    }

    const cs::StageOne* stage1(uint8_t sender) const {
        return core.find_stage1(sender);
    }

    size_t trueStagesThree() const {
        return core.trueStagesThree();
    }

    bool realTrustedChanged() const {
        return core.realTrustedChanged();
    }

    void realTrustedChangedSet(bool val) const {
        return core.realTrustedChangedSet(val);
    }

    void realTrustedSetValue(cs::Byte position, cs::Byte value) {
        csdebug() << __func__;
        core.realTrustedSetValue(position, value);
    }

    void realTrustedSet(cs::Bytes realTrusted) {
        csdebug() << __func__;
        core.realTrustedSet(realTrusted);
    }

    cs::Bytes getRealTrusted() {
        return core.getRealTrusted();
    }

    bool checkNodeCache(cs::PublicKey sender) const {
        return core.checkNodeCache(sender);
    }

    size_t stagesThree() const {
        return core.stagesThree();
    }

    const cs::StageTwo* stage2(uint8_t sender) const {
        return core.find_stage2(sender);
    }

    const cs::StageThree* stage3(uint8_t sender) const {
        return core.find_stage3(sender);
    }

    void request_stage1(uint8_t from, uint8_t required);

    void request_stage2(uint8_t from, uint8_t required);

    void request_stage3(uint8_t from, uint8_t required);

    void init_zero(cs::StageOne& stage) {
        stage.sender = cs::InvalidSender;
        stage.hash.fill(0);
        stage.messageHash.fill(0);
        stage.signature.fill(0);
        stage.hashesCandidates.clear();
        stage.trustedCandidates.clear();
        stage.roundTimeStamp.clear();
    }

    void init_zero(cs::StageTwo& stage) {
        stage.sender = cs::InvalidSender;
        stage.signature.fill(0);
        size_t cnt = cnt_trusted();
        stage.hashes.resize(cnt, Zero::hash);
        stage.signatures.resize(cnt, Zero::signature);
    }

    void fake_stage1(uint8_t from) {
        if (core.find_stage1(from) == nullptr) {
            csdebug() << "SolverCore: make stage-1 [" << static_cast<int>(from) << "] as silent";
            cs::StageOne fake;
            init_zero(fake);
            fake.sender = from;
            core.gotStageOne(fake);
        }
    }

    void fake_stage2(uint8_t from) {
        if (core.find_stage2(from) == nullptr) {
            csdebug() << "SolverCore: make stage-2 [" << static_cast<int>(from) << "] as silent";
            cs::StageTwo fake;
            init_zero(fake);
            fake.sender = from;
            core.gotStageTwo(fake);
        }
    }

    void fake_stage3(uint8_t from) {
        if (core.find_stage3(from) == nullptr) {
            cs::StageThree fake;
            fake.sender = from;
            core.gotStageThree(fake, false);
        }
    }

    void mark_untrusted(uint8_t sender) {
        if (sender < Consensus::MaxTrustedNodes) {
            if (core.markUntrusted[sender] < std::numeric_limits<uint8_t>::max()) {
                ++(core.markUntrusted[sender]);
            }
        }
    }

    uint8_t untrusted_value(uint8_t sender) const {
        if (sender < Consensus::MaxTrustedNodes) {
            return (core.markUntrusted[sender]);
        }
        return 0;
    }

    /**
     * @fn  uint32_t SolverContext::subRound() const;
     *
     * @brief   Gets the current subround.
     *
     * @author  dc
     * @date    26.10.2018
     *
     * @return  uint8_t.
     *
     * ### remarks  ???
     */

    uint8_t subRound() const {
        return core.subRound();
    }

    /**
     * @fn  uint8_t SolverContext::own_conf_number() const;
     *
     * @brief   Gets the own number among confidant (trusted) nodes.
     *
     * @author  aae
     * @date    03.10.2018
     *
     * @return  An uint8_t.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    uint8_t own_conf_number() const;

    /**
     * @fn  size_t SolverContext::cnt_trusted() const;
     *
     * @brief   Gets count of trusted nodes in current round.
     *
     * @author  aae
     * @date    03.10.2018
     *
     * @return  The total number of trusted.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    size_t cnt_trusted() const;

    /**
     * @fn  const std::vector<PublicKey>& SolverContext::trusted() const;
     *
     * @brief   Gets the trusted
     *
     * @author  Alexander Avramenko
     * @date    15.10.2018
     *
     * @return  A reference to a const std::vector&lt;PublicKey&gt;
     *
     */

    size_t cnt_real_trusted() const;

    const std::vector<cs::PublicKey>& trusted() const;

    /**
     * @fn  const uint8_t* SolverContext::last_block_hash();
     *
     * @brief   Last block hash
     *
     * @author  Alexander Avramenko
     * @date    24.10.2018
     *
     * @return  Null if it fails, else a pointer to a const uint8_t.
     */

    cs::Bytes last_block_hash() const;

    /**
     * @fn  void SolverContext::request_round_table() const;
     *
     * @brief   Request round table
     *
     *
     * @author  Alexander Avramenko
     * @date    15.10.2018
     */

    void request_round_table() const;

    /**
     * @fn  void SolverContext::add(const csdb::Transaction& tr);
     *
     * @brief   Adds transaction to inner list
     *
     * @author  aae
     * @date    03.10.2018
     *
     * @param   tr  The tr to add.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    void add(const csdb::Transaction& tr) {
        core.send_wallet_transaction(tr);
    }

    /**
     * @fn  csdb::Address SolverContext::address_genesis() const
     *
     * @brief   Address genesis
     *
     * @author  Alexander Avramenko
     * @date    10.10.2018
     *
     * @return  The csdb::Address.
     */

    csdb::Address address_genesis() const {
        return core.addr_genesis;
    }

    /**
     * @fn  csdb::Address SolverContext::address_start() const
     *
     * @brief   Address start
     *
     * @author  Alexander Avramenko
     * @date    10.10.2018
     *
     * @return  The csdb::Address.
     */

    csdb::Address address_start() const {
        return core.addr_start;
    }

    /**
     * @fn	csdb::Address SolverContext::optimize(const csdb::Address& address) const;
     *
     * @brief	Optimizes the given address. Tries to get wallet id from blockchain, otherwise return dicrect address
     *
     * @author	User
     * @date	09.10.2018
     *
     * @param	address	The address to optimize.
     *
     * @return	The csdb::Address optimized with id if possible
     */

    csdb::Address optimize(const csdb::Address& address) const;

    /**
     * @fn  void SolverContext::send_hash(const cs::Hash& hash, const cs::PublicKey& target);
     *
     * @brief   Sends a hash to a target
     *
     * @author  Alexander Avramenko
     * @date    15.10.2018
     *
     * @param   hash    The hash.
     * @param   target  Target for the.
     */

    void send_hash(const cs::Hash& hash, const cs::PublicKey& target);

    /**
     * @fn  bool SolverContext::test_trusted_idx(uint8_t idx, const cs::PublicKey& sender);
     *
     * @brief   test conformance of node index to public key.
     *
     * @author  Alexander Avramenko
     * @date    31.10.2018
     *
     * @param   idx     Zero-based index of the.
     * @param   sender  The sender.
     *
     * @return  True if the test passes, false if the test fails.
     */

    bool test_trusted_idx(uint8_t idx, const cs::PublicKey& sender);

    /**
     * @fn  bool SolverContext::transaction_still_in_pool(int64_t inner_id) const
     *
     * @brief   Tests if transaction with inner_id passed still in pool (not sent yet)
     *
     * @author  Alexander Avramenko
     * @date    31.10.2018
     *
     * @param   inner_id    Identifier for the inner.
     *
     * @return  True if it succeeds, false if it fails.
     */

    bool transaction_still_in_pool(int64_t inner_id) const;
    void request_round_info(uint8_t respondent1, uint8_t respondent2);

    using RefExecution = std::pair<cs::Sequence, uint32_t>;
    void send_rejected_smarts(const std::vector<RefExecution>& reject_list);

private:
  SolverCore& core;
};

}  // namespace cs
```
# ..\node\solver\include\solver\solvercore.hpp 
```cpp 
#pragma once

#include "callsqueuescheduler.hpp"
#include "consensus.hpp"
#include "inodestate.hpp"
#include "smartconsensus.hpp"
#include "stage.hpp"
#include "timeouttracking.hpp"

#include <csdb/pool.hpp>
#include <csnode/transactionspacket.hpp>

#include <algorithm>
#include <array>
#include <chrono>
#include <map>
#include <memory>
#include <optional>
#include <set>
#include <vector>

// forward declarations
class Node;

namespace cs {
class WalletsState;
class SmartContracts;
}  // namespace cs

// TODO: discuss possibility to switch states after timeout expired, timeouts can be individual but controlled by
// SolverCore

namespace cs {

constexpr cs::Byte InvalidConfidant = 255;

class SolverCore {
public:
    using Counter = size_t;

    SolverCore();
    explicit SolverCore(Node* pNode, csdb::Address GenesisAddress, csdb::Address StartAddress);

    ~SolverCore();

    void startDefault() {
        opt_mode == Mode::Debug ? ExecuteStart(Event::SetNormal) : ExecuteStart(Event::Start);
    }

    void startAsMain() {
        ExecuteStart(Event::SetTrusted);
    }

    void finish();

    bool is_finished() const {
        return req_stop;
    }

    void sendRoundTable();

    bool addSignaturesToDeferredBlock(cs::Signatures&& blockSignatures);

    uint8_t subRound();
    // Solver "public" interface,
    // below are the "required" methods to be implemented by Solver-compatibility issue:

    void setKeysPair(const cs::PublicKey& pub, const cs::PrivateKey& priv);
    void gotConveyerSync(cs::RoundNumber rNum);
    void gotHash(csdb::PoolHash&& hash, const cs::PublicKey& sender);

    const cs::PublicKey& getPublicKey() const {
        return public_key;
    }

    const cs::PrivateKey& getPrivateKey() const {
        return private_key;
    }

    // TODO: requires revision
    const cs::PublicKey& getWriterPublicKey() const;

    void beforeNextRound();
    void nextRound();
    void gotRoundInfoRequest(const cs::PublicKey& requester, cs::RoundNumber requester_round);
    void gotRoundInfoReply(bool next_round_started, const cs::PublicKey& respondent);

    // Solver3 "public" extension
    void gotStageOne(const cs::StageOne& stage);
    void gotStageTwo(const cs::StageTwo& stage);
    void gotStageThree(const cs::StageThree& stage, const uint8_t flagg);

    void gotStageOneRequest(uint8_t requester, uint8_t required);
    void gotStageTwoRequest(uint8_t requester, uint8_t required);
    void gotStageThreeRequest(uint8_t requester, uint8_t required /*, uint8_t iteration*/);
    void printStage3(const cs::StageThree& stage);

    void removeDeferredBlock(cs::Sequence);
    bool realTrustedChanged() const;
    void adjustStageThreeStorage();
    void realTrustedChangedSet(bool);
    void realTrustedSetValue(cs::Byte position, cs::Byte value);
    void realTrustedSet(cs::Bytes realTrusted);
    bool checkNodeCache(const cs::PublicKey& sender);
    void addToGraylist(const cs::PublicKey& sender, uint32_t rounds);
    void updateGrayList(cs::RoundNumber round);
    cs::Bytes getRealTrusted();
    size_t trueStagesThree();
    uint8_t currentStage3iteration();

    size_t stagesThree();
    bool stateFailed(Result res);

    /// <summary>   Adds a transaction passed to send pool </summary>
    ///
    /// <remarks>   Aae, 14.10.2018. </remarks>
    ///
    /// <param name="tr">   The transaction </param>

    void send_wallet_transaction(const csdb::Transaction& tr);

    cs::SmartContracts& smart_contracts() const {
        return *psmarts;
    }

    bool isContractLocked(const csdb::Address&) const;

private:
    // to use private data while serve for states as SolverCore context:
    friend class SolverContext;

    enum class Mode {
        Default,
        Debug,
        Monitor,
        WebWallet
    };

    enum class Event {
        Start,
        BigBang,
        RoundTable,
        Transactions,
        Hashes,
        Stage1Enough,
        Stage2Enough,
        FailConsensus,
        Stage3Enough,
        Stage3NonComplete,
        SmartDeploy,
        SmartResult,
        Expired,
        SetNormal,
        SetTrusted,
        SetWriter
    };

    using StatePtr = std::shared_ptr<INodeState>;
    using Transitions = std::map<Event, StatePtr>;

    // options

    /** @brief   True to enable, false to disable the option to track timeout of current state */
    bool opt_timeouts_enabled;

    /** @brief   True to enable, false to disable the option repeat the same state */
    bool opt_repeat_state_enabled;

    /** @brief The option mode */
    Mode opt_mode;

    // inner data

    std::unique_ptr<SolverContext> pcontext;
    CallsQueueScheduler scheduler;
    CallsQueueScheduler::CallTag tag_state_expired;
    bool req_stop;
    std::map<StatePtr, Transitions> transitions;
    StatePtr pstate;

    // consensus data

    csdb::Address addr_genesis;
    csdb::Address addr_start;
    cs::PublicKey public_key;
    cs::PrivateKey private_key;
    // senders of hashes received this round
    std::vector<std::pair<csdb::PoolHash, cs::PublicKey>> recv_hash;

    Node* pnode;
    std::unique_ptr<cs::WalletsState> pws;
    // smart contracts service
    std::unique_ptr<cs::SmartContracts> psmarts;

    void ExecuteStart(Event start_event);

    void InitTransitions();
    void InitDebugModeTransitions();
    void InitMonitorModeTransitions();
    void InitWebWalletModeTransitions();
    void setState(const StatePtr& pState);

    void handleTransitions(Event evt);
    bool stateCompleted(Result result);

    void spawn_next_round(const cs::PublicKeys& nodes, const cs::PacketsHashes& hashes, std::string&& currentTimeStamp, cs::StageThree& st3);

    // timeout tracking

    TimeoutTracking timeout_request_stage;
    TimeoutTracking timeout_request_neighbors;
    TimeoutTracking timeout_force_transition;

    /**
     * @fn  cs::StageOne* SolverCore::find_stage1(uint8_t sender);
     *
     * @brief   Searches for the stage 1 of given sender
     *
     * @author  Alexander Avramenko
     * @date    07.11.2018
     *
     * @param   sender  The sender.
     *
     * @return  Null if it fails, else the found stage 1.
     */

    cs::StageOne* find_stage1(uint8_t sender) {
        return find_stage<>(stageOneStorage, sender);
    }

    /**
     * @fn  cs::StageTwo* SolverCore::find_stage2(uint8_t sender);
     *
     * @brief   Searches for the stage 2 of given sender
     *
     * @author  Alexander Avramenko
     * @date    07.11.2018
     *
     * @param   sender  The sender.
     *
     * @return  Null if it fails, else the found stage 2.
     */

    cs::StageTwo* find_stage2(uint8_t sender) {
        return find_stage<>(stageTwoStorage, sender);
    }

    /**
     * @fn  cs::StageThree* SolverCore::find_stage3(uint8_t sender);
     *
     * @brief   Searches for the stage 3 of given sender
     *
     * @author  Alexander Avramenko
     * @date    07.11.2018
     *
     * @param   sender  The sender.
     *
     * @return  Null if it fails, else the found stage 3.
     */

public:
    cs::StageThree* find_stage3(uint8_t sender) {
        return find_stage<>(stageThreeStorage, sender);
    }

private:
    const cs::StageThree* find_stage3(uint8_t sender) const {
        return find_stage<>(stageThreeStorage, sender);
    }
    const cs::StageThree* find_stage3(uint8_t sender, uint8_t iteration) const {
        for (auto& it : stageThreeStorage) {
            if (it.sender == sender && it.iteration == iteration) {
                return &it;
            }
        }
        return nullptr;
    }

    template <typename StageT>
    StageT* find_stage(const std::vector<StageT>& vec, uint8_t sender) const {
        for (auto it = vec.begin(); it != vec.end(); ++it) {
            if (it->sender == sender) {
                return const_cast<StageT*>(&(*it));
            }
        }
        return nullptr;
    }

    //// -= THIRD SOLVER CLASS DATA FIELDS =-
    std::array<uint8_t, Consensus::MaxTrustedNodes> markUntrusted;

    std::vector<cs::StageOne> stageOneStorage;
    std::vector<cs::StageTwo> stageTwoStorage;
    std::vector<cs::StageThree> stageThreeStorage;
    std::vector<cs::StageThree> trueStageThreeStorage;
    bool realTrustedChanged_;
    cs::Bytes tempRealTrusted_;

    std::vector<std::pair<uint8_t, cs::Signature>> newBlockSignatures;

    std::vector<int> smartUntrusted;
    std::vector<csdb::Pool::SmartSignature> solverSmartSignatures_;
    // stores candidates for next round
    std::vector<cs::PublicKey> trusted_candidates;
    std::vector<cs::TransactionsPacketHash> hashes_candidates;
    csdb::Pool deferredBlock_;
    uint8_t currentStage3iteration_ = 0;

    // tracks round info missing ("last hope" tool)
    TimeoutTracking track_next_round;
    std::map<cs::PublicKey, uint16_t> grayList_;
    cs::RoundNumber lastGrayUpdated_ = 0;
};

}  // namespace cs
```
# ..\node\solver\include\solver\stage.hpp 
```cpp 
#ifndef STAGE_HPP
#define STAGE_HPP

#include <consensus.hpp>
#include <csnode/nodecore.hpp>
#include <cstdint>
#include <lib/system/utils.hpp>

namespace cs {

constexpr const uint8_t InvalidSender = uint8_t(-1);

struct StageOne {
    uint8_t sender;
    Hash hash;
    std::string roundTimeStamp;
    std::vector<PublicKey> trustedCandidates;
    std::vector<TransactionsPacketHash> hashesCandidates;
    Hash messageHash;
    Signature signature;
    cs::Bytes message;
};

struct StageTwo {
    uint8_t sender;
    cs::Hashes hashes;  // hashes of stage one
    cs::Signatures signatures;
    Signature signature;
    cs::Bytes message;
};

// struct StageThree {
//  uint8_t sender;
//  uint8_t writer;
//  std::vector<uint8_t> realTrustedMask;
//  Hash hashBlock;
//  Hash hashHashesList;
//  Hash hashCandidatesList;
//  Signature signature;
//};

struct StageThree {
    void print() {
        std::string realTrustedString;
        for (auto& i : realTrustedMask) {
            realTrustedString = realTrustedString + "[" + std::to_string(static_cast<int>(i)) + "] ";
        }
        csdebug() << "     SENDER = " << static_cast<int>(sender) << ", WRITER = " << static_cast<int>(writer) << ", RealTrusted = " << realTrustedString;
        csdebug() << "     BlockHash = " << cs::Utils::byteStreamToHex(blockHash);
        csdebug() << "     BlockSign = " << cs::Utils::byteStreamToHex(blockSignature);
        csdebug() << "     RoundHash = " << cs::Utils::byteStreamToHex(roundHash);
        csdebug() << "     RoundSign = " << cs::Utils::byteStreamToHex(roundSignature);
        csdebug() << "     TrustHash = " << cs::Utils::byteStreamToHex(trustedHash);
        csdebug() << "     TrustSign = " << cs::Utils::byteStreamToHex(trustedSignature);
    }

    uint8_t sender;
    uint8_t writer;
    uint8_t iteration;
    std::vector<uint8_t> realTrustedMask;
    Signature blockSignature;
    Hash blockHash;
    Signature roundSignature;
    Hash roundHash;
    Hash trustedHash;
    Signature trustedSignature;
    Signature signature;
    cs::Bytes message;
};

// smart-contracts stages
struct StageOneSmarts {
    bool fillBinary();
    bool fillFromBinary();
    uint8_t sender;
    uint64_t id = 0;  // combination of starter params: block number, transaction number, counter
    // cs::Sequence sBlockNum;
    // uint32_t startTransaction;
    std::vector <csdb::Amount> fees;
    Hash hash;
    Hash messageHash;
    Signature signature;
    Bytes message;
};

struct StageTwoSmarts {
    Bytes toBinary();
    bool fromBinary(Bytes message, StageTwoSmarts& stage);
    uint8_t sender;
    uint64_t id;  // combination of starter params: block number, transaction number, counter
    // cs::Sequence sBlockNum;
    // uint32_t startTransaction;
    std::vector<Hash> hashes;  // hashes of stage one
    std::vector<Signature> signatures;
    Signature signature;
    Bytes message;
};

struct StageThreeSmarts {
    Bytes toBinary();
    static bool fromBinary(Bytes message, StageThreeSmarts& stage);
    uint8_t sender;
    uint8_t iteration;
    uint64_t id;  // combination of starter params: block number, transaction number, counter
    // cs::Sequence sBlockNum;
    // uint32_t startTransaction;
    uint8_t writer;
    std::vector<uint8_t> realTrustedMask;
    Signature packageSignature;
    Signature signature;
    Bytes message;
};

struct Stage {
    uint8_t msgType;
    std::string msgData;
    cs::RoundNumber msgRoundNum;
    cs::PublicKey msgSender;
};

}  // namespace cs

#endif  // STAGE_HPP
```
# ..\node\solver\include\solver\timeouttracking.hpp 
```cpp 
#pragma once

#include <callsqueuescheduler.hpp>

namespace cs {

class TimeoutTracking {
public:
    void start(CallsQueueScheduler& scheduler, uint32_t wait_for_ms, const CallsQueueScheduler::ProcType& proc, bool replace_existing,
               CallsQueueScheduler::CallTag tag = CallsQueueScheduler::auto_tag);

    bool cancel();

    bool is_active() const {
        return call_tag != CallsQueueScheduler::no_tag;
    }

private:
    CallsQueueScheduler* pscheduler{nullptr};
    CallsQueueScheduler::CallTag call_tag{CallsQueueScheduler::no_tag};
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\defaultstatebehavior.hpp 
```cpp 
#pragma once

#include <inodestate.hpp>

namespace cs {
/**
 * @class   DefaultStateBehavior
 *
 * @brief   Implements a default node state behavior. Intended to be inherited by most of all
 *          final states classes
 *
 * @author  aae
 * @date    01.10.2018
 *
 * @sa  T:INodeState
 *
 * ### remarks  Aae, 30.09.2018.
 */

class DefaultStateBehavior : public INodeState {
public:
    ~DefaultStateBehavior() override {
    }

    void on(SolverContext& /*context*/) override {
    }

    void off(SolverContext& /*context*/) override {
    }

    void expired(SolverContext& /*context*/) override {
    }

    /**
     * @fn  void DefaultStateBehavior::onRoundEnd(SolverContext& context, bool is_bigbang) override;
     *
     * @brief   Executes the round end action: stores block if write was deferred
     *
     * @author  Alexander Avramenko
     * @date    24.10.2018
     *
     * @param [in,out]  context     The context.
     * @param           is_bigbang  True if is bigbang, false if not.
     */

    void onRoundEnd(SolverContext& context, bool is_bigbang) override;

    /**
     * @fn  Result DefaultStateBehavior::onRoundTable(SolverContext& context, const cs::RoundNumber round)
     * override;
     *
     * @brief   Executes the round table action. Signals for core to make transition on
     *          Event::RoundTable
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in,out]  context  The context.
     * @param           round    The new round number.
     *
     * @return  A Result::Finished value.
     */

    Result onRoundTable(SolverContext& context, const cs::RoundNumber round) override;

    /**
     * @fn  Result DefaultStateBehavior::onBlock(SolverContext& context, csdb::Pool& block, const cs::PublicKey& sender)
     * override;
     *
     * @brief   Do test of block received.
     *
     *          If OK stores block in chain storage. Has to be invoked in overrides.
     *          Performs deferred block write. May be overridden to flush block immediately.
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in,out]  context The context.
     * @param [in,out]  block   The block received.
     * @param           sender  The sender of current block.
     *
     * @return  A Result::Finish value if block accepted and stored, Result::Ignore value if ignored.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    Result onBlock(SolverContext& context, csdb::Pool& block, const cs::PublicKey& sender) override;

    /**
     * @fn  Result DefaultStateBehavior::onHash(SolverContext& context, const cs::Hash& hash, const cs::PublicKey& sender)
     * override;
     *
     * @brief   Ignores the hash received
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in,out]  context The context.
     * @param           hash    The hash.
     * @param           sender  The sender.
     *
     * @return  A Result::Ignore value.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    Result onHash(SolverContext& context, const csdb::PoolHash& pool_hash, const cs::PublicKey& sender) override;

    /**
     * @fn  Result DefaultStateBehavior::onTransaction(SolverContext& context, const csdb::Transaction& trans) override;
     *
     * @brief   Ignores the transaction received
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in,out]  context The context.
     * @param           trans   The transaction.
     *
     * @return  A Result::Ignore value.
     *
     * ### remarks  Aae, 30.09.2018.
     */

    Result onTransaction(SolverContext& context, const csdb::Transaction& trans) override;

    /**
     * @fn  Result DefaultStateBehavior::onSyncTransactions(SolverContext& context, cs::RoundNumber round) override;
     *
     * @brief   Ignores the transaction list received
     *
     * @author  aae
     * @date    01.10.2018
     *
     * @param [in,out]  context The context.
     * @param           round   The round.
     *
     * @return  A Result::Ignore value.
     */

    Result onSyncTransactions(SolverContext& context, cs::RoundNumber round) override;

    Result onStage1(SolverContext& context, const cs::StageOne& stage) override;
    Result onStage2(SolverContext& context, const cs::StageTwo& stage) override;
    Result onStage3(SolverContext& context, const cs::StageThree& stage) override;

protected:
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\handlebbstate.hpp 
```cpp 
#pragma once
#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   HandleBBState
 *
 * @brief   A special state to handle a Big Bang. This class cannot be inherited. Acts almost as
 *          WriteState. Currently is not functional as Node grab the BB handling
 *
 * @author  aae
 * @date    02.10.2018
 *
 * @sa  T:WriteState
 */

class HandleBBState final : public DefaultStateBehavior {
public:
    ~HandleBBState() override {
    }

    /**
     * @fn  void final::on(SolverContext& context) override;
     *
     * @brief   Override WriteState behavior. Repeat last block when on and does not require no hashes received when on
     *
     * @author  aae
     * @date    02.10.2018
     *
     * @param [in,out]  context The context.
     */

    void on(SolverContext& context) override;

    const char* name() const override {
        return "Handle BB";
    }
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\handlertstate.hpp 
```cpp 
#pragma once
#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   HandleRTState
 *
 * @brief   A special state to handle a new round table. This class cannot be inherited. When on,
 *          invokes immediately further transition according to round table
 *
 * @author  Alexander Avramenko
 * @date    09.10.2018
 *
 * @sa  T:DefaultStateBehavior
 *
 * ### remarks  Aae, 30.09.2018.
 */

class HandleRTState : public DefaultStateBehavior {
public:
    ~HandleRTState() override {
    }

    void on(SolverContext& context) override;

    const char* name() const override {
        return "Handle RT";
    }
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\normalstate.hpp 
```cpp 
#pragma once

#include <callsqueuescheduler.hpp>
#include <csdb/address.hpp>
#include <vector>
#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   NormalState
 *
 * @brief   A normal node state. If spammer mode is on in SolverCore, this state implements spam functionality
 *
 * @author  Alexander Avramenko
 * @date    09.10.2018
 *
 * @sa  T:DefaultStateBehavior
 *
 * ### remarks  Aae, 30.09.2018.
 */

class NormalState : public DefaultStateBehavior {
public:
    ~NormalState() override {
    }

    void on(SolverContext& context) override;

    const char* name() const override {
        return "Normal";
    }
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\nostate.hpp 
```cpp 
#pragma once
#include "inodestate.hpp"

namespace cs {
/**
 * @class   NoState
 *
 * @brief   A special state of "No state". Used at the very beginning of work. This class cannot
 *          be inherited. Does nothing when activated
 *
 * @author  Alexander Avramenko
 * @date    09.10.2018
 *
 * @sa  T:INodeState
 *
 * ### remarks  Aae, 30.09.2018.
 */

class NoState final : public INodeState {
public:
    void on(SolverContext& /*context*/) override {
    }

    void off(SolverContext& /*context*/) override {
    }

    void expired(SolverContext& /*context*/) override {
    }

    void onRoundEnd(SolverContext& /*context*/, bool /*is_bingbang*/) override {
    }

    /**
     * @fn  Result final::onRoundTable(SolverContext& , const cs::RoundNumber ) override
     *
     * @brief   Handles the round table action
     *
     * @author  Alexander Avramenko
     * @date    09.10.2018
     *
     * @param [in,out]  parameter1  The first parameter.
     * @param           uint32_t    The 32 t.
     *
     * @return  A Result::Finish to allow/initiate transition to proper state.
     */

    Result onRoundTable(SolverContext& /*context*/, const cs::RoundNumber /*round*/) override {
        return Result::Finish;
    }

    Result onBlock(SolverContext& /*context*/, csdb::Pool& /*pool*/, const cs::PublicKey& /*sender*/) override {
        return Result::Failure;
    }

    Result onHash(SolverContext& /*context*/, const csdb::PoolHash& /*pool_hash*/, const cs::PublicKey& /*sender*/) override {
        return Result::Failure;
    }

    Result onTransaction(SolverContext& /*context*/, const csdb::Transaction& /*trans*/) override {
        return Result::Failure;
    }

    Result onSyncTransactions(SolverContext& /*context*/, cs::RoundNumber /*round*/) override {
        return Result::Failure;
    }

    Result onStage1(SolverContext& /*context*/, const cs::StageOne& /*stage*/) override {
        return Result::Failure;
    }

    Result onStage2(SolverContext& /*context*/, const cs::StageTwo& /*stage*/) override {
        return Result::Failure;
    }

    Result onStage3(SolverContext& /*context*/, const cs::StageThree& /*stage*/) override {
        return Result::Failure;
    }

    const char* name() const override {
        return "None";
    }
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\primitivewritestate.hpp 
```cpp 
#pragma once
#include <callsqueuescheduler.hpp>
#include <vector>
#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   PermanentCollectWriteState
 *
 * @brief   A permanent collect write state. This class cannot be inherited. It is used in special testing mode to serve
 * at the same time as Collector (main node) and Writer (write node) during the same round
 *
 * @author  Alexander Avramenko
 * @date    11.10.2018
 */

class PrimitiveWriteState final : public DefaultStateBehavior {
public:
    ~PrimitiveWriteState() override {
    }

    void on(SolverContext& context) override;

    void off(SolverContext& context) override;

    Result onHash(SolverContext& context, const csdb::PoolHash& pool_hash, const cs::PublicKey& sender) override;

    Result onSyncTransactions(SolverContext& context, cs::RoundNumber round) override;

    const char* name() const override {
        return "Primitive Write";
    }

private:
    CallsQueueScheduler::CallTag tag_timeout{CallsQueueScheduler::no_tag};

    std::vector<cs::PublicKey> trusted_candidates;
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\syncstate.hpp 
```cpp 
#pragma once

#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   SyncState
 *
 * @brief   A synchronize state. Used for node normal mode when some blocks are missed. This
 *          class cannot be inherited. Currently is not functional as Node grab the block sync
 *
 * @author  Alexander Avramenko
 * @date    09.10.2018
 *
 * @sa  T:DefaultStateBehavior
 */

class SyncState final : public DefaultStateBehavior {
public:
    ~SyncState() override {
    }

    void on(SolverContext& context) override;

    const char* name() const override {
        return "Sync";
    }
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\trustedpoststagestate.hpp 
```cpp 
#pragma once
#include <timeouttracking.hpp>
#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   TrustedPostStageState
 *
 * @brief   TODO:
 *
 * @author  Alexander Avramenko
 * @date    09.10.2018
 *
 * @sa  T:TrustedState
 *
 * ### remarks  Aae, 30.09.2018.
 */

class TrustedPostStageState final : public DefaultStateBehavior {
public:
    ~TrustedPostStageState() override {
    }

    void on(SolverContext& context) override;

    void off(SolverContext& context) override;

    Result onStage3(SolverContext& context, const cs::StageThree& stage) override;

    const char* name() const override {
        return "Trusted-Z";
    }
    void request_stages(SolverContext& context);
    void request_stages_neighbors(SolverContext& context);
    void mark_outbound_nodes(SolverContext& context);

protected:
    size_t cnt_recv_stages;

    TimeoutTracking timeout_request_stage;
    TimeoutTracking timeout_request_neighbors;
    TimeoutTracking timeout_force_transition;
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\trustedstage1state.hpp 
```cpp 
#pragma once

#include <stage.hpp>
#include "defaultstatebehavior.hpp"
//#include <timeouttracking.hpp>

#include <csdb/pool.hpp>
#include <csnode/itervalidator.hpp>

#include <memory>

namespace cs {
class TransactionsPacket;
class IterValidator;
}  // namespace cs

namespace cs {
/**
 * @class   TrustedStage1State
 *
 * @brief   TODO:
 *
 * @author  Alexander Avramenko
 * @date    09.10.2018
 *
 * @sa  T:DefaultStateBehavior
 *
 * ### remarks  Aae, 30.09.2018.
 */

class TrustedStage1State : public DefaultStateBehavior {
public:
    ~TrustedStage1State() override {
    }

    void on(SolverContext& context) override;

    void off(SolverContext& context) override;

    Result onSyncTransactions(SolverContext& context, cs::RoundNumber round) override;

    Result onHash(SolverContext& context, const csdb::PoolHash& pool_hash, const cs::PublicKey& sender) override;

    const char* name() const override {
        return "Trusted-1";
    }

protected:
    bool enough_hashes{false};
    bool transactions_checked{false};
    bool min_time_expired{false};

    // TimeoutTracking min_time_tracking;

    cs::StageOne stage;

    cs::Hash build_vector(SolverContext& context, TransactionsPacket& trans_pack, cs::Packets& smartsPackets);
    cs::Hash formHashFromCharacteristic(const cs::Characteristic& characteristic);

    std::unique_ptr<IterValidator> pValidator_;
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\trustedstage2state.hpp 
```cpp 
#pragma once
#include <stage.hpp>
#include <timeouttracking.hpp>
#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   TrustedStage2State
 *
 * @brief   TODO:
 *
 * @author  Alexander Avramenko
 * @date    09.10.2018
 *
 * @sa  T:TrustedState
 *
 * ### remarks  Aae, 30.09.2018.
 */

class TrustedStage2State final : public DefaultStateBehavior {
public:
    ~TrustedStage2State() override {
    }

    /**
     * @fn  virtual void final::on(SolverContext& context) override;
     *
     * @brief   Sends stage-1 result
     *
     * @author  Alexander Avramenko
     * @date    26.10.2018
     *
     * @param [in,out]  context The context.
     */

    void on(SolverContext& context) override;

    void off(SolverContext& context) override;

    Result onStage1(SolverContext& context, const cs::StageOne& stage) override;

    const char* name() const override {
        return "Trusted-2";
    }

private:
    cs::StageTwo stage;

    size_t cnt_recv_stages;

    // timeout tracking

    TimeoutTracking timeout_request_stage;
    TimeoutTracking timeout_request_neighbors;
    TimeoutTracking timeout_force_transition;

    // requests stages from corresponded nodes
    void request_stages(SolverContext& context);

    // requests stages from any available neighbor nodes
    void request_stages_neighbors(SolverContext& context);

    // forces transition to next stage
    void mark_outbound_nodes(SolverContext& context);
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\trustedstage3state.hpp 
```cpp 
#pragma once
#include <stage.hpp>
#include <timeouttracking.hpp>
#include "defaultstatebehavior.hpp"

#include <vector>

namespace cs {
/**
 * @class   TrustedStage3State
 *
 * @brief   TODO:
 *
 * @author  Alexander Avramenko
 * @date    09.10.2018
 *
 * @sa  T:TrustedState
 *
 * ### remarks  Aae, 30.09.2018.
 */

class TrustedStage3State final : public DefaultStateBehavior {
public:
    ~TrustedStage3State() override {
    }

    virtual void on(SolverContext& context) override;

    void off(SolverContext& context) override;

    virtual Result onStage2(SolverContext& context, const cs::StageTwo& stage) override;

    const char* name() const override {
        return "Trusted-3";
    }

protected:
    // timeout tracking

    TimeoutTracking timeout_request_stage;
    TimeoutTracking timeout_request_neighbors;
    TimeoutTracking timeout_force_transition;

    size_t cnt_recv_stages;
    cs::StageThree stage;
    std::vector<cs::PublicKey> next_round_trust;
    std::vector<cs::TransactionsPacketHash> next_round_hashes;

    void trusted_election(SolverContext& context);
    bool pool_solution_analysis(SolverContext& context);
    bool take_urgent_decision(SolverContext& context);
    Result finalizeStageThree(SolverContext& context);

    void request_stages(SolverContext& context);
    void request_stages_neighbors(SolverContext& context);
    // forces transition to next stage
    void mark_outbound_nodes(SolverContext& context, cs::RoundNumber round);
};

}  // namespace cs
```
# ..\node\solver\include\solver\states\waitingstate.hpp 
```cpp 
#ifndef WAITING_STAGE_HPP
#define WAITING_STAGE_HPP

#include <string>
#include <timeouttracking.hpp>
#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   WaitingState
 *
 * @brief   A waiting state. This class cannot be inherited. Waits for round info until timeout expired. On timeout
 *          starts conversation with WritingState node and "next" WaitingState node to provide new round start
 *
 * @author  Alexander Avramenko
 * @date    02.11.2018
 */

class WaitingState final : public DefaultStateBehavior {
public:
    ~WaitingState() override {
    }

    void on(SolverContext& context) override;

    void off(SolverContext& context) override;

    const char* name() const override {
        return myName_.c_str();
    }

private:
    constexpr static const char* prefix_ = "Waiting";
    const static uint32_t sendRoundTableDelayMs_ = 6000;

    uint8_t writingQueueNumber_ = {0};
    std::string myName_ = {prefix_};

    TimeoutTracking roundTimeout_;

    void activate_new_round(SolverContext& context);
};
}  // namespace cs

#endif  // WAITING_STAGE_HPP
```
# ..\node\solver\include\solver\states\writingstate.hpp 
```cpp 
#pragma once

#include "defaultstatebehavior.hpp"

namespace cs {
/**
 * @class   WritingState
 *
 * @brief   A writing state. This class cannot be inherited. Writes new block and send round info to other nodes
 *
 * @author  Alexander Avramenko
 * @date    02.11.2018
 */

class WritingState final : public DefaultStateBehavior {
public:
    ~WritingState() override {
    }

    void on(SolverContext& context) override;

    const char* name() const override {
        return "Writing";
    }
};
}  // namespace cs
```
# ..\node\solver\src\callsqueuescheduler.cpp 
```cpp 
#include "callsqueuescheduler.hpp"
#include <algorithm>
#include <lib/system/utils.hpp>  // CallsQueue

void CallsQueueScheduler::SchedulerProc() {
    bool signaled{false};
    constexpr long long min_wait_for = 5;
    while (!_stop) {
        // get earliest action time
        auto earliest = ClockType::now() + std::chrono::seconds(60);
        {
            std::lock_guard<std::mutex> lque(_mtx_queue);
            if (!_queue.empty()) {
                earliest = _queue.cbegin()->tp;
            }
        }
        // sleep until scheduled event and get ready to awake at any time
        std::unique_lock<std::mutex> lsig(_mtx_signal);
        signaled = _signal.wait_until(lsig, earliest, [this]() { return _flag; });  // std::system_error!
        // test stop condition before reaction
        if (_stop) {
            break;
        }
        // event occurs
        if (signaled) {
            // reset _flag for the next signal
            _flag = false;
            // awake by direct notification: re-schedule next timeout
            std::lock_guard<std::mutex> lque(_mtx_queue);
            if (!_queue.empty()) {
                // test whether to call immediately
                if ((_queue.cbegin()->tp - ClockType::now()).count() >= min_wait_for) {
                    // schedule next wait period
                    continue;
                }
                // fall through to execute proc now (either timeout almost coincided with the signal, or proc is scheduled with
                // tiny wait_for)
            }
            else {
                // queue is empty, schedule next wait period
                continue;
            }
        }
        // awake due timeout: the most probable its time to execute earliest proc
        // test scheduled time (if it was at all)
        Context run;
        run.id = no_tag;
        {
            std::lock_guard<std::mutex> lque(_mtx_queue);
            // execute calls until wait time >= min_wait_for
            while (!_queue.empty()) {
                if ((_queue.cbegin()->tp - ClockType::now()).count() >= min_wait_for) {
                    break;
                }
                run = *_queue.cbegin();
                _queue.erase(_queue.cbegin());
                ProcType proc = run.proc;
                // push to CallsQueue only if there are no any previous calls
                if (CanExe(run.id)) {
                    OnExeQueued(run.id);
                    CallsQueue::instance().insert([this, run]() {
                        {
                            std::lock_guard<std::mutex> lque(_mtx_queue);
                            if (!ConfirmExe(run.id)) {
                                // its highly likely the job was canceled
                                return;
                            }
                        }
                        // call out of lock to avoid recursive mutex locking if proc to insert another scheduled call
                        run.proc();
                        {
                            std::lock_guard<std::mutex> lque(_mtx_queue);
                            OnExeDone(run.id);
                        }
                    });
                    _cnt_total += 1;
                }
                else {
                    _cnt_block_exe += 1;
                }
                // Launch::periodic -> schedule next item
                if (run.dt > 0) {
                    run.tp = ClockType::now() + std::chrono::milliseconds(run.dt);
                    auto pos = _queue.insert(run);
                    if (pos == _queue.end()) {
                        // periodic calls aborted due to unexpected problem!
                    }
                }
            }
        }
    }
}

void CallsQueueScheduler::Run() {
    _stop = false;
    _worker = std::thread([this]() { SchedulerProc(); });
}

void CallsQueueScheduler::OnExeQueued(CallTag id) {
    auto it = _exe_sync.find(id);
    if (it == _exe_sync.cend()) {
        _exe_sync.insert({id, {1, 0}});
    }
    else {
        it->second.queued += 1;
    }
}

void CallsQueueScheduler::OnExeDone(CallTag id) {
    auto it = _exe_sync.find(id);
    if (it != _exe_sync.end()) {
        it->second.done += 1;
    }
}

bool CallsQueueScheduler::CanExe(CallTag id) {
    auto it = _exe_sync.find(id);
    if (it != _exe_sync.end()) {
        return it->second.done == it->second.queued;
    }
    return true;
}

bool CallsQueueScheduler::ConfirmExe(CallTag id) {
    auto it = _exe_sync.find(id);
    if (it != _exe_sync.end()) {
        return (it->second.queued - it->second.done) == 1;
    }
    return false;
}

void CallsQueueScheduler::Stop() {
    Clear();
    _stop = true;
    // awake worker thread if it sleeps
    _flag = true;
    _signal.notify_one();
    if (_worker.joinable()) {
        _worker.join();
    }
}

CallsQueueScheduler::CallTag CallsQueueScheduler::Insert(ClockType::duration wait_for, const ProcType& proc, Launch scheme, bool replace_existing /*= false*/,
                                                         CallTag tag /*= auto_tag*/) {
    if (!_worker.joinable()) {
        Run();
    }
    // TODO: find better way to identify procs (especially, in case of "in-place" lambdas when those may have the same
    // address)
    // CallTag id = (CallTag) &proc;
    // current solution requires enable RTTI = Yes (/GR) to compile:
    CallTag id = (tag == auto_tag ? proc.target_type().hash_code() : tag);
    {
        std::lock_guard<std::mutex> l(_mtx_queue);
        auto it = std::find(_queue.cbegin(), _queue.cend(), id);
        if (it != _queue.cend()) {
            if (!replace_existing) {
                // reject schedule, the one already added before and still in queue
                _cnt_block_que += 1;
                return id;
            }
            else {
                // remove from queue, below we will add a new schedule
                _queue.erase(it);
                csdebug() << "Erasing existing calls: " << it->id;
            }
        }
        // add new item
        auto result = _queue.insert(CallsQueueScheduler::Context{
            id, ClockType::now() + wait_for, (scheme == Launch::once ? 0 : std::chrono::duration_cast<std::chrono::milliseconds>(wait_for).count()), std::move(proc)
            //, std::move(comment)
        });
        if (result == _queue.end()) {
            return no_tag;
        }
    }
    // awake worker thread to re-schedule its waiting
    _flag = true;
    _signal.notify_one();
    return id;
}

bool CallsQueueScheduler::Remove(CallsQueueScheduler::CallTag id) {
    {
        std::lock_guard<std::mutex> l(_mtx_queue);
        auto it = std::find(_queue.cbegin(), _queue.cend(), id);
        if (it == _queue.cend()) {
            return false;
        }
        // rollback last counter increment
        auto it_sync = _exe_sync.find(it->id);
        if (it_sync != _exe_sync.end()) {
            it_sync->second.queued = it_sync->second.done;
        }
        _queue.erase(it);
    }
    // awake worker thread to re-schedule its waiting
    _flag = true;
    _signal.notify_one();
    return true;
}

void CallsQueueScheduler::RemoveAll() {
    {
        std::lock_guard<std::mutex> l(_mtx_queue);
        _queue.clear();
        for (auto& sync : _exe_sync) {
            // rollback last counter increment
            sync.second.queued = sync.second.done;
        }
    }
    // awake worker thread to re-schedule its waiting
    _flag = true;
    _signal.notify_one();
}

void CallsQueueScheduler::Clear() {
    {
        std::lock_guard<std::mutex> l(_mtx_queue);
        _queue.clear();
        _exe_sync.clear();
    }
    // awake worker thread to re-schedule its waiting
    _flag = true;
    _signal.notify_one();
}
```
# ..\node\solver\src\smartconsensus.cpp 
```cpp 
#include <smartconsensus.hpp>
#include <smartcontracts.hpp>

#pragma warning(push)
#pragma warning(disable : 4267 4244 4100 4245)
#include <csnode/node.hpp>
#pragma warning(pop)

#include <csdb/amount.hpp>
#include <csdb/currency.hpp>
#include <csnode/datastream.hpp>
#include <solvercore.hpp>

#include <cscrypto/cscrypto.hpp>

namespace {
const char* kLogPrefix = "Smart: ";
}

namespace cs {

SmartConsensus::SmartConsensus() {
    pnode_ = nullptr;
    psmarts_ = nullptr;
}

SmartConsensus::~SmartConsensus() {
    cslog() << kLogPrefix << "======================  SMART-ROUND " << RefFormatter{ smartRoundNumber_, smartTransaction_ } << " END =====================";
    killTimer();
    pnode_->removeSmartConsensus(id());
    cs::Connector::disconnect(&pnode_->gotSmartStageOne, this, &cs::SmartConsensus::addSmartStageOne);
    cs::Connector::disconnect(&pnode_->gotSmartStageTwo, this, &cs::SmartConsensus::addSmartStageTwo);
    cs::Connector::disconnect(&pnode_->gotSmartStageThree, this, &cs::SmartConsensus::addSmartStageThree);
    cs::Connector::disconnect(&pnode_->receivedSmartStageRequest, this, &cs::SmartConsensus::gotSmartStageRequest);
}

const std::vector<cs::PublicKey>& SmartConsensus::smartConfidants() const {
    return smartConfidants_;
}

bool SmartConsensus::initSmartRound(const cs::TransactionsPacket& pack, uint8_t runCounter, Node* node, SmartContracts* smarts) {
    trustedChanged_ = false;
    smartStageThreeSent_ = false;
    pnode_ = node;
    psmarts_ = smarts;
    smartConfidants_.clear();
    runCounter_ = runCounter;
    smartRoundNumber_ = 0;
    smartTransaction_ = std::numeric_limits<uint32_t>::max();
    timeoutStageCounter_ = 0;
    // csdb::Address abs_addr;
    std::vector <csdb::Amount> executor_fees;
    cs::TransactionsPacket tmpPacket;
    /*bool primary_new_state_found = false;*/

    for (const auto& tr : pack.transactions()) {
        // only the 1st new_state is specifically handled
        if (SmartContracts::is_new_state(tr)/* && !primary_new_state_found*/) {
            /*primary_new_state_found = true;*/
            // abs_addr = smarts->absolute_address(tr.source());
            csdb::Transaction tmpNewState;
            csdb::UserField fld;
            if (smartRoundNumber_ == 0) {
                fld = tr.user_field(trx_uf::new_state::RefStart);
                if (fld.is_valid()) {
                    SmartContractRef ref(fld);
                    if (ref.is_valid()) {
                        smartRoundNumber_ = ref.sequence;
                        smartTransaction_ = static_cast<decltype(smartTransaction_)>(ref.transaction);
                    }
                }
            }
            fld = tr.user_field(trx_uf::new_state::Fee);
            if (fld.is_valid()) {
                executor_fees.push_back(fld.value<csdb::Amount>());
            }
            // break;
            // creating fee free copy of state transaction
            tmpNewState.set_amount(tr.amount());
            tmpNewState.set_source(tr.source());
            tmpNewState.set_target(tr.target());
            tmpNewState.set_currency(tr.currency());
            tmpNewState.set_counted_fee(tr.counted_fee());
            tmpNewState.set_currency(tr.currency());
            tmpNewState.set_innerID(tr.innerID());

            tmpNewState.add_user_field(trx_uf::new_state::Count, tr.user_field(trx_uf::new_state::Count));
            tmpNewState.add_user_field(trx_uf::new_state::RefStart, tr.user_field(trx_uf::new_state::RefStart));
            tmpNewState.add_user_field(trx_uf::new_state::RetVal, tr.user_field(trx_uf::new_state::RetVal));
            tmpNewState.add_user_field(trx_uf::new_state::Value, tr.user_field(trx_uf::new_state::Value));
            tmpNewStates_.push_back(tmpNewState);
            tmpPacket.addTransaction(tmpNewStates_.back());
        }
        else {
            tmpPacket.addTransaction(tr);
        }
    }

    if (/*!primary_new_state_found || */0 == smartRoundNumber_ || std::numeric_limits<uint32_t>::max() == smartTransaction_) {
        cserror() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " smart contract result packet must contain new state transaction";
        return false;
    }

    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " consensus for " << tmpNewStates_.size()
        << " job(s) starting on R-" << cs::Conveyer::instance().currentRoundNumber() << "... ";

    smartConfidants_ = pnode_->retriveSmartConfidants(smartRoundNumber_);
    ownSmartsConfNum_ = calculateSmartsConfNum();
    refreshSmartStagesStorage();
    if (ownSmartsConfNum_ == cs::InvalidConfidantIndex) {
        cserror() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " cannot determine own number in confidant list";
        return false;
    }

    cslog() << "======================  SMART-ROUND: " << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " [" << static_cast<int>(ownSmartsConfNum_) << "] =========================";
    std::string strFees;
    for (auto it : executor_fees) {
        strFees += (it.to_string(18) + ", ");
    }
    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " SMART confidants (" << smartConfidants_.size() << "), proposed fee(s): " << strFees;

    // pack_.transactions(0).user_field(1) = 0;

    currentSmartTransactionPack_ = pack;

    tmpPacket.makeHash();
    auto tmp = tmpPacket.hash().toBinary();
    std::copy(tmp.cbegin(), tmp.cend(), st1.hash.begin());
    st1.fees = executor_fees;
    // signals subscription
    cs::Connector::connect(&pnode_->gotSmartStageOne, this, &cs::SmartConsensus::addSmartStageOne);
    cs::Connector::connect(&pnode_->gotSmartStageTwo, this, &cs::SmartConsensus::addSmartStageTwo);
    cs::Connector::connect(&pnode_->gotSmartStageThree, this, &cs::SmartConsensus::addSmartStageThree);
    cs::Connector::connect(&pnode_->receivedSmartStageRequest, this, &cs::SmartConsensus::gotSmartStageRequest);
    st1.id = id();
    pnode_->addSmartConsensus(st1.id);
    st1.sender = ownSmartsConfNum_;
    if (!st1.fillBinary()) {
        return false;
    }
    st1.signature = cscrypto::generateSignature(pnode_->getSolver()->getPrivateKey(),st1.messageHash.data(), st1.messageHash.size());
    addSmartStageOne(st1, true);
    return true;
}

uint8_t SmartConsensus::calculateSmartsConfNum() {
    uint8_t i = 0;
    uint8_t ownSmartConfNumber = cs::InvalidConfidantIndex;
    for (auto& e : smartConfidants_) {
        if (e == pnode_->getNodeIdKey()) {
            ownSmartConfNumber = i;
        }
        csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ } << " [" << static_cast<int>(i) << "] "
                  << (ownSmartConfNumber != cs::InvalidConfidantIndex && i == ownSmartConfNumber ? "me" : cs::Utils::byteStreamToHex(e.data(), e.size()));
        ++i;
    }

    if (ownSmartConfNumber == cs::InvalidConfidantIndex) {
        csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " This NODE is not a confidant one for this smart-contract consensus round";
    }

    return ownSmartConfNumber;
}

uint8_t SmartConsensus::ownSmartsConfidantNumber() {
    return ownSmartsConfNum_;
}

cs::Sequence SmartConsensus::smartRoundNumber() {
    return smartRoundNumber_;
}

void SmartConsensus::refreshSmartStagesStorage() {
    csdetails() << "          " << __func__;
    size_t cSize = smartConfidants_.size();
    smartStageOneStorage_.clear();
    smartStageOneStorage_.resize(cSize);
    smartStageTwoStorage_.clear();
    smartStageTwoStorage_.resize(cSize);
    smartStageThreeStorage_.clear();
    smartStageThreeStorage_.resize(cSize);

    for (size_t i = 0; i < cSize; ++i) {
        smartStageOneStorage_.at(i).sender = cs::ConfidantConsts::InvalidConfidantIndex;
        smartStageTwoStorage_.at(i).sender = cs::ConfidantConsts::InvalidConfidantIndex;
        smartStageThreeStorage_.at(i).sender = cs::ConfidantConsts::InvalidConfidantIndex;
    }

    st1 = decltype(st1){};

    st2.signatures.clear();
    st2.signatures.resize(cSize);
    st2.hashes.clear();
    st2.hashes.resize(cSize);
    st2.id = 0;
    st3.realTrustedMask.clear();
    st3.realTrustedMask.resize(cSize);
    st3.packageSignature.fill(0);
    st2.sender = cs::ConfidantConsts::InvalidConfidantIndex;
    st3.sender = cs::ConfidantConsts::InvalidConfidantIndex;
    st3.writer = cs::ConfidantConsts::InvalidConfidantIndex;
    st3.id = 0;

    st2.signature.fill(0);
    st3.signature.fill(0);

    smartUntrusted.clear();
    smartUntrusted.resize(cSize);
    smartConsensusMask.clear();
    smartConsensusMask.resize(cSize);

    std::fill(smartConsensusMask.begin(), smartConsensusMask.end(), cs::ConfidantConsts::InvalidConfidantIndex);
    std::fill(smartUntrusted.begin(), smartUntrusted.end(), 0);

    startTimer(1);
}

void SmartConsensus::addSmartStageOne(cs::StageOneSmarts& stage, bool send) {
    if (stage.id != id()) {
        return;
    }
    csmeta(csdetails) << "start";
    if (send) {
        pnode_->sendSmartStageOne(smartConfidants_, stage);
    }
    if (smartStageOneStorage_.size() <= (size_t)stage.sender) {
        // normally unexpected
        return;
    }
    if (smartStageOneStorage_.at(stage.sender).sender == stage.sender) {
        return;
    }
    if (!std::equal(stage.hash.cbegin(), stage.hash.cend(), Zero::hash.cbegin())) {
        smartConsensusMask[stage.sender] = 0;
    }
    else {
        smartConsensusMask[stage.sender] = 254;
    }
    smartStageOneStorage_.at(stage.sender) = stage;
    std::string stagesPlot;
    for (size_t i = 0; i < smartConfidants_.size(); ++i) {
        // csdebug() << log_prefix << "[" << i << "] - " << static_cast<int>(smartStageOneStorage_.at(i).sender);
        stagesPlot = stagesPlot + '[' + std::to_string(static_cast<int>(smartStageOneStorage_.at(i).sender)) + "] ";
    }
    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ } << "  <-- SMART-Stage-1 " << stagesPlot;
    st2.signatures.at(stage.sender) = stage.signature;
    st2.hashes.at(stage.sender) = stage.messageHash;
    if (smartStageOneEnough()) {
        killTimer();
        cs::Connector::disconnect(&pnode_->gotSmartStageOne, this, &cs::SmartConsensus::addSmartStageOne);
        st2.sender = ownSmartsConfNum_;
        st2.id = id();
        addSmartStageTwo(st2, true);
        uint8_t index = 0;
        for (auto it : smartConsensusMask) {
            if (it == 255 || it == 254) {
                fake_stage2(index);
            }
        }
        startTimer(2);
    }
}

void SmartConsensus::addSmartStageTwo(cs::StageTwoSmarts& stage, bool send) {
    if (stage.id != id()) {
        return;
    }
    if (send) {
        pnode_->sendSmartStageTwo(smartConfidants_, stage);
    }
    if (smartStageTwoStorage_.size() <= (size_t)stage.sender) {
        // normally unexpected
        return;
    }
    auto& stageTwo = smartStageTwoStorage_.at(stage.sender);
    if (stageTwo.sender == stage.sender) {
        return;
    }
    // stageTwo = stage;
    std::string stagesPlot;
    for (size_t i = 0; i < smartConfidants_.size(); ++i) {
        smartStageTwoStorage_.at(stage.sender) = stage;
        stagesPlot = stagesPlot + '[' + std::to_string(static_cast<int>(smartStageTwoStorage_.at(i).sender)) + "] ";
    }
    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << "  <-- SMART-Stage-2 - SmartRound {" << blockPart(stage.id) << '.' << transactionPart(stage.id) << "} " << stagesPlot;
    if (smartStageTwoEnough()) {
        killTimer();
        cs::Connector::disconnect(&pnode_->gotSmartStageTwo, this, &cs::SmartConsensus::addSmartStageTwo);
        processStages();
    }
}

// cs::PublicKey SmartConsensus::smartAddress() {
//  return smartAddress_;
//}

void SmartConsensus::processStages() {
    csmeta(csdetails) << "start";
    const size_t cnt = smartConfidants_.size();
    // perform the evaluation og stages 1 & 2 to find out who is traitor
    int hashFrequency = 1;
    const auto& hash_t = smartStageOneStorage_.at(ownSmartsConfNum_).hash;
    size_t currentSmartsNumber = smartStageOneStorage_.at(ownSmartsConfNum_).fees.size();
    for (auto& st : smartStageOneStorage_) {
        if (st.sender == ownSmartsConfNum_) {
            continue;
        }
        if (st.fees.size() != currentSmartsNumber) {
            ++(smartUntrusted.at(st.sender));
            cslog() << kLogPrefix << "Confidant [" << static_cast<int>(st.sender) << "] is marked as untrusted (different fee-vector size)";
        }
        if (st.hash != hash_t) {
            ++(smartUntrusted.at(st.sender));
            cslog() << kLogPrefix << "Confidant [" << static_cast<int>(st.sender) << "] is marked as untrusted (wrong hash)";
        }
        else {
            ++hashFrequency;
        }
    }
    csdebug() << kLogPrefix << "{" << smartRoundNumber_ << "} Hash " << cs::Utils::byteStreamToHex(hash_t.data(), hash_t.size()) << ", Frequency = " << hashFrequency;
    auto& myStage2 = smartStageTwoStorage_.at(ownSmartsConfNum_);
    for (auto& st : smartStageTwoStorage_) {
        if (st.sender == ownSmartsConfNum_) {
            continue;
        }
        for (size_t i = 0; i < cnt; ++i) {
            if (st.signatures[i] != myStage2.signatures[i]) {
                if (cscrypto::verifySignature(st.signatures[i], smartConfidants_[i], st.hashes[i].data(), sizeof(st.hashes[i]))) {
                    ++(smartUntrusted.at(i));
                    cslog() << kLogPrefix << "Confidant [" << i << "] is marked as untrusted (wrong hash)";
                }
                else {
                    ++(smartUntrusted.at(st.sender));
                    cslog() << kLogPrefix << "Confidant [" << static_cast<int>(st.sender) << "] is marked as untrusted (wrong signature)";
                }
            }
        }
    }
    size_t cnt_active = 0;
    cs::StageThreeSmarts stage;
    stage.realTrustedMask.resize(cnt);
    for (size_t i = 0; i < cnt; ++i) {
        stage.realTrustedMask[i] = (smartUntrusted[i] > 0 ? cs::ConfidantConsts::InvalidConfidantIndex : cs::ConfidantConsts::FirstWriterIndex);
        if (stage.realTrustedMask[i] == cs::ConfidantConsts::FirstWriterIndex) {
            ++cnt_active;
        }
    }
    const size_t lowerTrustedLimit = static_cast<size_t>(smartConfidants_.size() / 2. + 1.);
    if (cnt_active < lowerTrustedLimit) {
        cslog() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " smart consensus is NOT achieved, the state transaction won't send to the conveyer";
        return;
    }
    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " smart consensus achieved";

    if (hash_t.empty()) {
        return;  // TODO: decide what to return
    }
    int k = *(unsigned int*)hash_t.data();
    if (k < 0) {
        k = -k;
    }
    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " smart consensus result 1 from 3";
    size_t idx_writer = static_cast<size_t>(k % cnt_active);
    size_t idx = 0;

    std::vector <csdb::Amount> sumFees;
    size_t feesNumber = smartStageOneStorage_.at(ownSmartsConfNum_).fees.size();
    sumFees.resize(feesNumber);
    for (size_t i = 0; i < feesNumber; ++i) {
        sumFees[i] = csdb::Amount{0};
    }
    // here will the fee be calculated too
    for (size_t i = 0; i < cnt; ++i) {
        if (st3.realTrustedMask.at(i) != InvalidConfidantIndex) {
            for (size_t j = 0; j < feesNumber; ++j) {
                if (smartStageOneStorage_.at(i).fees.size() > j) {
                   sumFees[j] += smartStageOneStorage_.at(i).fees[j];
                }
            }

            if (idx == idx_writer) {
                st3.writer = static_cast<uint8_t>(i);
            }
            ++idx;
        }
    }
    std::vector <csdb::Amount> finalFees = calculateFinalFee(sumFees, idx);
    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " smart consensus result 2 from 3";
    idx = 0;
    for (size_t i = st3.writer; i < cnt + st3.writer; ++i) {
        size_t c = i % cnt;
        if (st3.realTrustedMask.at(c) != InvalidConfidantIndex) {
            st3.realTrustedMask.at(c) = static_cast<uint8_t>(idx);
            ++idx;
        }
    }
    csdebug() << kLogPrefix << "{" << smartRoundNumber_ << "} smart consensus result 3 from 3";
    startTimer(3);
    createFinalTransactionSet(finalFees);
    st3.packageSignature =
        cscrypto::generateSignature(pnode_->getSolver()->getPrivateKey(), finalSmartTransactionPack_.hash().toBinary().data(), finalSmartTransactionPack_.hash().toBinary().size());
    csmeta(cslog) << "done";
    st3.id = id();
    st3.sender = ownSmartsConfNum_;
    st3.iteration = 0U;
    addSmartStageThree(st3, true);
}

// TODO: finalize the function
std::vector <csdb::Amount> SmartConsensus::calculateFinalFee(const std::vector <csdb::Amount>& finalFees, size_t realTrustedAmount) {
    csdebug() << __func__;
    std::vector <csdb::Amount> fees;
    fees.resize(finalFees.size());
    for (size_t i = 0; i < finalFees.size(); ++i) {
        fees[i] = csdb::Amount{ 0 };
    }
    csdebug() << __func__ << ": 1";
    uint32_t trustedNumber = static_cast<uint32_t>(realTrustedAmount);
    for (size_t j = 0; j < finalFees.size(); ++j) {
        fees[j] += finalFees[j];
        fees[j] /= (trustedNumber * trustedNumber);
        fees[j] = fees[j] * static_cast<int32_t>(realTrustedAmount);  // the overloaded operator *= doesn't work correct
    }
    csdebug() << __func__ << ": 2";
    std::string strFees;
    for (auto it : fees) {
        strFees += (it.to_string(18) + ", ");
    }
    csdebug() << "Final fee(s) = " << strFees;
    return fees;
}

void SmartConsensus::addSmartStageThree(cs::StageThreeSmarts& stage, bool send) {
    if (stage.id != id()) {
        return;
    }

    auto lambda = [this](const cs::StageThreeSmarts& stageFrom, cs::Bytes hash) {
        if (!cscrypto::verifySignature(stageFrom.packageSignature, smartConfidants().at(stageFrom.sender), hash.data(), hash.size())) {
            cslog() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
            << " ____ The signature is not valid";
            return;  // returns this function if the signature of smartco
        }
        smartStageThreeStorage_.at(stageFrom.sender) = stageFrom;
    };

    if (send) {
        csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ } << " ____ 1.";
        pnode_->sendSmartStageThree(smartConfidants_, stage);
        smartStageThreeSent_ = true;
    }
    if (smartStageThreeStorage_.size() <= (size_t)stage.sender) {
        // normally unexpected
        return;
    }
    if (smartStageThreeStorage_.at(stage.sender).sender == stage.sender) {
        // avoid duplication
        return;
    }

    if (stage.sender != ownSmartsConfNum_) {
        if (smartStageThreeSent_ == false) {
            smartStageThreeTempStorage_.push_back(stage);
        }
        else {
            // const auto& hash = smartStageOneStorage_.at(stage.sender).hash;
            lambda(stage, finalSmartTransactionPack_.hash().toBinary());
        }
    }
    else {
        smartStageThreeStorage_.at(stage.sender) = stage;
        for (auto& it : smartStageThreeTempStorage_) {
            lambda(it, finalSmartTransactionPack_.hash().toBinary());
            csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ } << " <-- SMART-Stage-3 [" << static_cast<int>(stage.sender)
                      << "] = " << smartStage3StorageSize();
        }
    }

    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ } << " <-- SMART-Stage-3 [" << static_cast<int>(stage.sender)
              << "] = " << smartStage3StorageSize();
    if (smartStageThreeSent_ && smartStageThreeEnough()) {
        killTimer();
        cs::Connector::disconnect(&pnode_->gotSmartStageThree, this, &cs::SmartConsensus::addSmartStageThree);
        if (finalSmartTransactionPack_.isHashEmpty()) {
            cserror() << kLogPrefix << "Trying to send FinalTransactionSet that doesn't exest";
            return;
        }
        sendFinalTransactionSet();
    }
}

size_t SmartConsensus::smartStage3StorageSize() {
    return std::count_if(smartStageThreeStorage_.begin(), smartStageThreeStorage_.end(),
                         [](const cs::StageThreeSmarts& it) { return it.sender != cs::ConfidantConsts::InvalidConfidantIndex; });
}

void SmartConsensus::createFinalTransactionSet(const std::vector<csdb::Amount>& finalFees) {
    /*bool primary_new_state_found = false;*/
    size_t counter = 0;
    for (const auto& tr : currentSmartTransactionPack_.transactions()) {
        if (/*!primary_new_state_found && */SmartContracts::is_new_state(tr)) {
            /*primary_new_state_found = true;*/
            tmpNewStates_[counter].add_user_field(trx_uf::new_state::Fee, finalFees[counter]);
            finalSmartTransactionPack_.addTransaction(tmpNewStates_[counter]);
            ++counter;
        }
        else {
            finalSmartTransactionPack_.addTransaction(tr);
        }
    }
    finalSmartTransactionPack_.makeHash();
}

void SmartConsensus::sendFinalTransactionSet() {
    csmeta(csdetails) << "<starting> ownSmartConfNum = " << static_cast<int>(ownSmartsConfNum_)
                      << ", writer = " << static_cast<int>(smartStageThreeStorage_.at(ownSmartsConfNum_).writer);
    // if (ownSmartsConfNum_ == smartStageThreeStorage_.at(ownSmartsConfNum_).writer) {
    auto& conv = cs::Conveyer::instance();

    for (auto& st : smartStageThreeStorage_) {
        if (st.sender != cs::ConfidantConsts::InvalidConfidantIndex) {
            if (finalSmartTransactionPack_.addSignature(st.sender, st.packageSignature)) {
                csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
                    << " signature of T[" << static_cast<int>(st.sender) << "] added to the Transactions Packet";
            }
            else {
                csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
                << " signature of T[" << static_cast<int>(st.sender) << "] isn't added";
            }
        }
    }
    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ } << " adding separate package with "
        << finalSmartTransactionPack_.signatures().size() << " signatures";
    conv.addSeparatePacket(finalSmartTransactionPack_);

    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << " ==============================================> SEND RESULT TO CONVEYER, packet hash "
        << finalSmartTransactionPack_.hash().toString();
}

void SmartConsensus::gotSmartStageRequest(uint8_t msgType, cs::Sequence smartRound, uint32_t startTransaction, uint8_t requesterNumber, uint8_t requiredNumber,
                                          const cs::PublicKey& requester) {
    if (smartRoundNumber_ != smartRound || smartTransaction_ != startTransaction) {
        return;
    }

    if (!smartConfidantExist(requesterNumber)) {
        return;
    }
    if (smartConfidants().size() <= requesterNumber) {
        // normally unexpected
        return;
    }
    if (requester != smartConfidants().at(requesterNumber)) {
        return;
    }
    // const cs::Bytes message, const cs::RoundNumber smartRNum, const cs::Signature& signature, const MsgTypes msgType, const cs::PublicKey requester
    switch (msgType) {
        case MsgTypes::SmartFirstStageRequest:
            if ((size_t)requiredNumber < smartStageOneStorage_.size()) {
                if (smartStageOneStorage_.at(requiredNumber).sender == cs::ConfidantConsts::InvalidConfidantIndex) {
                    pnode_->smartStageEmptyReply(requesterNumber);
                }
                else {
                    pnode_->sendSmartStageReply(smartStageOneStorage_.at(requiredNumber).message, smartRoundNumber_, smartStageOneStorage_.at(requiredNumber).signature,
                                                MsgTypes::FirstSmartStage, requester);
                }
            }
            break;
        case MsgTypes::SmartSecondStageRequest:
            if ((size_t)requiredNumber < smartStageTwoStorage_.size()) {
                if (smartStageTwoStorage_.at(requiredNumber).sender == cs::ConfidantConsts::InvalidConfidantIndex) {
                    pnode_->smartStageEmptyReply(requesterNumber);
                }
                else {
                    pnode_->sendSmartStageReply(smartStageTwoStorage_.at(requiredNumber).message, smartRoundNumber_, smartStageTwoStorage_.at(requiredNumber).signature,
                                                MsgTypes::FirstSmartStage, requester);
                }
            }
            break;
        case MsgTypes::SmartThirdStageRequest:
            if ((size_t)requiredNumber < smartStageThreeStorage_.size()) {
                if (smartStageThreeStorage_.at(requiredNumber).sender == cs::ConfidantConsts::InvalidConfidantIndex) {
                    pnode_->smartStageEmptyReply(requesterNumber);
                }
                else {
                    pnode_->sendSmartStageReply(smartStageThreeStorage_.at(requiredNumber).message, smartRoundNumber_, smartStageThreeStorage_.at(requiredNumber).signature,
                                                MsgTypes::FirstSmartStage, requester);
                }
            }
            break;
    }
}

bool SmartConsensus::smartStageOneEnough() {
    return smartStageEnough(smartStageOneStorage_, "SmartStageOne");
}

bool SmartConsensus::smartStageTwoEnough() {
    return smartStageEnough(smartStageTwoStorage_, "SmartStageTwo");
}

bool SmartConsensus::smartStageThreeEnough() {
    return smartStageEnough(smartStageThreeStorage_, "SmartStageThree");
}

template <class T>
bool SmartConsensus::smartStageEnough(const std::vector<T>& smartStageStorage, const std::string& funcName) {
    size_t stageSize = 0;
    for (size_t idx = 0; idx < smartStageStorage.size(); ++idx) {
        if (smartStageStorage[idx].sender == idx) {
            ++stageSize;
        }
    }
    size_t cSize;
    if (funcName == "SmartStageThree") {
        cSize = smartConfidants_.size() / 2 + 1;
    }
    else {
        cSize = smartConfidants_.size();
    }
    csdebug() << kLogPrefix << RefFormatter{ smartRoundNumber_, smartTransaction_ }
        << ' ' << funcName << " completed " << stageSize << " of " << cSize;
    return stageSize == cSize;
}

void SmartConsensus::startTimer(int st) {
    csdebug() << kLogPrefix << "start track timeout " << Consensus::T_stage_request << " ms of stages-" << st << " received";
    timeoutStageCounter_ = st;
    timeout_request_stage.start(
        psmarts_->getScheduler(), Consensus::T_stage_request,
        // timeout #1 handler:
        [this, st]() {
            csdebug() << kLogPrefix << "(): timeout for stages-" << st << " is expired, make requests";
            requestSmartStages(st);
            // start subsequent track timeout for "wide" request
            csdebug() << kLogPrefix << "(): start subsequent track timeout " << Consensus::T_stage_request << " ms to request neighbors about stages-" << st;
            timeout_request_neighbors.start(psmarts_->getScheduler(), Consensus::T_stage_request,
                                            // timeout #2 handler:
                                            [this, st]() {
                                                csdebug() << kLogPrefix << "(): timeout for requested stages-" << st << " is expired, make requests to neighbors";
                                                requestSmartStagesNeighbors(st);
                                                // timeout #3 handler
                                                timeout_force_transition.start(psmarts_->getScheduler(), Consensus::T_stage_request,
                                                                               [this, st]() {
                                                                                   csdebug() << kLogPrefix
                                                                                             << "(): timeout for transition is expired, mark silent nodes as no stage-" << st;
                                                                                   markSmartOutboundNodes(st);
                                                                               },
                                                                               true /*replace if exists*/, timer_tag());
                                            },
                                            true /*replace if exists*/, timer_tag());
        },
        true /*replace if exists*/, timer_tag());
}

void SmartConsensus::killTimer() {
    if (timeout_request_stage.cancel()) {
        csdebug() << kLogPrefix << __func__ << "(): cancel track timeout of stages-" << timeoutStageCounter_;
    }
    if (timeout_request_neighbors.cancel()) {
        csdebug() << kLogPrefix << __func__ << "(): cancel track timeout to request neighbors about stages-" << timeoutStageCounter_;
    }
    if (timeout_force_transition.cancel()) {
        csdebug() << kLogPrefix << __func__ << "(): cancel track timeout to force transition to next state after stages-" << timeoutStageCounter_;
    }
}

void SmartConsensus::requestSmartStages(int st) {
    csmeta(csdetails);
    uint8_t cnt = static_cast<uint8_t>(smartConfidants_.size());
    bool isRequested = false;
    MsgTypes msg = MsgTypes::SmartFirstStageRequest;
    uint8_t sender = 0;

    for (uint8_t i = 0; i < cnt; ++i) {
        switch (st) {
            case 1:
                sender = smartStageOneStorage_[i].sender;
                msg = MsgTypes::SmartFirstStageRequest;
                break;
            case 2:
                sender = smartStageTwoStorage_[i].sender;
                msg = MsgTypes::SmartSecondStageRequest;
                break;
            case 3:
                sender = smartStageThreeStorage_[i].sender;
                msg = MsgTypes::SmartThirdStageRequest;
                break;
        }

        if (sender == cs::ConfidantConsts::InvalidConfidantIndex) {
            if (i != ownSmartsConfNum_ && i != sender && smartConfidantExist(i)) {
                pnode_->smartStageRequest(msg, smartRoundNumber_, smartTransaction_, smartConfidants_.at(i), ownSmartsConfNum_, i);
            }
            isRequested = true;
        }
    }

    if (!isRequested) {
        csdebug() << kLogPrefix << __func__ << ": no node to request";
    }
}

// requests stages from any available neighbor nodes
void SmartConsensus::requestSmartStagesNeighbors(int st) {
    csmeta(csdetails);
    const uint8_t cnt = static_cast<uint8_t>(smartConfidants_.size());
    bool isRequested = false;
    uint8_t required = 0;
    MsgTypes messageType = MsgTypes::SmartFirstStageRequest;

    for (uint8_t idx = 0; idx < cnt; ++idx) {
        switch (st) {
            case 1:
                required = smartStageOneStorage_[idx].sender;
                messageType = MsgTypes::SmartFirstStageRequest;
                break;
            case 2:
                required = smartStageTwoStorage_[idx].sender;
                messageType = MsgTypes::SmartSecondStageRequest;
                break;
            case 3:
                required = smartStageThreeStorage_[idx].sender;
                messageType = MsgTypes::SmartThirdStageRequest;
                break;
        }

        if (required == cs::ConfidantConsts::InvalidConfidantIndex) {
            if (idx != ownSmartsConfNum_ && idx != required && smartConfidantExist(idx)) {
                pnode_->smartStageRequest(messageType, smartRoundNumber_, smartTransaction_, smartConfidants_.at(idx), ownSmartsConfNum_, required);
                isRequested = true;
            }
        }
    }

    if (!isRequested) {
        csdebug() << kLogPrefix << __func__ << ": no node to request";
    }
}

// forces transition to next stage
void SmartConsensus::markSmartOutboundNodes(int st) {
    uint8_t count = 0;
    switch (st) {
        case 1:

            for (auto& it : smartStageOneStorage_) {
                if (it.sender == cs::ConfidantConsts::InvalidConfidantIndex) {
                    fake_stage1(count);
                    if (smartUntrusted.size() > count) {
                        ++(smartUntrusted[count]);
                    }
                }
                ++count;
            }
            return;
        case 2:

            for (auto& it : smartStageTwoStorage_) {
                if (it.sender == cs::ConfidantConsts::InvalidConfidantIndex) {
                    fake_stage2(count);
                    if (smartUntrusted.size() > count) {
                        ++(smartUntrusted[count]);
                    }
                }
                ++count;
            }
            return;
        case 3:
            for (auto& it : smartStageThreeStorage_) {
                if (it.sender == cs::ConfidantConsts::InvalidConfidantIndex) {
                    st3.realTrustedMask[count] = cs::ConfidantConsts::InvalidConfidantIndex;
                    trustedChanged_ = true;
                }
                ++count;
            }
            if (trustedChanged_) {
                smartStageThreeStorage_.clear();
                smartStageThreeStorage_.resize(st3.realTrustedMask.size());
                smartStageThreeTempStorage_.clear();
                ++(st3.iteration);
            }
            return;
    }
}

void SmartConsensus::fake_stage1(uint8_t from) {
    bool find = false;
    for (auto& it : smartStageOneStorage_) {
        if (it.sender == from) {
            find = true;
            break;
        }
    }
    if (!find) {
        csdebug() << kLogPrefix << "make stage-1 [" << static_cast<int>(from) << "] as silent";
        cs::StageOneSmarts fake;
        init_zero(fake);
        fake.sender = from;
        fake.id = id();
        addSmartStageOne(fake, false);
    }
}

void SmartConsensus::fake_stage2(uint8_t from) {
    bool find = false;
    for (auto& it : smartStageTwoStorage_) {
        if (it.sender == from) {
            find = true;
            break;
        }
    }
    if (!find) {
        csdebug() << kLogPrefix << "make stage-2 [" << static_cast<int>(from) << "] as silent";
        cs::StageTwoSmarts fake;
        init_zero(fake);
        fake.sender = from;
        fake.id = id();
        addSmartStageTwo(fake, false);
    }
}

void SmartConsensus::init_zero(cs::StageOneSmarts& stage) {
    stage.sender = cs::ConfidantConsts::InvalidConfidantIndex;
    stage.hash = Zero::hash;
    stage.messageHash = Zero::hash;
    stage.signature = Zero::signature;
}

void SmartConsensus::init_zero(cs::StageTwoSmarts& stage) {
    stage.sender = cs::ConfidantConsts::InvalidConfidantIndex;
    stage.signature = Zero::signature;
    size_t cnt = smartConfidants_.size();
    stage.hashes.resize(cnt, Zero::hash);
    stage.signatures.resize(cnt, Zero::signature);
}

void SmartConsensus::fakeStage(uint8_t confIndex) {
    csunused(confIndex);
}

bool SmartConsensus::smartConfidantExist(uint8_t confidantIndex) {
    return confidantIndex < smartConfidants_.size();
}

/*static*/
void SmartConsensus::sendFakeStageOne(Node* pnode, cs::PublicKeys confidants, cs::Byte confidantIndex, uint64_t smartId) {
    cs::StageOneSmarts fake;
    fake.sender = confidantIndex;
    fake.hash.fill(0);
    fake.id = smartId;
    pnode->sendSmartStageOne(confidants, fake);
}

/*static*/
void SmartConsensus::sendFakeStageTwo(Node* pnode, cs::PublicKeys confidants, cs::Byte confidantIndex, uint64_t smartId) {
    csunused(smartId);
    cs::StageTwoSmarts fake;
    fake.sender = confidantIndex;
    size_t cnt = confidants.size();
    cs::Hash zHash;
    cs::Signature zSignature;
    zHash.fill(0);
    zSignature.fill(0);
    fake.hashes.resize(cnt, zHash);
    fake.signatures.resize(cnt, zSignature);
    pnode->sendSmartStageTwo(confidants, fake);
}

}  // namespace cs
```
# ..\node\solver\src\smartcontracts.cpp 
```cpp 
#include <smartcontracts.hpp>
#include <solvercontext.hpp>

#include <ContractExecutor.h>
#include <base58.h>
#include <cscrypto/cryptoconstants.hpp>
#include <csdb/currency.hpp>
#include <csnode/datastream.hpp>
#include <lib/system/logger.hpp>

#include <functional>
#include <memory>
#include <optional>
#include <sstream>

namespace {
const char* kLogPrefix = "Smart: ";

inline void print(std::ostream& os, const ::general::Variant& var) {
    os << "Variant(";
    bool print_default = false;
    if (var.__isset.v_string) {
        os << var.v_string;
    }
    else if (var.__isset.v_null) {
        os << "Null";
    }
    else if (var.__isset.v_boolean) {
        os << var.v_boolean;
    }
    else if (var.__isset.v_boolean_box) {
        os << var.v_boolean_box;
    }
    else if( var.__isset.v_array ) {
        os << "Array";
    }
    else if( var.__isset.v_object ) {
        os << "Object";
    }
    else if( var.__isset.v_void) {
        os << "Void";
    }
    else if( var.__isset.v_list ) {
        os << "List";
    }
    else if( var.__isset.v_set ) {
        os << "Set";
    }
    else if( var.__isset.v_map ) {
        os << "Map";
    }
    else if( var.__isset.v_int ) {
        os << var.v_int;
    }
    else if (var.__isset.v_int_box) {
        os << var.v_int_box;
    }
    else if (var.__isset.v_byte) {
        os << (unsigned int)var.v_byte;
    }
    else if (var.__isset.v_byte_box) {
        os << (unsigned int)var.v_byte_box;
    }
    else if (var.__isset.v_short) {
        os << var.v_short;
    }
    else if (var.__isset.v_short_box) {
        os << var.v_short_box;
    }
    else if (var.__isset.v_long) {
        os << var.v_long;
    }
    else if (var.__isset.v_long_box) {
        os << var.v_long_box;
    }
    else if (var.__isset.v_float) {
        os << var.v_float;
    }
    else if (var.__isset.v_float_box) {
        os << var.v_float_box;
    }
    else if (var.__isset.v_double) {
        os << var.v_double;
    }
    else if (var.__isset.v_double_box) {
        os << var.v_double_box;
    }
    else {
        /* other variant types are shown by default */
        print_default = true;
    }
    os << ')';

    if( print_default ) {
        os << ": ";
        var.printTo( os );
    }
}

}

namespace cs {

csdb::UserField SmartContractRef::to_user_field() const {
    cs::Bytes data;
    cs::DataStream stream(data);
    stream << hash << sequence << transaction;
    return csdb::UserField(stream.convert<std::string>());
}

void SmartContractRef::from_user_field(const csdb::UserField& fld) {
    std::string data = fld.value<std::string>();
    cs::DataStream stream(data.c_str(), data.size());
    stream >> hash >> sequence >> transaction;
    if (!stream.isValid() || stream.isAvailable(1)) {
        cserror() << "SmartCotractRef: read from malformed user field, abort!";
        hash = csdb::PoolHash{};
        sequence = std::numeric_limits<decltype(sequence)>().max();
        transaction = std::numeric_limits<decltype(transaction)>().max();
    }
}

void SmartContracts::QueueItem::add(const SmartContractRef& ref_contract, csdb::Transaction tr_start) {
    csdb::Amount tr_start_fee = csdb::Amount(tr_start.counted_fee().to_double());
    // TODO: here new_state_fee prediction may be calculated, currently it is equal to starter fee
    csdb::Amount new_state_fee = tr_start_fee;
    // apply starter fee consumed
    csdb::Amount avail_fee = csdb::Amount(tr_start.max_fee().to_double()) - tr_start_fee - new_state_fee;
    //consumed_fee = 0;
    auto& execution = executions.emplace_back(ExecutionItem{ ref_contract, avail_fee, new_state_fee, csdb::Amount{ 0 }, {}, {} });

    if (SmartContracts::is_executable(tr_start)) {
        const csdb::UserField fld = tr_start.user_field(trx_uf::start::Methods);  // start::Methods == deploy::Code, so does not matter what type of executable is
        if (fld.is_valid()) {
            std::string data = fld.value<std::string>();
            if (!data.empty()) {
                auto invoke = deserialize<api::SmartContractInvocation>(std::move(data));
                if (!invoke.usedContracts.empty()) {
                    for (const auto item : invoke.usedContracts) {
                        const csdb::Address addr = BlockChain::getAddressFromKey(item);
                        if (addr.is_valid()) {
                            execution.uses.push_back(addr);
                        }
                    }
                }
            }
        }
    }
    // reserve new_state fee for every using contract also
    if (!execution.uses.empty()) {
        for (const auto& it : execution.uses) {
            csunused(it);
            execution.avail_fee -= new_state_fee;
        }
    }
}

/*explicit*/
SmartContracts::SmartContracts(BlockChain& blockchain, CallsQueueScheduler& calls_queue_scheduler)
: scheduler(calls_queue_scheduler)
, bc(blockchain)
, execution_allowed(true) {
    // signals subscription (MUST occur AFTER the BlockChains has already subscribed to storage)

    // as event receiver:
    cs::Connector::connect(&bc.storeBlockEvent, this, &SmartContracts::on_store_block);
    cs::Connector::connect(&bc.readBlockEvent(), this, &SmartContracts::on_read_block);
    // as event source:
    cs::Connector::connect(&signal_payable_invoke, &bc, &BlockChain::onPayableContractReplenish);
    cs::Connector::connect(&signal_payable_timeout, &bc, &BlockChain::onPayableContractTimeout);
    cs::Connector::connect(&signal_emitted_accepted, &bc, &BlockChain::onContractEmittedAccepted);
}

SmartContracts::~SmartContracts() = default;

void SmartContracts::init(const cs::PublicKey& id, Node* node) {
    cs::Lock lock(public_access_lock);

    cs::Connector::connect(&node->gotRejectedContracts, this, &SmartContracts::on_reject);

    pnode = node;
    auto connector_ptr = pnode->getConnector();
    if (connector_ptr != nullptr) {
        exec_handler_ptr = connector_ptr->apiExecHandler();
    }
    node_id = id;

    // currently, blockchain is read in such manner that does not require absolute/optimized consolidation post-factum
    // anyway this tested code may become useful in future

    size_t cnt = known_contracts.size();
    // consolidate contract states addressed by public keys with those addressed by wallet ids
    auto pred = [](const auto& item) { return item.first.is_wallet_id(); };
    auto it = std::find_if(known_contracts.cbegin(), known_contracts.cend(), pred);
    while (it != known_contracts.cend()) {
        // non-absolute address item is always newer then absolute one:
        csdb::Address abs_addr = absolute_address(it->first);
        if (abs_addr.is_valid()) {
            const StateItem& opt_out = it->second;
            if (!opt_out.state.empty()) {
                StateItem& updated = known_contracts[abs_addr];
                if (opt_out.ref_deploy.is_valid()) {
                    if (updated.ref_deploy.is_valid()) {
                        cswarning() << kLogPrefix << "contract deploy is overwritten by subsequent deploy of the same contract";
                    }
                    updated.ref_deploy = opt_out.ref_deploy;
                    updated.state = opt_out.state;
                }
                if (opt_out.ref_execute.is_valid()) {
                    updated.ref_execute = opt_out.ref_execute;
                    updated.state = opt_out.state;
                }
            }
            else {
                cswarning() << kLogPrefix << "empty state stored in contracts states table";
            }
        }
        known_contracts.erase(it);
        it = std::find_if(known_contracts.begin(), known_contracts.end(), pred);
    }

    // validate contract states
    for (const auto& item : known_contracts) {
        const StateItem& val = item.second;
        if (val.state.empty()) {
            cswarning() << kLogPrefix << "completely unsuccessful contract found, neither deployed, nor executed";
        }
        if (!val.ref_deploy.is_valid()) {
            cswarning() << kLogPrefix << "unsuccessfully deployed contract found";
        }
    }

    size_t new_cnt = known_contracts.size();
    cslog() << kLogPrefix << "" << new_cnt << " smart contract states loaded";
    if (cnt > new_cnt) {
        cslog() << kLogPrefix << "" << cnt - new_cnt << " smart contract state(s) is/are optimizied out";
    }
}

/*static*/
std::string SmartContracts::get_error_message(uint8_t code) {
    using namespace cs::error;
    switch (code) {
    case TimeExpired:
        return "timeout during operation";
    case OutOfFunds:
        return "insufficient funds to complete operation";
    case StdException:
        return "connection error while executing contract";
    case Exception:
        return "common error while executing contract";
    case UnpayableReplenish:
        return "replenished contract does not implement payable()";
    case ConsensusRejected:
        return "the trusted consensus have rejected new_state (or emitted transactions)";
    case ExecuteTransaction:
        return "common error in executor";
    case InternalBug:
        return "internal bug in node detected";
    case ExecutionError:
        return "executor is disconnected or unavailable, or incompatible";
    }
    std::ostringstream os;
    os << "Error code " << (unsigned int)code;
    return os.str();
}

/*static*/
bool SmartContracts::is_smart_contract(const csdb::Transaction& tr) {
    if (!tr.is_valid()) {
        return false;
    }
    // to contain smart contract trx must contain either FLD[0] (deploy, start) or FLD[-2] (new_state), both of type
    // "String":
    csdb::UserField f = tr.user_field(trx_uf::deploy::Code);
    if (!f.is_valid()) {
        f = tr.user_field(trx_uf::new_state::Value);
    }
    return f.is_valid() && f.type() == csdb::UserField::Type::String;
}

/*static*/
bool SmartContracts::is_executable(const csdb::Transaction& tr) {
    return SmartContracts::is_smart_contract(tr) && !SmartContracts::is_new_state(tr);
}

/*static*/
bool SmartContracts::is_deploy(const csdb::Transaction& tr) {
    if (!SmartContracts::is_executable(tr)) {
        return false;
    }

    using namespace cs::trx_uf;
    csdb::UserField uf = tr.user_field(deploy::Code);
    if (!uf.is_valid()) {
        return false;
    }

    const auto invoke = deserialize<api::SmartContractInvocation>(uf.value<std::string>());
    // deploy ~ start but method in invoke info is empty
    return invoke.method.empty();
}

/*static*/
bool SmartContracts::is_start(const csdb::Transaction& tr) {
    return SmartContracts::is_executable(tr) && !SmartContracts::is_deploy(tr);
}

/*static*/
bool SmartContracts::is_new_state(const csdb::Transaction& tr) {
    // must contain user field new_state::Value and new_state::RefStart
    using namespace cs::trx_uf;
    // test user_field[RefStart] helps filter out ancient smart contracts:
    return (tr.user_field(new_state::Value).type() == csdb::UserField::Type::String && tr.user_field(new_state::RefStart).type() == csdb::UserField::Type::String);
}

/* static */
/* Assuming deployer.is_public_key() */
csdb::Address SmartContracts::get_valid_smart_address(const csdb::Address& deployer, const uint64_t trId, const api::SmartContractDeploy& data) {
    static_assert(cscrypto::kHashSize <= cscrypto::kPublicKeySize);
    const uint8_t kInnerIdSize = 6;

    std::vector<cscrypto::Byte> strToHash;
    std::string byteCode{};
    if (!data.byteCodeObjects.empty()) {
        for (auto& curr_byteCode : data.byteCodeObjects) {
            byteCode += curr_byteCode.byteCode;
        }
    }
    strToHash.reserve(cscrypto::kPublicKeySize + kInnerIdSize + byteCode.size());

    const auto dPk = deployer.public_key();
    const auto idPtr = reinterpret_cast<const cscrypto::Byte*>(&trId);

    std::copy(dPk.begin(), dPk.end(), std::back_inserter(strToHash));
    std::copy(idPtr, idPtr + kInnerIdSize, std::back_inserter(strToHash));
    std::copy(byteCode.begin(), byteCode.end(), std::back_inserter(strToHash));

    cscrypto::Hash hash = cscrypto::calculateHash(strToHash.data(), strToHash.size());
    cscrypto::PublicKey res;
    res.fill(0);
    std::copy(hash.data(), hash.data() + cscrypto::kHashSize, res.data());

    return csdb::Address::from_public_key(res);
}

/*static*/
csdb::Transaction SmartContracts::get_transaction(BlockChain& storage, const SmartContractRef& contract) {
    csdb::Pool block = storage.loadBlock(contract.sequence);
    if (!block.is_valid()) {
        return csdb::Transaction{};
    }
    if (contract.transaction >= block.transactions_count()) {
        return csdb::Transaction{};
    }
    return block.transactions().at(contract.transaction);
}

std::optional<api::SmartContractInvocation> SmartContracts::find_deploy_info(const csdb::Address& abs_addr) const {
    using namespace trx_uf;
    const auto item = known_contracts.find(abs_addr);
    if (item != known_contracts.cend()) {
        const StateItem& val = item->second;
        if (val.ref_deploy.is_valid()) {
            csdb::Transaction tr_deploy = get_transaction(val.ref_deploy);
            if (tr_deploy.is_valid()) {
                csdb::UserField fld = tr_deploy.user_field(deploy::Code);
                if (fld.is_valid()) {
                    std::string data = fld.value<std::string>();
                    if (!data.empty()) {
                        return std::make_optional(deserialize<api::SmartContractInvocation>(std::move(data)));
                    }
                }
            }
        }
    }
    return std::nullopt;
}

bool SmartContracts::is_replenish_contract(const csdb::Transaction& tr) {
    if (is_smart_contract(tr)) {
        // must not be deploy/execute/new_state transaction
        return false;
    }
    return in_known_contracts(tr.target());
}

std::optional<api::SmartContractInvocation> SmartContracts::get_smart_contract_impl(const csdb::Transaction& tr) {
    // currently calls to is_***() from this method are prohibited, infinite recursion is possible!
    using namespace trx_uf;

    bool is_replenish_contract = false;
    if (!is_smart_contract(tr)) {
        is_replenish_contract = is_payable_target(tr);
        if (!is_replenish_contract) {
            return std::nullopt;
        }
    }

    const csdb::Address abs_addr = absolute_address(tr.target());

    // get info from private contracts table (faster), not from API

    if (is_new_state(tr) || is_replenish_contract) {
        auto maybe_contract = find_deploy_info(abs_addr);
        if (maybe_contract.has_value()) {
            return maybe_contract;
        }
    }
    // is executable (deploy or start):
    else {
        const csdb::UserField fld = tr.user_field(deploy::Code);  // start::Methods == deploy::Code, so does not matter what type of executable is
        if (fld.is_valid()) {
            std::string data = fld.value<std::string>();
            if (!data.empty()) {
                auto invoke = deserialize<api::SmartContractInvocation>(std::move(data));
                if (invoke.method.empty()) {
                    // is deploy
                    return std::make_optional(std::move(invoke));
                }
                else {
                    // is start
                    auto maybe_deploy = find_deploy_info(abs_addr);
                    if (maybe_deploy.has_value()) {
                        api::SmartContractInvocation& deploy = maybe_deploy.value();
                        deploy.method = invoke.method;
                        deploy.params = invoke.params;
                        return std::make_optional(deploy);
                    }
                }
            }
        }
    }

    return std::nullopt;
}

bool SmartContracts::is_payable_target(const csdb::Transaction& tr) {
    csdb::Address abs_addr = absolute_address(tr.target());
    if (!in_known_contracts(abs_addr)) {
        return false;
    }
    // may do blocking call to API::executor
    return is_payable(abs_addr);
}

void SmartContracts::enqueue(const csdb::Pool& block, size_t trx_idx) {
    if (trx_idx >= block.transactions_count()) {
        cserror() << kLogPrefix << "incorrect trx index in block to enqueue smart contract";
        return;
    }
    SmartContractRef new_item(block.hash().clone(), block.sequence(), trx_idx);
    csdb::Transaction t = block.transaction(trx_idx);
    csdb::Address abs_addr = absolute_address(t.target());

    auto it = find_in_queue(new_item);
    if (it != exe_queue.cend()) {
        csdebug() << kLogPrefix << "attempt to queue duplicated {" << new_item.sequence << '.' << new_item.transaction << "}, already queued on round #"
                    << it->seq_enqueue;
        return;
    }

    // test if this contract has already enqueued in this block
    for (it = exe_queue.begin(); it != exe_queue.end(); ++it) {
        if (it->seq_enqueue == new_item.sequence && it->abs_addr == abs_addr) {
            break;
        }
    }

    if (it == exe_queue.end()) {
        // enqueue to end
        [[maybe_unused]] bool payable = false;
        if (SmartContracts::is_deploy(t)) {
            // pre-register in known_contracts
            auto maybe_invoke_info = get_smart_contract_impl(t);
            if (maybe_invoke_info.has_value()) {
                const auto& invoke_info = maybe_invoke_info.value();
                StateItem& state = known_contracts[abs_addr];
                state.ref_deploy = new_item;
                if (update_metadata(invoke_info, state)) {
                    payable = (state.payable == PayableStatus::Implemented);
                }
            }
        }
        else {
            // "lazy" metadata update, also covers cases of reading contracts from DB
            if (!is_metadata_actual(abs_addr)) {
                auto maybe_invoke_info = get_smart_contract_impl(t);
                if (maybe_invoke_info.has_value()) {
                    StateItem& state = known_contracts[abs_addr];
                    update_metadata(maybe_invoke_info.value(), state);
                }
            }
            payable = is_payable(abs_addr);
        }
        std::cout << std::endl; // emphasize with empty line
        cslog() << kLogPrefix << "enqueue " << print_executed_method(new_item);
        std::cout << std::endl; // emphasize with empty line
        it = exe_queue.emplace(exe_queue.cend(), QueueItem(new_item, abs_addr, t));
    }
    else {
        // add to existing queue item
        it->add(new_item, t);
        std::cout << std::endl; // emphasize with empty line
        cslog() << kLogPrefix << "add " << new_item << " to already enqueued contract";
        std::cout << std::endl; // emphasize with empty line
    }

    if (!it->executions.empty()) {
        execution_iterator execution = find_in_queue_item(it, new_item);
        if (execution == it->executions.end()) {
            // smth. strange, failed to find newly created item
            // nothing to do with it
            csdebug() << kLogPrefix << "logical error, unable to find just created execution item";
        }
        else {
            // in addition to contract "subcalls" set by transaction take more from contract's metadata
            const std::string method = get_executed_method_name(new_item);
            const size_t cnt_0 = execution->uses.size();
            add_uses_from(abs_addr, method, execution->uses);  // if failed, execution_allowed wil be set to false
            const size_t cnt = execution->uses.size();
            if (cnt > 0) {
                for (const auto& u : execution->uses) {
                    if (!in_known_contracts(u)) {
                        cslog() << kLogPrefix << "call to unknown contract declared in executing item, cancel {"
                            << new_item.sequence << '.' << new_item.transaction << '}';
                        remove_from_queue(new_item);
                        // also removes parent "it" from exe_queue if empty
                        return;
                    }
                }
            }
            if (cnt > cnt_0) {
                for (size_t i = cnt_0; i < cnt; ++i) {
                    execution->avail_fee -= execution->new_state_fee;  // reserve more fee for future new_state
                }
            }
            execution->consumed_fee += smart_round_fee(block);  // setup costs of initial round
        }
    }

    update_status(*it, new_item.sequence, SmartContractStatus::Waiting);
    it->is_executor = contains_me(block.confidants());
}

void SmartContracts::on_new_state(const csdb::Pool& block, size_t trx_idx) {
    if (!block.is_valid() || trx_idx >= block.transactions_count()) {
        cserror() << kLogPrefix << "incorrect new_state transaction specfied";
    }
    else {
        auto new_state = get_transaction(SmartContractRef{block.hash(), block.sequence(), trx_idx});
        if (!new_state.is_valid()) {
            cserror() << kLogPrefix << "get new_state transaction failed";
        }
        else {
            csdb::UserField fld_contract_ref = new_state.user_field(trx_uf::new_state::RefStart);
            if (!fld_contract_ref.is_valid()) {
                cserror() << kLogPrefix << "new_state transaction does not contain reference to contract";
            }
            else {
                SmartContractRef contract_ref(fld_contract_ref);
                // update state
                update_contract_state(new_state, false);
                const csdb::Address abs_addr = absolute_address(new_state.target());
                const cs::PublicKey& key = abs_addr.public_key();
                std::cout << std::endl; // emphasize with empty line
                cslog() << kLogPrefix << '{' << contract_ref.sequence << '.' << contract_ref.transaction << "} (" << EncodeBase58(key.data(), key.data() + key.size())
                        << ") state has been updated";
                std::cout << std::endl; // emphasize with empty line
                update_lock_status(abs_addr, false);
                remove_from_queue(contract_ref);
            }
            csdb::UserField fld_fee = new_state.user_field(trx_uf::new_state::Fee);
            if (fld_fee.is_valid()) {
                csdebug() << kLogPrefix << "contract execution fee " << fld_fee.value<csdb::Amount>().to_double();
                csdebug() << kLogPrefix << "contract new state fee " << new_state.counted_fee().to_double();
            }
        }
    }

    test_exe_queue();
}

void SmartContracts::test_exe_queue() {
    // update queue items status
    auto it = exe_queue.begin();
    while (it != exe_queue.end()) {
        if (it->status == SmartContractStatus::Closed) {
            csdebug() << kLogPrefix << "finished {" << it->seq_enqueue << ".*} still in queue, remove it";
            it = remove_from_queue(it);
            continue;
        }
        if (it->executions.empty()) {
            // the senseless item in the queue
            csdebug() << kLogPrefix << "empty {" << it->seq_enqueue << ".*} in queue, remove it";
            it = remove_from_queue(it);
            continue;
        }
        if (it->status == SmartContractStatus::Running) {
            // some contract is already running
            ++it;
            continue;
        }
        if (it->status == SmartContractStatus::Finished) {
            // some contract is under consensus
            ++it;
            continue;
        }
        // status: Waiting

        // is locked:
        bool wait_until_unlock = false;
        if (is_locked(it->abs_addr)) {
            csdebug() << kLogPrefix << '{' << it->seq_enqueue << ".*} still is locked, wait until unlocked";
            wait_until_unlock = true;
        }
        // is anyone of using locked:
        else {
            for (const auto& execution : it->executions) {
                for (const auto& u : execution.uses) {
                    if (is_locked(absolute_address(u))) {
                        csdebug() << kLogPrefix << "some contract using by {" << execution.ref_start.sequence << '.'
                            << execution.ref_start.transaction << "} still is locked, wait until unlocked";
                        wait_until_unlock = true;
                        break;
                    }
                }
            }
        }
        if (wait_until_unlock) {
            ++it;
            continue;
        }

        csdebug() << kLogPrefix << "set running status to {" << it->seq_enqueue << ".*} containing " << it->executions.size() << " jobs";
        update_status(*it, bc.getLastSequence(), SmartContractStatus::Running);
        // call to executor only if is trusted relatively to this contract
        if (it->is_executor) {
            // final decision to execute contract is here, based on executor availability
            if (!execution_allowed && !test_executor_availability()) {
                cslog() << kLogPrefix << "skip {" << it->seq_enqueue << ".*}, execution is not allowed (executor is not connected)";
                it->is_executor = false;
                // notify partners that unable to play trusted role
                bool fake_sent = false;
                const auto& confidants = pnode->retriveSmartConfidants(it->seq_enqueue);
                for (auto itconf = confidants.cbegin(); itconf != confidants.cend(); ++itconf) {
                    if (std::equal(itconf->cbegin(), itconf->cend(), node_id.cbegin())) {
                        cslog() << kLogPrefix << "unable to execute {" << it->seq_enqueue << ".*}, so send fake stage-1 & stage-2";
                        cs::Byte own_conf_num = cs::Byte(itconf - confidants.cbegin());
                        // empty it->executions tested above, so it is safe to call to front()
                        const auto& ref_start = it->executions.front().ref_start;
                        uint64_t id = SmartConsensus::createId(ref_start.sequence, uint16_t(ref_start.transaction), 0);
                        SmartConsensus::sendFakeStageOne(pnode, confidants, own_conf_num, id);
                        SmartConsensus::sendFakeStageTwo(pnode, confidants, own_conf_num, id);
                        fake_sent = true;
                        break;
                    }
                }
                if (!fake_sent) {
                    cslog() << kLogPrefix << "unable to execute {" << it->seq_enqueue << ".*} and failed to send fake stage-1 & stage-2";
                }
            }
            else {
                csdebug() << kLogPrefix << "execute {" << it->seq_enqueue << ".*} now";
                execute_async(it->executions);
            }
        }
        else {
            csdebug() << kLogPrefix << "skip {" << it->seq_enqueue << ".*} execution, not in trusted list";
        }

        ++it;
    }
}

SmartContractStatus SmartContracts::get_smart_contract_status(const csdb::Address& addr) const {
    if (!exe_queue.empty()) {
        const auto it = find_first_in_queue(absolute_address(addr));
        if (it != exe_queue.cend()) {
            return it->status;
        }
    }
    return SmartContractStatus::Idle;
}

bool SmartContracts::capture_transaction(const csdb::Transaction& tr) {
    cs::Lock lock(public_access_lock);

    // test smart contract as source of transaction
    // the new_state transaction is unable met here, we are the only one source of new_state
    csdb::Address abs_addr = absolute_address(tr.source());
    if (in_known_contracts(abs_addr)) {
        csdebug() << kLogPrefix << "smart contract is not allowed to emit transaction via API, drop it";
        return true;  // avoid from conveyer sync
    }

    // test smart contract as target of transaction (is it payable?)
    abs_addr = absolute_address(tr.target());
    bool is_contract = false;
    bool has_state = false;
    const auto it = known_contracts.find(abs_addr);
    if (it != known_contracts.end()) {
        is_contract = true;
        has_state = !it->second.state.empty();
    }

    if (is_contract) {
        // test contract was deployed (and maybe called successfully)
        if (!has_state) {
            cslog() << kLogPrefix << "unable execute not successfully deployed contract, drop transaction";
            return true;  // block from conveyer sync
        }

        double amount = tr.amount().to_double();
        // possible blocking call to executor for the first time:
        if (!is_payable(abs_addr)) {
            if (amount > std::numeric_limits<double>::epsilon()) {
                cslog() << kLogPrefix << "unable replenish balance of contract without payable() feature, drop transaction";
                return true;  // block from conveyer sync
            }
            else /*amount is 0*/ {
                if (!is_smart_contract(tr)) {
                    // not deploy/execute/new_state transaction as well as smart is not payable
                    cslog() << kLogPrefix << "unable call to payable(), feature is not implemented in contract, drop transaction";
                    return true;  // block from conveyer sync
                }
            }
        }
        else /* is payable */ {
            // test if payable() is not directly called
            if (is_executable(tr)) {
                const csdb::UserField fld = tr.user_field(cs::trx_uf::start::Methods);
                if (fld.is_valid()) {
                    std::string data = fld.value<std::string>();
                    if (!data.empty()) {
                        auto invoke = deserialize<api::SmartContractInvocation>(std::move(data));
                        if (invoke.method == PayableName) {
                            cslog() << kLogPrefix << "unable call to payable() directly, drop transaction";
                            return true;  // block from conveyer sync
                        }
                    }
                }
                csdebug() << kLogPrefix << "allow deploy/executable transaction";
            }
            else /* not executable transaction */ {
                // contract is payable and transaction addresses it, ok then
                csdebug() << kLogPrefix << "allow transaction to target payable contract";
            }
        }
    }

    if (SmartContracts::is_deploy(tr)) {
        csdebug() << kLogPrefix << "deploy transaction detected";
    }
    else if (SmartContracts::is_start(tr)) {
        csdebug() << kLogPrefix << "start transaction detected";
    }

    return false;  // allow pass to conveyer sync
}

bool SmartContracts::test_executor_availability() {
    if (!execution_allowed) {
        execution_allowed = exec_handler_ptr && exec_handler_ptr->getExecutor().isConnect();
        if (execution_allowed) {
            cslog() << std::endl << kLogPrefix << "connection to executor is restored" << std::endl;
            // update all currently running contracts locks, missed while executor was unavailable
            for (const auto& exe_item : exe_queue) {
                if (exe_item.status == SmartContractStatus::Running || exe_item.status == SmartContractStatus::Finished) {
                    if (!is_metadata_actual(exe_item.abs_addr)) {
                        auto maybe_deploy = find_deploy_info(exe_item.abs_addr);
                        if (maybe_deploy.has_value()) {
                            auto it_state = known_contracts.find(exe_item.abs_addr);
                            if (it_state != known_contracts.end()) {
                                if (!update_metadata(maybe_deploy.value(), it_state->second)) {
                                    if (!execution_allowed) {
                                        // the problem has got back
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return execution_allowed;
}

CallsQueueScheduler& SmartContracts::getScheduler() {
    return scheduler;
}

void SmartContracts::on_store_block(const csdb::Pool& block) {
    cs::Lock lock(public_access_lock);

    test_executor_availability();
    test_exe_conditions(block);
    test_exe_queue();
    test_contracts_locks();

    // inspect transactions against smart contracts, raise special event on every item found:
    if (block.transactions_count() > 0) {
        size_t tr_idx = 0;
        for (const auto& tr : block.transactions()) {
            if (is_smart_contract(tr)) {
                // dispatch transaction by its type
                bool is_deploy = this->is_deploy(tr);
                bool is_start = is_deploy ? false : this->is_start(tr);
                if (is_deploy || is_start) {
                    if (is_deploy) {
                        csdebug() << kLogPrefix << "contract is deployed by #" << block.sequence() << "." << tr_idx;
                    }
                    else {
                        csdebug() << kLogPrefix << "contract is invoked by #" << block.sequence() << "." << tr_idx;
                    }
                    enqueue(block, tr_idx);
                }
                else if (is_new_state(tr)) {
                    csdebug() << kLogPrefix << "contract state is updated by #" << block.sequence() << "." << tr_idx;
                    on_new_state(block, tr_idx);
                }
            }
            else if (is_payable_target(tr)) {
                // execute payable method
                csdebug() << kLogPrefix << "contract balance is replenished by #" << block.sequence() << "." << tr_idx;
                emit signal_payable_invoke(tr);
                enqueue(block, tr_idx);
            }
            else {
                // test is emitted by contract
                csdb::Address abs_addr = absolute_address(tr.source());
                const auto it = known_contracts.find(abs_addr);
                if (it != known_contracts.cend()) {
                    // is emitted by contract
                    const auto& state = it->second;
                    csdb::Transaction starter = get_transaction(state.ref_execute);
                    if (state.payable == PayableStatus::Implemented && starter.is_valid()) {
                        emit signal_emitted_accepted(tr, starter);
                    }
                    else {
                        cserror() << kLogPrefix << "failed to find starter transaction for contract emitted one";
                    }
                }
            }
            ++tr_idx;
        }
    }

    test_exe_queue();
}

void SmartContracts::on_read_block(const csdb::Pool& block, bool* /*should_stop*/) {
    cs::Lock lock(public_access_lock);

    // uncomment when exe_queue is updated during blocks reading on startup:
    // test_exe_conditions(block);

    // control round-based timeout
    // assume block arrive in increasing sequence order
    while (!replenish_contract.empty()) {
        const auto it = replenish_contract.cbegin();
        if (block.sequence() - it->sequence <= Consensus::MaxRoundsCancelContract) {
            // no timeout yet
            break;
        }
        csdb::Transaction t = get_transaction(*it);
        if (t.is_valid()) {
            emit signal_payable_timeout(t);
        }
        replenish_contract.erase(it);
    }

    if (block.transactions_count() > 0) {
        size_t tr_idx = 0;
        for (const auto& tr : block.transactions()) {
            if (is_new_state(tr)) {
                update_contract_state(tr, true);
            }
            else {
                csdb::Address abs_addr = absolute_address(tr.target());
                if (!abs_addr.is_valid()) {
                    cserror() << kLogPrefix << "failed convert optimized address";
                }
                else {
                    if (!in_known_contracts(abs_addr)) {
                        if (is_deploy(tr)) {
                            // register ONLY contract deploy,
                            // known contracts will be updated on new_state handling
                            StateItem& state = known_contracts[abs_addr];
                            state.ref_deploy.hash = block.hash();
                            state.ref_deploy.sequence = block.sequence();
                            state.ref_deploy.transaction = tr_idx;
                        }
                    }
                    else {
                        if (!is_executable(tr)) {
                            // replenish smart contract
                            emit signal_payable_invoke(tr);
                            replenish_contract.emplace_back(block.hash(), block.sequence(), tr_idx);
                        }
                    }
                }
            }

            ++tr_idx;
        }
    }

    // do not assign stop flag not to overwrite value set by other subscribers:
    //*should_stop = false;
}

// tests max fee amount and round-based timeout on executed smart contracts;
// is invoked on every new block
void SmartContracts::test_exe_conditions(const csdb::Pool& block) {
    if (exe_queue.empty()) {
        return;
    }

    const auto seq = block.sequence();
    for (auto& item : exe_queue) {
        if (item.status != SmartContractStatus::Running && item.status != SmartContractStatus::Finished) {
            continue;
        }

        // smart is in executor or is under smart-consensus

        // unconditional timeout, actual for both Finished and Running items
        if (seq > item.seq_start && seq - item.seq_start > Consensus::MaxRoundsCancelContract) {
            cswarning() << kLogPrefix << '{' << item.seq_enqueue << ".*} is in queue over " << Consensus::MaxRoundsCancelContract
                        << " blocks (from #" << item.seq_start << "), remove it without transaction";
            update_status(item, seq, SmartContractStatus::Closed);
            for (const auto& execution : item.executions) {
                csdb::Transaction starter = get_transaction(execution.ref_start);
                if (starter.is_valid()) {
                    if (!is_executable(starter)) {
                        emit signal_payable_timeout(starter);
                    }
                }
                else {
                    cserror() << kLogPrefix << "cannot handle {" << execution.ref_start.sequence << '.' << execution.ref_start.transaction
                        << "} execution timeout properly, starter transaction not found";
                }
            }
            continue;
        }

        if (item.status == SmartContractStatus::Running) {
            // test near-timeout:
            if (seq > item.seq_start && seq - item.seq_start > Consensus::MaxRoundsExecuteContract) {
                cslog() << kLogPrefix << '{' << item.seq_enqueue << ".*} is in queue over " << Consensus::MaxRoundsExecuteContract
                        << " blocks (from #" << item.seq_start << "), stop it";
                if (item.is_executor) {
                    std::vector<SmartExecutionData> data_list;
                    for (const auto& execution : item.executions) {
                        SmartExecutionData& data = data_list.emplace_back();
                        data.contract_ref = execution.ref_start;
                        data.error = "contract execution timeout";
                        data.result.retValue.__set_v_byte(error::TimeExpired);
                    }
                    if (!data_list.empty()) {
                        on_execution_completed_impl(std::move(data_list));
                    }
                }
                else {
                    update_status(item, seq, SmartContractStatus::Finished);
                }
                continue;
            }
            // test out-of-fee in every execution item and cancel all jobs if any out-of-fee occurs
            const auto add_fee = smart_round_fee(block);
            for (auto& execution : item.executions) {
                execution.consumed_fee += add_fee;
                if (execution.avail_fee < execution.consumed_fee) {
                    // cancel all item and break the loop
                    cslog() << kLogPrefix << '{' << execution.ref_start.sequence << '.' << execution.ref_start.transaction
                        << "} is out of fee, cancel the whole queue item";
                    if (item.is_executor) {
                        std::vector<SmartExecutionData> data_list;
                        for (const auto& e: item.executions) {
                            SmartExecutionData& data = data_list.emplace_back();
                            data.contract_ref = e.ref_start;
                            data.error = "contract execution is out of funds";
                            data.result.retValue.__set_v_byte(error::OutOfFunds);
                        }
                        if (!data_list.empty()) {
                            on_execution_completed_impl(std::move(data_list));
                        }
                    }
                    else {
                        update_status(item, seq, SmartContractStatus::Finished);
                    }
                    break;
                }
            }
        }  // if block for Running only contract

    }  // for each exe_queue item
}

// return next element in queue
SmartContracts::queue_iterator SmartContracts::remove_from_queue(SmartContracts::queue_iterator it) {
    if (it != exe_queue.cend()) {
        cslog() << kLogPrefix << "remove from queue completed item {" << it->seq_enqueue << ".*}";
        for (const auto item : it->executions) {
            cslog() << "\t{" << item.ref_start.sequence << '.' << item.ref_start.transaction << "} " << print_executed_method(item.ref_start);
        }
        const cs::Sequence seq = bc.getLastSequence();
        const cs::Sequence seq_cancel = it->seq_start + Consensus::MaxRoundsCancelContract + 1;
        if (seq > it->seq_start + Consensus::MaxRoundsExecuteContract && seq < seq_cancel) {
            cslog() << kLogPrefix << seq_cancel - seq << " round(s) remains until unconditional timeout";
        }
        // its too early to unlock contract(s), wait until states will updated
        // unlock only closed (after timeout) contracts
        if (it->status == SmartContractStatus::Closed) {
            update_lock_status(*it, false);
        }
        it = exe_queue.erase(it);

        if (exe_queue.empty()) {
            csdebug() << kLogPrefix << "contract queue is empty, nothing to execute";
        }
        else {
            csdebug() << kLogPrefix << exe_queue.size() << " item(s) in queue";
        }
    }

    return it;
}

void SmartContracts::remove_from_queue(const SmartContractRef& item) {
    queue_iterator it = find_in_queue(item);
    if (it == exe_queue.end()) {
        return;
    }
    auto execution = find_in_queue_item(it, item);
    if (execution != it->executions.cend()) {
        cslog() << kLogPrefix << "remove from queue completed {"
            << execution->ref_start.sequence << '.' << execution->ref_start.transaction << "} " << print_executed_method(execution->ref_start);
        it->executions.erase(execution);
    }
    if (it->executions.empty()) {
        remove_from_queue(it);
    }
}

bool SmartContracts::execute(SmartExecutionData& data) {
    if (!exec_handler_ptr) {
        data.error = "contract executor is unavailable";
        data.result.retValue.__set_v_byte(error::ExecuteTransaction);
        return false;
    }
    csdb::Pool block = bc.loadBlock(data.contract_ref.sequence);
    if (!block.is_valid()) {
        data.error = "load block with starter transaction failed";
        data.result.retValue.__set_v_byte(error::InternalBug);
        return false;
    }
    cslog() << kLogPrefix << "executing " << data.contract_ref << "::" << print_executed_method(data.contract_ref) << std::endl;
    // using data.result.newState to pass previous (not yet cached) new state in case of multi-call to conrtract:
    auto maybe_result = exec_handler_ptr->getExecutor().executeTransaction(block, data.contract_ref.transaction, data.executor_fee, data.result.newState);
    if (maybe_result.has_value()) {
        data.result = maybe_result.value();
        if (data.result.newState.empty()) {
            if (data.result.retValue.__isset.v_string) {
                data.error = data.result.retValue.v_string;
                data.result.retValue.__set_v_byte(error::ExecuteTransaction);
            }
            else {
                data.error = "contract execution failed, contract state is unchanged";
            }
        }
    }
    else {
        data.error = "contract execution failed";
        data.result.retValue.__set_v_byte(error::ExecuteTransaction);
    }
    return true;
}

// returns false if execution canceled, so caller may call to remove_from_queue()
bool SmartContracts::execute_async(const std::vector<ExecutionItem>& executions) {
    std::vector<SmartExecutionData> data_list;
    for (const auto& execution : executions) {
        SmartExecutionData& execution_data = data_list.emplace_back();
        execution_data.contract_ref = execution.ref_start;
        execution_data.executor_fee = execution.avail_fee;
        csdb::Transaction start_tr = get_transaction(execution.ref_start);
        bool replenish_only = false;  // means indirect call to payable()
        if (!is_executable(start_tr)) {
            replenish_only = is_payable_target(start_tr);
            if (!replenish_only) {
                // it must be filtered before not to prevent other calls from execution
                cserror() << kLogPrefix << "unable execute neither deploy nor start/replenish transaction";
                return false;
            }
        }
        bool deploy = is_deploy(start_tr);
        csdebug() << kLogPrefix << "invoke api to remote executor to " << (deploy ? "deploy" : (!replenish_only ? "execute" : "replenish"))
            << " {" << execution.ref_start.sequence << '.' << execution.ref_start.transaction << '}';
    }

    if (data_list.empty()) {
        // in fact, it was tested before
        return false;
    }

    // create runnable object
    auto runnable = [this, data_list{std::move(data_list)}]() mutable {
        if (!data_list.empty()) {

            // actually, multi-execution list always refers to the same contract, so we need not to distinct different contracts last state
            std::string last_state;
            for (auto& data : data_list) {
                // use data.result.newStatef member to pass last contract's state in multi-call
                data.result.newState = last_state;
                if (!execute(data)) {
                    if (data.error.empty()) {
                        data.error = "failed to invoke contract";
                    }
                    // last_state is not updated
                }
                else {
                    if (!data.result.newState.empty()) {
                        // remember last state for the next execution
                        last_state = data.result.newState;
                    }
                }
                if (data.result.fee > data.executor_fee) {
                    // out of fee detected
                    data.error = "contract execution is out of funds";
                    data.result.retValue.__set_v_byte(error::OutOfFunds);
                }
            }
        }
        return data_list;
    };

    // run async and watch result
    auto watcher = cs::Concurrent::run(cs::RunPolicy::CallQueuePolicy, runnable);
    cs::Connector::connect(&watcher->finished, this, &SmartContracts::on_execution_completed);

    return true;
}

void SmartContracts::on_execution_completed_impl(const std::vector<SmartExecutionData>& data_list) {
    using namespace trx_uf;
    if (data_list.empty()) {
        // actually is checked before
        return;
    }

    // any of data item "points" to the same queue item
    auto it = find_in_queue(data_list.front().contract_ref);
    if (it != exe_queue.end()) {
        if (it->status == SmartContractStatus::Finished || it->status == SmartContractStatus::Closed) {
            // already finished (by timeout), no transaction required
            return;
        }
        update_status(*it, bc.getLastSequence(), SmartContractStatus::Finished);
    }
    else {
        return;
    }

    // create (multi-)packet:
    // new_state[0] + [ emitted_list[0] ] + [ susequent_state_list[0] ] + ... + new_state[n-1] + [ emitted_list[n-1] ] + [ subsequent_state_list[n-1] ]
    cs::TransactionsPacket integral_packet;
    int64_t next_id = 0; // "lazy" initialization assumed

    for (const auto& data_item : data_list) {
        ExecutionItem* execution = nullptr;
        // create partial new_state transaction
        if (it != exe_queue.end()) {
            auto it_exe = find_in_queue_item(it, data_item.contract_ref);
            csdebug() << kLogPrefix << "execution of " << data_item.contract_ref << " has completed";
            if (it_exe != it->executions.end()) {
                execution = &(*it_exe);
            }
        }
        if (execution == nullptr) {
            // wtf data without execution item?
            continue;
        }

        execution->consumed_fee = data_item.result.fee;  // executor calculates fee for now
        cs::TransactionsPacket& packet = execution->result;
        if (packet.transactionsCount() > 0) {
            packet.clear();
        }

        if (next_id > 0) {
            ++next_id;
        }
        else {
            // 1st-time init
            auto starter = get_transaction(execution->ref_start);
            if (starter.is_valid()) {
                next_id = next_inner_id(absolute_address(starter.target()));
            }
            else {
                next_id = 1;
            }
        }
        csdb::Transaction result = create_new_state(*execution, next_id);

        // create partial failure if new_state is not created
        if(!result.is_valid()) {
            cserror() << kLogPrefix << "cannot find in queue just completed contract, so cannot create new_state";
            csdb::Transaction tmp = get_transaction(data_item.contract_ref);
            if (!tmp.is_valid()) {
                return;
            }
            QueueItem fake(data_item.contract_ref, absolute_address(tmp.target()), tmp);
            if (!fake.executions.empty()) {
                result = create_new_state(fake.executions.front(), next_id); // use the same next_id again
            }
            else {
                // wtf!
                cserror() << kLogPrefix << "failed to create new_state transaction, even empty";
            }
        }

        // finalize new_state transaction
        if (!data_item.error.empty()) {
            cserror() << std::endl << kLogPrefix << data_item.error << std::endl;
            csdebug() << kLogPrefix << "execution of " << data_item.contract_ref << " is failed, new state is empty";
            // result contains empty USRFLD[state::Value]
            result.add_user_field(new_state::Value, std::string{});
            // result contains error code from ret_val
            result.add_user_field(new_state::RetVal, serialize(data_item.result.retValue));
            packet.addTransaction(result);
        }
        else {
            csdebug() << kLogPrefix << "execution of " << data_item.contract_ref << " is successful, new state size = " << data_item.result.newState.size();

            // put new state
            result.add_user_field(new_state::Value, data_item.result.newState);
            result.add_user_field(new_state::RetVal, serialize(data_item.result.retValue));
            packet.addTransaction(result);

            if (it != exe_queue.end()) {
                // put emitted transactions
                if (!data_item.result.trxns.empty()) {
                    int64_t next_emitted_id = result.innerID() + 1;  // may or may not be useful next block of code
                    for (const auto& tr : data_item.result.trxns) {
                        if (tr.innerID() == 0) {
                            // auto inner id generating
                            csdebug() << kLogPrefix << "zero innerID in emitted transaction, generate new";
                            csdb::Transaction tmp = tr.clone();
                            tmp.set_innerID(next_emitted_id);
                            packet.addTransaction(tmp);
                            ++next_emitted_id;
                        }
                        else {
                            packet.addTransaction(tr);
                        }
                    }
                    csdebug() << kLogPrefix << "add " << data_item.result.trxns.size() << " emitted transaction(s) to " << data_item.contract_ref << " state";
                }
                else {
                    csdebug() << kLogPrefix << "no emitted transaction added to " << data_item.contract_ref;
                }
                // put subsequent new_states if any
                if (!data_item.result.states.empty()) {
                    csdebug() << kLogPrefix << "add " << data_item.result.states.size() << " subsequent new state(s) along with " << data_item.contract_ref << " state";
                    for (const auto& [addr, state] : data_item.result.states) {
                        auto it_call = find_in_queue_item(it, data_item.contract_ref);
                        if (it_call != it->executions.end()) {
                            csdb::Transaction t = create_new_state(*it_call, ++next_id);
                            if (t.is_valid()) {
                                // re-assign some fields
                                t.set_innerID(next_inner_id(addr));
                                t.set_source(addr);
                                t.set_target(addr);
                                t.add_user_field(trx_uf::new_state::Value, state);
                                t.add_user_field(trx_uf::new_state::Fee, csdb::Amount(0));
                                t.add_user_field(trx_uf::new_state::RetVal, serialize(::general::Variant{}));
                                packet.addTransaction(t);
                            }
                        }
                    }
                }
            }
        }
        // add all transactions to integral packet
        for (const auto& t : packet.transactions()) {
            integral_packet.addTransaction(t);
        }
    }

    // 'it' already has tested
    std::ostringstream os;
    for (const auto e : it->executions) {
        os << e.ref_start << ' ';
    }
    csdebug() << kLogPrefix << "starting " << os.str() << "consensus";
    if (!start_consensus(*it, integral_packet)) {
        cserror() << kLogPrefix << os.str() << "consensus failed, remove item from queue";
        remove_from_queue(it);
    }

    // inform slots if any, packet does not contain smart consensus' data!
    emit signal_smart_executed(integral_packet);
}

uint64_t SmartContracts::next_inner_id(const csdb::Address& addr) const {
    csdb::Address abs_addr = SmartContracts::absolute_address(addr);
    
    // lookup in blockchain
    BlockChain::WalletData wallData{};
    BlockChain::WalletId wallId{};
    uint64_t id = 1;
    if (bc.findWalletData(abs_addr, wallData, wallId)) {
        if (!wallData.trxTail_.empty()) {
            id = wallData.trxTail_.getLastTransactionId() + 1;
        }
    }
    //csdebug() << kLogPrefix << "next innerID " << id << " (from storage)";
    return id;
}

csdb::Transaction SmartContracts::create_new_state(const ExecutionItem& item, int64_t new_id) {
    csdb::Transaction src = get_transaction(item.ref_start);
    if (!src.is_valid()) {
        return csdb::Transaction{};
    }
    csdb::Transaction result(new_id,        
                             src.target(),      // contract's address
                             src.target(),      // contract's address
                             src.currency(),    // source value
                             0,                 // amount
                             csdb::AmountCommission((item.avail_fee - item.consumed_fee).to_double()), csdb::AmountCommission(item.new_state_fee.to_double()),
                             Zero::signature  // empty signature
    );
    // USRFLD1 - ref to start trx
    result.add_user_field(trx_uf::new_state::RefStart, item.ref_start.to_user_field());
    // USRFLD2 - total fee
    result.add_user_field(trx_uf::new_state::Fee, item.consumed_fee);
    return result;
}

// get & handle rejected transactions
// the aim is
//  - to store completed executions
//  - repeat consensus for rejected executions fixing empty new_states
//  - re-execute valid but "compromised" by rejected items executions
void SmartContracts::on_reject(const std::vector<Node::RefExecution>& reject_list) {

    if (reject_list.empty()) {
        return;
    }

    cs::RoundNumber current_sequence = bc.getLastSequence();

    cs::Lock lock(public_access_lock);

    // handle failed calls
    csdebug() << kLogPrefix << "get reject contract(s) signal";
    if (reject_list.empty()) {
        csdebug() << kLogPrefix << "rejected contract list is empty";
    }
    else {
        csdebug() << kLogPrefix << "" << reject_list.size() << " contract(s) are rejected";

        // group reject_list by block sequence
        std::map< cs::Sequence, std::list<uint16_t> > grouped_failed;
        for (const auto& item : reject_list) {
            grouped_failed[item.first].emplace_back(item.second);
        }

        for (const auto& [sequence, executions] : grouped_failed) {
            if (executions.empty()) {
                // actually impossible
                continue;
            }
            // to store newly created items:
            decltype(exe_queue) new_queue_items;
            auto it_queue = exe_queue.begin();
            while (it_queue != exe_queue.end()) {
                if (it_queue->seq_enqueue == sequence) {
                    auto it_exe = it_queue->executions.begin();
                    while (it_exe != it_queue->executions.end()) {
                        if (std::find(executions.cbegin(), executions.cend(), it_exe->ref_start.transaction) != executions.cend()) {
                            // found (maybe partially) rejected queue item
                            if (it_queue->is_rejected) {
                                // has alredy done before
                                break;
                            }
                            // it_exe here points to the first rejected call in multi-call
                            // replace all rejected items with empty new state
                            std::vector<ExecutionItem> reject;
                            reject.emplace_back(*it_exe);
                            it_exe = it_queue->executions.erase(it_exe);
                            // schedule re-execution of subsequent non-rejected items
                            std::vector<ExecutionItem> restart;

                            // starting inner sub-cycle
                            while (it_exe != it_queue->executions.end()) {
                                if (std::find(executions.cbegin(), executions.cend(), it_exe->ref_start.transaction) != executions.cend()) {
                                    // do not clear result, new_state is required
                                    reject.emplace_back(*it_exe);
                                }
                                else {
                                    // empty result pack required
                                    it_exe->result.clear();
                                    restart.emplace_back(*it_exe);
                                }
                                it_exe = it_queue->executions.erase(it_exe);
                            }

                            // it_exe now is equal to it_queue->executions.end(), do not use it!!!

                            // finally create 1 otr 2 new queue items
                            if (!reject.empty()) {
                                QueueItem& new_rejected_item = new_queue_items.emplace_back(it_queue->fork());
                                new_rejected_item.executions.assign(reject.cbegin(), reject.cend());
                                update_status(new_rejected_item, current_sequence, SmartContractStatus::Finished);
                                new_rejected_item.is_rejected = true;
                                cs::TransactionsPacket integral_pack;
                                for (auto& e : new_rejected_item.executions) {
                                    for (auto& t : e.result.transactions()) {
                                        // lookup proper new state, erase other transactions in result
                                        if (SmartContracts::is_new_state(t) && SmartContracts::absolute_address(t.target()) == new_rejected_item.abs_addr) {
                                            t.add_user_field(trx_uf::new_state::Value, std::string{});
                                            t.add_user_field(trx_uf::new_state::RetVal, error::ConsensusRejected);
                                            integral_pack.addTransaction(t);
                                            e.result.clear();
                                            e.result.addTransaction(t);
                                            break;
                                        }
                                    }
                                }
                                start_consensus(new_rejected_item, integral_pack);
                            }
                            if (!restart.empty()) {
                                QueueItem& new_restart_item = new_queue_items.emplace_back(it_queue->fork());
                                new_restart_item.executions.assign(restart.cbegin(), restart.cend());
                                update_status(new_restart_item, current_sequence, SmartContractStatus::Waiting);
                            }
                            csdebug() << kLogPrefix << "{" << sequence << "*.} is splitted onto " << it_queue->executions.size() << " completed + "
                                << reject.size() << " rejected + " << restart.size() << " restart calls";
                            break;
                        }
                        if (it_exe == it_queue->executions.end()) {
                            break;
                        }
                        ++it_exe;
                    }
                }
                if (it_queue->executions.empty()) {
                    // all jobs are rejected/restarted
                    it_queue = exe_queue.erase(it_queue);
                }
                if (it_queue == exe_queue.end()) {
                    break;
                }
                ++it_queue;
            }
            // add new items if any
            if (!new_queue_items.empty()) {
                exe_queue.insert(exe_queue.end(), new_queue_items.cbegin(), new_queue_items.cend());
            }
        }
    }

    test_exe_queue();
}

bool SmartContracts::update_contract_state(const csdb::Transaction& t, bool reading_db) {
    using namespace trx_uf;
    csdb::UserField fld = t.user_field(new_state::Value);
    if (!fld.is_valid()) {
        cserror() << kLogPrefix << "contract state is not updated, transaction does not contain it";
        return false;
    }
    std::string state_value = fld.value<std::string>();
    if (!state_value.empty()) {
        if (!reading_db) {
            std::cout << std::endl; // emphasize with empty line
            if (state_value.empty()) {
                cslog() << kLogPrefix << "last contract state remains unchanged, execution failed";
            }
            else {
                cslog() << kLogPrefix << "contract state is updated, new size is " << state_value.size();
            }
            std::cout << std::endl; // emphasize with empty line
        }
        // create or get contract state item
        csdb::Address abs_addr = absolute_address(t.target());
        if (abs_addr.is_valid()) {
            StateItem& item = known_contracts[abs_addr];
            item.state = std::move(state_value);
            // determine it is the result of whether deploy or execute
            fld = t.user_field(new_state::RefStart);
            if (fld.is_valid()) {
                SmartContractRef ref(fld);
                csdb::Transaction t_start = get_transaction(ref);
                if (t_start.is_valid()) {
                    if (is_executable(t_start)) {
                        if (is_deploy(t_start)) {
                            item.ref_deploy = ref;
                        }
                        else {
                            item.ref_execute = ref;
                        }
                    }
                    else {
                        // new_state after replenish contract transaction
                        if (reading_db) {
                            // handle replenish during startup reading
                            const auto it = std::find(replenish_contract.cbegin(), replenish_contract.cend(), ref);
                            if (it != replenish_contract.cend()) {
                                replenish_contract.erase(it);
                            }
                            else {
                                csdebug() << kLogPrefix << "(error in blockchain) cannot find replenish transaction new_state refers to";
                            }
                        }
                        else {
                            // handle replenish from on-the-air blocks
                            if (item.payable != PayableStatus::Implemented) {
                                cserror() << kLogPrefix << "non-payable contract state is updated by replenish transaction";
                            }
                        }
                        item.ref_execute = ref;
                    }
                }
                else {
                    if (reading_db) {
                        csdebug() << kLogPrefix << "(error in blockchain) cannot find starter transaction new_state refer to";
                    }
                    else {
                        cswarning() << kLogPrefix << "new_state transaction does not refer to starter one";
                    }
                }
            }
        }
        else {
            if (reading_db) {
                csdebug() << kLogPrefix << "(error in blockchain) cannot find contract by address from new_state";
            }
            else {
                cserror() << kLogPrefix << "failed to convert optimized address";
            }
        }
    }
    else {
        // state_value is empty - erase replenish_contract item if exists
        if (!replenish_contract.empty()) {
            fld = t.user_field(new_state::RefStart);
            if (fld.is_valid()) {
                SmartContractRef ref(fld);
                csdb::Transaction t_start = get_transaction(ref);
                if (t_start.is_valid()) {
                    // handle replenish during startup reading
                    const auto it = std::find(replenish_contract.cbegin(), replenish_contract.cend(), ref);
                    if (it != replenish_contract.cend()) {
                        replenish_contract.erase(it);
                    }
                }
            }
        }
        std::string error_message("execution is failed");
        fld = t.user_field(new_state::RetVal);
        if (fld.is_valid()) {
            ::general::Variant var = deserialize <::general::Variant> (fld.value<std::string>());
            if (var.__isset.v_byte) {
                error_message = SmartContracts::get_error_message(var.v_byte);
            }
            else if (var.__isset.v_string) {
                error_message = var.v_string;
            }
        }
        csdebug() << kLogPrefix << "contract state is not updated, " << error_message;
        return false;
    }
    return true;
}

bool SmartContracts::is_payable(const csdb::Address& abs_addr) {
    // the most frequent fast test
    auto item = known_contracts.find(abs_addr);
    if (item == known_contracts.end()) {
        // unknown contract
        return false;
    }

    StateItem& state = item->second;
    if (state.payable != PayableStatus::Unknown) {
        return state.payable == PayableStatus::Implemented;
    }

    // the first time test
    auto maybe_deploy = find_deploy_info(abs_addr);
    if (!maybe_deploy.has_value()) {
        // smth goes wrong, do not update contract state but return false result
        return false;
    }
    if (!update_metadata(maybe_deploy.value(), state)) {
        return false;
    }
    return (state.payable == PayableStatus::Implemented);
}

bool SmartContracts::update_metadata(const api::SmartContractInvocation& contract, StateItem& state) {
    if (!exec_handler_ptr) {
        return false;
    }
    executor::GetContractMethodsResult result;
    std::string error;
    auto& executor_instance = exec_handler_ptr->getExecutor();
    executor_instance.getContractMethods(result, contract.smartContractDeploy.byteCodeObjects);
    if (result.status.code != 0) {
        execution_allowed = executor_instance.isConnect();
        if (!result.status.message.empty()) {
            cswarning() << kLogPrefix << result.status.message;
        }
        else {
            if (!execution_allowed) {
                cswarning() << kLogPrefix << "unable to connect to executor";
            }
            else {
                cswarning() << kLogPrefix << "execution error " << int(result.status.code);
            }
        }
        // remain payable status & using unknown for future calls
        return false;
    }

    state.payable = PayableStatus::Absent;
    // lookup payable(amount, currency) && annotations
    for (const auto& m : result.methods) {
        // payable status
        if (state.payable != PayableStatus::Implemented) {
            if (m.name == PayableName && m.returnType == PayableRetType) {
                if (m.arguments.size() == 2) {
                    const auto& a0 = m.arguments[0];
                    if (a0.name == PayableNameArg0 && a0.type == PayableArgType) {
                        const auto& a1 = m.arguments[1];
                        if (/*a1.name == PayableNameArg1 &&*/ a1.type == PayableArgType) {
                            state.payable = PayableStatus::Implemented;
                        }
                    }
                }
            }
        }
        // uses
        if (!m.annotations.empty()) {
            for (const auto& a : m.annotations) {
                if (a.name == UsesContract) {
                    csdb::Address addr;
                    std::string method;
                    if (a.arguments.count(UsesContractAddr) > 0) {
                        std::vector<uint8_t> bytes;
                        if (DecodeBase58(a.arguments.at(UsesContractAddr), bytes)) {
                            addr = csdb::Address::from_public_key(bytes);
                            if (addr.is_valid()) {
                                if (a.arguments.count(UsesContractMethod) > 0) {
                                    method = a.arguments.at(UsesContractMethod);
                                }
                                auto& u = state.uses[m.name];
                                u[addr] = method;  // empty method name is allowed too
                            }
                        }
                    }
                }
            }
        }
    }

    return true;
}

void SmartContracts::add_uses_from(const csdb::Address& abs_addr, const std::string& method, std::vector<csdb::Address>& uses) {
    const auto it = known_contracts.find(abs_addr);
    if (it != known_contracts.cend()) {
        if (it->second.uses.empty() && it->second.payable == PayableStatus::Unknown) {
            csdb::Transaction t = get_transaction(it->second.ref_deploy);
            if (t.is_valid()) {
                auto maybe_invoke_info = get_smart_contract_impl(t);
                if (maybe_invoke_info.has_value()) {
                    // try update it->second.uses, make a call to ApiExec
                    if (!update_metadata(maybe_invoke_info.value(), it->second)) {
                        // disable execution until metadata can be updated
                        cslog() << kLogPrefix << "disable contract execution until connection to executor restored";
                        execution_allowed = false;
                    }
                }
            }
        }

        for (const auto& [meth, subcalls] : it->second.uses) {
            if (meth != method) {
                continue;
            }
            for (const auto& [subaddr, submeth] : subcalls) {
                if (std::find(uses.cbegin(), uses.cend(), subaddr) != uses.cend()) {
                    continue;  // skip, already in uses
                }
                uses.emplace_back(subaddr);
                add_uses_from(subaddr, submeth, uses);
            }
        }
    }
}

std::string SmartContracts::print_executed_method(const SmartContractRef& ref) {
    csdb::Transaction t = get_transaction(ref);
    if (!t.is_valid()) {
        return std::string();
    }
    if (is_executable(t)) {
        const auto maybe_invoke_info = get_smart_contract_impl(t);
        if (!maybe_invoke_info.has_value()) {
            return std::string();
        }
        const auto& invoke_info = maybe_invoke_info.value();
        if (invoke_info.method.empty()) {
            return std::string("constructor()");
        }
        std::ostringstream os;
        os << invoke_info.method << '(';
        size_t cnt_params = 0;
        for (const auto& p : invoke_info.params) {
            if (cnt_params > 0) {
                os << ',';
            }
            print(os, p);
            ++cnt_params;
        }
        os << ')';
        return os.str();
    }
    if (is_payable_target(t)) {
        std::ostringstream os;
        os << PayableName << "(" << PayableNameArg0 << " = " << t.amount().to_double() << ", " << PayableNameArg1 << " = 1)";
        return os.str();
    }
    return std::string("???");
}

std::string SmartContracts::get_executed_method_name(const SmartContractRef& ref) {
    csdb::Transaction t = get_transaction(ref);
    if (!t.is_valid()) {
        return std::string();
    }
    if (is_executable(t)) {
        const auto maybe_invoke_info = get_smart_contract_impl(t);
        if (!maybe_invoke_info.has_value()) {
            return std::string();
        }
        const auto& invoke_info = maybe_invoke_info.value();
        if (invoke_info.method.empty()) {
            return std::string("constructor");
        }
        return invoke_info.method;
    }
    if (is_payable_target(t)) {
        return PayableName;
    }
    return std::string();
}

csdb::Amount SmartContracts::smart_round_fee(const csdb::Pool& block) {
    csdb::Amount fee(0);
    if (block.transactions_count() > 0) {
        for (const auto& t : block.transactions()) {
            fee += csdb::Amount(t.counted_fee().to_double());
        }
    }
    return fee;
}

void SmartContracts::update_status(QueueItem& item, cs::RoundNumber r, SmartContractStatus status) {
    item.status = status;

    switch (status) {
        case SmartContractStatus::Waiting:
            item.seq_enqueue = r;
            csdebug() << kLogPrefix << '{' << item.seq_enqueue << ".*} is waiting from #" << r;
            break;
        case SmartContractStatus::Running:
            item.seq_start = r;
            update_lock_status(item, true);
            csdebug() << kLogPrefix << '{' << item.seq_enqueue << ".*} is running from #" << r;
            break;
        case SmartContractStatus::Finished:
            item.seq_finish = r;
            csdebug() << kLogPrefix << '{' << item.seq_enqueue << ".*} is finished on #" << r;
            break;
        case SmartContractStatus::Closed:
            update_lock_status(item, false);
            csdebug() << kLogPrefix << '{' << item.seq_enqueue << ".*} is closed";
            break;
        default:
            break;
    }
}

void SmartContracts::test_contracts_locks() {
    // lookup running items
    if (!exe_queue.empty()) {
        for (const auto& exe_item : exe_queue) {
            if (exe_item.status == SmartContractStatus::Running || exe_item.status == SmartContractStatus::Finished) {
                return;
            }
        }
    }
    // no running items, ensure no locked contracts
    for (auto& item : known_contracts) {
        if (item.second.is_locked) {
            item.second.is_locked = false;
            const cs::PublicKey& key = item.first.public_key();
            csdebug() << kLogPrefix << "find locked contract " << EncodeBase58(key.data(), key.data() + key.size()) << " which is not executed now, unlock";
        }
    }
}

void SmartContracts::update_lock_status(const csdb::Address& abs_addr, bool value) {
    auto it = known_contracts.find(abs_addr);
    if (it != known_contracts.end()) {
        if (it->second.is_locked != value) {
            const cs::PublicKey& key = abs_addr.public_key();
            csdebug() << kLogPrefix << (value ? "lock" : "unlock") << " contract " << EncodeBase58(key.data(), key.data() + key.size());
            it->second.is_locked = value;
        }
    }
}

}  // namespace cs
```
# ..\node\solver\src\solvercontext.cpp 
```cpp 
#include "solvercontext.hpp"
#include "smartcontracts.hpp"
#include "solvercore.hpp"

#include <csnode/conveyer.hpp>
#include <csnode/node.hpp>
#include <lib/system/logger.hpp>

namespace
{
    const char* kLogPrefix = "SolverCore: ";
}

namespace cs {

BlockChain& SolverContext::blockchain() const {
    return core.pnode->getBlockChain();
}

std::string SolverContext::sender_description(const cs::PublicKey& sender_id) {
    // either RVO or string's move constructor used:
    return core.pnode->getSenderText(sender_id);
}

csdb::PoolHash SolverContext::spoileHash(const csdb::PoolHash& hashToSpoil, const cs::PublicKey& pKey) {
    // either RVO or string's move constructor used:
    return core.pnode->spoileHash(hashToSpoil, pKey);
}

void SolverContext::sendHashReply(const csdb::PoolHash& hash, const cs::PublicKey& respondent) {
    // either RVO or string's move constructor used:
    return core.pnode->sendHashReply(hash, respondent);
}

void SolverContext::add_stage1(cs::StageOne& stage, bool send) {
    // core.stageOneStorage.push_back(stage);
    if (send) {
        core.pnode->sendStageOne(stage);
    }
    csdetails() << "Context> Stage1 message: " << cs::Utils::byteStreamToHex(stage.message);
    csdetails() << "Context> Stage1 signature: " << cs::Utils::byteStreamToHex(stage.signature);

    /*the order is important! the signature is created in node
    before sending stage and then is inserted in the field .sig
    now we can add it to stages storage*/
    core.gotStageOne(stage);
}

void SolverContext::add_stage2(cs::StageTwo& stage, bool send) {
    // core.stageTwoStorage.push_back(stage);

    if (send) {
        core.pnode->sendStageTwo(stage);
    }
    /*the order is important! the signature is created in node
    before sending stage and then is inserted in the field .sig
    now we can add it to stages storage*/
    core.gotStageTwo(stage);
}

void SolverContext::add_stage3(cs::StageThree& stage) {
    // core.stageThreeStorage.push_back(stage);

    core.pnode->sendStageThree(stage);
    /*the order is important! the signature is created in node
    before sending stage and then is inserted in the field .sig
    now we can add it to stages storage*/
    core.gotStageThree(stage, 1);
}

uint8_t SolverContext::own_conf_number() const {
    return core.pnode->getConfidantNumber();
}

size_t SolverContext::cnt_trusted() const {
    return cs::Conveyer::instance().confidantsCount();
}

size_t SolverContext::cnt_real_trusted() const {
    const auto rtMask = stage3(own_conf_number())->realTrustedMask;
    return rtMask.size() - std::count(rtMask.cbegin(), rtMask.cend(), cs::ConfidantConsts::InvalidConfidantIndex);
}

const std::vector<cs::PublicKey>& SolverContext::trusted() const {
    return cs::Conveyer::instance().confidants();
}

void SolverContext::request_round_table() const {
    //        core.pnode->sendRoundTableRequest(core.cur_round);
}

bool SolverContext::addSignaturesToLastBlock(Signatures&& signatures) {
    return core.addSignaturesToDeferredBlock(std::move(signatures));
}

Role SolverContext::role() const {
    auto v = core.pnode->getNodeLevel();
    switch (v) {
        case Node::Level::Normal:
        case Node::Level::Main:
            return Role::Normal;
        case Node::Level::Confidant:
        case Node::Level::Writer:
            return Role::Trusted;
        default:
            break;
    }
    cserror() << kLogPrefix << "unknown NodeLevel value " << static_cast<int>(v) << " was returned by Node";
    // TODO: how to handle "unknown" node level value?
    return Role::Normal;
}

void SolverContext::spawn_next_round(cs::StageThree& st3) {
    if (st3.sender == InvalidConfidantIndex) {
        cserror() << "Writer wasn't elected on this node";
        return;
    }

    std::string tStamp;

    if (st3.writer != InvalidConfidantIndex) {
        auto ptr = stage1(st3.writer);
        if (ptr != nullptr) {
            tStamp = ptr->roundTimeStamp;
        }
    }

    if (tStamp.empty()) {
        cswarning() << kLogPrefix << "cannot act as writer because lack writer timestamp";
        return;
    }

    csdebug() << kLogPrefix << "spawn next round";
    if (core.trusted_candidates.empty()) {
        cserror() << kLogPrefix << "trusted candidates list must not be empty while spawn next round";
    }

    csdebug() << kLogPrefix << "new confidant nodes: ";
    int i = 0;
    for (const auto& it : core.trusted_candidates) {
        csdebug() << '\t' << i << ". " << cs::Utils::byteStreamToHex(it.data(), it.size());
        ++i;
    }

    csdebug() << kLogPrefix << "new hashes count is " << core.hashes_candidates.size();
    core.spawn_next_round(core.trusted_candidates, core.hashes_candidates, std::move(tStamp), st3);
}

void SolverContext::sendRoundTable() {
    // if(own_conf_number()==1) {
    //  return;
    //}
    core.sendRoundTable();
}

csdb::Address SolverContext::optimize(const csdb::Address& address) const {
    csdb::internal::WalletId id;
    if (core.pnode->getBlockChain().findWalletId(address, id)) {
        return csdb::Address::from_wallet_id(id);
    }
    return address;
}

bool SolverContext::test_trusted_idx(uint8_t idx, const cs::PublicKey& sender) {
    // vector<Hash> confidantNodes_ in Node actually stores PublicKey items :-)
    const auto& trusted = this->trusted();
    if (idx < trusted.size()) {
        const auto& pk = *(trusted.cbegin() + idx);
        return 0 == memcmp(pk.data(), sender.data(), pk.size());
    }
    return false;
}

cs::Bytes SolverContext::last_block_hash() const {
    // if(!core.is_block_deferred()) {
    return core.pnode->getBlockChain().getLastHash().to_binary();
    //}
    // return core.deferred_block.hash().to_binary().data();
}

void SolverContext::request_stage1(uint8_t from, uint8_t required) {
    const auto& conveyer = cs::Conveyer::instance();
    if (!conveyer.isConfidantExists(from)) {
        return;
    }
    csdebug() << kLogPrefix << "ask [" << static_cast<int>(from) << "] for stage-1 of [" << static_cast<int>(required) << "]";
    core.pnode->stageRequest(MsgTypes::FirstStageRequest, from, required /*, 0U*/);
}

void SolverContext::request_stage2(uint8_t from, uint8_t required) {
    const auto& conveyer = cs::Conveyer::instance();
    if (!conveyer.isConfidantExists(from)) {
        return;
    }
    csdebug() << kLogPrefix << "ask [" << static_cast<int>(from) << "] for stage-2 of [" << static_cast<int>(required) << "]";
    core.pnode->stageRequest(MsgTypes::SecondStageRequest, from, required /*, 0U*/);
}

void SolverContext::request_stage3(uint8_t from, uint8_t required) {
    const auto& conveyer = cs::Conveyer::instance();
    if (!conveyer.isConfidantExists(from)) {
        return;
    }
    csdebug() << kLogPrefix << "ask [" << static_cast<int>(from) << "] for stage-3 of [" << static_cast<int>(required) << "]";
    core.pnode->stageRequest(MsgTypes::ThirdStageRequest, from, required /*, core.currentStage3iteration()*/);
}

bool SolverContext::transaction_still_in_pool(int64_t inner_id) const {
    auto lock = cs::Conveyer::instance().lock();
    const auto& block = cs::Conveyer::instance().packetQueue();

    for (const auto& packet : block) {
        for (const auto& tr : packet.transactions()) {
            if (tr.innerID() == inner_id) {
                return true;
            }
        }
    }

    return false;
}

void SolverContext::request_round_info(uint8_t respondent1, uint8_t respondent2) {
    csdebug() << kLogPrefix << "ask [" << static_cast<int>(respondent1) << "] for RoundTable";
    core.pnode->sendRoundTableRequest(respondent1);

    csdebug() << kLogPrefix << "ask [" << static_cast<int>(respondent2) << "] for RoundTable";
    core.pnode->sendRoundTableRequest(respondent2);
}

void SolverContext::send_rejected_smarts(const std::vector<RefExecution>& reject_list) {
    csdebug() << kLogPrefix << "sending " << reject_list.size() << " rejected contract calls";
    core.pnode->sendSmartReject(reject_list);
}

}  // namespace cs
```
# ..\node\solver\src\solvercore.cpp 
```cpp 
#include <smartcontracts.hpp>
#include <solvercontext.hpp>
#include <solvercore.hpp>
#include <states/nostate.hpp>

#pragma warning(push)
#pragma warning(disable : 4267 4244 4100 4245)
#include <csnode/node.hpp>
#pragma warning(pop)

#include <csnode/datastream.hpp>
#include <csnode/walletsstate.hpp>
#include <lib/system/logger.hpp>

#include <functional>
#include <limits>
#include <sstream>
#include <string>

namespace
{
    const char* log_prefix = "SolverCore: ";
}

namespace cs {

// initial values for SolverCore options

// To track timeout for active state
constexpr const bool TimeoutsEnabled = false;
// To enable perform a transition to the same state
constexpr const bool RepeatStateEnabled = true;
// Special mode: uses debug transition table
constexpr const bool DebugModeOn = false;
// Special mode: uses monitor mode transition table
constexpr const bool MonitorModeOn =
#if defined(MONITOR_NODE)
    true;
#else
    false;
#endif  // MONITOR_NODE

constexpr const bool WebWalletModeOn =
#if defined(WEB_WALLET_NODE) && false
    true;
#else
    false;
#endif  // WEB_WALLET_NODE

// default (test intended) constructor
SolverCore::SolverCore()
// options
: opt_timeouts_enabled(TimeoutsEnabled)
, opt_repeat_state_enabled(RepeatStateEnabled)
, opt_mode(Mode::Default)
// inner data
, pcontext(std::make_unique<SolverContext>(*this))
, tag_state_expired(CallsQueueScheduler::no_tag)
, req_stop(true)
, pnode(nullptr)
, pws(nullptr)
, psmarts(nullptr)

/*, smartProcess_(this)*/ {
    if constexpr (MonitorModeOn) {
        cslog() << log_prefix << "opt_monitor_mode is on, so use special transition table";
        InitMonitorModeTransitions();
    }
    else if constexpr (WebWalletModeOn) {
        cslog() << log_prefix << "opt_web_wallet_mode is on, so use special transition table";
        InitWebWalletModeTransitions();
    }
    else if constexpr (DebugModeOn) {
        cslog() << log_prefix << "opt_debug_mode is on, so use special transition table";
        InitDebugModeTransitions();
    }
    else if constexpr (true) {
        cslog() << log_prefix << "use default transition table";
        InitTransitions();
    }
}

// actual constructor
SolverCore::SolverCore(Node* pNode, csdb::Address GenesisAddress, csdb::Address StartAddress)
: SolverCore() {
    addr_genesis = GenesisAddress;
    addr_start = StartAddress;
    pnode = pNode;
    auto& bc = pNode->getBlockChain();
    pws = std::make_unique<cs::WalletsState>(bc);
    psmarts = std::make_unique<cs::SmartContracts>(bc, scheduler);
}

SolverCore::~SolverCore() {
    scheduler.Stop();
    transitions.clear();
}

void SolverCore::ExecuteStart(Event start_event) {
    if (!is_finished()) {
        cswarning() << log_prefix << "cannot start again, already started";
        return;
    }
    req_stop = false;
    handleTransitions(start_event);
}

void SolverCore::finish() {
    if (pstate) {
        pstate->off(*pcontext);
    }
    scheduler.RemoveAll();
    tag_state_expired = CallsQueueScheduler::no_tag;
    pstate = std::make_shared<NoState>();
    req_stop = true;
}

void SolverCore::setState(const StatePtr& pState) {
    if (!opt_repeat_state_enabled) {
        if (pState == pstate) {
            return;
        }
    }
    if (tag_state_expired != CallsQueueScheduler::no_tag) {
        // no timeout, cancel waiting
        scheduler.Remove(tag_state_expired);
        tag_state_expired = CallsQueueScheduler::no_tag;
    }
    else {
        // state changed due timeout from within expired state
    }

    if (pstate) {
        csdebug() << log_prefix << "pstate-off";
        pstate->off(*pcontext);
    }
    if (Consensus::Log) {
        csdebug() << log_prefix << "switch " << (pstate ? pstate->name() : "null") << " -> " << (pState ? pState->name() : "null");
    }
    pstate = pState;
    if (!pstate) {
        return;
    }
    pstate->on(*pcontext);

    auto closure = [this]() {
        csdebug() << log_prefix << "state " << pstate->name() << " is expired";
        // clear flag to know timeout expired
        tag_state_expired = CallsQueueScheduler::no_tag;
        // control state switch
        std::weak_ptr<INodeState> p1(pstate);
        pstate->expired(*pcontext);
        if (pstate == p1.lock()) {
            // expired state did not change to another one, do it now
            csdebug() << log_prefix << "there is no state set on expiration of " << pstate->name();
            // setNormalState();
        }
    };

    // timeout handling
    if (opt_timeouts_enabled) {
        tag_state_expired = scheduler.InsertOnce(Consensus::DefaultStateTimeout, closure, true /*replace if exists*/);
    }
}

void SolverCore::handleTransitions(Event evt) {
    if (!pstate) {
        // unable to work until initTransitions() called
        return;
    }
    if (Event::BigBang == evt) {
        cswarning() << log_prefix << "BigBang on";
    }
    const auto& variants = transitions[pstate];
    if (variants.empty()) {
        cserror() << log_prefix << "there are no transitions for " << pstate->name();
        return;
    }
    auto it = variants.find(evt);
    if (it == variants.cend()) {
        // such event is ignored in current state
        csdebug() << log_prefix << "event " << static_cast<int>(evt) << " ignored in state " << pstate->name();
        return;
    }
    setState(it->second);
}

bool SolverCore::stateCompleted(Result res) {
    if (Result::Failure == res) {
        cserror() << log_prefix << "error in state " << (pstate ? pstate->name() : "null");
    }
    return (Result::Finish == res);
}

bool SolverCore::stateFailed(Result res) {
    if (Result::Failure == res) {
        cserror() << log_prefix << "error in state " << (pstate ? pstate->name() : "null");
        return true;
    }
    return false;
}

// void SolverCore::adjustTrustedCandidates(cs::Bytes mask, cs::PublicKeys& confidants) {
//  for (int i = 0; i < mask.size(); ++i) {
//    if (mask[i] == cs::ConfidantConsts::InvalidConfidantIndex) {
//      auto it = std::find(trusted_candidates.cbegin(), trusted_candidates.cend(), confidants[i]);
//      if (it != trusted_candidates.cend()) {
//        trusted_candidates.erase(it);
//      }
//    }
//  }
//}

// TODO: this function is to be implemented the block and RoundTable building <====
void SolverCore::spawn_next_round(const cs::PublicKeys& nodes, const cs::PacketsHashes& hashes, std::string&& currentTimeStamp, cs::StageThree& stage3) {
    csmeta(csdetails) << "start";
    cs::Conveyer& conveyer = cs::Conveyer::instance();
    cs::RoundTable table;
    table.round = conveyer.currentRoundNumber() + 1;
    table.confidants = nodes;
    table.hashes = hashes;

    csdetails() << log_prefix << "applying " << hashes.size() << " hashes to ROUND Table";

    // only for new consensus
    cs::PoolMetaInfo poolMetaInfo;
    poolMetaInfo.sequenceNumber = pnode->getBlockChain().getLastSequence() + 1;  // change for roundNumber
    poolMetaInfo.timestamp = std::move(currentTimeStamp);

    const auto confirmation = pnode->getConfirmation(conveyer.currentRoundNumber());
    if (confirmation.has_value()) {
        poolMetaInfo.confirmationMask = confirmation.value().mask;
        poolMetaInfo.confirmations = confirmation.value().signatures;
    }

    csdetails() << log_prefix << "timestamp: " << poolMetaInfo.timestamp;
    for (std::size_t i = 0; i < hashes.size(); ++i) {
        csdetails() << log_prefix << '\t' << i << ". " << hashes[i].toString();
    }

    if (stage3.sender != cs::ConfidantConsts::InvalidConfidantIndex) {
        const cs::ConfidantsKeys& confidants = conveyer.confidants();
        if (stage3.writer < confidants.size()) {
            poolMetaInfo.writerKey = confidants[stage3.writer];
        }
        else {
            cserror() << log_prefix << "stage-3 writer index: " << static_cast<int>(stage3.writer)
                << ", out of range is current confidants size: " << confidants.size();
        }
    }

    poolMetaInfo.realTrustedMask = stage3.realTrustedMask;
    poolMetaInfo.previousHash = pnode->getBlockChain().getLastHash();

    // TODO: in this method we delete the local hashes - so if we need to rebuild thid pool again from the roundTable it's impossible
    uint32_t binSize = 0;
    if (stage3.iteration == 0) {
        std::optional<csdb::Pool> pool = conveyer.applyCharacteristic(poolMetaInfo);

        if (!pool.has_value()) {
            cserror() << log_prefix << "applyCharacteristic() failed to create block";
            return;
        }

        deferredBlock_ = std::move(pool.value());
        deferredBlock_.set_confidants(conveyer.confidants());

        csdebug() << log_prefix << "block #" << deferredBlock_.sequence() << " add new wallets to pool";
        pnode->getBlockChain().addNewWalletsToPool(deferredBlock_);
        pnode->getBlockChain().setTransactionsFees(deferredBlock_);
    }
    else {
        csdb::Pool tmpPool;
        tmpPool.set_sequence(deferredBlock_.sequence());
        tmpPool.set_previous_hash(deferredBlock_.previous_hash());
        tmpPool.add_real_trusted(cs::Utils::maskToBits(stage3.realTrustedMask));
        tmpPool.add_number_trusted(static_cast<uint8_t>(stage3.realTrustedMask.size()));
        tmpPool.setRoundCost(deferredBlock_.roundCost());
        tmpPool.set_confidants(deferredBlock_.confidants());
        for (auto& it : deferredBlock_.transactions()) {
            tmpPool.add_transaction(it);
        }
        tmpPool.add_user_field(0, poolMetaInfo.timestamp);
        for (auto& it : deferredBlock_.smartSignatures()) {
            tmpPool.add_smart_signature(it);
        }

        csdb::Pool::NewWallets* newWallets = tmpPool.newWallets();
        csdb::Pool::NewWallets* defWallets = deferredBlock_.newWallets();
        if (!newWallets) {
            cserror() << log_prefix << "newPool is read-only";
            return;
        }
        for (auto& it : *defWallets) {
            newWallets->push_back(it);
        }
        if (poolMetaInfo.sequenceNumber > 1) {
            tmpPool.add_number_confirmations(static_cast<uint8_t>(poolMetaInfo.confirmationMask.size()));
            tmpPool.add_confirmation_mask(cs::Utils::maskToBits(poolMetaInfo.confirmationMask));
            tmpPool.add_round_confirmations(poolMetaInfo.confirmations);
        }

        deferredBlock_ = csdb::Pool{};
        deferredBlock_ = tmpPool;
    }
    deferredBlock_.to_byte_stream(binSize);
    deferredBlock_.hash();
    csdetails() << log_prefix << "pool #" << deferredBlock_.sequence() << ": " << cs::Utils::byteStreamToHex(deferredBlock_.to_binary().data(), deferredBlock_.to_binary().size());
    const auto lastHashBin = deferredBlock_.hash().to_binary();
    std::copy(lastHashBin.cbegin(), lastHashBin.cend(), stage3.blockHash.begin());
    stage3.blockSignature = cscrypto::generateSignature(private_key, stage3.blockHash.data(), stage3.blockHash.size());

    pnode->prepareRoundTable(table, poolMetaInfo, stage3);
    csmeta(csdetails) << "end";
}

void SolverCore::sendRoundTable() {
    pnode->sendRoundTable();
}

bool SolverCore::addSignaturesToDeferredBlock(cs::Signatures&& blockSignatures) {
    csmeta(csdetails) << "begin";
    if (!deferredBlock_.is_valid()) {
        csmeta(cserror) << " ... Failed!!!";
        return false;
    }

    for (auto& it : blockSignatures) {
        csdetails() << log_prefix << cs::Utils::byteStreamToHex(it.data(), it.size());
    }
    deferredBlock_.set_signatures(blockSignatures);

    auto resPool = pnode->getBlockChain().createBlock(deferredBlock_);

    if (!resPool.has_value()) {
        cserror() << log_prefix << "Blockchain failed to write new block";
        return false;
    }
    //pnode->cleanConfirmationList(deferredBlock_.sequence());
    deferredBlock_ = csdb::Pool();

    csmeta(csdetails) << "end";
    return true;
}

void SolverCore::removeDeferredBlock(cs::Sequence seq) {
    if (deferredBlock_.sequence() == seq) {
        pnode->getBlockChain().removeWalletsInPoolFromCache(deferredBlock_);
        deferredBlock_ = csdb::Pool();
        csdebug() << log_prefix << "just created new block was thrown away";
    }
    else {
        csdebug() << log_prefix << "we don't have the correct block to throw";
    }
}

uint8_t SolverCore::subRound() {
    return (pnode->subRound());
}

}  // namespace cs
```
# ..\node\solver\src\solverinterface.cpp 
```cpp 
#include <consensus.hpp>
#include <smartcontracts.hpp>
#include <solvercontext.hpp>
#include <solvercore.hpp>

#include <csnode/conveyer.hpp>
#include <csnode/fee.hpp>
#include <csnode/node.hpp>

#include <csdb/currency.hpp>
#include <lib/system/logger.hpp>

#include <chrono>

namespace cs {
void SolverCore::setKeysPair(const cs::PublicKey& pub, const cs::PrivateKey& priv) {
    public_key = pub;
    private_key = priv;

    auto pconnector = pnode->getConnector();

    if (pconnector != nullptr) {
        psmarts->init(pub, pnode);
    }
    else {
        psmarts->init(pub, nullptr);
    }
}

void SolverCore::gotConveyerSync(cs::RoundNumber rNum) {
    // clear data
    markUntrusted.fill(0);

    if (!pstate) {
        return;
    }

    if (stateCompleted(pstate->onSyncTransactions(*pcontext, rNum))) {
        handleTransitions(Event::Transactions);
    }

    // restore possibly cached hashes from other nodes
    // this is actual if conveyer has just stored last required block
    if (!recv_hash.empty() && cs::Conveyer::instance().currentRoundNumber() == rNum) {
        for (const auto& item : recv_hash) {
            if (stateCompleted(pstate->onHash(*pcontext, item.first, item.second))) {
                handleTransitions(Event::Hashes);
            }
        }
    }
}

const cs::PublicKey& SolverCore::getWriterPublicKey() const {
    // Previous solver returns confidant key with index equal result of takeDecision() method.
    // As analogue, found writer's index in stage3 if exists, otherwise return empty object as prev. solver does
    auto ptr = find_stage3(pnode->getConfidantNumber());
    if (ptr != nullptr) {
        const auto& trusted = cs::Conveyer::instance().confidants();
        if (trusted.size() >= ptr->writer) {
            return *(trusted.cbegin() + ptr->writer);
        }
    }
    return Zero::key;
}

bool SolverCore::checkNodeCache(const cs::PublicKey& sender) {
    if (cs::Conveyer::instance().currentRoundNumber() < Consensus::StartingDPOS) {
        csdebug() << "The DPOS doesn't work unless the roundNumber is less than " << Consensus::StartingDPOS;
        return true;
    }
    BlockChain::WalletData wData;
    BlockChain::WalletId wId;
    pnode->getBlockChain().findWalletData(csdb::Address::from_public_key(sender), wData, wId);
    if (wData.balance_ < Consensus::MinStakeValue) {
        return false;
    }
    return true;
}

void SolverCore::addToGraylist(const cs::PublicKey & sender, uint32_t rounds) {
    if (grayList_.find(sender) == grayList_.cend()) {
        grayList_.emplace(sender, rounds);
        csdebug() << "Node " << cs::Utils::byteStreamToHex(sender.data(), sender.size()) << " is in gray list now";
    }
    else {
        grayList_[sender] += uint16_t(rounds * 2);
        csdebug() << "Node " << cs::Utils::byteStreamToHex(sender.data(), sender.size()) << " will continue its being in gray list now";
    }
}

void SolverCore::gotHash(csdb::PoolHash&& hash, const cs::PublicKey& sender) {
    // GrayList check
    if (grayList_.count(sender) > 0) {
        csdebug() << "The sender " << cs::Utils::byteStreamToHex(sender.data(), sender.size()) << " is in gray list";
        return;
    }

    // DPOS check start -> comment if unnecessary
    if (!checkNodeCache(sender)) {
        csdebug() << "The sender's cash value is too low -> Don't allowed to be a confidant";
        return;
    }
    // DPOS check finish
    cs::Sequence delta = cs::Conveyer::instance().currentRoundNumber() - pnode->getBlockChain().getLastSequence();
    if (delta > 1) {
        recv_hash.push_back(std::make_pair<>(hash, sender));
        csdebug() << "SolverCore: cache hash until last block ready";
        return;
    }

    if (!pstate) {
        return;
    }

    if (stateCompleted(pstate->onHash(*pcontext, hash, sender))) {
        handleTransitions(Event::Hashes);
    }
}

void SolverCore::beforeNextRound() {
    if (!pstate) {
        return;
    }
    pstate->onRoundEnd(*pcontext, false /*is_bigbang*/);
}

void SolverCore::nextRound() {
    // as store result of current round:
    if (Consensus::Log) {
        csdebug() << "SolverCore: clear all stored round data (block hashes, stages-1..3)";
    }

    recv_hash.clear();
    stageOneStorage.clear();
    stageTwoStorage.clear();
    stageThreeStorage.clear();
    trueStageThreeStorage.clear();
    trusted_candidates.clear();
    realTrustedChanged_ = false;
    tempRealTrusted_.clear();
    currentStage3iteration_ = 0;
    updateGrayList(cs::Conveyer::instance().currentRoundNumber());

    if (!pstate) {
        return;
    }

    if (stateCompleted(pstate->onRoundTable(*pcontext, cs::Conveyer::instance().currentRoundNumber()))) {
        handleTransitions(Event::RoundTable);
    }
}

void SolverCore::gotStageOne(const cs::StageOne& stage) {
    if (find_stage1(stage.sender) != nullptr) {
        // duplicated
        return;
    }
    stageOneStorage.push_back(stage);
    csdebug() << "SolverCore: <-- stage-1 [" << static_cast<int>(stage.sender) << "] = " << stageOneStorage.size();

    if (!pstate) {
        return;
    }
    if (stateCompleted(pstate->onStage1(*pcontext, stage))) {
        handleTransitions(Event::Stage1Enough);
    }
}

void SolverCore::gotStageOneRequest(uint8_t requester, uint8_t required) {
    csdebug() << "SolverCore: [" << static_cast<int>(requester) << "] asks for stage-1 of [" << static_cast<int>(required) << "]";

    const auto ptr = find_stage1(required);
    if (ptr != nullptr) {
        pnode->sendStageReply(ptr->sender, ptr->signature, MsgTypes::FirstStage, requester, ptr->message);
    }
}

void SolverCore::gotStageTwoRequest(uint8_t requester, uint8_t required) {
    csdebug() << "SolverCore: [" << static_cast<int>(requester) << "] asks for stage-2 of [" << static_cast<int>(required) << "]";

    const auto ptr = find_stage2(required);
    if (ptr != nullptr) {
        pnode->sendStageReply(ptr->sender, ptr->signature, MsgTypes::SecondStage, requester, ptr->message);
    }
}

uint8_t SolverCore::currentStage3iteration() {
    return currentStage3iteration_;
}

void SolverCore::gotStageThreeRequest(uint8_t requester, uint8_t required /*, uint8_t iteration*/) {
    csdebug() << "SolverCore: [" << static_cast<int>(requester) << "] asks for stage-3 of [" << static_cast<int>(required) << "]";  // - i" << static_cast<int>(iteration);

    // const auto ptr = find_stage3(required);

    for (auto& it : stageThreeStorage) {
        if (it.iteration == currentStage3iteration_ && it.sender == requester) {
            pnode->sendStageReply(it.sender, it.signature, MsgTypes::ThirdStage, requester, it.message);
            return;
        }
    }
    csdebug() << "SolverCore: don't have the requested stage three";
}

void SolverCore::gotStageTwo(const cs::StageTwo& stage) {
    if (find_stage2(stage.sender) != nullptr) {
        // duplicated
        return;
    }

    stageTwoStorage.push_back(stage);
    csdebug() << "SolverCore: <-- stage-2 [" << static_cast<int>(stage.sender) << "] = " << stageTwoStorage.size();

    if (!pstate) {
        return;
    }

    if (stateCompleted(pstate->onStage2(*pcontext, stage))) {
        handleTransitions(Event::Stage2Enough);
    }
}

void SolverCore::printStage3(const cs::StageThree& stage) {
    std::string realTrustedString;

    for (auto& i : stage.realTrustedMask) {
        realTrustedString = realTrustedString + "[" + std::to_string(int(i)) + "] ";
    }

    csdebug() << "     SENDER = " << static_cast<int>(stage.sender) << ", WRITER = " << static_cast<int>(stage.writer) << ", RealTrusted = " << realTrustedString;
    csdebug() << "     BlockHash = " << cs::Utils::byteStreamToHex(stage.blockHash);
    csdebug() << "     BlockSign = " << cs::Utils::byteStreamToHex(stage.blockSignature);
    csdebug() << "     RoundHash = " << cs::Utils::byteStreamToHex(stage.roundHash);
    csdebug() << "     RoundSign = " << cs::Utils::byteStreamToHex(stage.roundSignature);
    csdebug() << "     TrustHash = " << cs::Utils::byteStreamToHex(stage.trustedHash);
    csdebug() << "     TrustSign = " << cs::Utils::byteStreamToHex(stage.trustedSignature);
}

void SolverCore::gotStageThree(const cs::StageThree& stage, const uint8_t flagg) {
    if (stage.iteration < currentStage3iteration_) {
        // stage with old iteration
        return;
    }
    auto ptr = find_stage3(stage.sender, stage.iteration);
    if (ptr != nullptr) {
        return;
    }

    auto lamda = [this](const cs::StageThree& stageFrom, const cs::StageThree& stageTo) {
        const cs::Conveyer& conveyer = cs::Conveyer::instance();
        bool somethingInvalid = false;
        if (stageTo.realTrustedMask[stageFrom.sender] == cs::ConfidantConsts::InvalidConfidantIndex) {
            cswarning() << "The node, who sent this stage was marked as untrusted";
            somethingInvalid = true;
        }

        if (!cscrypto::verifySignature(stageFrom.blockSignature, conveyer.confidantByIndex(stageFrom.sender), stageTo.blockHash.data(), stageTo.blockHash.size())) {
            cswarning() << "Block Signatures are not valid ! -> ";
            somethingInvalid = true;
        }

        if (!cscrypto::verifySignature(stageFrom.roundSignature, conveyer.confidantByIndex(stageFrom.sender), stageTo.roundHash.data(), stageTo.roundHash.size())) {
            cswarning() << "Round Signatures are not valid !";
            somethingInvalid = true;
        }

        if (!cscrypto::verifySignature(stageFrom.trustedSignature, conveyer.confidantByIndex(stageFrom.sender), stageTo.trustedHash.data(), stageTo.trustedHash.size())) {
            cswarning() << "Trusted Signatures are not valid !";
            somethingInvalid = true;
        }

        if (!(stageFrom.realTrustedMask == stageTo.realTrustedMask) || stageTo.realTrustedMask[stageFrom.sender] == cs::ConfidantConsts::InvalidConfidantIndex) {
            cswarning() << "Real Trusted are not valid !";
            somethingInvalid = true;
        }

        if (!(stageFrom.writer == stageTo.writer)) {
            cswarning() << "Writer is not valid !";
            somethingInvalid = true;
        }

        if (somethingInvalid) {
            if (stageTo.realTrustedMask[stageFrom.sender] != cs::ConfidantConsts::InvalidConfidantIndex) {
                printStage3(stageFrom);
                realTrustedSetValue(stageFrom.sender, cs::ConfidantConsts::InvalidConfidantIndex);
            }
            return;
        }

        // if (getRealTrusted()[stageFrom.sender] == cs::ConfidantConsts::InvalidConfidantIndex) {
        //  realTrustedSet(stageFrom.sender, cs::ConfidantConsts::FirstWriterIndex);
        //}
        trueStageThreeStorage.emplace_back(stageFrom);
        pnode->addRoundSignature(stageFrom);
        csdebug() << "Stage3 [" << static_cast<int>(stageFrom.sender) << "] - signatures are OK";
    };

    switch (flagg) {
        case 0:
            break;

        case 1:
            // TODO: change the routine of pool signing
            for (const auto& st : stageThreeStorage) {
                if (st.iteration == currentStage3iteration_) {
                    lamda(st, stage);
                }
            }
            trueStageThreeStorage.push_back(stage);
            pnode->addRoundSignature(stage);
            break;

        case 2:
            const auto st = find_stage3(pnode->getConfidantNumber());
            if (st != nullptr && stage.iteration == st->iteration) {
                lamda(stage, *st);
            }
            break;
    }

    stageThreeStorage.push_back(stage);

    csdebug() << "SolverCore: <-- stage-3 [" << static_cast<int>(stage.sender) << "] = " << stageThreeStorage.size() << " : " << trueStageThreeStorage.size();

    if (!pstate) {
        return;
    }

    switch (pstate->onStage3(*pcontext, stage)) {
        case Result::Finish:
            handleTransitions(Event::Stage3Enough);
            break;
        case Result::Retry:
            ++currentStage3iteration_;
            adjustStageThreeStorage();
            handleTransitions(Event::Stage3NonComplete);
            break;
        case Result::Failure:
            cserror() << "SolverCore: error in state " << (pstate ? pstate->name() : "null");
            removeDeferredBlock(deferredBlock_.sequence());
            handleTransitions(Event::SetNormal);
            break;
        default:
            break;
    }
}

void SolverCore::adjustStageThreeStorage() {
    std::vector<cs::StageThree> tmpStageThreeStorage;
    for (auto& it : stageThreeStorage) {
        if (it.iteration == currentStage3iteration_) {
            tmpStageThreeStorage.push_back(it);
        }
    }
    stageThreeStorage.clear();
    stageThreeStorage = tmpStageThreeStorage;
    trueStageThreeStorage.clear();  // how to put the realTrusted value to the on-stage3
    pnode->adjustStageThreeStorage();
}

size_t SolverCore::trueStagesThree() {
    return trueStageThreeStorage.size();
}

bool SolverCore::realTrustedChanged() const {
    return realTrustedChanged_;
}

void SolverCore::realTrustedChangedSet(bool val) {
    realTrustedChanged_ = val;
}

void SolverCore::realTrustedSetValue(cs::Byte position, cs::Byte value) {
    csdebug() << __func__ << ": realtrusted in solvercore set, realTrustedChanged switched to true";
    realTrustedChangedSet(true);
    size_t pos = static_cast<size_t>(position);
    if (tempRealTrusted_.size() > pos) {
        tempRealTrusted_[pos] = value;
    }
}

void SolverCore::realTrustedSet(cs::Bytes realTrusted) {
    tempRealTrusted_ = realTrusted;
}

void SolverCore::updateGrayList(cs::RoundNumber round) {
    csdebug() << __func__;
    if (lastGrayUpdated_ >= round) {
        csdebug() << "Gray list will update only if the round number changes";
        return;
    }
    const uint16_t delta = uint16_t(round - lastGrayUpdated_);
    lastGrayUpdated_ = round;

    auto it = grayList_.begin();
    while (it != grayList_.end()) {
        if (it->second <= delta) {
            csdebug() << "Node with PK " << cs::Utils::byteStreamToHex(it->first.data(), it->first.size()) << " freed from grayList trap";
            it = grayList_.erase(it);
        }
        else {
            it->second -= delta;
            ++it;
        }
    }

}

cs::Bytes SolverCore::getRealTrusted() {
    return tempRealTrusted_;
}

size_t SolverCore::stagesThree() {
    return stageThreeStorage.size();
}

void SolverCore::send_wallet_transaction(const csdb::Transaction& tr) {
    if (psmarts->capture_transaction(tr)) {
        // avoid pass to conveyer, psmarts provide special handling
        return;
    }
    cs::Conveyer::instance().addTransaction(tr);
}

void SolverCore::gotRoundInfoRequest(const cs::PublicKey& requester, cs::RoundNumber requester_round) {
    csdebug() << "SolverCore: got round info request from " << cs::Utils::byteStreamToHex(requester.data(), requester.size());
    auto& conveyer = cs::Conveyer::instance();

    if (requester_round == conveyer.currentRoundNumber()) {
        const auto ptr = /*cur_round == 10 ? nullptr :*/ find_stage3(pnode->getConfidantNumber());
        if (ptr != nullptr) {
            if (ptr->sender == ptr->writer) {
                if (pnode->tryResendRoundTable(requester, conveyer.currentRoundNumber())) {
                    csdebug() << "SolverCore: re-send full round info #" << conveyer.currentRoundNumber() << " completed";
                    return;
                }
            }
        }
        csdebug() << "SolverCore: also on the same round, inform cannot help with";
        pnode->sendRoundTableReply(requester, false);
    }
    else if (requester_round < conveyer.currentRoundNumber()) {
        if (conveyer.isConfidantExists(requester)) {
            if (pnode->tryResendRoundTable(requester, conveyer.currentRoundNumber())) {
                csdebug() << "SolverCore: requester is trusted next round, supply it with round info";
            }
            else {
                csdebug() << "SolverCore: try but cannot send full round info";
            }
            return;
        }
        csdebug() << "SolverCore: inform requester next round has come and it is not in trusted list";
        pnode->sendRoundTableReply(requester, true);
    }
    else {
        // requester_round > cur_round, cannot help with!
        csdebug() << "SolverCore: cannot help with outrunning round info";
    }
}

void SolverCore::gotRoundInfoReply(bool next_round_started, const cs::PublicKey& /*respondent*/) {
    if (next_round_started) {
        csdebug() << "SolverCore: round info reply means next round started, and I am not trusted node. Waiting next round";
        return;
    }
    csdebug() << "SolverCore: round info reply means next round is not started, become writer";
    handleTransitions(SolverCore::Event::SetWriter);
}

bool SolverCore::isContractLocked(const csdb::Address& address) const {
    return psmarts->is_contract_locked(address);
}

}  // namespace cs
```
# ..\node\solver\src\solvertransitions.cpp 
```cpp 
#include <solvercore.hpp>
#include <states/handlebbstate.hpp>
#include <states/handlertstate.hpp>
#include <states/nostate.hpp>
#include <states/normalstate.hpp>
#include <states/primitivewritestate.hpp>
#include <states/syncstate.hpp>
#include <states/trustedpoststagestate.hpp>
#include <states/trustedstage1state.hpp>
#include <states/trustedstage2state.hpp>
#include <states/trustedstage3state.hpp>
#include <states/waitingstate.hpp>
#include <states/writingstate.hpp>

namespace cs
{

  void SolverCore::InitTransitions()
  {
    opt_mode = Mode::Default;

    StatePtr pNormal = std::make_shared<NormalState>();
    StatePtr pSync = std::make_shared<SyncState>();
    StatePtr pTrusted1 = std::make_shared<TrustedStage1State>();
    StatePtr pTrusted2 = std::make_shared<TrustedStage2State>();
    StatePtr pTrusted3 = std::make_shared<TrustedStage3State>();
    StatePtr pTrustedPost = std::make_shared<TrustedPostStageState>();
    StatePtr pRTH = std::make_shared<HandleRTState>();
    StatePtr pBB = std::make_shared<HandleBBState>();
    StatePtr pNone = std::make_shared<NoState>();
    StatePtr pWriting = std::make_shared<WritingState>();
    StatePtr pWaiting = std::make_shared<WaitingState>();

    StatePtr pWrite = std::make_shared<PrimitiveWriteState>();
    // start with that:
    pstate = pNone;

    std::pair<Event, StatePtr> defaultRT { Event::RoundTable, pRTH };
    std::pair<Event, StatePtr> defaultBB { Event::BigBang, pBB };

    transitions = {

      // transition NoState -> Start on the first round
      {pNone, {{Event::Start, pNormal}, {Event::SetTrusted, pWrite}, defaultRT}},

      // Normal state (normal node)
      {pNormal, {defaultRT, defaultBB}},

      // Sync state, not useful for now due to Node implements sync process
      {pSync, {defaultRT, defaultBB}},

      // Trusted stage 1: preparing characteristic function and gaethering hashes form all nodes -> sending message of
      // Stage1 to all trusted
      {pTrusted1, {defaultRT, defaultBB, {Event::Transactions, pTrusted2}, {Event::Hashes, pTrusted2}}},

      // Trusted state 2 after enough Stage1 messages are received (confidant node)
      {pTrusted2, {defaultRT, defaultBB, {Event::Stage1Enough, pTrusted3}}},

      // Trusted state 3 after enough Stage2 messages are received (confidant node)
      {pTrusted3, {defaultRT, defaultBB, {Event::Stage2Enough, pTrustedPost}, {Event::FailConsensus, pNormal}}},

      // Trusted PostStageState after enough Stage3 (confirmation)are received (confidant node)
      {pTrustedPost, {defaultRT, defaultBB, {Event::Stage3Enough, pWaiting}, {Event::SetNormal, pNormal}, {Event::Stage3NonComplete, pTrusted3}}},

      // Trusted pre-Writing (confidant node)
      {pWaiting, {defaultRT, defaultBB, {Event::SetWriter, pWriting}}},

      // round table handler
      {pRTH, {{Event::SetNormal, pNormal}, {Event::SetTrusted, pTrusted1}}},

      // BigBang handler, not useful for now due to Node implements BigBang handling
      {pBB, { defaultRT}},

      // post-writing transition upon RoundTable && BigBang
      {pWriting, {defaultRT, defaultBB}}
    };
  }

  void SolverCore::InitDebugModeTransitions()
  {
    opt_mode = Mode::Debug;

    StatePtr pNormal = std::make_shared<NormalState>();
    StatePtr pWrite = std::make_shared<PrimitiveWriteState>();
    StatePtr pNone = std::make_shared<NoState>();
    // start with that:
    pstate = pNone;

    transitions = {

      // transition on the first round
      {pNone, {{Event::SetTrusted, pWrite}, {Event::SetNormal, pNormal}}},

      // transition Normal -> Write every round
      {pNormal, {{Event::RoundTable, pWrite}}},

      // transition Write -> Normal every round
      {pWrite, {{Event::RoundTable, pNormal}}},

    };
  }

  void SolverCore::InitMonitorModeTransitions()
  {
    opt_mode = Mode::Monitor;

    StatePtr pNormal = std::make_shared<NormalState>();
    StatePtr pNone = std::make_shared<NoState>();
    // start with that:
    pstate = pNone;

    transitions = {
      // transition on the first round
      {pNone, {{Event::Start, pNormal}}},
      {pNormal, {{Event::Expired, pNormal}}}
    };
  }

  void SolverCore::InitWebWalletModeTransitions()
  {
    opt_mode = Mode::WebWallet;

    StatePtr pNormal = std::make_shared<NormalState>();
    StatePtr pNone = std::make_shared<NoState>();
    // start with that:
    pstate = pNone;

    transitions = {
      // transition on the first round
      {pNone, {{Event::Start, pNormal}}},
      {pNormal, {{Event::Expired, pNormal}}}
    };
  }
} // namespace slv2
```
# ..\node\solver\src\stage.cpp 
```cpp 
#include <stage.hpp>
#include <csdb/amount.hpp>
#include <csdb/currency.hpp>
#include <csnode/datastream.hpp>

#include <cscrypto/cscrypto.hpp>
namespace cs {
 
    bool StageOneSmarts::fillBinary()
    {
        if (message.size() > 0) {
            message.clear();
        }

        messageHash.fill(0);
        if (sender == cs::ConfidantConsts::InvalidConfidantIndex) {
            return false;
        }
        if (id == 0) {
            return false;
        }
        if (fees.size() == 0) {
            return false;
        }
        std::string a = " ";//fees
        DataStream stream(message);
        stream << sender;
        stream << id;
        //bad implementation
        stream << fees.size(); //fees
        for (size_t i = 0; i < fees.size(); ++i) {
            stream << fees[i].integral() << fees[i].fraction();
        }
        stream << hash;

        cs::Bytes messageToSign;
        messageToSign.reserve(sizeof(cs::Hash));
        // hash of message
        messageHash = cscrypto::calculateHash(message.data(), message.size());
        return true;
    }

    bool StageOneSmarts::fillFromBinary()
    {
        std::string a; //fees
        DataStream stream(message.data(), message.size());
        stream >> sender;
        stream >> id;
        //bad implementation
        size_t fees_size;
        stream >> fees_size; //fees
        int32_t fee_integral;
        uint64_t fee_fracture;
        for (size_t i = 0; i < fees_size; ++i) {
            fee_integral = 0;
            fee_fracture = 0;
            stream >> fee_integral >> fee_fracture;
            csdb::Amount fee{ fee_integral, fee_fracture, csdb::Amount::AMOUNT_MAX_FRACTION };
            fees.push_back(fee);
        }
        stream >> hash;
        return false;
    }

    Bytes StageTwoSmarts::toBinary()
    {
        return Bytes();
    }

    bool StageTwoSmarts::fromBinary(Bytes /*msg*/, StageTwoSmarts & /*stage*/)
    {
        return false;
    }

    Bytes StageThreeSmarts::toBinary()
    {
        return Bytes();
    }

    bool StageThreeSmarts::fromBinary(Bytes /*msg*/, StageThreeSmarts & /*stage*/)
    {
        return false;
    }
}```
# ..\node\solver\src\timeouttracking.cpp 
```cpp 
#include <timeouttracking.hpp>

namespace cs {

void TimeoutTracking::start(CallsQueueScheduler& scheduler, uint32_t wait_for_ms, const CallsQueueScheduler::ProcType& proc, bool replace_existing,
                            CallsQueueScheduler::CallTag tag) {
    pscheduler = &scheduler;
    call_tag = pscheduler->InsertOnce(wait_for_ms,
                                      [this, proc]() {
                                          // extra test whether to execute proc():
                                          if (call_tag != CallsQueueScheduler::no_tag) {
                                              call_tag = CallsQueueScheduler::no_tag;
                                              proc();
                                          }
                                      },
                                      replace_existing, tag);
}

bool TimeoutTracking::cancel() {
    if (call_tag != CallsQueueScheduler::no_tag) {
        pscheduler->Remove(call_tag);
        call_tag = CallsQueueScheduler::no_tag;
        return true;
    }
    return false;
}

}  // namespace cs
```
# ..\node\solver\src\states\defaultstatebehavior.cpp 
```cpp 
#include <consensus.hpp>
#include <solvercontext.hpp>
#include <states/defaultstatebehavior.hpp>

#pragma warning(push)
//#pragma warning(disable: 4267 4244 4100 4245)
#include <csnode/blockchain.hpp>
#pragma warning(pop)

#include <csdb/pool.hpp>
#include <lib/system/hash.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>

#include <algorithm>

// provide find by sequence() capability
namespace std {
bool operator==(const std::pair<csdb::Pool, cs::PublicKey>& lhs, uint64_t rhs) {
    return lhs.first.sequence() == rhs;
}
}  // namespace std

namespace cs {

void DefaultStateBehavior::onRoundEnd(SolverContext& /*context*/, bool /*is_bigbang*/) {
}

Result DefaultStateBehavior::onRoundTable(SolverContext& /*context*/, const cs::RoundNumber round) {
    csdebug() << name() << ": <-- round table #" << round;
    return Result::Finish;
}

Result DefaultStateBehavior::onBlock(SolverContext& /*context*/, csdb::Pool& /*block*/, const cs::PublicKey& /*sender*/) {
    cswarning() << name() << ": currently block should not handle by state";
    return Result::Ignore;
}

Result DefaultStateBehavior::onHash(SolverContext& /*context*/, const csdb::PoolHash& /*pool_hash*/, const cs::PublicKey& /*sender*/) {
    csdebug() << name() << ": block hash ignored in this state";
    return Result::Ignore;
}

Result DefaultStateBehavior::onTransaction(SolverContext& /*context*/, const csdb::Transaction& /*trans*/) {
    csdebug() << name() << ": nothing to do with transaction in this state";
    return Result::Ignore;
}

Result DefaultStateBehavior::onSyncTransactions(SolverContext& /*context*/, cs::RoundNumber /*round*/) {
    csdebug() << name() << ": nothing to do with transactions packet in this state";
    return Result::Ignore;
}

Result DefaultStateBehavior::onStage1(SolverContext& /*context*/, const cs::StageOne& /*stage*/) {
    csdebug() << name() << ": stage-1 ignored in this state";
    return Result::Ignore;
}

Result DefaultStateBehavior::onStage2(SolverContext& /*context*/, const cs::StageTwo& /*stage*/) {
    csdebug() << name() << ": stage-2 ignored in this state";
    return Result::Ignore;
}

Result DefaultStateBehavior::onStage3(SolverContext& /*context*/, const cs::StageThree& /*stage*/) {
    csdebug() << name() << ": stage-3 ignored in this state";
    return Result::Ignore;
}

}  // namespace cs
```
# ..\node\solver\src\states\handlebbstate.cpp 
```cpp 
#include <lib/system/logger.hpp>
#include <solvercontext.hpp>
#include <states/handlebbstate.hpp>

namespace cs {

void HandleBBState::on(SolverContext& context) {
    cswarning() << name() << ": BigBang processing is implemented in Node class";
    DefaultStateBehavior::on(context);
}

}  // namespace cs
```
# ..\node\solver\src\states\handlertstate.cpp 
```cpp 
#include <consensus.hpp>
#include <lib/system/logger.hpp>
#include <solvercontext.hpp>
#include <states/handlertstate.hpp>

namespace cs {
void HandleRTState::on(SolverContext& context) {
    auto role = context.role();
    switch (role) {
        case Role::Trusted:
            context.request_role(Role::Trusted);
            break;
        case Role::Normal:
            context.request_role(Role::Normal);
            break;
        default:
            cserror() << name() << ": unknown role requested";
            break;
    }
}

}  // namespace cs
```
# ..\node\solver\src\states\normalstate.cpp 
```cpp 
#include <consensus.hpp>
#include <solvercontext.hpp>
#include <states/normalstate.hpp>

#pragma warning(push)
//#pragma warning(disable: 4267 4244 4100 4245)
#include <csnode/blockchain.hpp>
#pragma warning(pop)

#include <csdb/address.hpp>
#include <csdb/amount.hpp>
#include <csdb/amount_commission.hpp>
#include <csdb/currency.hpp>
#include <lib/system/logger.hpp>

namespace cs {

void NormalState::on(SolverContext& context) {
    DefaultStateBehavior::on(context);
}

}  // namespace cs
```
# ..\node\solver\src\states\primitivewritestate.cpp 
```cpp 
#include <consensus.hpp>
#include <csnode/conveyer.hpp>
#include <lib/system/logger.hpp>
#include <solvercontext.hpp>
#include <states/primitivewritestate.hpp>

namespace cs {
void PrimitiveWriteState::on(SolverContext& context) {
    DefaultStateBehavior::on(context);

    SolverContext* pctx = &context;

    if (cs::Conveyer::instance().currentRoundNumber() == 0) {
        csdebug() << name() << ": start track timeout " << Consensus::T_round << " ms to spawn first round";
        context.scheduler().InsertOnce(Consensus::T_round,
                                       [pctx, this]() {
                                           csdebug() << name() << ": it is time to spawn first round";
                                           trusted_candidates.assign(Consensus::MinTrustedNodes, pctx->public_key());
                                           pctx->next_trusted_candidates(trusted_candidates);
                                           trusted_candidates.clear();
                                           pctx->spawn_first_round();
                                       },
                                       true);
        return;
    }

    csdebug() << name() << ": start track timeout " << Consensus::DefaultStateTimeout << " ms to complete round";
    tag_timeout = context.scheduler().InsertPeriodic(Consensus::DefaultStateTimeout, [pctx, this]() {
        csdebug() << name() << ": round duration is expired";
        // "complete" trusted candidates with own key
        if (Consensus::MinTrustedNodes > trusted_candidates.size()) {
            size_t cnt = Consensus::MinTrustedNodes - trusted_candidates.size();
            for (size_t i = 0; i < cnt; i++) {
                trusted_candidates.emplace_back(pctx->public_key());
            }
        }
        pctx->next_trusted_candidates(trusted_candidates);
        trusted_candidates.clear();

        cs::StageThree stageThree;
        pctx->spawn_next_round(stageThree);
    });
}

void PrimitiveWriteState::off(SolverContext& context) {
    if (tag_timeout != CallsQueueScheduler::no_tag) {
        context.scheduler().Remove(tag_timeout);
        tag_timeout = CallsQueueScheduler::no_tag;
    }
    DefaultStateBehavior::off(context);
}

Result PrimitiveWriteState::onHash(SolverContext& /*context*/, const csdb::PoolHash& /*pool_hash*/, const cs::PublicKey& sender) {
    // form "trusted candidates"
    trusted_candidates.emplace_back(sender);
    return Result::Ignore;
}

Result PrimitiveWriteState::onSyncTransactions(SolverContext& context, cs::RoundNumber round) {
    DefaultStateBehavior::onSyncTransactions(context, round);
    return Result::Ignore;
}
}  // namespace cs
```
# ..\node\solver\src\states\syncstate.cpp 
```cpp 
#include <solvercontext.hpp>
#include <states/syncstate.hpp>

namespace cs {

void SyncState::on(SolverContext& context) {
    DefaultStateBehavior::on(context);
}

}  // namespace cs
```
# ..\node\solver\src\states\trustedpoststagestate.cpp 
```cpp 
#include <csnode/conveyer.hpp>
#include <lib/system/logger.hpp>
#include <solvercontext.hpp>
#include <states/trustedpoststagestate.hpp>

namespace
{
    constexpr uint64_t TIMER_BASE_ID = 40;
}

namespace cs {

void TrustedPostStageState::on(SolverContext& context) {
    DefaultStateBehavior::on(context);

    cnt_recv_stages = 0;
    //// decide to write
    // const auto ptr = context.stage3(context.own_conf_number());
    // if(ptr != nullptr) {
    //    if(ptr->sender == ptr->writer) {
    //        context.request_role(Role::Writer);
    //        return;
    //    }
    //}

    // process already received stage-3, possible to go further to waiting/writting state
    if (!context.stage3_data().empty()) {
        csdebug() << name() << ": handle early received stages-3";
        bool finish = false;
        for (const auto& st : context.stage3_data()) {
            if (Result::Finish == onStage3(context, st)) {
                finish = true;
            }
        }
        if (finish) {
            context.complete_post_stage();
            return;
        }
    }

    SolverContext* pctx = &context;
    csdebug() << name() << ": start track timeout " << 0 << " ms of stages-3 received";
    timeout_request_stage.start(context.scheduler(), 0,
                                // timeout #1 handler:
                                [pctx, this]() {
                                    csdebug() << name() << ": direct request for absent stages-3";
                                    request_stages(*pctx);
                                    // start subsequent track timeout for "wide" request
                                    csdebug() << name() << ": start subsequent track timeout " << Consensus::T_stage_request << " ms to request neighbors about stages-3";
                                    timeout_request_neighbors.start(
                                        pctx->scheduler(), Consensus::T_stage_request,
                                        // timeout #2 handler:
                                        [pctx, this]() {
                                            csdebug() << name() << ": timeout for transition is expired, make requests to neighbors";
                                            request_stages_neighbors(*pctx);
                                            // timeout #3 handler
                                            csdebug() << name() << ": start subsequent track timeout " << Consensus::T_stage_request << " ms to give up in receiving stages-3";
                                            timeout_force_transition.start(
                                                pctx->scheduler(), Consensus::T_stage_request,
                                                [pctx, this]() {
                                                    csdebug() << name() << ": timeout for transition is expired, mark silent nodes as outbound and recalculate the signatures";
                                                    mark_outbound_nodes(*pctx);
                                                },
                                                true /*replace if exists*/, TIMER_BASE_ID + 3);
                                        },
                                        true /*replace if exists*/, TIMER_BASE_ID + 2);
                                },
                                true /*replace if exists*/, TIMER_BASE_ID + 1);
}

void TrustedPostStageState::off(SolverContext& /*context*/) {
    csdebug() << name() << ": finishing 3rd stage";
    if (timeout_request_stage.cancel()) {
        csdebug() << name() << ": cancel track timeout of stages-3";
    }
    if (timeout_request_neighbors.cancel()) {
        csdebug() << name() << ": cancel track timeout to request neighbors about stages-3";
    }
    if (timeout_force_transition.cancel()) {
        csdebug() << name() << ": cancel track timeout to force transition to next state";
    }
}

// requests stages from corresponded nodes
void TrustedPostStageState::request_stages(SolverContext& context) {
    uint8_t cnt = (uint8_t)context.cnt_trusted();
    auto& realTrusted = context.stage3(context.own_conf_number())->realTrustedMask;
    if (realTrusted.size() != cnt) {
        csmeta(cserror) << ": The size of real Trusted doesn't match the size of Confidants!";
        return;
    }
    for (uint8_t i = 0; i < cnt; ++i) {
        if (context.stage3(i) == nullptr && realTrusted.at(i) != cs::ConfidantConsts::InvalidConfidantIndex) {
            context.request_stage3(i, i);
        }
    }
}

// requests stages from any available neighbor nodes
void TrustedPostStageState::request_stages_neighbors(SolverContext& context) {
    const auto& stage3_data = context.stage3_data();
    uint8_t cnt = (uint8_t)context.cnt_trusted();
    for (uint8_t i = 0; i < cnt; ++i) {
        if (context.stage3(i) == nullptr) {
            for (const auto& d : stage3_data) {
                if (d.sender != context.own_conf_number()) {
                    context.request_stage3(d.sender, i);
                }
            }
        }
    }
}

void TrustedPostStageState::mark_outbound_nodes(SolverContext& context) {
    cs::RoundNumber rNum = cs::Conveyer::instance().currentRoundNumber();
    csdebug() << name() << ": mark outbound nodes in round #" << rNum;
    auto cnt = static_cast<uint8_t>(context.cnt_trusted());
    cs::Bytes realTrusted = context.stage3(context.own_conf_number())->realTrustedMask;

    if (realTrusted.size() == cnt) {
        for (uint8_t i = 0; i < cnt; ++i) {
            if (context.stage3(i) == nullptr) {
                // it is possible to get a transition to other state in SolverCore from any iteration, this is not a problem, simply execute method until end
                csdebug() << name() << ": making fake stage-3 [" << static_cast<int>(i) << "] in round " << rNum;
                realTrusted[i] = cs::ConfidantConsts::InvalidConfidantIndex;
                context.realTrustedSetValue(i, cs::ConfidantConsts::InvalidConfidantIndex);
                // this procedute can cause the round change
            }
        }

        for (uint8_t i = 0; i < cnt; ++i) {
            if (realTrusted[i] == cs::ConfidantConsts::InvalidConfidantIndex) {
                context.fake_stage3(i);
            }
        }
    }
    // TODO: add the code to go to the third stage ->
}

Result TrustedPostStageState::onStage3(SolverContext& context, const cs::StageThree& /*stage*/) {
    csdebug() << name() << ": TrueStages3 amount = " << context.trueStagesThree() << ", realTrusted.value = " << context.cnt_real_trusted();
    if (context.trueStagesThree() == context.cnt_real_trusted()) {
        csdebug() << name() << ": enough stage-3 received amount = " << context.trueStagesThree();
        return Result::Finish;
    }
    if (context.realTrustedChanged() && context.stagesThree() == context.cnt_real_trusted()) {
        if (context.cnt_real_trusted() > context.getRealTrusted().size() / 2U) {
            csdebug() << name() << ": the number of received messages on stage 3 doesn't correspond to the signed one, we have to retry stage 3";
            return Result::Retry;
        }
        else {
            csdebug() << name() << ": there is no availability to continue this consensus - not enough stages 3 with hashes like mine";
            return Result::Failure;
        }
    }
    return Result::Ignore;
}

}  // namespace cs
```
# ..\node\solver\src\states\trustedstage1state.cpp 
```cpp 
#include <consensus.hpp>
#include <smartcontracts.hpp>
#include <solvercontext.hpp>
#include <states/trustedstage1state.hpp>

#include <csdb/amount.hpp>
#include <csnode/blockchain.hpp>
#include <csnode/conveyer.hpp>
#include <csnode/itervalidator.hpp>
#include <csnode/transactionspacket.hpp>
#include <csnode/walletscache.hpp>
#include <lib/system/logger.hpp>
#include <lib/system/utils.hpp>

#include <cscrypto/cscrypto.hpp>

namespace cs {
void TrustedStage1State::on(SolverContext& context) {
    if (!pValidator_) {
        pValidator_ = std::make_unique<IterValidator>(context.wallets());
    }

    DefaultStateBehavior::on(context);
    context.init_zero(stage);
    stage.sender = context.own_conf_number();

    enough_hashes = false;
    transactions_checked = false;
    min_time_expired = false;

    SolverContext* pctx = &context;
    auto dt = Consensus::T_min_stage1;
    csdebug() << name() << ": start track min time " << dt << " ms to get hashes";

    cs::Timer::singleShot(dt, cs::RunPolicy::CallQueuePolicy, [this, pctx]() {
        csdebug() << name() << ": min time to get hashes is expired, may proceed to the next state";
        min_time_expired = true;
        if (transactions_checked && enough_hashes) {
            csdebug() << name() << ": transactions & hashes ready, so proceed to the next state now";
            pctx->complete_stage1();
        }
    });

    // min_time_tracking.start(
    //  context.scheduler(), dt,
    //  [this, pctx](){
    //    csdebug() << name() << ": min time to get hashes is expired, may proceed to the next state";
    //    min_time_expired = true;
    //    if (transactions_checked && enough_hashes) {
    //      csdebug() << name() << ": transactions & hashes ready, so proceed to the next state now";
    //      pctx->complete_stage1();
    //    }
    //  },
    //  true /*replace if exists*/
    //);
}

void TrustedStage1State::off(SolverContext& context) {
    // if (min_time_tracking.cancel()) {
    //  csdebug() << name() << ": cancel track min time to get hashes";
    //}
    csdebug() << name() << ": --> stage-1 [" << static_cast<int>(stage.sender) << "]";
    if (min_time_expired && transactions_checked && enough_hashes) {
        context.add_stage1(stage, true);
    }
}

Result TrustedStage1State::onSyncTransactions(SolverContext& context, cs::RoundNumber round) {
    cs::Conveyer& conveyer = cs::Conveyer::instance();
    if (round < conveyer.currentRoundNumber()) {
        cserror() << name() << ": cannot handle transactions from old round " << round;
        return Result::Ignore;
    }

    csdebug() << name() << ": -------> STARTING CONSENSUS #" << conveyer.currentRoundNumber() << " <------- ";
    auto data = conveyer.createPacket();

    if (!data.has_value()) {
        cserror() << name() << ": error while prepare consensus to build vector, maybe method called before sync completed?";
        return Result::Ignore;
    }

    // bindings
    auto&& [packet, smartContractPackets] = std::move(data).value();

    csdebug() << name() << ": packet of " << packet.transactionsCount() << " transactions in" << typeid(conveyer).name();
    if (!smartContractPackets.empty()) {
        csdebug() << name() << ": smart contract packets count " << smartContractPackets.size();
        if (!smartContractPackets.empty()) {
            for (const auto& p : smartContractPackets) {
                csdetails() << name() << ": packet hash " << p.hash().toString();
            }
        }
    }

    // review & validate transactions
    stage.hash = build_vector(context, packet, smartContractPackets);

    {
        std::unique_lock<cs::SharedMutex> lock = conveyer.lock();
        const cs::RoundTable& roundTable = conveyer.currentRoundTable();

        for (const auto& element : conveyer.transactionsPacketTable()) {
            const cs::PacketsHashes& hashes = roundTable.hashes;

            if (std::find(hashes.cbegin(), hashes.cend(), element.first) == hashes.cend()) {
                stage.hashesCandidates.push_back(element.first);

                if (stage.hashesCandidates.size() > Consensus::MaxStageOneHashes) {
                    break;
                }
            }
        }
    }

    transactions_checked = true;
    bool other_conditions = enough_hashes && min_time_expired;
    return (other_conditions ? Result::Finish : Result::Ignore);
}

Result TrustedStage1State::onHash(SolverContext& context, const csdb::PoolHash& pool_hash, const cs::PublicKey& sender) {
    csdb::PoolHash lastHash = context.blockchain().getLastHash();
    csdb::PoolHash spoiledHash = context.spoileHash(lastHash, sender);
    csdebug() << name() << ": <-- hash from " << context.sender_description(sender);
    if (spoiledHash == pool_hash) {
        // get node status for useful logging

        // if (stage.trustedCandidates.size() <= Consensus::MaxTrustedNodes) {
        csdebug() << name() << ": hash is OK";
        if (std::find(stage.trustedCandidates.cbegin(), stage.trustedCandidates.cend(), sender) == stage.trustedCandidates.cend()) {
            stage.trustedCandidates.push_back(sender);
        }
        //}
        if (stage.trustedCandidates.size() >= Consensus::MinTrustedNodes) {
            // enough hashes
            // flush deferred block to blockchain if any
            enough_hashes = true;
            bool other_conditions = transactions_checked && min_time_expired;
            return (other_conditions ? Result::Finish : Result::Ignore);
        }
    }
    else {
        cslog() << name() << ": DOES NOT MATCH my value " << lastHash.to_string();
        context.sendHashReply(std::move(pool_hash), sender);
    }

    return Result::Ignore;
}

cs::Hash TrustedStage1State::build_vector(SolverContext& context, cs::TransactionsPacket& packet, cs::Packets& smartsPackets) {
    const std::size_t transactionsCount = packet.transactionsCount();

    cs::Characteristic characteristic;

    if (transactionsCount > 0) {
        characteristic = pValidator_->formCharacteristic(context, packet.transactions(), smartsPackets);
    }
    if (characteristic.mask.size() != transactionsCount) {
        cserror() << name() << ": characteristic mask size is not equal to transactions count in build_vector()";
    }

    cs::Conveyer& conveyer = cs::Conveyer::instance();
    conveyer.setCharacteristic(characteristic, conveyer.currentRoundNumber());

    return formHashFromCharacteristic(characteristic);
}

cs::Hash TrustedStage1State::formHashFromCharacteristic(const cs::Characteristic& characteristic) {
    cs::Hash hash;

    if (characteristic.mask.empty()) {
        cs::Conveyer& conveyer = cs::Conveyer::instance();
        auto round = conveyer.currentRoundNumber();
        hash = cscrypto::calculateHash(reinterpret_cast<cs::Byte*>(&round), sizeof(cs::RoundNumber));
    }
    else {
        hash = cscrypto::calculateHash(characteristic.mask.data(), characteristic.mask.size());
    }

    csdebug() << name() << ": generated hash: " << cs::Utils::byteStreamToHex(hash.data(), hash.size());
    return hash;
}
}  // namespace cs
```
# ..\node\solver\src\states\trustedstage2state.cpp 
```cpp 
#include <states/trustedstage2state.hpp>
#include <solvercontext.hpp>
#include <consensus.hpp>

#include <lib/system/logger.hpp>
#include <csnode/conveyer.hpp>

namespace
{
    constexpr uint64_t TIMER_BASE_ID = 20;
}

namespace cs {

void TrustedStage2State::on(SolverContext& context) {
    DefaultStateBehavior::on(context);
    cnt_recv_stages = 0;
    context.init_zero(stage);
    stage.sender = context.own_conf_number();
    const auto ptr = context.stage1(stage.sender);
    if (ptr == nullptr) {
        cswarning() << name() << ": stage one result not found";
    }
    else {
        stage.signatures[ptr->sender] = ptr->signature;
        stage.hashes[ptr->sender] = ptr->messageHash;
    }
    // if have already received stage-1, make possible to go further (to stage-3)
    if (!context.stage1_data().empty()) {
        csdebug() << name() << ": handle early received stages-1";
        bool finish = false;
        for (const auto& st : context.stage1_data()) {
            csdebug() << name() << ": stage-1 [" << static_cast<int>(st.sender) << "] has already received";
            if (Result::Finish == onStage1(context, st)) {
                finish = true;
            }
        }
        if (finish) {
            context.complete_stage2();
            return;
        }
    }

    // 3 subsequent timeouts:
    //  - request stages-1 from origins
    //  - request stages-1 from anyone
    //  - create fake stages-1 from outbound nodes and force to next state

    constexpr size_t TimerBaseId = 20;
    csunused(TimerBaseId);

    SolverContext* pctx = &context;

    auto dt = Consensus::T_stage_request;
    // increase dt in case of large trx amount:
    cs::Conveyer& conveyer = cs::Conveyer::instance();
    const cs::Characteristic * characteristic = conveyer.characteristic(conveyer.currentRoundNumber());
    if (characteristic != nullptr) {
        // count of transactions seen in build_vector on stage-1
        size_t cnt_trx = characteristic->mask.size();
        if (cnt_trx > dt) {
            dt = uint32_t(cnt_trx); // 1 msec/transaction, 5K trx => 5 sec timeout
        }
    }
    csdebug() << name() << ": start track timeout " << 0 << " ms of stages-1 received";
    timeout_request_stage.start(context.scheduler(), 0,
                                // timeout #1 handler:
                                [pctx, this, dt]() {
                                    csdebug() << name() << ": (now) skip direct requests for absent stages-1";
                                    // request_stages(*pctx);
                                    // start subsequent track timeout for "wide" request
                                    csdebug() << name() << ": start subsequent track timeout " << dt << " ms to request neighbors about stages-1";
                                    timeout_request_neighbors.start(pctx->scheduler(), dt,
                                                                    // timeout #2 handler:
                                                                    [pctx, this, dt]() {
                                                                        csdebug() << name() << ": timeout for requested stages is expired, make requests to neighbors";
                                                                        request_stages_neighbors(*pctx);
                                                                        // timeout #3 handler
                                                                        csdebug() << name() << ": start subsequent track timeout " << dt << " ms to mark silent nodes";
                                                                        timeout_force_transition.start(
                                                                            pctx->scheduler(), dt,
                                                                            [pctx, this, dt]() {
                                                                                csdebug() << name() << ": timeout for transition is expired, mark silent nodes as outbound";
                                                                                mark_outbound_nodes(*pctx);
                                                                            },
                                                                            true /*replace if exists*/, TIMER_BASE_ID + 3);
                                                                    },
                                                                    true /*replace if exists*/, TIMER_BASE_ID + 2);
                                },
                                true /*replace if exists*/, TIMER_BASE_ID + 1);
}

void TrustedStage2State::off(SolverContext& /*context*/) {
    if (timeout_request_stage.cancel()) {
        csdebug() << name() << ": cancel track timeout of stages-1";
    }
    if (timeout_request_neighbors.cancel()) {
        csdebug() << name() << ": cancel track timeout to request neighbors about stages-1";
    }
    if (timeout_force_transition.cancel()) {
        csdebug() << name() << ": cancel track timeout to force transition to next state";
    }
}

Result TrustedStage2State::onStage1(SolverContext& context, const cs::StageOne& st) {
    stage.signatures[st.sender] = st.signature;
    stage.hashes[st.sender] = st.messageHash;
    ++cnt_recv_stages;
    if (cnt_recv_stages == context.cnt_trusted()) {
        csdebug() << name() << ": enough stage-1 received";
        /*signing of the second stage should be placed here*/
        csdebug() << name() << ": --> stage-2 [" << static_cast<int>(stage.sender) << "]";
        context.add_stage2(stage, true);
        return Result::Finish;
    }
    return Result::Ignore;
}

// requests stages from corresponded nodes
void TrustedStage2State::request_stages(SolverContext& context) {
    const uint8_t cnt = static_cast<uint8_t>(context.cnt_trusted());
    int cnt_requested = 0;
    for (uint8_t i = 0; i < cnt; ++i) {
        if (context.stage1(i) == nullptr) {
            context.request_stage1(i, i);
            ++cnt_requested;
        }
    }
    if (!cnt_requested) {
        csdebug() << name() << ": no node to request";
    }
}

// requests stages from any available neighbor nodes
void TrustedStage2State::request_stages_neighbors(SolverContext& context) {
    const auto& stage2_data = context.stage2_data();
    const uint8_t cnt = static_cast<uint8_t>(context.cnt_trusted());
    int cnt_requested = 0;
    for (uint8_t i = 0; i < cnt; ++i) {
        if (context.stage1(i) == nullptr) {
            for (const auto& d : stage2_data) {
                if (d.sender != context.own_conf_number()) {
                    context.request_stage1(d.sender, i);
                    ++cnt_requested;
                }
            }
        }
    }
    if (0 == cnt_requested) {
        csdebug() << name() << ": no node to request";
    }
}

// forces transition to next stage
void TrustedStage2State::mark_outbound_nodes(SolverContext& context) {
    const uint8_t cnt = static_cast<uint8_t>(context.cnt_trusted());
    for (uint8_t i = 0; i < cnt; ++i) {
        if (context.stage1(i) == nullptr) {
            // it is possible to get a transition to other state in SolverCore from any iteration, this is not a problem,
            // simply execute method until end
            context.fake_stage1(i);
        }
    }
}

}  // namespace cs
```
# ..\node\solver\src\states\trustedstage3state.cpp 
```cpp 
#include <solvercontext.hpp>
#include <states/trustedstage3state.hpp>

#include <csnode/blockchain.hpp>
#include <csnode/conveyer.hpp>
#include <csnode/datastream.hpp>

#include <lib/system/utils.hpp>
#include <lib/system/random.hpp>

#include <algorithm>
#include <cmath>

namespace
{
    constexpr uint64_t TIMER_BASE_ID = 30;
}

namespace cs {

void TrustedStage3State::on(SolverContext& context) {
    DefaultStateBehavior::on(context);
    if (!context.realTrustedChanged()) {
        stage.iteration = 0;
        stage.realTrustedMask.clear();
        stage.realTrustedMask.resize(context.cnt_trusted());
        stage.sender = context.own_conf_number();
    }
    else {
        ++(stage.iteration);
        stage.realTrustedMask.clear();
        stage.realTrustedMask = context.getRealTrusted();  // we delete this storage so the realtrusted will be zero
    }
    context.realTrustedChangedSet(false);
    cnt_recv_stages = 0;

    if (std::count(stage.realTrustedMask.cbegin(), stage.realTrustedMask.cend(), cs::ConfidantConsts::InvalidConfidantIndex) > 0) {
        if (Result::Finish == finalizeStageThree(context)) {
            context.complete_stage3();
            return;
        }
        else {
            cswarning() << name() << "the stage can't finish successfully, waiting for Big Bang";
            context.fail_stage3();
            return;
        }
    }

    const auto ptr = context.stage2(stage.sender);
    if (ptr == nullptr) {
        cswarning() << name() << ": stage one result not found";
    }
    // process already received stage-2, possible to go further to post trusted state
    if (!context.stage2_data().empty()) {
        csdebug() << name() << ": handle early received stages-2";
        Result finish = Result::Ignore;
        for (const auto& st : context.stage2_data()) {
            csdebug() << name() << ": stage-2[" << static_cast<int>(st.sender) << "] has already received";
            if (Result::Finish == onStage2(context, st)) {
                finish = Result::Finish;
            }
        }

        if (finish == Result::Finish) {
            context.complete_stage3();
            return;
        }

        if (finish == Result::Failure) {
            context.fail_stage3();
            return;
        }
    }

    // 3 subsequent timeouts:
    //  - request stages-2 from origins
    //  - request stages-2 from anyone
    //  - create fake stages-2 from outbound nodes and force to next state

    SolverContext* pctx = &context;
    auto dt = 2 * Consensus::T_stage_request;
    csdebug() << name() << ": start track timeout " << 0 << " ms of stages-2 received";
    timeout_request_stage.start(context.scheduler(), 0,  // no timeout
                                // timeout #1 handler:
                                [pctx, this, dt]() {
                                    csdebug() << name() << ": (now) skip direct requests for absent stages-2";
                                    // request_stages(*pctx);
                                    // start subsequent track timeout for "wide" request
                                    csdebug() << name() << ": start subsequent track timeout " << dt << " ms to request neighbors about stages-2";
                                    timeout_request_neighbors.start(pctx->scheduler(), dt,
                                                                    // timeout #2 handler:
                                                                    [pctx, this, dt]() {
                                                                        csdebug() << name() << ": timeout for transition is expired, make requests to neighbors";
                                                                        request_stages_neighbors(*pctx);
                                                                        cs::RoundNumber rnum = cs::Conveyer::instance().currentRoundNumber();
                                                                        // timeout #3 handler
                                                                        csdebug() << name() << ": start subsequent track timeout " << dt << " ms to mark silent nodes";
                                                                        timeout_force_transition.start(
                                                                            pctx->scheduler(), dt,
                                                                            [pctx, this, rnum, dt]() {
                                                                                csdebug() << name() << ": timeout for transition is expired, mark silent nodes as outbound";
                                                                                mark_outbound_nodes(*pctx, rnum);
                                                                            },
                                                                            true /*replace if exists*/, TIMER_BASE_ID + 3);
                                                                    },
                                                                    true /*replace if exists*/, TIMER_BASE_ID + 2);
                                },
                                true /*replace if exists*/, TIMER_BASE_ID + 1);
}

void TrustedStage3State::off(SolverContext& /*context*/) {
    if (timeout_request_stage.cancel()) {
        csdebug() << name() << ": cancel track timeout of stages-2";
    }
    if (timeout_request_neighbors.cancel()) {
        csdebug() << name() << ": cancel track timeout to request neighbors about stages-2";
    }
    if (timeout_force_transition.cancel()) {
        csdebug() << name() << ": cancel track timeout to force transition to next state";
    }
}

// requests stages from corresponded nodes
void TrustedStage3State::request_stages(SolverContext& context) {
    auto cnt = static_cast<uint8_t>(context.cnt_trusted());
    int cnt_requested = 0;

    for (uint8_t i = 0; i < cnt; ++i) {
        if (context.stage2(i) == nullptr) {
            context.request_stage2(i, i);
            ++cnt_requested;
        }
    }

    if (cnt_requested == 0) {
        csdebug() << name() << ": no node to request";
    }
}

// requests stages from any available neighbor nodes
void TrustedStage3State::request_stages_neighbors(SolverContext& context) {
    const auto& stage2_data = context.stage2_data();
    auto cnt = static_cast<uint8_t>(context.cnt_trusted());
    int cnt_requested = 0;
    for (uint8_t i = 0; i < cnt; ++i) {
        if (context.stage2(i) == nullptr) {
            for (const auto& d : stage2_data) {
                if (d.sender != context.own_conf_number()) {
                    context.request_stage2(d.sender, i);
                    ++cnt_requested;
                }
            }
        }
    }

    if (cnt_requested == 0) {
        csdebug() << name() << ": no node to request";
    }
}

// forces transition to next stage
void TrustedStage3State::mark_outbound_nodes(SolverContext& context, cs::RoundNumber round) {
    csdebug() << name() << ": mark outbound nodes in round #" << round;
    auto cnt = static_cast<uint8_t>(context.cnt_trusted());
    for (uint8_t i = 0; i < cnt; ++i) {
        if (context.stage2(i) == nullptr) {
            // it is possible to get a transition to other state in SolverCore from any iteration, this is not a problem, simply execute method until end
            csdebug() << name() << ": making fake stage-2 in round " << round;
            context.fake_stage2(i);
            // this procedute can cause the round change
            if (round != cs::Conveyer::instance().currentRoundNumber()) {
                return;
            }
        }
    }
}

Result TrustedStage3State::onStage2(SolverContext& context, const cs::StageTwo&) {
    const auto ptr = context.stage2(context.own_conf_number());
    ++cnt_recv_stages;
    if (ptr != nullptr && cnt_recv_stages == context.cnt_trusted()) {
        csdebug() << name() << ": enough stage-2 received";
        const size_t cnt = context.cnt_trusted();
        for (auto& it : context.stage2_data()) {
            if (it.sender != context.own_conf_number()) {
                csdebug() << "Comparing with T(" << static_cast<int>(ptr->sender) << "):";
                for (size_t j = 0; j < cnt; j++) {
                    // check amount of trusted node's signatures nonconformity
                    csdetails() << "Signature of T(" << j << ") in my storage is: " << cs::Utils::byteStreamToHex(ptr->signatures[j]);
                    if (ptr->signatures[j] != it.signatures[j]) {
                        csdebug() << "Signature of T(" << j << ") sent by T(" << static_cast<int>(it.sender) << "):" << cs::Utils::byteStreamToHex(it.signatures[j])
                                  << " from stage-2 is not equal to mine";

                        if (it.hashes[j] == Zero::hash) {
                            csdebug() << name() << ": [" << static_cast<int>(it.sender) << "] marked as untrusted (silent)";
                            context.mark_untrusted(it.sender);
                            continue;
                        }

                        cs::Bytes toVerify;
                        size_t messageSize = sizeof(cs::RoundNumber) + sizeof(uint8_t) + sizeof(cs::Hash);
                        toVerify.reserve(messageSize);
                        cs::DataStream stream(toVerify);
                        stream << cs::Conveyer::instance().currentRoundNumber() << context.subRound();  // Attention!!! the uint32_t type
                        stream << it.hashes[j];

                        if (cscrypto::verifySignature(it.signatures[j], context.trusted().at(it.sender), toVerify.data(), messageSize)) {
                            cslog() << name() << ": [" << static_cast<int>(j) << "] marked as untrusted (sent bad hash-signature pair of [" << static_cast<int>(it.sender) << "])";
                            context.mark_untrusted(static_cast<uint8_t>(j));
                        }
                        else {
                            cslog() << name() << ": [" << static_cast<int>(it.sender) << "] marked as untrusted (bad signature)";
                            context.mark_untrusted(it.sender);
                        }
                    }
                }

                bool toBreak = false;
                size_t tCandSize = 0;
                const auto ptrStage1 = context.stage1(it.sender);
                if (ptrStage1 != nullptr) {
                    tCandSize = ptrStage1->trustedCandidates.size();
                }

                if (tCandSize > 0) {
                    for (size_t outer = 0; outer < tCandSize - 1; outer++) {
                        // DPOS check start -> comment if unnecessary
                        if (!context.checkNodeCache(ptrStage1->trustedCandidates.at(outer))) {
                            cslog() << name() << ": [" << static_cast<int>(it.sender) << "] marked as untrusted (low-value candidates)";
                            context.mark_untrusted(it.sender);
                            break;
                        }
                        // DPOS check finish
                        for (size_t inner = outer + 1; inner < tCandSize; inner++) {
                            if (ptrStage1->trustedCandidates.at(outer) == ptrStage1->trustedCandidates.at(inner)) {
                                cslog() << name() << ": [" << static_cast<int>(it.sender) << "] marked as untrusted (duplicated candidates)";
                                context.mark_untrusted(it.sender);
                                toBreak = true;
                                break;
                            }
                        }
                        if (toBreak) {
                            break;
                        }
                    }
                }
                else {
                    cslog() << name() << ": [" << static_cast<int>(it.sender) << "] marked as untrusted (no candidates)";
                    context.mark_untrusted(it.sender);
                }
            }
        }

        trusted_election(context);

        csdebug() << "============================ CONSENSUS SUMMARY =================================";
        if (pool_solution_analysis(context)) {
            if (take_urgent_decision(context)) {  // to be redesigned
                csdebug() << "\t==> [" << static_cast<int>(stage.writer) << "]";
            }
            else {
                cslog() << "\tconsensus failed waiting for BigBang";
                return Result::Failure;
            }
        }
        else {
            cslog() << "\tconsensus is not achieved";
            return Result::Failure;
            /*the action is needed*/
        }
        csdebug() << "================================================================================";

        context.realTrustedSet(stage.realTrustedMask);
        // all trusted nodes must send stage3 data
        context.next_trusted_candidates(next_round_trust, next_round_hashes);
        // TODO: The pool building is starting here <===
        context.spawn_next_round(stage);
        csdebug() << name() << ": --> stage-3 [" << static_cast<int>(stage.sender) << "]";
        context.add_stage3(stage);  //, stage.writer != stage.sender);

        return Result::Finish;
    }

    csdebug() << name() << ": continue to receive stages-2";
    return Result::Ignore;
}

Result TrustedStage3State::finalizeStageThree(SolverContext& context) {
    // TODO : here write the code to clean stage three storage, perhaps add st3 iterations
    if (take_urgent_decision(context)) {  // to be redesigned
        csdebug() << "\t==> [" << static_cast<int>(stage.writer) << "]";
    }
    else {
        cslog() << "\tconsensus failed: waiting for BigBang";
        return Result::Failure;
    }
    csdebug() << "Starting new collection of stage 3 because a part of nodes didn't respond correct";
    context.spawn_next_round(stage);
    csdebug() << name() << ": --> stage-3 [" << static_cast<int>(stage.sender) << "]";
    context.add_stage3(stage);  //, stage.writer != stage.sender);

    return Result::Finish;
}

bool TrustedStage3State::pool_solution_analysis(SolverContext& context) {
    struct HashWeight {
        cs::Hash hash;
        uint8_t weight{0};
    };

    std::vector<HashWeight> hWeight;
    HashWeight everyHashWeight;
    // creating hash frequency table
    for (const auto& it : context.stage1_data()) {
        if (hWeight.size() == 0) {
            std::copy(it.hash.cbegin(), it.hash.cend(), everyHashWeight.hash.begin());
            everyHashWeight.weight = 1;
            hWeight.push_back(everyHashWeight);
        }
        else {
            bool found = false;
            for (auto& itt : hWeight) {
                if (itt.hash == it.hash) {
                    ++(itt.weight);
                    found = true;
                    break;
                }
            }
            if (!found) {
                std::copy(it.hash.cbegin(), it.hash.cend(), everyHashWeight.hash.begin());
                everyHashWeight.weight = 1;
                hWeight.push_back(everyHashWeight);
            }
        }
    }
    size_t maxWeight = 0;
    cs::Hash mostFrequentHash;
    mostFrequentHash.fill(0);

    ////searching for most frequent hash
    for (auto& it : hWeight) {
        if (it.weight > maxWeight) {
            maxWeight = it.weight;
            std::copy(it.hash.cbegin(), it.hash.cend(), mostFrequentHash.begin());
        }
    }
    uint8_t liarNumber = 0;
    /* csdebug() <<  "Most Frequent hash: " << byteStreamToHex((const char*)mostFrequentHash.val, cscrypto::kHashSize);*/
    for (const auto& it : context.stage1_data()) {
        if (it.sender >= stage.realTrustedMask.size()) {
            cserror() << name() << ": index of sender is greater than the container size";
            return false;
        }
        if (std::equal(it.hash.cbegin(), it.hash.cend(), mostFrequentHash.cbegin()) && stage.realTrustedMask.at(it.sender) != cs::ConfidantConsts::InvalidConfidantIndex) {
            csdebug() << "[" << static_cast<int>(it.sender) << "] is not liar";
        }
        else {
            ++liarNumber;
            context.mark_untrusted(it.sender);
            stage.realTrustedMask.at(it.sender) = cs::ConfidantConsts::InvalidConfidantIndex;

            bool is_lost = (std::equal(it.hash.cbegin(), it.hash.cend(), Zero::hash.cbegin()));
            csdebug() << "[" << static_cast<int>(it.sender) << "] IS "
                      << ((is_lost && stage.realTrustedMask.at(it.sender) == cs::ConfidantConsts::InvalidConfidantIndex) ? "LOST" : "LIAR") << " with hash "
                      << cs::Utils::byteStreamToHex(it.hash);
        }
    }

    // TODO: modify to select right confidants to trusted_mask
    if (liarNumber > 0) {
        cswarning() << "\tLiars detected: " << static_cast<int>(liarNumber);
    }
    else {
        csdebug() << "\tNo liars detected";
    }
    if (liarNumber > context.cnt_trusted() / 2) {
        return false;
    }
    else {
        return true;
    }
}

void TrustedStage3State::trusted_election(SolverContext& context) {
    if (!next_round_trust.empty()) {
        next_round_trust.clear();
    }
    if (!next_round_hashes.empty()) {
        next_round_hashes.clear();
    }
    std::array<uint8_t, Consensus::MaxTrustedNodes> trustedMask;
    trustedMask.fill(0);
    std::map<cs::PublicKey, uint8_t> candidatesElection;
    size_t myPacks = 0;
    std::vector<cs::TransactionsPacketHash> myHashes;
    std::map<cs::TransactionsPacketHash, uint8_t> hashesElection;
    std::vector<cs::TransactionsPacketHash> myRejectedHashes;
    const uint8_t cnt_trusted = std::min(static_cast<uint8_t>(context.cnt_trusted()), static_cast<uint8_t>(Consensus::MaxTrustedNodes));
    uint8_t cr = cnt_trusted / 2;
    std::vector<cs::PublicKey> aboveThreshold;
    std::vector<cs::PublicKey> belowThreshold;
    csdebug() << name() << ": number of generals / 2 = " << static_cast<int>(cr);

    for (uint8_t i = 0; i < cnt_trusted; i++) {
        trustedMask[i] = (context.untrusted_value(i) == 0);
        if (trustedMask[i]) {
            stage.realTrustedMask.at(i) = cs::ConfidantConsts::FirstWriterIndex;
            auto ptr = context.stage1(i);
            if (ptr == nullptr) {
                continue;
            }
            const auto& stage_i = *ptr;
            uint8_t candidates_amount = static_cast<uint8_t>(stage_i.trustedCandidates.size());
            csdebug() << "Candidates amount of [" << static_cast<int>(i) << "] : " << static_cast<int>(candidates_amount);

            for (uint8_t j = 0; j < candidates_amount; j++) {
                //  csdebug() << (int)i << "." << (int)j << " " << cs::Utils::byteStreamToHex(stage_i.trustedCandidates.at(j).data(), cscrypto::kPublicKeySize);
                if (candidatesElection.count(stage_i.trustedCandidates.at(j)) > 0) {
                    candidatesElection.at(stage_i.trustedCandidates.at(j)) += 1;
                }
                else {
                    candidatesElection.emplace(stage_i.trustedCandidates.at(j), uint8_t(1));
                }
            }

            size_t hashes_amount = stage_i.hashesCandidates.size();
            // csdebug() << "My conf number = " << context.own_conf_number();
            if (stage_i.sender == context.own_conf_number()) {
                myHashes = stage_i.hashesCandidates;
                myPacks = stage_i.hashesCandidates.size();
            }

            csdebug() << "Hashes amount of [" << static_cast<int>(i) << "]: " << static_cast<int>(hashes_amount);
            for (uint32_t j = 0; j < hashes_amount; j++) {
                // csdebug() << (int)i << "." << j << " " << cs::Utils::byteStreamToHex(stage_i.hashesCandidates.at(j).toBinary().data(), cscrypto::kHashSize);
                if (hashesElection.count(stage_i.hashesCandidates.at(j)) > 0) {
                    hashesElection.at(stage_i.hashesCandidates.at(j)) += 1;
                }
                else {
                    hashesElection.emplace(stage_i.hashesCandidates.at(j), uint8_t(1));
                }
            }
        }
        else {
            stage.realTrustedMask.at(i) = cs::ConfidantConsts::InvalidConfidantIndex;
        }
    }

    csdebug() << name() << ": election table ready";
    size_t max_conf = 0;
    if (candidatesElection.size() < 4) {
        max_conf = candidatesElection.size();
        csdebug() << name() << ": too few TRUSTED NODES, but we continue at the minimum ...";
    }
    else {
        max_conf = static_cast<size_t>(4. + 1.85 * log(candidatesElection.size() / 4.));
        if (max_conf > Consensus::MaxTrustedNodes) {
            max_conf = Consensus::MaxTrustedNodes;
        }
    }
    csdebug() << name() << ": max confidant: " << max_conf;

    for (auto& it : candidatesElection) {
        // csdebug() << byteStreamToHex(it.first.str, cscrypto::kPublicKeySize) << " - " << (int) it.second;
        if (it.second > cr) {
            aboveThreshold.emplace_back(it.first);
        }
        else {
            belowThreshold.emplace_back(it.first);
        }
    }

    for (auto& it : hashesElection) {
        if (it.second > cr) {
            next_round_hashes.emplace_back(it.first);
        }
    }
    size_t acceptedPacks = 0;
    for (const auto& hash : myHashes) {
        bool rejectedFound = true;
        for (const auto& next_hash : next_round_hashes) {
            if (next_hash != hash) {
                ++acceptedPacks;
                rejectedFound = false;
            }
        }
        if (rejectedFound) {
            myRejectedHashes.emplace_back(hash);
        }
    }

    csdebug() << name() << ": initial amount: " << myPacks << ", next round hashes: " << next_round_hashes.size() << ", accepted: " << acceptedPacks;
    csdebug() << name() << ": candidates divided: above = " << aboveThreshold.size() << ", below = " << belowThreshold.size();
    csdebug() << "======================================================";

    for (size_t i = 0; i < aboveThreshold.size(); i++) {
        const auto& tmp = aboveThreshold[i];
        csdebug() << i << ". " << cs::Utils::byteStreamToHex(tmp.data(), tmp.size()) << " - " << static_cast<int>(candidatesElection.at(tmp));
    }

    csdebug() << "------------------------------------------------------";
    for (size_t i = 0; i < belowThreshold.size(); i++) {
        const auto& tmp = belowThreshold[i];
        csdebug() << i << ". " << cs::Utils::byteStreamToHex(tmp.data(), tmp.size()) << " - " << static_cast<int>(candidatesElection.at(tmp));
    }

    csdebug() << name() << ": final list of next round trusted:";

    if (aboveThreshold.size() >= max_conf) {  // Consensus::MinTrustedNodes) {
        std::random_device rd;
        std::mt19937 g;
        g.seed((unsigned int)Conveyer::instance().currentRoundNumber());
        cs::Random::shuffle(aboveThreshold.begin(), aboveThreshold.end(), g);
        for (size_t i = 0; i < max_conf; ++i) {
            const auto& tmp = aboveThreshold.at(i);
            next_round_trust.emplace_back(tmp);
            csdebug() << "\t" << cs::Utils::byteStreamToHex(tmp.data(), tmp.size());
        }
    }
    else {
        if (belowThreshold.size() >= max_conf - aboveThreshold.size()) {
            for (size_t i = 0; i < aboveThreshold.size(); i++) {
                const auto& tmp = aboveThreshold.at(i);
                next_round_trust.emplace_back(tmp);
                csdebug() << cs::Utils::byteStreamToHex(tmp.data(), tmp.size());
            }
            const size_t toAdd = max_conf - next_round_trust.size();
            for (size_t i = 0; i < toAdd; i++) {
                const auto& tmp = belowThreshold.at(i);
                next_round_trust.emplace_back(tmp);
                csdebug() << cs::Utils::byteStreamToHex(tmp.data(), tmp.size());
            }
        }
        else {
            cslog() << name() << ": cannot create list of trusted, too few candidates.";
        }
    }
    csdebug() << name() << ": end of trusted election";
}

bool TrustedStage3State::take_urgent_decision(SolverContext& context) {
    auto hash_t = context.blockchain().getHashBySequence(cs::Conveyer::instance().currentRoundNumber() - 1).to_binary();
    if (hash_t.empty()) {
        return false;  // TODO: decide what to return
    }
    int k = *(unsigned int*)hash_t.data();
    if (k < 0) {
        k = -k;
    }
    // stage.realTrustedMask contains !0 on good nodes:
    int cnt = std::min(static_cast<int>(context.cnt_trusted()), (int)Consensus::MaxTrustedNodes);
    int cnt_active = cnt - static_cast<int>(std::count(stage.realTrustedMask.cbegin(), stage.realTrustedMask.cend(), InvalidConfidantIndex));
    if (cnt_active * 2 < cnt + 1) {
        cswarning() << name() << ": not enough active confidants to make a decision, BigBang required";
        return false;
    }
    int idx_writer = k % cnt_active;
    if (cnt != cnt_active) {
        csdebug() << "\tselect #" << idx_writer << " from " << cnt_active << " good nodes in " << cnt << " total";
    }
    else {
        csdebug() << "\tselect #" << idx_writer << " from " << cnt << " nodes";
    }
    // count idx_writer through good nodes (optional):
    int idx = 0;
    for (size_t i = 0; i < size_t(cnt); ++i) {
        if (stage.realTrustedMask.at(i) != InvalidConfidantIndex) {
            if (idx == idx_writer) {
                stage.writer = static_cast<uint8_t>(i);
            }
            ++idx;
        }
    }
    size_t c = 0;
    idx = 0;
    for (size_t i = stage.writer; i < size_t(cnt + stage.writer); ++i) {
        c = i % size_t(cnt);
        if (stage.realTrustedMask.at(c) != InvalidConfidantIndex) {
            stage.realTrustedMask.at(c) = static_cast<uint8_t>(idx);
            ++idx;
        }
    }
    if ((size_t)std::count(stage.realTrustedMask.cbegin(), stage.realTrustedMask.cend(), cs::ConfidantConsts::InvalidConfidantIndex) > stage.realTrustedMask.size() / 2U + 1U) {
        return false;
    }
    return true;
}

}  // namespace cs
```
# ..\node\solver\src\states\waitingstate.cpp 
```cpp 
#include "waitingstate.hpp"
#include <consensus.hpp>
#include <solvercontext.hpp>
#include <sstream>

namespace
{
    constexpr uint64_t TIMER_BASE_ID = 50;
}

namespace cs {

void WaitingState::on(SolverContext &context) {
    // TODO:: calculate my queue number starting from writing node:
    const auto ptr = context.stage3(context.own_conf_number());
    writingQueueNumber_ = ptr->realTrustedMask.at(ptr->sender);
    if (writingQueueNumber_ == InvalidConfidantIndex) {
        return;
    }

    cs::Signatures bSignatures;
    cs::Bytes rMask = ptr->realTrustedMask;
    size_t counter = 0;
    for (auto &it : rMask) {
        if (it != cs::ConfidantConsts::InvalidConfidantIndex) {
            ++counter;
        }
    }
    if (context.final_stage3_data().size() != counter) {
        // TODO: write what to do if these parameters arn't equal
    }

    bSignatures.reserve(counter);
    for (size_t i = 0; i < rMask.size(); ++i) {  // auto& it : context.final_stage3_data()) {
        if (rMask[i] != cs::ConfidantConsts::InvalidConfidantIndex) {
            bSignatures.push_back(context.stage3((uint8_t)i)->blockSignature);  // emplace_back(it.sender, it.blockSignature);
        }
    }

    // TODO: The pool should be send to blockchain here <===
    csmeta(csdebug) << "Signatures to add: " << bSignatures.size();
    if (!context.addSignaturesToLastBlock(std::move(bSignatures))) {
        csmeta(cserror) << "Signatures added to new block failed";
        return;
    }

    csmeta(csdebug) << "Signatures added to new block successfully";

    std::ostringstream os;
    os << prefix_ << "-" << static_cast<size_t>(writingQueueNumber_);
    myName_ = os.str();

    const size_t invalids_count = static_cast<size_t>(std::count(ptr->realTrustedMask.cbegin(), ptr->realTrustedMask.cend(), InvalidConfidantIndex));
    const size_t cnt_active = ptr->realTrustedMask.size() - invalids_count;
    csdebug() << name() << ": my order " << static_cast<int>(ptr->sender) << ", trusted " << context.cnt_trusted() << " (good " << cnt_active << ")"
              << ", writer " << static_cast<int>(ptr->writer);

    if (writingQueueNumber_ == 0) {
        csdebug() << name() << ": becoming WRITER";
        context.request_role(Role::Writer);
        return;
    }

    // TODO: value = (Consensus::PostConsensusTimeout * "own number in "writing" queue")
    const uint32_t value = sendRoundTableDelayMs_ * writingQueueNumber_;

    if (Consensus::Log) {
        csdebug() << name() << ": start wait " << value / 1000 << " sec until new round";
    }

    SolverContext *pctx = &context;
    roundTimeout_.start(context.scheduler(), value,
                        [pctx, this]() {
                            if (Consensus::Log) {
                                csdebug() << name() << ": time to wait new round is expired";
                            }
                            activate_new_round(*pctx);
                        },
                        true /*replace existing*/, TIMER_BASE_ID);
}

void WaitingState::off(SolverContext & /*context*/) {
    myName_ = prefix_;
    if (roundTimeout_.cancel()) {
        if (Consensus::Log) {
            csdebug() << name() << ": cancel wait new round";
        }
    }
}

void WaitingState::activate_new_round(SolverContext &context) {
    csdebug() << name() << ": activating new round ";
    const auto ptr = context.stage3(context.own_conf_number());
    if (ptr == nullptr) {
        cserror() << name() << ": cannot access own stage data, didnt you forget to cancel this call?";
        return;
    }

    const uint8_t writer = ptr->writer + writingQueueNumber_;
    context.request_round_info((writer - 1) % context.cnt_trusted(),   // previous "writer"
                               (writer + 1) % context.cnt_trusted());  // next "writer"
}

}  // namespace cs
```
# ..\node\solver\src\states\writingstate.cpp 
```cpp 
#include <consensus.hpp>
#include <solvercontext.hpp>
#include <writingstate.hpp>

namespace cs {

void WritingState::on(SolverContext& context) {
    // simply try to spawn next round
    csdebug() << name() << ": spawn next round";
    context.sendRoundTable();
}

}  // namespace cs
```
# ..\node\solver\tests\tests_main.cpp 
```cpp 
#include <Consensus.h>

#include <clocale>
#include <gtest/gtest.h>
#include <gmock/gmock.h>

int main(int argc, char** argv)
{
#if defined(__MINGW32__)
    std::setlocale(LC_ALL, "Russian");
#elif defined(_WIN32)
    std::setlocale(LC_ALL, "ru-RU");
#else
    std::setlocale(LC_ALL, "ru_RU.UTF-8");
#endif

    ::testing::InitGoogleTest(&argc, argv);
    ::testing::InitGoogleMock(&argc, argv);

    return RUN_ALL_TESTS();
}

TEST(Init, Done)
{
  EXPECT_FALSE(false);
  EXPECT_TRUE(true);
}
```
# ..\node\solver\tests\test_trustedstage1state.cpp 
```cpp 
#include <MockData.h>
#include <states/TrustedStage1State.h>

#include <gtest/gtest.h>

TEST(TrustedStage1State, TrivialMethods)
{
    MockData mock;

    using namespace slv2;
    TrustedStage1State state;

    EXPECT_EQ(Result::Ignore, state.onBlock(mock.context, mock.block, mock.sender1));
    EXPECT_EQ(Result::Ignore, state.onStage1(mock.context, mock.stage1));
    EXPECT_EQ(Result::Ignore, state.onStage2(mock.context, mock.stage2));
    EXPECT_EQ(Result::Ignore, state.onStage3(mock.context, mock.stage3));
    EXPECT_EQ(Result::Ignore, state.onTransaction(mock.context, mock.trans));
    EXPECT_EQ(Result::Finish, state.onRoundTable(mock.context, 1));
}

TEST(TrustedStage1State, TrList_then_all_hashes)
{
    using namespace ::testing;

    NiceMock<MockData> mock;

    EXPECT_CALL(mock.context, is_block_deferred)
        .Times(2) // on(), onHash()-#3
        .WillRepeatedly(Return(true));
    EXPECT_CALL(mock.context, flush_deferred_block)
        .Times(2);

    using namespace slv2;
    TrustedStage1State state;

    EXPECT_NO_THROW(state.on(mock.context));

    EXPECT_EQ(Result::Ignore, state.onTransactionList(mock.context, mock.tl));

    EXPECT_EQ(Result::Ignore, state.onHash(mock.context, mock.hash, mock.sender1));
    EXPECT_EQ(Result::Ignore, state.onHash(mock.context, mock.hash, mock.sender2));
    EXPECT_EQ(Result::Finish, state.onHash(mock.context, mock.hash, mock.sender3));
}

TEST(TrustedStage1State, All_hashes_then_TrList)
{
    using namespace ::testing;

    NiceMock<MockData> mock;

    EXPECT_CALL(mock.context, is_block_deferred)
        .Times(2) // on(), onHash()-#3
        .WillRepeatedly(Return(true));
    EXPECT_CALL(mock.context, flush_deferred_block)
        .Times(2);

    using namespace slv2;
    TrustedStage1State state;

    EXPECT_NO_THROW(state.on(mock.context));

    EXPECT_EQ(Result::Ignore, state.onHash(mock.context, mock.hash, mock.sender1));
    EXPECT_EQ(Result::Ignore, state.onHash(mock.context, mock.hash, mock.sender2));
    EXPECT_EQ(Result::Ignore, state.onHash(mock.context, mock.hash, mock.sender3));

    EXPECT_EQ(Result::Finish, state.onTransactionList(mock.context, mock.tl));
}

TEST(TrustedStage1State, TrList_between_hashes)
{
    using namespace ::testing;

    NiceMock<MockData> mock;

    EXPECT_CALL(mock.context, is_block_deferred)
        .Times(2) // on(), onHash()-#3
        .WillRepeatedly(Return(true));
    EXPECT_CALL(mock.context, flush_deferred_block)
        .Times(2);

    using namespace slv2;
    TrustedStage1State state;

    EXPECT_NO_THROW(state.on(mock.context));

    EXPECT_EQ(Result::Ignore, state.onHash(mock.context, mock.hash, mock.sender1));

    EXPECT_EQ(Result::Ignore, state.onTransactionList(mock.context, mock.tl));

    EXPECT_EQ(Result::Ignore, state.onHash(mock.context, mock.hash, mock.sender2));
    EXPECT_EQ(Result::Finish, state.onHash(mock.context, mock.hash, mock.sender3));
}
```
# ..\node\solver\tests\test_trustedstage2state.cpp 
```cpp 
#include <MockData.h>
#include <states/TrustedStage2State.h>

#include <gtest/gtest.h>

TEST(TrustedStage2State, TrivialMethods)
{
    using namespace ::testing;

    NiceMock<MockData> mock;

    using namespace slv2;
    TrustedStage2State state;

    EXPECT_EQ(Result::Ignore, state.onBlock(mock.context, mock.block, mock.sender1));
    EXPECT_EQ(Result::Ignore, state.onTransactionList(mock.context, mock.tl));
    EXPECT_EQ(Result::Ignore, state.onHash(mock.context, mock.hash, mock.sender1));
    EXPECT_EQ(Result::Ignore, state.onStage2(mock.context, mock.stage2));
    EXPECT_EQ(Result::Ignore, state.onStage3(mock.context, mock.stage3));
    EXPECT_EQ(Result::Ignore, state.onTransaction(mock.context, mock.trans));
    EXPECT_EQ(Result::Finish, state.onRoundTable(mock.context, 1));
}

TEST(TrustedStage2State, TrList_then_all_hashes)
{
    using namespace ::testing;

    NiceMock<MockData> mock;

    using namespace ::testing;
    using namespace slv2;

    TrustedStage2State state;

    EXPECT_NO_THROW(state.on(mock.context));

    // context.enough_stage1() => Ignore || Finish
    struct SequenceBool
    {
        SequenceBool(bool start_from)
            : flag(!start_from)
        {}
        bool flag;
        bool Next()
        {
            flag = !flag;
            return flag;
        }
    };
    SequenceBool seq(false);
    EXPECT_CALL(mock.context, enough_stage1)
        .Times(2) // on(), onHash()-#3
        .WillRepeatedly(Invoke(&seq, &SequenceBool::Next));

    EXPECT_EQ(Result::Ignore, state.onStage1(mock.context, mock.stage1));
    EXPECT_EQ(Result::Finish, state.onStage1(mock.context, mock.stage1));
}
```
# ..\node\solver\tests\mock\blake2.hpp 
```cpp 
#pragma once

inline void blake2s(const uint8_t*, size_t, const uint8_t*, size_t, void*, size_t)
{
}```
# ..\node\solver\tests\mock\callsqueuescheduler.hpp 
```cpp 
#pragma once

namespace slv2
{
    class CallsQueueScheduler
    {
    public:
        using ProcType = std::function<void()>;
        using CallTag = uintptr_t;

        CallsQueueScheduler() = default;

        CallsQueueScheduler(const CallsQueueScheduler&)
        {}

        constexpr static CallTag no_tag = 0;

    };
}```
# ..\node\solver\tests\mock\mockdata.hpp 
```cpp 
#pragma once

#include "SolverContext.h"
#include <states/TrustedStage1State.h>
#include <Consensus.h>
#include <csdb/pool.h>

#include <gtest/gtest.h>

struct MockData
{
    slv2::CallsQueueScheduler sched;
    BlockChain bc;
    cs::Hash hash;
    cs::Hash hash1;
    cs::Hash hash2;
    cs::Hash hash3;
    csdb::internal::byte_array pool_hash_data;
    csdb::internal::byte_array pool_hash_data_1;
    csdb::internal::byte_array pool_hash_data_2;
    csdb::internal::byte_array pool_hash_data_3;
    csdb::PoolHash pool_hash;
    csdb::PoolHash pool_hash_1;
    csdb::PoolHash pool_hash_2;
    csdb::PoolHash pool_hash_3;
    cs::StageOne stage1;
    cs::StageTwo stage2;
    cs::StageThree stage3;
    cs::PublicKey sender1;
    cs::PublicKey sender2;
    cs::PublicKey sender3;
    csdb::Pool tl;
    csdb::Pool block;
    csdb::Transaction trans;
    slv2::SolverContext context;

    std::vector<cs::StageOne> stage1_storage;
    std::vector<cs::StageTwo> stage2_storage;
    std::vector<cs::StageThree> stage3_storage;

    MockData()
    {
        std::string s("334431BE08B784BA87B153842D1B46308CC737B4D9EFD15952C3C426E599AA1E");
        std::string s1("1111111111111111111111111111111111111111111111111111111111111111");
        std::string s2("2222222222222222222222222222222222222222222222222222222222222222");
        std::string s3("3333333333333333333333333333333333333333333333333333333333333333");
        std::copy(s.cbegin(), s.cend(), hash.begin());
        std::copy(s1.cbegin(), s1.cend(), hash1.begin());
        std::copy(s2.cbegin(), s2.cend(), hash2.begin());
        std::copy(s3.cbegin(), s3.cend(), hash3.begin());
        std::string pk1("11111111111111111111111111111111");
        std::string pk2("22222222222222222222222222222222");
        std::string pk3("33333333333333333333333333333333");
        std::copy(pk1.cbegin(), pk1.cend(), sender1.begin());
        std::copy(pk2.cbegin(), pk2.cend(), sender2.begin());
        std::copy(pk3.cbegin(), pk3.cend(), sender3.begin());
        pool_hash_data.assign(std::begin(hash), std::end(hash));
        pool_hash_data_1.assign(std::begin(hash1), std::end(hash1));
        pool_hash_data_2.assign(std::begin(hash2), std::end(hash2));
        pool_hash_data_3.assign(std::begin(hash3), std::end(hash3));
        tl.set_sequence(1);
        block.set_sequence(1);
        memset(&stage1, 0, sizeof(stage1));
        stage1_storage.assign(Consensus::MinTrustedNodes, stage1);
        memset(&stage2, 0, sizeof(stage2));
        stage2_storage.assign(Consensus::MinTrustedNodes, stage2);
        memset(&stage3, 0, sizeof(stage3));
        stage3_storage.assign(Consensus::MinTrustedNodes, stage3);
        InitCalls();
    }

    void InitCalls()
    {
        using namespace ::testing;

        ON_CALL(context, is_block_deferred()).WillByDefault(Return(true));
        ON_CALL(context, blockchain()).WillByDefault(ReturnRef(bc));
        ON_CALL(context, cnt_trusted()).WillByDefault(Return(Consensus::MinTrustedNodes));
        ON_CALL(context, scheduler()).WillByDefault(ReturnRef(sched));
        ON_CALL(context, stage1_data()).WillByDefault(ReturnRef(stage1_storage));
        ON_CALL(context, stage2_data()).WillByDefault(ReturnRef(stage2_storage));
        ON_CALL(context, stage3_data()).WillByDefault(ReturnRef(stage3_storage));
        ON_CALL(context, stage1(0)).WillByDefault(Return(&stage1_storage.at(0)));
        ON_CALL(context, stage2(0)).WillByDefault(Return(&stage2_storage.at(0)));
        ON_CALL(context, stage3(0)).WillByDefault(Return(&stage3_storage.at(0)));

        //unsigned counter = 0;
        ON_CALL(bc, getLastHash())
            //.WillByDefault(Invoke([&counter, this]() -> csdb::PoolHash& {
            //    switch(++counter) {
            //    case 1:
            //        return pool_hash_1;
            //    case 2:
            //        return pool_hash_2;
            //    case 3:
            //        return pool_hash_3;
            //    default:
            //        break;
            //    }
            //    return pool_hash;
            //}));
            .WillByDefault(ReturnRef(pool_hash));

        ON_CALL(bc, getHashBySequence(0)).WillByDefault(ReturnRef(pool_hash));
        ON_CALL(bc, getHashBySequence(1)).WillByDefault(ReturnRef(pool_hash_1));
        ON_CALL(bc, getHashBySequence(2)).WillByDefault(ReturnRef(pool_hash_2));
        ON_CALL(bc, getHashBySequence(3)).WillByDefault(ReturnRef(pool_hash_3));

        ON_CALL(pool_hash, to_binary).WillByDefault(ReturnRef(pool_hash_data));

    }
};
```
# ..\node\solver\tests\mock\sodium.hpp 
```cpp 
#pragma once

inline void crypto_sign_detached(const uint8_t*, unsigned long long*, const uint8_t*, size_t, const uint8_t*)
{
}

inline int crypto_sign_verify_detached(const uint8_t*, const uint8_t*, size_t, const uint8_t*)
{
}


```
# ..\node\solver\tests\mock\solvercontext.hpp 
```cpp 
#pragma once

#include <gmock/gmock.h>
#include <CallsQueueScheduler.h>
#include <Stage.h>
#include <csdb/pool.h>
#include <csnode/blockchain.hpp>
#include <lib/system/hash.hpp>
#include <Solver/Solver.hpp>
#include <Solver/WalletsState.h>
#include <csnode/conveyer.hpp>

namespace slv2
{
    class SolverContext
    {
    public:

        MOCK_METHOD2(add_stage1, void(const cs::StageOne&, bool));
        MOCK_METHOD2(add_stage2, void(const cs::StageTwo&, bool));
        MOCK_METHOD2(add_stage3, void(const cs::StageThree&, bool));
        MOCK_CONST_METHOD0(enough_stage1, bool());
        MOCK_CONST_METHOD0(enough_stage2, bool());
        MOCK_CONST_METHOD0(enough_stage3, bool());
        MOCK_METHOD0(complete_stage2, void());
        MOCK_METHOD0(complete_stage3, void());
        MOCK_CONST_METHOD2(request_stage1, void(uint8_t, uint8_t));
        MOCK_CONST_METHOD2(request_stage2, void(uint8_t, uint8_t));
        MOCK_CONST_METHOD0(stage1_data, std::vector<cs::StageOne>& ());
        MOCK_CONST_METHOD0(stage2_data, std::vector<cs::StageTwo>& ());
        MOCK_CONST_METHOD0(stage3_data, std::vector<cs::StageThree>& ());
        MOCK_CONST_METHOD1(stage1, cs::StageOne* (uint8_t));
        MOCK_CONST_METHOD1(stage2, cs::StageTwo* (uint8_t));
        MOCK_CONST_METHOD1(stage3, cs::StageThree* (uint8_t));
        MOCK_CONST_METHOD0(cnt_trusted, size_t());
        //MOCK_CONST_METHOD0(role, slv2::Role());

        MOCK_CONST_METHOD0(is_block_deferred, bool());
        MOCK_METHOD0(flush_deferred_block, void());
        MOCK_METHOD0(drop_deferred_block, void());
        MOCK_METHOD2(store_received_block, void(csdb::Pool&, bool));
        MOCK_METHOD0(last_block_hash, cs::Hash());
        MOCK_METHOD2(send_hash, void(const cs::Hash&, const cs::PublicKey&));

        MOCK_CONST_METHOD0(blockchain, BlockChain&());
        MOCK_CONST_METHOD0(wallets, cs::WalletsState&());
        MOCK_CONST_METHOD0(scheduler, slv2::CallsQueueScheduler&());
        MOCK_METHOD1(update_fees, void(cs::TransactionsPacket&));
        MOCK_METHOD1(accept_transactions, void(const csdb::Pool&));

        MOCK_CONST_METHOD0(round, size_t());
        MOCK_CONST_METHOD0(own_conf_number, uint8_t());
        MOCK_CONST_METHOD0(is_spammer, bool());
        MOCK_CONST_METHOD0(address_spammer, csdb::Address());
    };

}
```
# ..\node\solver\tests\mock\timeouttracking.hpp 
```cpp 
#pragma once

#include <gmock/gmock.h>
#include <CallsQueueScheduler.h>

namespace slv2
{
    class TimeoutTracking
    {
    public:

        TimeoutTracking() = default;

        TimeoutTracking(const TimeoutTracking&)
        {}

        MOCK_METHOD4(start, void(CallsQueueScheduler&, size_t, CallsQueueScheduler::ProcType, bool));
        MOCK_METHOD0(cancel, bool());
    };
}```
# ..\node\solver\tests\mock\csdb\pool.hpp 
```cpp 
#pragma once

#include <gmock/gmock.h>
#include <vector>
#include <cstdint>
#include <lib/system/common.hpp>

namespace csdb
{
    class PoolHash
    {
    public:

        PoolHash() = default;
        PoolHash(const PoolHash&)
        {}

        MOCK_METHOD0(to_binary, cs::Bytes&());
    };

    class Address
    {
    public:
        using WalletId = uint32_t;

        Address() = default;
        Address(const Address&)
        {}

        MOCK_CONST_METHOD0(is_wallet_id, bool());
        MOCK_CONST_METHOD0(wallet_id, WalletId());
        MOCK_CONST_METHOD0(public_key, const cs::Bytes&());
    };

    class Amount
    {
    public:
        Amount() = default;
        Amount(const Amount&)
        {}

        MOCK_CONST_METHOD0(to_double, double());
    };

    class Transaction
    {
    public:
        Transaction() = default;
        Transaction(const Transaction&)
        {}

        MOCK_CONST_METHOD0(innerID, int64_t());
        MOCK_CONST_METHOD0(source, Address());
        MOCK_CONST_METHOD0(target, Address());
        MOCK_CONST_METHOD0(amount, Amount());
        MOCK_CONST_METHOD1(verify_signature, bool(cs::Bytes));
    };

    class Pool
    {
    public:
        Pool() = default;

        Pool(const Pool&)
        {}

        Pool& operator=(const Pool&)
        {
            return *this;
        }

        MOCK_CONST_METHOD0(sequence, size_t());
        MOCK_METHOD1(set_sequence, void(size_t));
        MOCK_CONST_METHOD0(transactions_count, size_t());
        MOCK_CONST_METHOD0(transactions, const std::vector<Transaction>());
        MOCK_METHOD0(verify_signature, bool());
        MOCK_METHOD1(add_transaction, void(const Transaction));
        MOCK_CONST_METHOD0(writer_public_key, cs::Bytes());
    };

}
```
# ..\node\solver\tests\mock\csnode\blockchain.hpp 
```cpp 
#pragma once

#include <csnode/WalletsCache.h>
#include <csdb/pool.h>

class BlockChain
{
public:
    using WalletData = cs::WalletsCache::WalletData;

    BlockChain()
    {}

    BlockChain(const BlockChain &)
    {}

    MOCK_METHOD0(getLastHash, csdb::PoolHash&());
    MOCK_METHOD1(getHashBySequence, csdb::PoolHash&(uint32_t));
    MOCK_METHOD0(getLastSequence, size_t());
    MOCK_CONST_METHOD2(findWalletData, void(const csdb::Address::WalletId, WalletData&));

};
```
# ..\node\solver\tests\mock\csnode\conveyer.hpp 
```cpp 
#pragma once

#include <gmock/gmock.h>
#include <vector>

namespace cs
{
    class TransactionsPacket
    {
    public:
        MOCK_CONST_METHOD0(transactions, std::vector<csdb::Transaction>());
        MOCK_METHOD1(addTransaction, bool(const csdb::Transaction&));
        MOCK_CONST_METHOD0(transactionsCount, size_t());
    };

    class Characteristic
    {
    public:
        cs::Bytes mask;
    };

    struct RoundTable
    {
        size_t round = 0;
        PublicKey general;
        std::vector<PublicKey> confidants;
        std::vector<Hash> hashes;
    };

    class Conveyer
    {
    public:

        static Conveyer& instance()
        {
            static Conveyer impl;
            return impl;
        }

        MOCK_CONST_METHOD0(roundTable, RoundTable&());
        MOCK_CONST_METHOD0(transactionsPacketTable, std::set<Hash>&());
        MOCK_CONST_METHOD1(packet, TransactionsPacket&(Hash));
        MOCK_CONST_METHOD1(setCharacteristic, void(const cs::Characteristic&));
    };
}
```
# ..\node\solver\tests\mock\csnode\csnode.hpp 
```cpp 
#pragma once

class Node
{
public:
};
```
# ..\node\solver\tests\mock\csnode\transactionspacket.hpp 
```cpp 
#pragma once```
# ..\node\solver\tests\mock\csnode\walletscache.hpp 
```cpp 
#pragma once

#include <array>

namespace cs
{
    class WalletsCache
    {
    public:

        struct WalletData
        {
            using Address = std::array<uint8_t, 32>;
            Address address_;
        };
    };
}
```
# ..\node\solver\tests\mock\Solver\solver.hpp 
```cpp 
#pragma once
#include <gmock/gmock.h>
#include <cstdint>

constexpr const size_t MAX_CONF_NUMBER = 5;

class Node;
namespace csdb
{
    class Pool;
}

namespace cs
{
    class Fee
    {
    public:

        MOCK_METHOD2(CountFeesInPool, void(const Node*, const csdb::Pool*));
    };

    class Solver
	{
	public:
	};
}```
# ..\node\solver\tests\mock\Solver\transactionsvalidator.hpp 
```cpp 
#pragma once
#include <gmock/gmock.h>
#include <csdb/pool.h>
#include <Solver/WalletsState.h>

namespace cs
{

    class TransactionsValidator
    {
    public:

        struct Config
        {};

        TransactionsValidator(const cs::WalletsState&, const Config&)
        {}

        MOCK_METHOD1(reset, void(size_t));
        MOCK_METHOD3(validateTransaction, bool(csdb::Transaction, size_t, uint8_t&));
        MOCK_METHOD3(validateByGraph, void(cs::Bytes&, const std::vector<csdb::Transaction>&, const csdb::Pool&));
    };

}
```
# ..\node\solver\tests\mock\Solver\walletsstate.hpp 
```cpp 
#pragma once
#include <gmock/gmock.h>

namespace cs
{
    class WalletsState
    {
    public:
        
        MOCK_METHOD0(updateFromSource, void());
    };
}```
# ..\node\tests\csnode\clientconfigmock.hpp 
```cpp 
//
// Created by User on 01.10.2018.
//

#ifndef PROJECT_MOCKCLIENTCONFIG_HPP
#define PROJECT_MOCKCLIENTCONFIG_HPP

#include <gmock/gmock.h>
#include <string>
#include <vector>
#include "config.hpp"

class MockConfig : public Config {
public:
  MOCK_CONST_METHOD0(getInputEndpoint, const EndpointData&());
  MOCK_CONST_METHOD0(getOutputEndpoint, const EndpointData&());

  MOCK_CONST_METHOD0(getSignalServerEndpoint, const EndpointData&());

  MOCK_CONST_METHOD0(getBootstrapType, BootstrapType());
  MOCK_CONST_METHOD0(getNodeType, NodeType());
  MOCK_CONST_METHOD0(getIpList, const std::vector<EndpointData>&());

  MOCK_CONST_METHOD0(getMyPublicKey, const cs::PublicKey&());
  MOCK_CONST_METHOD0(getPathToDB, const std::string&());

  MOCK_METHOD0(isGood, bool());

  MOCK_CONST_METHOD0(useIPv6, bool());
  MOCK_CONST_METHOD0(hasTwoSockets, bool());

  MOCK_CONST_METHOD0(isSymmetric, bool());
  MOCK_CONST_METHOD0(getAddressEndpoint, const EndpointData&());
};

#endif  // PROJECT_MOCKCLIENTCONFIG_HPP
```
# ..\node\tests\csnode\conveyer_tests.cpp 
```cpp 
#include <gtest/gtest.h>
#include <csdb/amount_commission.hpp>
#include <csdb/currency.hpp>
#include <csnode/conveyer.hpp>
#include <iostream>

#include <lib/system/hash.hpp>

const cs::RoundNumber kRoundNumber = 12345;
const cs::PublicKey kPublicKey = {0x53, 0x4B, 0xD3, 0xDF, 0x77, 0x29, 0xFD, 0xCF, 0xEA, 0x4A, 0xCD, 0x0E, 0xCC, 0x14, 0xAA, 0x05,
                                  0x0B, 0x77, 0x11, 0x6D, 0x8F, 0xCD, 0x80, 0x4B, 0x45, 0x36, 0x6B, 0x5C, 0xAE, 0x4A, 0x06, 0x82};

const cs::ConfidantsKeys kConfidantsKeys = {{0X53, 0X4B, 0XD3, 0XDF, 0X77, 0X29, 0XFD, 0XCF, 0XEA, 0X4A, 0XCD, 0X0E, 0XCC, 0X14, 0XAA, 0X05,
                                             0X0B, 0X77, 0X11, 0X6D, 0X8F, 0XCD, 0X80, 0X4B, 0X45, 0X36, 0X6B, 0X5C, 0XAE, 0X4A, 0X06, 0X82},
                                            {0X53, 0X4B, 0XD3, 0XDF, 0X77, 0X29, 0XFD, 0XCF, 0XEA, 0X4A, 0XCD, 0X0E, 0XCC, 0X14, 0XAA, 0X05,
                                             0X0B, 0X77, 0X11, 0X6D, 0X8F, 0XCD, 0X80, 0X4B, 0X45, 0X36, 0X6B, 0X5C, 0XAE, 0X4A, 0X06, 0X82},
                                            {0X53, 0X4B, 0XD3, 0XDF, 0X77, 0X29, 0XFD, 0XCF, 0XEA, 0X4A, 0XCD, 0X0E, 0XCC, 0X14, 0XAA, 0X05,
                                             0X0B, 0X77, 0X11, 0X6D, 0X8F, 0XCD, 0X80, 0X4B, 0X45, 0X36, 0X6B, 0X5C, 0XAE, 0X4A, 0X06, 0X82},
                                            {0X53, 0X4B, 0XD3, 0XDF, 0X77, 0X29, 0XFD, 0XCF, 0XEA, 0X4A, 0XCD, 0X0E, 0XCC, 0X14, 0XAA, 0X05,
                                             0X0B, 0X77, 0X11, 0X6D, 0X8F, 0XCD, 0X80, 0X4B, 0X45, 0X36, 0X6B, 0X5C, 0XAE, 0X4A, 0X06, 0X82},
                                            {0X53, 0X4B, 0XD3, 0XDF, 0X77, 0X29, 0XFD, 0XCF, 0XEA, 0X4A, 0XCD, 0X0E, 0XCC, 0X14, 0XAA, 0X05,
                                             0X0B, 0X77, 0X11, 0X6D, 0X8F, 0XCD, 0X80, 0X4B, 0X45, 0X36, 0X6B, 0X5C, 0XAE, 0X4A, 0X06, 0X82},
                                            {0X53, 0X4B, 0XD3, 0XDF, 0X77, 0X29, 0XFD, 0XCF, 0XEA, 0X4A, 0XCD, 0X0E, 0XCC, 0X14, 0XAA, 0X05,
                                             0X0B, 0X77, 0X11, 0X6D, 0X8F, 0XCD, 0X80, 0X4B, 0X45, 0X36, 0X6B, 0X5C, 0XAE, 0X4A, 0X06, 0X82},
                                            {0X53, 0X4B, 0XD3, 0XDF, 0X77, 0X29, 0XFD, 0XCF, 0XEA, 0X4A, 0XCD, 0X0E, 0XCC, 0X14, 0XAA, 0X05,
                                             0X0B, 0X77, 0X11, 0X6D, 0X8F, 0XCD, 0X80, 0X4B, 0X45, 0X36, 0X6B, 0X5C, 0XAE, 0X4A, 0X06, 0X82}};

const cs::Characteristic kCharacteristic = {{0xEE, 0xEE, 0xEd}};

namespace cs {
bool operator==(const cs::RoundTable& left, const cs::RoundTable& right) {
    auto round_is_equal = left.round == right.round, general_is_equal = left.general == right.general, confidants_is_equal = left.confidants == right.confidants,
         hashes_is_equal = left.hashes == right.hashes, charBytes_is_equal = left.characteristic.mask == right.characteristic.mask;

    return round_is_equal && general_is_equal && confidants_is_equal && hashes_is_equal && charBytes_is_equal;
}

bool operator==(const cs::Characteristic& left, const cs::Characteristic& right) {
    return left.mask == right.mask;
}
}  // namespace cs

namespace csdb {
bool operator==(const csdb::Transaction& left, const csdb::Transaction& right) {
    auto innerIdResult = left.innerID() == right.innerID();
    auto idResult = left.id() == right.id();
    auto signatureResult = left.signature() == right.signature();
    auto sourceResult = left.source() == right.source();
    auto currencyResult = left.currency() == right.currency();
    auto targetResult = left.target() == right.target();
    auto feeResult = left.max_fee().to_double() == right.max_fee().to_double();
    auto countedFeeResult = left.counted_fee().to_double() == right.counted_fee().to_double();

    return innerIdResult && idResult && signatureResult && sourceResult && currencyResult && targetResult && feeResult & countedFeeResult;
}
}  // namespace csdb

csdb::Transaction CreateTestTransaction(const int64_t id, const uint8_t amount) {
    cs::Signature sign;
    sign.fill(0);

    csdb::Transaction transaction{id,
                                  csdb::Address::from_public_key(cs::PublicKey{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                                                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}),
                                  csdb::Address::from_public_key(cs::PublicKey{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                                                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02}),
                                  csdb::Currency{amount},
                                  csdb::Amount{0, 0},
                                  csdb::AmountCommission{0.},
                                  csdb::AmountCommission{0.},
                                  sign};

    return transaction;
}

auto CreateTestPacket(const size_t number_of_transactions) {
    cs::TransactionsPacket packet;

    for (size_t i = 0; i < number_of_transactions; ++i) {
        size_t value = 0x1234567800000001;
        packet.addTransaction(CreateTestTransaction(static_cast<int64_t>(value + i), static_cast<uint8_t>(1)));
    }

    packet.makeHash();
    cslog() << "hash = " << packet.hash().toString();
    return packet;
}

auto CreateTestRoundTable(const cs::PacketsHashes& hashes) {
    return cs::RoundTable{kRoundNumber, kPublicKey, kConfidantsKeys, hashes, kCharacteristic};
}

TEST(TransactionsEqualityOperator, SameAreEqual) {
    auto transaction1 = CreateTestTransaction(123, uint8_t{45}), transaction2 = transaction1;
    ASSERT_EQ(transaction1, transaction2);
    ASSERT_TRUE(transaction1 == transaction2);
}

TEST(TransactionsEqualityOperator, DifferentId) {
    ASSERT_FALSE(CreateTestTransaction(123, uint8_t{45}) == CreateTestTransaction(321, uint8_t{45}));
}

TEST(TransactionsEqualityOperator, DifferentAmount) {
    ASSERT_FALSE(CreateTestTransaction(123, uint8_t{45}) == CreateTestTransaction(123, uint8_t{00}));
}

class ConveyerTest : public cs::ConveyerBase {
public:
    ConveyerTest()
    : ConveyerBase() {
    }
    ~ConveyerTest() = default;
};

TEST(Conveyer, RoundTableReturnsNullIfRoundDoesNotExist) {
    ConveyerTest conveyer{};
    ASSERT_EQ(conveyer.roundTable(1), nullptr);
}

TEST(Conveyer, GetCharacteristicReturnsNullIfConveyerHasNoMeta) {
    ConveyerTest conveyer{};
    const auto kAnyRoundNumber{123};
    ASSERT_EQ(nullptr, conveyer.characteristic(kAnyRoundNumber));
}

TEST(Conveyer, RoundTableReturnsSameAsThatWasSetWithSetRound) {
    ConveyerTest conveyer{};
    auto round_table{CreateTestRoundTable({CreateTestPacket(2).hash()})};
    auto&& round_table_copy{cs::RoundTable{round_table}};
    conveyer.setRound(round_table.round);
    conveyer.setTable(round_table_copy);
    ASSERT_EQ(round_table, conveyer.currentRoundTable());
}

TEST(Conveyer, SetRoundDoesNotSetInvalidRoundNumber) {
    ConveyerTest conveyer{};
    auto&& round_table{CreateTestRoundTable({CreateTestPacket(2).hash()})};
    auto&& incorrect_round_table{cs::RoundTable{round_table}};
    conveyer.setTable(std::move(round_table));
    ASSERT_EQ(round_table.round, conveyer.currentRoundNumber());
    incorrect_round_table.round = round_table.round - 1;
    conveyer.setTable(std::move(incorrect_round_table));
    ASSERT_EQ(round_table.round, conveyer.currentRoundNumber());
    incorrect_round_table.round = 0;
    conveyer.setTable(std::move(incorrect_round_table));
    ASSERT_EQ(round_table.round, conveyer.currentRoundNumber());
}

TEST(Conveyer, RoundTableReturnsNullIfRoundWasNotAdded) {
    ConveyerTest conveyer{};
    auto&& round_table{CreateTestRoundTable({CreateTestPacket(2).hash()})};
    conveyer.setTable(std::move(round_table));
    ASSERT_EQ(conveyer.roundTable(1), nullptr);
}

TEST(Conveyer, AddTransaction) {
    ConveyerTest conveyer{};
    auto transaction{CreateTestTransaction(3, 1)};
    conveyer.addTransaction(transaction);
    auto& transactions_block = conveyer.packetQueue();
    ASSERT_EQ(1, conveyer.packetQueue().size());
    auto packet{cs::TransactionsPacket{}};
    packet.addTransaction(transaction);
    ASSERT_EQ(packet.toBinary(), transactions_block.back().toBinary());
}

TEST(Conveyer, TransactionPacketTableIsEmptyAtCreation) {
    constexpr auto size = 0;
    ConveyerTest conveyer{};
    auto& table = conveyer.transactionsPacketTable();
    ASSERT_EQ(table.size(), size);
}

TEST(Conveyer, CanSuccessfullyAddTransactionsPacket) {
    ConveyerTest conveyer{};
    auto packet = CreateTestPacket(2);
    conveyer.addTransactionsPacket(packet);
    auto& table{conveyer.transactionsPacketTable()};
    ASSERT_EQ(table.at(packet.hash()).toBinary(cs::TransactionsPacket::Serialization::Transactions), packet.toBinary(cs::TransactionsPacket::Serialization::Transactions));
}

TEST(Conveyer, CanAddTransactionToLastBlock) {
    ConveyerTest conveyer{};
    auto& table = conveyer.packetQueue();
    ASSERT_TRUE(table.isEmpty());
    auto transaction1 = CreateTestTransaction(1, 1), transaction2 = CreateTestTransaction(2, 1);
    conveyer.addTransaction(transaction1);
    conveyer.addTransaction(transaction2);
    ASSERT_EQ(1, table.size());
    ASSERT_EQ(2, table.back().transactionsCount());
    ASSERT_EQ(transaction1, table.back().transactions().at(0));
    ASSERT_EQ(transaction2, table.back().transactions().at(1));
}

TEST(Conveyer, MainLogic) {
    auto packet = CreateTestPacket(20);
    auto&& packet_copy{cs::TransactionsPacket{packet}};
    ConveyerTest conveyer{};

    auto hash = packet_copy.hash();
    auto table = CreateTestRoundTable({packet_copy.hash()});

    conveyer.setTable(table);
    ASSERT_EQ(1, conveyer.currentNeededHashes().size());

    conveyer.addFoundPacket(kRoundNumber, std::move(packet_copy));
    ASSERT_TRUE(conveyer.currentNeededHashes().empty());
    ASSERT_TRUE(conveyer.isSyncCompleted());

    auto created_packet{conveyer.createPacket()};
    ASSERT_TRUE(created_packet.has_value());
    ASSERT_EQ(packet.transactionsCount(), created_packet.value().first.transactionsCount());

    created_packet.value().first.makeHash();
    ASSERT_EQ(packet.hash(), created_packet.value().first.hash());

    const auto characteristic{cs::Characteristic{{0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}}};
    conveyer.setCharacteristic(characteristic, kRoundNumber);

    cs::Hash expectedHash = generateHash(characteristic.mask.data(), characteristic.mask.size());

    ASSERT_EQ(characteristic, *conveyer.characteristic(kRoundNumber));

    auto characteristic_hash = conveyer.characteristicHash(kRoundNumber);

    ASSERT_EQ(characteristic_hash, expectedHash);

    cs::PublicKey pk;
    pk.fill(0);

    csdb::PoolHash ph;
    cs::PoolMetaInfo pool_meta_info{"1542617459297", pk, ph, kRoundNumber, cs::Bytes{}, std::vector<csdb::Pool::SmartSignature>{}, {}, {}};

    auto pool{conveyer.applyCharacteristic(pool_meta_info)};

    ASSERT_TRUE(pool.has_value());
    ASSERT_EQ(3, pool.value().transactions_count());
    ASSERT_EQ(packet.transactions().at(2), pool.value().transaction(0));
    ASSERT_EQ(packet.transactions().at(9), pool.value().transaction(1));
    ASSERT_EQ(packet.transactions().at(16), pool.value().transaction(2));
}
```
# ..\node\tests\csnode\cyclicbuffer_tests.cpp 
```cpp 

//#define TESTING

#include <gtest/gtest.h>
#include "cyclicbuffer.hpp"

TEST(CyclicBuffer, EmptyAfterCreation) {
    CyclicBuffer<int, 10> buffer;
    ASSERT_TRUE(buffer.empty());
}

TEST(CyclicBuffer, NotEmptyAfterElementAddedToBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1);
    ASSERT_FALSE(buffer.empty());
}

TEST(CyclicBuffer, NotEmptyAfterElementAddedToFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1);
    ASSERT_FALSE(buffer.empty());
}

TEST(CyclicBuffer, EmptyAfterElementAddedToBackAndPoppedFromBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1);
    buffer.pop_back();
    ASSERT_TRUE(buffer.empty());
}

TEST(CyclicBuffer, EmptyAfterElementAddedToFrontAndPoppedFromFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1);
    buffer.pop_front();
    ASSERT_TRUE(buffer.empty());
}

TEST(CyclicBuffer, EmptyAfterElementAddedToFrontAndPoppedFromBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1);
    buffer.pop_back();
    ASSERT_TRUE(buffer.empty());
}

TEST(CyclicBuffer, EmptyAfterElementAddedToBackAndPoppedFromFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1);
    buffer.pop_front();
    ASSERT_TRUE(buffer.empty());
}

TEST(CyclicBuffer, NotEmptyAfterTwoElementsAddedToFrontAndOnePoppedFromFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.pop_front();
    ASSERT_FALSE(buffer.empty());
}

TEST(CyclicBuffer, NotEmptyAfterTwoElementsAddedToFrontAndOnePoppedFromBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.pop_back();
    ASSERT_FALSE(buffer.empty());
}

TEST(CyclicBuffer, NotEmptyAfterTwoElementsAddedToBackAndOnePoppedFromFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.pop_front();
    ASSERT_FALSE(buffer.empty());
}

TEST(CyclicBuffer, NotEmptyAfterTwoElementsAddedToBackAndOnePoppedFromBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.pop_back();
    ASSERT_FALSE(buffer.empty());
}

TEST(CyclicBuffer, PeekedFromBackIsEqualToPushedToBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1234);
    ASSERT_EQ(1234, buffer.back());
}

TEST(CyclicBuffer, PeekedFromBackIsEqualToPushedToFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1234);
    ASSERT_EQ(1234, buffer.back());
}

TEST(CyclicBuffer, PeekedFromFrontIsEqualToPushedToFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1234);
    ASSERT_EQ(1234, buffer.front());
}

TEST(CyclicBuffer, PeekedFromFrontIsEqualToPushedToBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1234);
    ASSERT_EQ(1234, buffer.front());
}

TEST(CyclicBuffer, SizeIsZeroAfterCreation) {
    CyclicBuffer<int, 10> buffer;
    ASSERT_EQ(buffer.size(), 0);
}

TEST(CyclicBuffer, SizeIsEqualToNumberOfPushedToBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.push_back(3);
    buffer.push_back(4);
    buffer.push_back(5);
    ASSERT_EQ(buffer.size(), 5);
}

TEST(CyclicBuffer, SizeIsEqualToNumberOfPushedToFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.push_front(3);
    ASSERT_EQ(buffer.size(), 3);
}

TEST(CyclicBuffer, SizeIsCorrectAfterPushingToBackAndPoppngFromBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.pop_back();
    ASSERT_EQ(buffer.size(), 1);
}

TEST(CyclicBuffer, SizeIsCorrectAfterPushingToBackAndPoppngFromFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.pop_front();
    ASSERT_EQ(buffer.size(), 1);
}

TEST(CyclicBuffer, SizeIsCorrectAfterPushingToFrontAndPoppngFromFront) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.pop_front();
    ASSERT_EQ(buffer.size(), 1);
}

TEST(CyclicBuffer, SizeIsCorrectAfterPushingToFrontAndPoppngFromBack) {
    CyclicBuffer<int, 10> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.pop_back();
    ASSERT_EQ(buffer.size(), 1);
}

TEST(CyclicBuffer, ElementsAreCorrectlyAccessibleByIndexAfterPushedToBack) {
    CyclicBuffer<int, 20> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.push_back(3);
    buffer.push_back(7);
    buffer.push_back(125);
    ASSERT_EQ(1, buffer[0]);
    ASSERT_EQ(2, buffer[1]);
    ASSERT_EQ(3, buffer[2]);
    ASSERT_EQ(7, buffer[3]);
    ASSERT_EQ(125, buffer[4]);
}

TEST(CyclicBuffer, ElementsAreCorrectlyAccessibleByIndexAfterPushedToFront) {
    CyclicBuffer<int, 20> buffer;
    buffer.push_front(6);
    buffer.push_front(7);
    buffer.push_front(8);
    buffer.push_front(22);
    buffer.push_front(324);
    ASSERT_EQ(6, buffer[4]);
    ASSERT_EQ(7, buffer[3]);
    ASSERT_EQ(8, buffer[2]);
    ASSERT_EQ(22, buffer[1]);
    ASSERT_EQ(324, buffer[0]);
}

TEST(CyclicBuffer, BufferIsNotFullAfterCreation) {
    CyclicBuffer<int, 10> buffer;
    ASSERT_FALSE(buffer.full());
}

TEST(CyclicBuffer, BufferIsFullAfterMaxElementsWerePushedToBack) {
    CyclicBuffer<int, 6> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.push_back(3);
    buffer.push_back(4);
    buffer.push_back(5);
    buffer.push_back(6);
    ASSERT_TRUE(buffer.full());
}

TEST(CyclicBuffer, BufferIsFullAfterMaxElementsWerePushedToFront) {
    CyclicBuffer<int, 4> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.push_front(3);
    buffer.push_front(4);
    ASSERT_TRUE(buffer.full());
}

TEST(CyclicBuffer, BufferIsFullAfterMaxElementsWerePushedToBackAndFront) {
    CyclicBuffer<int, 4> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.push_front(3);
    buffer.push_front(4);
    ASSERT_TRUE(buffer.full());
}

TEST(CyclicBuffer, BufferIsFullAfterMaxElementsWerePushedToFrontAndBack) {
    CyclicBuffer<int, 4> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.push_back(3);
    buffer.push_back(4);
    ASSERT_TRUE(buffer.full());
}

TEST(CyclicBuffer, BufferIsNotFullAfterMaxElementsWerePushedToBackAndThenOnePoppedFromBack) {
    CyclicBuffer<int, 4> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.push_back(3);
    buffer.push_back(4);
    buffer.pop_back();
    ASSERT_FALSE(buffer.full());
}

TEST(CyclicBuffer, BufferIsNotFullAfterMaxElementsWerePushedToBackAndThenOnePoppedFromFront) {
    CyclicBuffer<int, 4> buffer;
    buffer.push_back(1);
    buffer.push_back(2);
    buffer.push_back(3);
    buffer.push_back(4);
    buffer.pop_front();
    ASSERT_FALSE(buffer.full());
}

TEST(CyclicBuffer, BufferIsNotFullAfterMaxElementsWerePushedToFrontAndThenOnePoppedFromBack) {
    CyclicBuffer<int, 4> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.push_front(3);
    buffer.push_front(4);
    buffer.pop_back();
    ASSERT_FALSE(buffer.full());
}

TEST(CyclicBuffer, BufferIsNotFullAfterMaxElementsWerePushedToFrontAndThenOnePoppedFromFront) {
    CyclicBuffer<int, 4> buffer;
    buffer.push_front(1);
    buffer.push_front(2);
    buffer.push_front(3);
    buffer.push_front(4);
    buffer.pop_front();
    ASSERT_FALSE(buffer.full());
}
```
# ..\node\tests\csnode\datastream_tests.cpp 
```cpp 
#include <gtest/gtest.h>
#include "datastream.hpp"

TEST(DataStream, DataPointerIsCorrectAfterCreation) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    ASSERT_EQ(stream.data(), data);
}

TEST(DataStream, SizeIsCorrect) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    ASSERT_EQ(stream.size(), sizeof data);
}

TEST(DataStream, IsValidAfterCreation) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    ASSERT_TRUE(stream.isValid());
}

TEST(DataStream, IsAvailableReturnsTrueIfRequestedEnough) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    ASSERT_TRUE(stream.isAvailable(8));
}

TEST(DataStream, IsAvailableReturnsTrueIfRequestedZero) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    ASSERT_TRUE(stream.isAvailable(0));
}

TEST(DataStream, IsAvailableReturnsFalseIfRequestedTooMany) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    ASSERT_FALSE(stream.isAvailable(9));
}

TEST(DataStream, MustGetCorrectStdArrayFromStream) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    auto result_array = stream.parseArray<char, sizeof data>();
    ASSERT_EQ(result_array[7], '\0');
    ASSERT_EQ(8, result_array.size());
    std::array<char, 8> test_array = {'1', '2', '3', '4', '5', '6', '7', '\0'};
    ASSERT_EQ(test_array, result_array);
}

TEST(DataStream, MustGetZeroFilledStdArrayIfRequestedMoreThanAvailable) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    auto result_array = stream.parseArray<char, 10>();
    ASSERT_EQ(result_array.size(), 10);
    for (auto i = 0u; i < result_array.size(); ++i) {
        ASSERT_EQ(result_array[i], 0);
    }
}

TEST(DataStream, EndPointWithIp4AndPortIsCorrectlyWritrenToStream) {
    cs::Bytes bytes;
    cs::DataStream stream(bytes);
    boost::asio::ip::udp::endpoint endpoint(boost::asio::ip::address::from_string("127.0.0.1"), 80);
    stream.addEndpoint(endpoint);
    const char encoded[7] = {0x06, 0x7f, 0x00, 0x00, 0x01, 0x50, 0x00};
    ASSERT_EQ(stream.size(), 7);
    ASSERT_TRUE(0 == memcmp(encoded, stream.data(), sizeof encoded));
}

TEST(DataStream, EndPointWithIp4AndPortIsCorrectlyReadFromStream) {
    char data[] = {0x06, 0x7f, 0x00, 0x00, 0x01, 0x50, 0x00};
    cs::DataStream stream(data, sizeof data);
    boost::asio::ip::udp::endpoint endpoint = stream.parseEndpoint();
    ASSERT_EQ(endpoint.address(), boost::asio::ip::address::from_string("127.0.0.1"));
    ASSERT_EQ(endpoint.port(), 80);
}

TEST(DataStream, EmptyEndPointIsCorrectlyReadFromStream) {
    char data[] = {0x00};
    cs::DataStream stream(data, sizeof data);
    boost::asio::ip::udp::endpoint endpoint = stream.parseEndpoint();
    ASSERT_EQ(endpoint.address(), boost::asio::ip::address());
    ASSERT_EQ(endpoint.port(), 0);
}

TEST(DataStream, EndPointWithOnlyIp4IsCorrectlyReadFromStream) {
    char data[] = {0x02, 0x7f, 0x00, 0x00, 0x01, 0x00};
    cs::DataStream stream(data, sizeof data);
    boost::asio::ip::udp::endpoint endpoint = stream.parseEndpoint();
    ASSERT_EQ(endpoint.address(), boost::asio::ip::address::from_string("127.0.0.1"));
    ASSERT_EQ(endpoint.port(), 0);
}

TEST(DataStream, EndPointWithOnlyPortIsCorrectlyReadFromStream) {
    char data[] = {0x04, 0x7f, 0x00};
    cs::DataStream stream(data, sizeof data);
    boost::asio::ip::udp::endpoint endpoint = stream.parseEndpoint();
    ASSERT_EQ(endpoint.address(), boost::asio::ip::address());
    ASSERT_EQ(endpoint.port(), 127);
}

TEST(DataStream, Int32ValueIsCorrectylyReadFromStream) {
    char data[] = {0x78, 0x56, 0x34, 0x12};
    cs::DataStream stream(data, sizeof data);
    auto value = stream.parseValue<int32_t>();
    ASSERT_EQ(value, 0x12345678);
}

TEST(DataStream, Int32ValueIsCorrectylyWrittenToStream) {
    cs::Bytes bytes;
    cs::DataStream stream(bytes);
    int32_t value = 0x12345678;
    stream.addValue<int32_t>(value);
    ASSERT_EQ(bytes, cs::Bytes({0x78, 0x56, 0x34, 0x12}));
}

TEST(DataStream, ByteArrayIsCorrectlyWrittenToStream) {
    cs::Bytes bytes;
    cs::DataStream stream(bytes);
    cs::ByteArray<8> array = {0, 1, 2, 3, 4, 5, 5, 145};
    stream.addArray(array);
    ASSERT_EQ(bytes, cs::Bytes({0, 1, 2, 3, 4, 5, 5, 145}));
}

TEST(DataStream, ByteArrayIsCorrectlyReadFromStream) {
    char data[] = {0x78, 0x56, 0x34, 0x12};
    cs::DataStream stream(data, sizeof data);
    auto value = stream.parseArray<char, 4>();
    ASSERT_EQ(value.size(), 4);
    ASSERT_EQ(value[0], 0x78);
    ASSERT_EQ(value[1], 0x56);
    ASSERT_EQ(value[2], 0x34);
    ASSERT_EQ(value[3], 0x12);
}

TEST(DataStream, MustGetZeroFilledByteArrayIfRequestedTooMany) {
    char data[] = {0x78, 0x56, 0x34, 0x12};
    cs::DataStream stream(data, sizeof data);
    auto value = stream.parseArray<char, 5>();
    ASSERT_EQ(value.size(), 5);
    ASSERT_EQ(value[0], 0);
    ASSERT_EQ(value[1], 0);
    ASSERT_EQ(value[2], 0);
    ASSERT_EQ(value[3], 0);
    ASSERT_EQ(value[4], 0);
}

TEST(DataStream, CorrectlySkipsRequestedNumberOfBytes) {
    char data[8] = "1234567";
    cs::DataStream stream(data, sizeof data);
    ASSERT_TRUE(stream.isAvailable(8));
    stream.skip<3>();
    ASSERT_TRUE(stream.isAvailable(5));
    stream.skip<4>();
    ASSERT_TRUE(stream.isAvailable(1));
    stream.skip<1>();
    ASSERT_FALSE(stream.isAvailable(1));
}

TEST(DataStream, CorrectValuesSerialization) {
    int expectedIntValue = 100;
    double expectedDoubleValue = 2.0;
    int64_t expectedInt64Value = 677777;
    constexpr size_t expectedSize = sizeof(expectedIntValue) + sizeof(expectedDoubleValue) + sizeof(expectedInt64Value);

    cs::Bytes bytes;
    cs::DataStream stream(bytes);
    stream << expectedIntValue << expectedDoubleValue << expectedInt64Value;

    ASSERT_EQ(expectedSize, bytes.size());
    ASSERT_EQ(expectedSize, stream.size());

    cs::DataStream readStream(bytes.data(), bytes.size());
    cs::Console::writeLine("Read data stream size before parsing: ", readStream.size());

    decltype(expectedIntValue) intValue = 0;
    decltype(expectedDoubleValue) doubleValue = 0;
    decltype(expectedInt64Value) int64Value = 0;

    readStream >> intValue >> doubleValue >> int64Value;
    cs::Console::writeLine("Read data stream size after parsing: ", readStream.size());

    ASSERT_FALSE(readStream.isAvailable(1));
    ASSERT_EQ(readStream.size(), 0);
    ASSERT_TRUE(readStream.isValid());

    ASSERT_EQ(intValue, expectedIntValue);
    ASSERT_EQ(static_cast<int>(doubleValue), static_cast<int>(expectedDoubleValue));
    ASSERT_EQ(int64Value, expectedInt64Value);
}

TEST(DataStream, CorrectAmountSerialization) {
    csdb::Amount amount{100};

    cs::Bytes bytes;
    cs::DataStream stream(bytes);

    stream << amount;

    ASSERT_TRUE(stream.size() != 0);

    cs::DataStream readStream(bytes.data(), bytes.size());
    csdb::Amount expectedAmount;

    readStream >> expectedAmount;

    ASSERT_TRUE(amount == expectedAmount);
}
```
# ..\node\tests\csnode\dynamicbuffer_tests.cpp 
```cpp 
#define TESTING

#include <gtest/gtest.h>
#include <algorithm>
#include "dynamicbuffer.hpp"

using namespace cs;

TEST(DynamicBuffer, equal_by_size) {
    DynamicBuffer a;
    DynamicBuffer b(a);

    ASSERT_TRUE(a == b);
}

TEST(DynamicBuffer, get_element_by_index) {
    char str[] = "teststring";
    size_t size = strlen(str) + 1;
    DynamicBuffer a(size);
    auto buffer = a.get();
    std::copy(std::begin(str), std::end(str), buffer);

    ASSERT_TRUE(a[3] == str[3]);
}

TEST(DynamicBuffer, stl_interface) {
    char str[] = "cba";
    size_t size = strlen(str) + 1;
    DynamicBuffer a(size);
    auto buffer = a.get();
    std::copy(std::begin(str), std::end(str), buffer);
    std::sort(a.begin(), a.end() - 1);

    ASSERT_STREQ("abc", *a);
}
```
# ..\node\tests\csnode\ipackstream_tests.cpp 
```cpp 

#include <gtest/gtest.h>
#include "packstream.hpp"

// commented tests require modification of IPackStream
// because they check IPackStream's internal state and
// it is filled with garbage before call to init()

TEST(IPackStream, IsNotGoodWithoutInitialization) {
    cs::IPackStream stream;
    ASSERT_FALSE(stream.good());
}

TEST(IPackStream, IsGoodAfterProperInitialization) {
    cs::IPackStream stream;
    uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof data);
    ASSERT_TRUE(stream.good());
}

TEST(IPackStream, OperatorBoolReturnsFalseWithoutInitialization) {
    cs::IPackStream stream;
    ASSERT_FALSE(static_cast<bool>(stream));
}

TEST(IPackStream, OperatorBoolReturnsTrueAfterInitialization) {
    cs::IPackStream stream;
    uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof data);
    ASSERT_TRUE(static_cast<bool>(stream));
}

/*
TEST(IPackStream, IsAtEndWithoutInitialization) {
  cs::IPackStream stream;
  ASSERT_TRUE(stream.end());
}//*/

TEST(IPackStream, IsNotAtEndAfterProperInitialization) {
    cs::IPackStream stream;
    uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof data);
    ASSERT_FALSE(stream.end());
}

/*
TEST(IPackStream, CanNotPeekWithoutInitialization) {
  cs::IPackStream stream;
  ASSERT_FALSE(stream.canPeek<int>());
}//*/

TEST(IPackStream, CanPeekAfterInitialization) {
    cs::IPackStream stream;
    uint8_t data[] = {0, 1, 2, 3};
    stream.init(data, sizeof data);
    ASSERT_TRUE(stream.canPeek<uint32_t>());
    ASSERT_FALSE(stream.canPeek<uint64_t>());
}

TEST(IPackStream, CurrentPointerIsEqualToThatPassedDuringInitialization) {
    cs::IPackStream stream;
    uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof(data));
    ASSERT_EQ(data, stream.getCurrentPtr());
}

/*
TEST(IPackStream, CanNotExtractByteArrayWithoutInitialization) {
  IPackStream stream;
  cs::ByteArray<3> string;
  stream >> string;
  ASSERT_EQ(string[0], 0);
  ASSERT_EQ(string[1], 0);
  ASSERT_EQ(string[2], 0);
}//*/

TEST(IPackStream, CanExtractByteArrayAfterInitialization) {
    cs::IPackStream stream;
    uint8_t data[] = {1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof data);
    cs::ByteArray<3> string;
    stream >> string;
    ASSERT_EQ(string[0], 1);
    ASSERT_EQ(string[1], 2);
    ASSERT_EQ(string[2], 3);
}

TEST(IPackStream, UnsafeSkipCorrectlyWorks) {
    cs::IPackStream stream;
    uint8_t data[] = {1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof data);
    cs::ByteArray<3> string;
    stream.skip<uint32_t>();
    stream >> string;
    ASSERT_EQ(string[0], 5);
    ASSERT_EQ(string[1], 6);
    ASSERT_EQ(string[2], 7);
}

TEST(IPackStream, SafeSkipCorrectlySkips) {
    cs::IPackStream stream;
    uint8_t data[] = {1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof data);
    cs::ByteArray<3> string;
    stream.safeSkip<uint32_t>(1);
    stream >> string;
    ASSERT_EQ(string[0], 5);
    ASSERT_EQ(string[1], 6);
    ASSERT_EQ(string[2], 7);
}

TEST(IPackStream, SafeSkipCorrectlyDeclinesTooBigShift) {
    cs::IPackStream stream;
    uint8_t data[] = {1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof data);
    stream.safeSkip<uint32_t>(2);
    ASSERT_FALSE(stream.good());
}

TEST(IPackStream, IsAtEndAfterSkipToTheEnd) {
    cs::IPackStream stream;
    uint8_t data[] = {1, 2, 3, 4, 5, 6, 7};
    stream.init(data, sizeof data);
    stream.safeSkip<uint8_t>(7);
    ASSERT_TRUE(stream.end());
}

TEST(IPackStream, IsAtEndAfterReadTheWholeBlob) {
    cs::IPackStream stream;
    uint8_t data[] = {0, 1, 2, 3};
    stream.init(data, sizeof data);
    uint32_t discarded_value;
    stream >> discarded_value;
    ASSERT_TRUE(stream.end());
}

TEST(IPackStream, SuccessfulReadOfIntegralType) {
    cs::IPackStream stream;
    uint8_t data[] = {0x12, 0x34, 0x56, 0x78, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE};
    stream.init(data, sizeof data);
    uint32_t value;
    stream >> value;
    EXPECT_TRUE(stream.good());
    ASSERT_EQ(value, 0x78563412);
}

TEST(IPackStream, IsNotGoodAfterRequestForReadingTooMany) {
    cs::IPackStream stream;
    uint8_t data[] = {0x12, 0x34, 0x56, 0x78};
    stream.init(data, sizeof data);
    uint64_t value = 0;
    stream >> value;
    EXPECT_FALSE(stream.good());
    ASSERT_EQ(value, 0);
}

TEST(IPackStream, PeekIntegerValue) {
    cs::IPackStream stream;
    uint8_t data[] = {0x12, 0x34, 0x56, 0x78};
    stream.init(data, sizeof data);
    uint32_t value;
    value = stream.peek<decltype(value)>();
    ASSERT_EQ(value, 0x78563412);
}

void displayStreamData(cs::IPackStream& stream, const size_t& size) {
    auto ptr = stream.getCurrentPtr();

    for (size_t i = 0; i < size; i++) {
        std::cout << "item " << i << ": " << (int)(*(ptr + i)) << std::endl;
    }
}
```
# ..\node\tests\csnode\main.cpp 
```cpp 
#include "gmock/gmock.h"
#include "gtest/gtest.h"

int main(int argc, char **argv) {
    ::testing::InitGoogleMock(&argc, argv);
    int ret = RUN_ALL_TESTS();
    return ret;
}
```
# ..\node\tests\csnode\networkmock.hpp 
```cpp 
//
// Created by User on 04.10.2018.
//

#ifndef PROJECT_NETWORKMOCK_HPP
#define PROJECT_NETWORKMOCK_HPP

#include <gmock/gmock.h>
#include "network.hpp"

class NetworkMock : public Network {
public:
  MOCK_CONST_METHOD0(isGood, bool());
  MOCK_METHOD1(resolve, ip::udp::endpoint(const EndpointData&));

  MOCK_METHOD2(sendDirect, void(const Packet, const ip::udp::endpoint&));

  MOCK_METHOD3(resendFragment, bool(const cs::Hash&, const uint16_t, const ip::udp::endpoint&));
  MOCK_METHOD2(registerMessage, void(Packet*, const uint32_t size));

  // private methods

  MOCK_METHOD1(readerRoutine, void(const Config&));
  MOCK_METHOD1(writerRoutine, void(const Config&));
  MOCK_METHOD0(processorRoutine, void());

  MOCK_METHOD4(getSocketInThread, ip::udp::socket*(const bool, const EndpointData&, std::atomic<ThreadStatus>&, const bool useIPv6));
};

#endif  // PROJECT_NETWORKMOCK_HPP
```
# ..\node\tests\csnode\nodemock.hpp 
```cpp 
//
// Created by User on 04.10.2018.
//

#ifndef PROJECT_NODEMOCK_HPP
#define PROJECT_NODEMOCK_HPP

#include <gmock/gmock.h>
#include "csnode/node.hpp"
#include "csnode/nodecore.hpp"

class NodeMock : public Node {
public:
  MOCK_CONST_METHOD0(isGood, bool());
  MOCK_METHOD1(run, void(const Config&));

  /* Incoming requests processing */
  MOCK_METHOD4(getRoundTable, void(const uint8_t*, const size_t, const cs::RoundNumber, uint8_t type));
  MOCK_METHOD2(getTransaction, void(const uint8_t*, const size_t));
  MOCK_METHOD2(getFirstTransaction, void(const uint8_t*, const size_t));
  MOCK_METHOD2(getTransactionsList, void(const uint8_t*, const size_t));
  MOCK_METHOD3(getVector, void(const uint8_t*, const size_t, const cs::PublicKey& sender));
  MOCK_METHOD3(getMatrix, void(const uint8_t*, const size_t, const cs::PublicKey& sender));
  MOCK_METHOD3(getBlock, void(const uint8_t*, const size_t, const cs::PublicKey& sender));
  MOCK_METHOD3(getHash, void(const uint8_t*, const size_t, const cs::PublicKey& sender));
  MOCK_METHOD2(getTransactionsPacket, void(const uint8_t*, const std::size_t));

  // transaction's pack syncro
  MOCK_METHOD3(getPacketHashesRequest, void(const uint8_t*, const std::size_t, const cs::PublicKey& sender));
  MOCK_METHOD2(getPacketHashesReply, void(const uint8_t*, const std::size_t));

  MOCK_METHOD3(getRoundTableUpdated, void(const uint8_t*, const size_t, const cs::RoundNumber));
  MOCK_METHOD3(getCharacteristic, void(const uint8_t* data, const size_t size, const cs::PublicKey& sender));

  MOCK_METHOD2(getWriterNotification, void(const uint8_t* data, const std::size_t size));
  MOCK_METHOD0(sendNotificationToWriter, void());

  /*syncro get functions*/
  MOCK_METHOD3(getBlockRequest, void(const uint8_t*, const size_t, const cs::PublicKey& sender));
  MOCK_METHOD2(getBlockReply, void(const uint8_t*, const size_t));
  MOCK_METHOD3(getWritingConfirmation, void(const uint8_t* data, const size_t size, const cs::PublicKey& sender));

  /* Outcoming requests forming */
  MOCK_METHOD0(sendRoundTable, void());
  MOCK_METHOD1(sendTransaction, void(const csdb::Transaction&));

  MOCK_METHOD1(sendFirstTransaction, void(const csdb::Transaction&));
  MOCK_METHOD1(sendTransactionList, void(const csdb::Pool&));
  MOCK_METHOD1(sendVector, void(const cs::HashVector&));
  MOCK_METHOD1(sendMatrix, void(const cs::HashMatrix&));
  MOCK_METHOD1(sendBlock, void(const csdb::Pool&));
  MOCK_METHOD2(sendHash, void(const std::string&, const cs::PublicKey&));

  // transaction's pack syncro
  MOCK_METHOD1(sendTransactionsPacket, void(const cs::TransactionsPacket& packet));
  MOCK_METHOD2(sendPacketHashesRequest, void(const cs::PacketsHashes& hashes, const cs::RoundNumber round));
  MOCK_METHOD2(sendPacketHashesRequestToRandomNeighbour, void(const cs::PacketsHashes& hashes, const cs::RoundNumber round));
  MOCK_METHOD3(sendPacketHashesReply,
               void(const cs::Packets& packet, const cs::RoundNumber round, const cs::PublicKey& sender));

  MOCK_METHOD3(sendCharacteristic, void(const csdb::Pool& emptyMetaPool, const uint32_t maskBitsCount,
                                        const std::vector<uint8_t>& characteristic));

  /*syncro send functions*/
  MOCK_METHOD1(sendBlockRequest, void(uint32_t seq));
  MOCK_METHOD2(sendBlockReply, void(const csdb::Pool&, const cs::PublicKey&));

  MOCK_METHOD0(flushCurrentTasks, void());
  MOCK_METHOD0(becomeWriter, void());
  MOCK_METHOD1(initNextRound, void(const cs::RoundTable& roundInfo));
  MOCK_METHOD0(isPoolsSyncroStarted, bool());

  MOCK_METHOD2(chooseMessageActionm, MessageActions(const cs::RoundNumber, const MsgTypes));

  MOCK_CONST_METHOD0(getMyPublicKey, const cs::PublicKey&());
  MOCK_CONST_METHOD0(getMyLevel, Level());
  MOCK_METHOD0(getRoundNumber, uint32_t());
  MOCK_METHOD0(getMyConfNumber, uint8_t());

  MOCK_CONST_METHOD0(getConfidants, const std::vector<cs::PublicKey>&());

  MOCK_METHOD0(getBlockChain, BlockChain&());
  MOCK_CONST_METHOD0(getBlockChain, const BlockChain&());

#ifdef NODE_API
  MOCK_METHOD0(getConnector, csconnector::connector&());
#endif

  MOCK_METHOD1(addToPackageTemporaryStorage, void(const csdb::Pool& pool));

  // private methods

  MOCK_METHOD0(init, bool());

  // signature verification
  MOCK_METHOD0(checkKeysFile, bool());
  MOCK_METHOD0(generateKeys, void());
  MOCK_METHOD0(checkKeysForSignature, bool());

  MOCK_METHOD1(readRoundData, bool(bool));
  MOCK_METHOD0(onRoundStart, void());
};

#endif  // PROJECT_NODEMOCK_HPP
```
# ..\node\tests\csnode\node_tests.cpp 
```cpp 
#define TESTING

#include <algorithm>
#include <array>
#include <cstring>
#include <list>
#include <mutex>
#include <thread>

#include <csnode/node.hpp>
#include "clientconfigmock.hpp"
#include "gtest/gtest.h"
#include "networkmock.hpp"
#include "nodemock.hpp"
#include "solvermock.hpp"
#include "transportmock.hpp"

TEST(NodeTest, connection) {
    MockConfig config;

    ASSERT_EQ(true, true);
}
```
# ..\node\tests\csnode\opackstream_tests.cpp 
```cpp 
#include <gtest/gtest.h>
#include "csdb/address.hpp"
#include "packstream.hpp"

using DataPtr = std::shared_ptr<char[]>;

struct StreamData {
    boost::asio::mutable_buffer encoded;
    DataPtr data;
};

const cs::PublicKey kPublicKey = {0x53, 0x4b, 0xd3, 0xdf, 0x77, 0x29, 0xfd, 0xcf, 0xea, 0x4a, 0xcd, 0x0e, 0xcc, 0x14, 0xaa, 0x05,
                                  0x0b, 0x77, 0x11, 0x6d, 0x8f, 0xcd, 0x80, 0x4b, 0x45, 0x36, 0x6b, 0x5c, 0xae, 0x4a, 0x06, 0x82};

void displayRawData(const void* data, const size_t size) {
    std::cout << "data = {";

    for (auto i = 0u; i < size; i++) {
        std::cout << "0x" << std::hex << std::setw(2) << std::setfill('0') << int(static_cast<const uint8_t*>(data)[i]) << ", ";
    }

    std::cout << "}" << std::dec << std::endl;
}

void displayStreamData(cs::OPackStream& stream) {
    auto ptr = stream.getCurrentPtr();
    auto offset = stream.getCurrentSize();
    displayRawData(ptr - offset, offset);
}

auto getStreamData(cs::OPackStream& stream) {
    auto packets = stream.getPackets();
    DataPtr bufferData(new char[Packet::MaxSize]);

    boost::asio::mutable_buffer buffer(bufferData.get(), Packet::MaxSize);
    auto encoded = packets->encode(buffer);

    StreamData streamData {
        encoded,
        bufferData
    };

    return streamData;
}

const std::size_t kPageSizeForAllocator = 1000;  // 109 is minimal stable

TEST(OPackStream, InitializationWithFragmentedAndNetworkMsgFlags) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);
    cs::OPackStream stream(&allocator, kPublicKey);

    const auto flags = BaseFlags(BaseFlags::Fragmented | BaseFlags::NetworkMsg);
    stream.init(flags);

    auto streamData = getStreamData(stream);
    auto encoded = streamData.encoded;

    const unsigned char encoded_expected[] = {flags, 0x00, 0x00, 0x01, 0x00};
    ASSERT_EQ(encoded.size(), sizeof encoded_expected);
    ASSERT_TRUE(0 == memcmp(encoded.data(), encoded_expected, encoded.size()));
}

TEST(OPackStream, InitializationWithFragmentedFlagOnly) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);
    cs::OPackStream stream(&allocator, kPublicKey);

    const auto flags = BaseFlags::Fragmented;
    stream.init(flags);

    auto streamData = getStreamData(stream);
    auto encoded = streamData.encoded;

    const unsigned char encoded_expected[] = {flags, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x4b,
                                              0xd3,  0xdf, 0x77, 0x29, 0xfd, 0xcf, 0xea, 0x4a, 0xcd, 0x0e, 0xcc, 0x14, 0xaa, 0x05, 0x0b,
                                              0x77,  0x11, 0x6d, 0x8f, 0xcd, 0x80, 0x4b, 0x45, 0x36, 0x6b, 0x5c, 0xae, 0x4a, 0x06, 0x82};

    ASSERT_EQ(1, stream.getPacketsCount());
    ASSERT_EQ(encoded.size(), sizeof encoded_expected);
    ASSERT_TRUE(0 == memcmp(encoded.data(), encoded_expected, encoded.size()));
}

TEST(OPackStream, WithoutInitializationPacketsCountIsZero) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);
    cs::OPackStream stream(&allocator, kPublicKey);

    ASSERT_EQ(0, stream.getPacketsCount());
}

TEST(OPackStream, AfterClearPacketsCountIsZero) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);
    cs::OPackStream stream(&allocator, kPublicKey);

    stream.init(BaseFlags::Fragmented);
    stream.clear();

    ASSERT_EQ(0, stream.getPacketsCount());
}

/*
TEST(OPackStream, WithoutInitializationEncodedDataIsEmpty) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);
    cs::OPackStream stream(&allocator, kPublicKey);

    auto streamData = getStreamData(stream);
    auto encoded = streamData.encoded;

    ASSERT_EQ(0, encoded.size());
}*/

TEST(OPackStream, getPacketsCount) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);
    cs::OPackStream oPackStream(&allocator, kPublicKey);
    oPackStream.init(BaseFlags::Fragmented | BaseFlags::NetworkMsg);

    ASSERT_EQ(1, oPackStream.getPacketsCount());
}

TEST(OPackStream, getCurrentPtr) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);
    cs::OPackStream oPackStream(&allocator, kPublicKey);
    oPackStream.init(BaseFlags::Fragmented | BaseFlags::NetworkMsg);

    ASSERT_EQ(1, static_cast<int>(*(oPackStream.getCurrentPtr() - 2)));
}

TEST(OPackStream, getCurrSize) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);
    cs::OPackStream oPackStream(&allocator, kPublicKey);
    oPackStream.init(BaseFlags::Fragmented | BaseFlags::NetworkMsg);

    ASSERT_EQ(5, oPackStream.getCurrentSize());
}

template <class T, size_t ArraySize>
void TestConcreteTypeWriteToOPackStream(const T& value, const unsigned char (&expected_encoded_data)[ArraySize]) {
    RegionAllocator allocator(kPageSizeForAllocator, 1);

    cs::OPackStream stream(&allocator, kPublicKey);
    stream.init(BaseFlags::Fragmented | BaseFlags::NetworkMsg);
    stream << value;

    auto streamData = getStreamData(stream);
    auto encoded = streamData.encoded;

    displayStreamData(stream);

    ASSERT_EQ(1, stream.getPacketsCount());
    ASSERT_EQ(encoded.size(), sizeof expected_encoded_data);
    ASSERT_TRUE(0 == memcmp(encoded.data(), expected_encoded_data, encoded.size()));
}

TEST(OPackStream, IpAddressWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x7f, 0x00, 0x00, 0x01};
    TestConcreteTypeWriteToOPackStream(boost::asio::ip::address_v4::from_string("127.0.0.1"), expected);
}

TEST(OPackStream, StdStringWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61,
                                      0x73, 0x63, 0x69, 0x69, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x20, 0x20};
    TestConcreteTypeWriteToOPackStream(std::string("ascii string   "), expected);
}

TEST(OPackStream, BytesWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00};
    TestConcreteTypeWriteToOPackStream(cs::Bytes{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}, expected);
}

TEST(OPackStream, DISABLED_EmptyPoolWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    TestConcreteTypeWriteToOPackStream(csdb::Pool{}, expected);
}

TEST(OPackStream, EmptyTransactionsPacketHashWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    TestConcreteTypeWriteToOPackStream(cs::TransactionsPacketHash{}, expected);
}

//
// TODO: TransactionsPacket, TransactionsPacketHash, Pool
//

TEST(OPackStream, EmptyTransactionsPacketWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    TestConcreteTypeWriteToOPackStream(cs::TransactionsPacket{}, expected);
}

TEST(OPackStream, HashVectorWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0xee, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55,
                                      0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44,
                                      0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55,
                                      0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44,
                                      0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22};
    cs::HashVector hash_vector{0xEE, cs::Hash{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
                                              0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22},
                               cs::Signature{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                             0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                             0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22}};
    TestConcreteTypeWriteToOPackStream(hash_vector, expected);
}

TEST(OPackStream, HashMatrixrWrite) {
    const unsigned char expected[] = {
        0x03, 0x00, 0x00, 0x01, 0x00, 0xee, 0xee, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11,
        0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0xee, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
        0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44,
        0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22,
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
        0x99, 0xaa, 0x11, 0x22, 0xee, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
        0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55,
        0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0xee, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
        0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22,
        0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
        0x11, 0x22, 0xee, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55,
        0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11,
        0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
        0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0x11, 0x22};
    cs::HashMatrix hash_matrix{0xEE,
                               {{0xEE, cs::Hash{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
                                                0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22},
                                 cs::Signature{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22}},
                                {0xEE, cs::Hash{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
                                                0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22},
                                 cs::Signature{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22}},
                                {0xEE, cs::Hash{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
                                                0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22},
                                 cs::Signature{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22}},
                                {0xEE, cs::Hash{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
                                                0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22},
                                 cs::Signature{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22}},
                                {0xEE, cs::Hash{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
                                                0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22},
                                 cs::Signature{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                               0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22}}},
                               cs::Signature{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                             0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22,
                                             0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0x11, 0x22}};
    TestConcreteTypeWriteToOPackStream(hash_matrix, expected);
}

TEST(OPackStream, EmptyPoolHashWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    TestConcreteTypeWriteToOPackStream(csdb::PoolHash{}, expected);
}

TEST(OPackStream, GeneralVectorWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x56,
                                      0x34, 0x12, 0x21, 0x43, 0x65, 0x87, 0xab, 0xab, 0xab, 0xab, 0xee, 0xee, 0xee, 0xee};
    std::vector<uint32_t> vector = {0x12345678, 0x87654321, 0xABABABAB, 0xEEEEEEEE};
    TestConcreteTypeWriteToOPackStream(vector, expected);
}

TEST(OPackStream, ByteArrayWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x01, 0x23};
    cs::ByteArray<10> array = {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x01, 0x23};
    TestConcreteTypeWriteToOPackStream(array, expected);
}

TEST(OPackStream, GeneralIntegerWrite) {
    const unsigned char expected[] = {0x03, 0x00, 0x00, 0x01, 0x00, 0x44, 0x03, 0x62, 0x67};
    uint32_t integer = 0x67620344;
    TestConcreteTypeWriteToOPackStream(integer, expected);
}
```
# ..\node\tests\csnode\packetqueue_tests.cpp 
```cpp 
#include <gtest/gtest.h>
#include <csnode/packetqueue.hpp>

const size_t kMaxPacketTransactions = 100;
const size_t kMaxPacketsPerRound = 10;
const size_t kMaxQueueSize = 100;

class PacketCreator {
public:
    using Pointer = void*;
    using Default = int;

    template<typename T>
    constexpr static auto create() {
        if constexpr (std::is_pointer_v<T>) {
            return new cs::PacketQueue(kMaxQueueSize, kMaxPacketTransactions, kMaxPacketsPerRound);
        }
        else {
            return cs::PacketQueue(kMaxQueueSize, kMaxPacketTransactions, kMaxPacketsPerRound);
        }
    }
};

TEST(PacketQueue, CreationAndDestroy) {
    cs::PacketQueue* queue = PacketCreator::create<PacketCreator::Pointer>();
    delete queue;

    queue = nullptr;

    ASSERT_EQ(queue, nullptr);
}

TEST(PacketQueue, EmptyState) {
    cs::PacketQueue queue = PacketCreator::create<PacketCreator::Default>();
    ASSERT_EQ(queue.isEmpty(), true);
}

void addTransactions(cs::PacketQueue& queue) {
    for (size_t i = 0; i < (kMaxPacketTransactions * 2) + 1; ++i) {
        queue.push(csdb::Transaction{});
    }
}

TEST(PacketQueue, pushTransaction) {
    cs::PacketQueue queue = PacketCreator::create<PacketCreator::Default>();
    addTransactions(queue);

    ASSERT_EQ(queue.size(), 3);
}

TEST(PacketQueue, popTransactionsBlocks) {
    cs::PacketQueue queue = PacketCreator::create<PacketCreator::Default>();
    addTransactions(queue);

    while (!queue.isEmpty()) {
        queue.pop();
    }

    ASSERT_EQ(queue.isEmpty(), true);
}
```
# ..\node\tests\csnode\solvermock.hpp 
```cpp 
//
// Created by User on 03.10.2018.
//

#ifndef PROJECT_SOLVERMOCK_HPP
#define PROJECT_SOLVERMOCK_HPP

#include <gmock/gmock.h>
#include <solver/solvercore.hpp>

class SolverMock : public cs::SolverCore {
public:
  MOCK_CONST_METHOD0(getMyPublicKey, cs::PublicKey());
  MOCK_CONST_METHOD0(getPathToDB, std::string());
  MOCK_METHOD2(set_keys, void(const std::vector<uint8_t>& pub, const std::vector<uint8_t>& priv));
  MOCK_METHOD1(gotTransactionsPacket, void(cs::TransactionsPacket&& packet));
  MOCK_METHOD2(gotPacketHashesRequest,
               void(std::vector<cs::TransactionsPacketHash>&& hashes, const cs::PublicKey& sender));
  MOCK_METHOD1(gotPacketHashesReply, void(cs::TransactionsPacket&& packet));
  MOCK_METHOD1(gotRound, void(cs::RoundTable&& round));
  MOCK_METHOD1(gotBlockCandidate, void(csdb::Pool&&));
  MOCK_METHOD1(gotVector, void(cs::HashVector&&));
  MOCK_METHOD1(gotMatrix, void(cs::HashMatrix&&));
  MOCK_METHOD2(gotHash, void(std::string&&, const cs::PublicKey&));
  MOCK_METHOD2(gotBlockRequest, void(csdb::PoolHash&&, const cs::PublicKey&));
  MOCK_METHOD1(gotBlockReply, void(csdb::Pool&&));
  MOCK_METHOD2(gotBadBlockHandler, void(csdb::Pool&&, const cs::PublicKey&));
  MOCK_METHOD4(applyCharacteristic, void(const std::vector<uint8_t>& characteristic, const uint32_t bitsCount,
                                         const csdb::Pool& metaInfoPool, const cs::PublicKey& sender));
  MOCK_CONST_METHOD0(getCharacteristicHash, cs::Hash());
  MOCK_METHOD0(getSignedNotification, std::vector<uint8_t>());

  MOCK_CONST_METHOD0(getWriterPublicKey, cs::PublicKey());

  MOCK_METHOD0(getSignature, const char*());

  // API methods
  MOCK_METHOD0(initApi, void());
  MOCK_METHOD0(addInitialBalance, void());

  MOCK_METHOD0(currentRoundNumber, cs::RoundNumber());
  MOCK_METHOD1(addTransaction, void(const csdb::Transaction& transaction));

  MOCK_METHOD1(send_wallet_transaction, void(const csdb::Transaction& transaction));

  MOCK_METHOD0(nextRound, void());
  MOCK_METHOD0(isPoolClosed, bool());
  MOCK_METHOD1(setLastRoundTransactionsGot, void(size_t trNum));

  // remove it!!!
  MOCK_METHOD1(buildBlock, void(csdb::Pool& block));
  MOCK_METHOD0(buildTransactionList, void());

  MOCK_CONST_METHOD0(getMyVector, cs::HashVector());
  MOCK_CONST_METHOD0(getMyMatrix, cs::HashMatrix());

  MOCK_METHOD0(initConfRound, void());
  MOCK_METHOD0(sendZeroVector, void());
  MOCK_METHOD1(checkVectorsReceived, void(size_t _rNum));
  MOCK_METHOD0(checkMatrixReceived, void());
  MOCK_METHOD1(addConfirmation, void(uint8_t confNumber_));
  MOCK_METHOD0(getIPoolClosed, bool());
  MOCK_METHOD0(getBigBangStatus, bool());
  MOCK_METHOD1(setBigBangStatus, void(bool _status));
  MOCK_METHOD1(setRNum, void(size_t _rNum));
  MOCK_METHOD3(setConfidants, void(const std::vector<cs::PublicKey>& confidants, const cs::PublicKey& general,
                                   const cs::RoundNumber roundNum));

  // private methods

  MOCK_METHOD0(_initApi, void());

  MOCK_METHOD0(runMainRound, void());
  MOCK_METHOD0(closeMainRound, void());

  MOCK_METHOD0(flushTransactions, void());

  MOCK_METHOD0(writeNewBlock, void());
  MOCK_METHOD1(prepareBlockForSend, void(csdb::Pool& block));

  MOCK_METHOD4(verify_signature,
               bool(uint8_t signature[64], uint8_t public_key[32], uint8_t* message, size_t message_len));
};

#endif  // PROJECT_SOLVERMOCK_HPP
```
# ..\node\tests\csnode\transactionspacket_tests.cpp 
```cpp 
#define TESTING

#include <gtest/gtest.h>
#include <algorithm>
#include <vector>

#include "transactionspacket.hpp"

#include <cscrypto/cscrypto.hpp>
#include <csdb/address.hpp>
#include <csdb/currency.hpp>
#include <csdb/transaction.hpp>

#include <lib/system/utils.hpp>
#include <lib/system/random.hpp>

static cs::TransactionsPacket packet;

static csdb::Transaction makeTransaction(int64_t innerId) {
    csdb::Transaction transaction;

    auto startAddress = csdb::Address::from_string("0000000000000000000000000000000000000000000000000000000000000007");
    cs::PublicKey myPublicForSig;

    transaction.set_target(csdb::Address::from_public_key(myPublicForSig));
    transaction.set_source(startAddress);
    transaction.set_currency(1);
    transaction.set_amount(csdb::Amount(10000, 0));
    transaction.set_innerID(innerId);

    return transaction;
}

TEST(TransactionsPacket, createPacket) {
    ASSERT_TRUE(packet.isHashEmpty());
}

TEST(TransactionsPacket, addTransactions) {
    auto startAddress = csdb::Address::from_string("0000000000000000000000000000000000000000000000000000000000000007");
    cs::PublicKey myPublicForSig;

    csdb::Transaction transaction;
    transaction.set_target(csdb::Address::from_public_key(myPublicForSig));
    transaction.set_source(startAddress);
    transaction.set_currency(1);
    transaction.set_amount(csdb::Amount(10000, 0));

    const size_t randomTransactionsCount = cs::Random::generateValue<size_t>(3, 30);
    const size_t startInnerID = cs::Random::generateValue<size_t>(1, 2789);

    const auto oldtransactionsCount = packet.transactionsCount();

    for (std::size_t i = 0; i < randomTransactionsCount; ++i) {
        transaction.set_innerID(static_cast<int64_t>(i + startInnerID));
        ASSERT_TRUE(packet.addTransaction(transaction));
    }

    const auto& newtransactionsCount = packet.transactionsCount();
    ASSERT_NE(oldtransactionsCount, newtransactionsCount);
    ASSERT_EQ(newtransactionsCount, randomTransactionsCount);
}

TEST(TransactionsPacket, makeHash) {
    const auto oldMainHash = packet.hash();

    packet.makeHash();

    ASSERT_FALSE(packet.isHashEmpty());
    ASSERT_NE(oldMainHash, packet.hash());
}

TEST(TransactionsPacket, makeNewHash) {
    const auto oldMainHash = packet.hash();
    const auto oldtransactionsCount = packet.transactionsCount();

    packet.makeHash();

    ASSERT_EQ(oldMainHash, packet.hash());
    ASSERT_EQ(oldtransactionsCount, packet.transactionsCount());
}

TEST(TransactionsPacket, makeHashFromString) {
    cs::TransactionsPacketHash hashFromString;
    ASSERT_TRUE(hashFromString.isEmpty());
    const auto& mainHash = packet.hash();
    const std::string mainHashStr = mainHash.toString();
    hashFromString = cs::TransactionsPacketHash::fromString(mainHashStr);

    ASSERT_EQ(mainHash, hashFromString);
    ASSERT_EQ(mainHashStr, hashFromString.toString());
    ASSERT_EQ(mainHash.toBinary(), hashFromString.toBinary());
}

TEST(TransactionsPacket, makeHashFromBinary) {
    const auto& mainHash = packet.hash();
    const auto& mainHashBin = mainHash.toBinary();
    const cs::TransactionsPacketHash hashFromBinary = cs::TransactionsPacketHash::fromBinary(mainHashBin);
    ASSERT_EQ(mainHash, hashFromBinary);
    ASSERT_EQ(mainHashBin, hashFromBinary.toBinary());
    ASSERT_EQ(mainHash.toString(), hashFromBinary.toString());
}

TEST(TransactionsPacket, makeTransactionsPacketFromBinary) {
    const auto& mainPacketBin = packet.toBinary();
    const cs::TransactionsPacket packetFromBinary = cs::TransactionsPacket::fromBinary(mainPacketBin);

    ASSERT_EQ(mainPacketBin, packetFromBinary.toBinary());
    ASSERT_EQ(packet.transactionsCount(), packetFromBinary.transactionsCount());

    const auto& mainHash = packet.hash();
    const auto& packetFromBinaryHash = packetFromBinary.hash();

    ASSERT_EQ(mainHash, packetFromBinaryHash);
    ASSERT_EQ(mainHash.toBinary(), packetFromBinaryHash.toBinary());
}

TEST(TransactionsPacket, makeTransactionsPacketFromByteStream) {
    const auto mainPacketBin = packet.toBinary();
    const size_t rawSize = mainPacketBin.size();
    const void* rawData = mainPacketBin.data();

    const cs::TransactionsPacket hashFromStream = cs::TransactionsPacket::fromByteStream(static_cast<const char*>(rawData), rawSize);

    ASSERT_EQ(mainPacketBin, hashFromStream.toBinary());
    ASSERT_EQ(packet.toBinary(), hashFromStream.toBinary());
    ASSERT_EQ(packet.transactionsCount(), hashFromStream.transactionsCount());

    const auto& mainHash = packet.hash();
    const auto& hashFromStreamHash = hashFromStream.hash();

    ASSERT_EQ(mainHash, hashFromStreamHash);
    ASSERT_EQ(mainHash.toBinary(), hashFromStreamHash.toBinary());
}

TEST(TransactionsPacket, signaturesSerialization) {
    constexpr size_t maxTransactionsCount = 100;
    const size_t count = cs::Random::generateValue<size_t>(0, maxTransactionsCount);
    cs::Console::writeLine("Generated transactions count ", count);

    cs::TransactionsPacket pack;

    for (size_t i = 0; i < count; ++i) {
        pack.addTransaction(makeTransaction(static_cast<int64_t>(i)));
    }

    cs::Signature signature;

    // 0
    signature.fill(0xFF);
    pack.addSignature(0, signature);

    // 1
    signature.fill(0xAA);
    pack.addSignature(1, signature);

    // 2
    signature.fill(0xDD);
    pack.addSignature(2, signature);

    ASSERT_EQ(pack.signatures().size(), 3);

    pack.makeHash();
    cs::TransactionsPacket expectedPacket = cs::TransactionsPacket::fromBinary(pack.toBinary());

    cs::Console::writeLine("Pack binary ", cs::Utils::byteStreamToHex(pack.toBinary()));
    cs::Console::writeLine("Expected pack packet binary ", cs::Utils::byteStreamToHex(expectedPacket.toBinary()));

    ASSERT_EQ(pack.toBinary(), expectedPacket.toBinary());
    ASSERT_EQ(pack.signatures().size(), expectedPacket.signatures().size());
    ASSERT_EQ(pack.hash(), expectedPacket.hash());
}

TEST(TransactionPacketHash, fromBinary) {
    auto startAddress = csdb::Address::from_string("0000000000000000000000000000000000000000000000000000000000000007");

    cs::PublicKey myPublicForSig;
    myPublicForSig.fill(0);

    csdb::Transaction transaction;
    transaction.set_target(csdb::Address::from_public_key(myPublicForSig));
    transaction.set_source(startAddress);
    transaction.set_currency(1);
    transaction.set_amount(csdb::Amount(10000, 0));
    transaction.set_innerID(cs::Random::generateValue<int64_t>(1, 2789));

    cs::TransactionsPacket testPacket;
    testPacket.addTransaction(transaction);

    ASSERT_EQ(testPacket.makeHash(), true);

    auto bytes = testPacket.hash().toBinary();
    cs::TransactionsPacketHash hash = cs::TransactionsPacketHash::fromBinary(std::move(bytes));

    ASSERT_EQ(hash, testPacket.hash());
}
```
# ..\node\tests\csnode\transportmock.hpp 
```cpp 
//
// Created by User on 03.10.2018.
//

#ifndef PROJECT_TRANSPORTMOCK_HPP
#define PROJECT_TRANSPORTMOCK_HPP

#include <gmock/gmock.h>
#include "transport.hpp"

class TransportMock : public Transport {
public:
  MOCK_METHOD0(run, void());

  MOCK_METHOD1(getPackSenderEntry, RemoteNodePtr(const ip::udp::endpoint&));

  MOCK_METHOD2(processNetworkTask, void(const TaskPtr<IPacMan>&, RemoteNodePtr&));
  MOCK_METHOD1(processNodeMessage, void(const Message&));
  MOCK_METHOD1(processNodeMessage, void(const Packet&));

  MOCK_METHOD4(addTask, void(Packet*, const uint32_t packNum, bool incrementWhenResend, bool sendToNeighbours));
  MOCK_METHOD0(clearTasks, void());

  MOCK_CONST_METHOD0(getMyPublicKey, const cs::PublicKey&());
  MOCK_CONST_METHOD0(isGood, bool());

  MOCK_METHOD1(sendBroadcast, void(const Packet* pack));

  MOCK_METHOD2(sendDirect, void(const Packet* pack, const Connection& conn));

  MOCK_METHOD2(gotPacket, void(const Packet&, RemoteNodePtr&));
  MOCK_METHOD1(redirectPacket, void(const Packet&));

  MOCK_METHOD0(refillNeighbourhood, void());
  MOCK_METHOD1(processPostponed, void(const cs::RoundNumber));

  MOCK_METHOD1(sendRegistrationRequest, void(Connection&));
  MOCK_METHOD1(sendRegistrationConfirmation, void(const Connection&));
  MOCK_METHOD2(sendRegistrationRefusal, void(const Connection&, const RegistrationRefuseReasons));
  MOCK_METHOD2(sendPackRenounce, void(const cs::Hash&, const Connection&));

  MOCK_METHOD1(sendPingPack, void(const Connection&));

  MOCK_METHOD1(registerMessage, void(MessagePtr));

  MOCK_METHOD3(registerTask, void(Packet* pack, const uint32_t packNum, const bool));

  // private methods

  MOCK_METHOD3(postponePacket, void(const cs::RoundNumber, const MsgTypes, const Packet&));

  // Dealing with network connections
  MOCK_METHOD1(parseSSSignal, bool(const TaskPtr<IPacMan>&));

  MOCK_METHOD5(dispatchNodeMessage,
               void(const MsgTypes, const cs::RoundNumber, const Packet&, const uint8_t* data, size_t));

  /* Network packages processing */
  MOCK_METHOD2(gotRegistrationRequest, bool(const TaskPtr<IPacMan>&, RemoteNodePtr&));

  MOCK_METHOD2(gotRegistrationConfirmation, bool(const TaskPtr<IPacMan>&, RemoteNodePtr&));

  MOCK_METHOD2(gotRegistrationRefusal, bool(const TaskPtr<IPacMan>&, RemoteNodePtr&));

  MOCK_METHOD2(gotSSRegistration, bool(const TaskPtr<IPacMan>&, RemoteNodePtr&));
  MOCK_METHOD1(gotSSRefusal, bool(const TaskPtr<IPacMan>&));
  MOCK_METHOD1(gotSSDispatch, bool(const TaskPtr<IPacMan>&));
  MOCK_METHOD1(gotSSPingWhiteNode, bool(const TaskPtr<IPacMan>&));
  MOCK_METHOD2(gotSSLastBlock, bool(const TaskPtr<IPacMan>&, uint32_t lastBlock));

  MOCK_METHOD2(gotPackInform, bool(const TaskPtr<IPacMan>&, RemoteNodePtr&));
  MOCK_METHOD2(gotPackRenounce, bool(const TaskPtr<IPacMan>&, RemoteNodePtr&));
  MOCK_METHOD2(gotPackRequest, bool(const TaskPtr<IPacMan>&, RemoteNodePtr&));

  MOCK_METHOD2(gotPing, bool(const TaskPtr<IPacMan>&, RemoteNodePtr&));

  MOCK_METHOD0(askForMissingPackages, void());
  MOCK_METHOD3(requestMissing, void(const cs::Hash&, const uint16_t, const uint64_t));
};

#endif  // PROJECT_TRANSPORTMOCK_HPP
```
# ..\node\tests\lib_system\concurrent_tests.cpp 
```cpp 
#include <lib/system/utils.hpp>
#include "gtest/gtest.h"
#include "lib/system/concurrent.hpp"

#include <atomic>
#include <iostream>
#include <string>

using ThreadId = std::thread::id;

template <typename T>
using Ref = std::reference_wrapper<T>;

static const uint64_t sleepTimeMs = 2500;

#define GENERATE_THREAD_VALUES()                        \
    std::atomic<bool> isRunningFinished = false;        \
    ThreadId mainId = std::this_thread::get_id();       \
    ThreadId concurrentId;                              \
    static std::atomic<bool> called = false;            \
    cs::Console::writeLine("Main thread id: ", mainId); \
    (void)called

TEST(Concurrent, SimpleRunWithBinding) {
    GENERATE_THREAD_VALUES();

    class Demo {
    public:
        void method(const std::string& message, Ref<ThreadId> wrapper, Ref<std::atomic<bool>> finished) {
            wrapper.get() = std::this_thread::get_id();

            cs::Console::writeLine("Concurrent thread id: ", wrapper);
            cs::Console::writeLine(message);

            finished.get() = true;
        }
    };

    Demo demo;
    cs::Concurrent::run(std::bind(&Demo::method, &demo, "Finished", std::ref(concurrentId), std::ref(isRunningFinished)));

    while (!isRunningFinished);

    ASSERT_NE(mainId, concurrentId);
}

TEST(Concurrent, SimpleRunWithoutBinding) {
    GENERATE_THREAD_VALUES();

    class Demo {
    public:
        void method(const std::string& message, Ref<ThreadId> wrapper, Ref<std::atomic<bool>> finished) {
            wrapper.get() = std::this_thread::get_id();

            cs::Console::writeLine("Concurrent thread id: ", wrapper);
            cs::Console::writeLine(message);

            finished.get() = true;
        }
    };

    Demo demo;
    cs::Concurrent::run(&Demo::method, &demo, "Finished", std::ref(concurrentId), std::ref(isRunningFinished));

    while (!isRunningFinished);

    ASSERT_NE(mainId, concurrentId);
}

TEST(Concurrent, SimpleRunLambda) {
    GENERATE_THREAD_VALUES();

    auto lambda = [&] {
        concurrentId = std::this_thread::get_id();

        cs::Console::writeLine("Concurrent thread id: ", concurrentId);
        cs::Console::writeLine("Finished");

        isRunningFinished = true;
    };

    cs::Concurrent::run(lambda);
    while (!isRunningFinished);

    ASSERT_NE(mainId, concurrentId);
}

TEST(Concurrent, VoidFutureWatcherBindedRun) {
    GENERATE_THREAD_VALUES();

    class Demo {
    public:
        void method(const std::string& message, Ref<ThreadId> wrapper, Ref<std::atomic<bool>> finished) {
            wrapper.get() = std::this_thread::get_id();

            cs::Console::writeLine("Concurrent thread id: ", wrapper);
            cs::Console::writeLine(message);

            finished.get() = true;
        }

    public slots:
        void onWatcherFinished() {
            cs::Console::writeLine("Watcher finished slot activated");
            called = true;
        }

        void onFailed() {
            cs::Console::writeLine("Execution failed");
        }
    };

    Demo demo;
    std::string message = "Finished";
    auto binder = std::bind(&Demo::method, &demo, message, std::ref(concurrentId), std::ref(isRunningFinished));

    cs::FutureWatcherPtr<void> watcher = cs::Concurrent::run(cs::RunPolicy::ThreadPolicy, std::move(binder));
    cs::Console::writeLine("Not connected yet");

    cs::Connector::connect(&watcher->finished, &demo, &Demo::onWatcherFinished);
    cs::Connector::connect(&watcher->failed, &demo, &Demo::onFailed);

    while (!isRunningFinished);

    if (!called) {
        std::this_thread::sleep_for(std::chrono::milliseconds(sleepTimeMs));
    }

    if (!called && isRunningFinished) {
        cs::Console::writeLine("Method executed, but does not generate finished signal");
    }

    cs::Console::writeLine("Called value is ", called);
    cs::Console::writeLine("isRunnings value is ", isRunningFinished);

    ASSERT_NE(mainId, concurrentId);
    ASSERT_EQ(called, true);
}

TEST(Concurrent, VoidFutureWatcherNonBindedRun) {
    GENERATE_THREAD_VALUES();

    class Demo {
    public:
        void method(const std::string& message, Ref<ThreadId> wrapper, Ref<std::atomic<bool>> finished) {
            wrapper.get() = std::this_thread::get_id();

            cs::Console::writeLine("Concurrent thread id: ", wrapper);
            cs::Console::writeLine(message);

            finished.get() = true;
        }

    public slots:
        void onWatcherFinished() {
            cs::Console::writeLine("Watcher finished slot activated");
            called = true;
        }

        void onFailed() {
            cs::Console::writeLine("Execution failed");
        }
    };

    Demo demo;
    std::string message = "Finished";

    cs::FutureWatcherPtr<void> watcher = cs::Concurrent::run(cs::RunPolicy::ThreadPolicy, &Demo::method, &demo, message, std::ref(concurrentId), std::ref(isRunningFinished));
    cs::Console::writeLine("Not connected yet");

    // look at watcher
    cs::Connector::connect(&watcher->finished, &demo, &Demo::onWatcherFinished);
    cs::Connector::connect(&watcher->failed, &demo, &Demo::onFailed);

    while (!isRunningFinished);

    if (!called) {
        cs::Console::writeLine("Not called, sleeping...");
        std::this_thread::sleep_for(std::chrono::milliseconds(sleepTimeMs));
    }

    cs::Console::writeLine("Called value is ", called);
    cs::Console::writeLine("isRunnings value is ", isRunningFinished);

    if (!called && isRunningFinished) {
        cs::Console::writeLine("Method executed, but does not generate finished signal");
    }

    ASSERT_NE(mainId, concurrentId);
    ASSERT_EQ(called, true);
}

TEST(Concurrent, FutureWatcherCorrectDestructionThreadPool) {
    static std::atomic<bool> isDone = false;
    static std::atomic<bool> isDestroyed = false;
    static std::atomic<int> destroyCount = 0;

    class Destroyer {
    public:
        [[maybe_unused]]
        Destroyer() = default;

        [[maybe_unused]]
        Destroyer(Destroyer&&) = default;

        [[maybe_unused]]
        ~Destroyer() {
            isDestroyed.store(true, std::memory_order::memory_order_release);
            ++destroyCount;
        }
    };

    class Demo {
    public:
        std::shared_ptr<Destroyer> execution() {
            cs::Console::writeLine("Demo execution done");
            return std::make_shared<Destroyer>();
        }

    public slots:
        void onFinished(std::shared_ptr<Destroyer>) {
            cs::Console::writeLine("Demo finished slot done");
            isDone.store(true, std::memory_order::memory_order_release);
        }
    };

    Demo demo;

    {
        auto watcher = cs::Concurrent::run(cs::RunPolicy::ThreadPolicy, &Demo::execution, &demo);
        cs::Connector::connect(&watcher->finished, &demo, &Demo::onFinished);
    }

    while (!isDone);

    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    cs::Console::writeLine("Is done ok, destroy count ", destroyCount.load(std::memory_order::memory_order_acquire));

    ASSERT_TRUE(destroyCount.load(std::memory_order::memory_order_acquire) == 1);
    ASSERT_TRUE(isDone);

    isDone = false;

    {
        auto watcher = cs::Concurrent::run(cs::RunPolicy::ThreadPolicy, &Demo::execution, &demo);
        cs::Connector::connect(&watcher->finished, &demo, &Demo::onFinished);
    }

    while (!isDone);

    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    cs::Console::writeLine("Is done ok, destroy count ", destroyCount.load(std::memory_order::memory_order_acquire));

    ASSERT_TRUE(destroyCount.load(std::memory_order::memory_order_acquire) == 2);
    ASSERT_TRUE(isDone);
}

TEST(Concurrent, FutureWatcherCorrectDestructionCallsQueue) {
    static std::atomic<bool> isDone = false;
    static std::atomic<bool> isDestroyed = false;
    static std::atomic<int> destroyCount = 0;

    class Destroyer {
    public:
        [[maybe_unused]]
        Destroyer() = default;

        [[maybe_unused]]
        Destroyer(Destroyer&&) = default;

        [[maybe_unused]]
        ~Destroyer() {
            isDestroyed.store(true, std::memory_order::memory_order_release);
            ++destroyCount;
        }
    };

    class Demo {
    public:
        std::shared_ptr<Destroyer> execution() {
            cs::Console::writeLine("Demo execution done");
            return std::make_shared<Destroyer>();
        }

    public slots:
        void onFinished(std::shared_ptr<Destroyer>) {
            cs::Console::writeLine("Demo finished slot done");
            isDone.store(true, std::memory_order::memory_order_release);
        }
    };

    Demo demo;

    {
        auto watcher = cs::Concurrent::run(cs::RunPolicy::CallQueuePolicy, &Demo::execution, &demo);
        cs::Connector::connect(&watcher->finished, &demo, &Demo::onFinished);
    }

    while (!isDone) {
        CallsQueue::instance().callAll();
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    cs::Console::writeLine("Is done ok, destroy count ", destroyCount.load(std::memory_order::memory_order_acquire));

    ASSERT_TRUE(destroyCount.load(std::memory_order::memory_order_acquire) == 1);
    ASSERT_TRUE(isDone);

    isDone = false;

    {
        auto watcher = cs::Concurrent::run(cs::RunPolicy::CallQueuePolicy, &Demo::execution, &demo);
        cs::Connector::connect(&watcher->finished, &demo, &Demo::onFinished);
    }

    while (!isDone) {
        CallsQueue::instance().callAll();
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    cs::Console::writeLine("Is done ok, destroy count ", destroyCount.load(std::memory_order::memory_order_acquire));

    ASSERT_TRUE(destroyCount.load(std::memory_order::memory_order_acquire) == 2);
    ASSERT_TRUE(isDone);
}
```
# ..\node\tests\lib_system\lib_system_tests.cpp 
```cpp 
#define TESTING
#include <algorithm>
#include <array>
#include <cstring>
#include <list>
#include <mutex>
#include <thread>

#include <lib/system/allocators.hpp>
#include <lib/system/queues.hpp>
#include <lib/system/structures.hpp>
#include <lib/system/random.hpp>

#include <boost/lockfree/spsc_queue.hpp>

#include "gtest/gtest.h"

void CreateRegionAllocatorAndThenAllocateInIt(const uint32_t page_size, const uint32_t initial_number_of_pages, const uint32_t number_of_additional_allocations,
                                              const uint32_t additional_allocation_size, uint32_t& final_number_of_pages) {
    RegionAllocator allocator(page_size, initial_number_of_pages);
    std::vector<RegionPtr> pointers;

    for (uint32_t i = 0; i < number_of_additional_allocations; ++i) {
        pointers.push_back(allocator.allocateNext(additional_allocation_size));
        ASSERT_EQ(pointers.back().size(), additional_allocation_size);
        *((uint32_t*)pointers.back().get()) = i;
    }

    uint32_t i = 0;

    for (auto ptr : pointers) {
        ASSERT_EQ(i, *(uint32_t*)ptr.get());
        ++i;
    }

    final_number_of_pages = allocator.getPagesNum();
}

// https://en.wikipedia.org/wiki/Data_structure_alignment#Computing_padding
constexpr int32_t AlignNumberToPowerOfTwo(const int32_t number, const uint32_t align) {
    return number + ((-number) & (align - 1));
}

constexpr int32_t AlignNumberTo64(const int32_t number) {
    return AlignNumberToPowerOfTwo(number, 64);
}

TEST(RegionAllocator, NoAdditionalPageIsAddedIfInitialPagesAreEnough) {
    constexpr uint32_t kAllocationSize = 4, kPageSize = AlignNumberTo64(sizeof(Region) + kAllocationSize) * 10, kInitialNumberOfPages = 2, kNumberOfAllocations = 20;
    uint32_t final_number_of_pages;
    CreateRegionAllocatorAndThenAllocateInIt(kPageSize, kInitialNumberOfPages, kNumberOfAllocations, kAllocationSize, final_number_of_pages);
    ASSERT_EQ(final_number_of_pages, kInitialNumberOfPages);
}

TEST(RegionAllocator, CorrectNumberOfPagesAllocated) {
    constexpr uint32_t kAllocationSize = 4, kPageSize = AlignNumberTo64(sizeof(Region) + kAllocationSize) * 10, kInitialNumberOfPages = 2, kNumberOfAllocations = 50;

    uint32_t final_number_of_pages;
    CreateRegionAllocatorAndThenAllocateInIt(kPageSize, kInitialNumberOfPages, kNumberOfAllocations, kAllocationSize, final_number_of_pages);
    ASSERT_EQ(final_number_of_pages, 5);
    CreateRegionAllocatorAndThenAllocateInIt(kPageSize, kInitialNumberOfPages, kNumberOfAllocations + 1, kAllocationSize, final_number_of_pages);
    ASSERT_EQ(final_number_of_pages, 6);
}

TEST(RegionAllocator, AllocateAndFreeUnusedObject) {
    RegionAllocator allocator(1000, 1);

    for (uint32_t i = 0; i < 100; ++i) {
        // every iteration this object is destructed and automatically removed from
        // allocator, so allocator is empty every iteration
        auto destructed_object = allocator.allocateNext(i + 1);
        *(char*)destructed_object.get() = 'x';
    }

    ASSERT_EQ(allocator.getPagesNum(), 1);
}

TEST(RegionAllocator, alloc_with_resizes) {
    constexpr uint32_t kPageSize = AlignNumberTo64(sizeof(Region) + 1) * 101;

    RegionAllocator allocator(kPageSize, 1);
    std::vector<RegionPtr> regs;

    for (uint32_t i = 0; i < 100; ++i) {
        auto p = allocator.allocateNext(50);
        *(char*)p.get() = 'x';
        allocator.shrinkLast(1);
        regs.push_back(p);
    }

    ASSERT_EQ(allocator.getPagesNum(), 1);
}

TEST(RegionAllocator, multithreaded_stress) {
    RegionAllocator a(10000, 10);
    uint64_t total = 0;

    std::mutex m;
    std::list<RegionPtr> regs;
    uint64_t lTot = 0;

    std::thread wr([&]() {
        for (uint32_t i = 0; i < 1000000; ++i) {
            uint32_t s = cs::Random::generateValue<uint32_t>(0, 100) + 4;

            auto p = a.allocateNext(s);
            *(uint32_t*)p.get() = i;
            total += i;

            if (i % 7 == 0) {
                a.shrinkLast(std::max((uint32_t)4, s % 25));
            }

            {
                std::lock_guard<std::mutex> l(m);
                regs.push_back(p);
            }
        }
    });

    auto rrout = [&]() {
        std::vector<RegionPtr> inCase;
        uint64_t t = 0;

        for (uint32_t i = 0; i < 250000; ++i) {
            for (;;) {
                RegionPtr p;
                {
                    std::lock_guard<std::mutex> l(m);
                    if (regs.empty())
                        continue;
                    p = regs.front();
                    regs.pop_front();
                }

                t += *(uint32_t*)p.get();

                if (i % 17 == 0) {
                    inCase.push_back(p);
                }

                break;
            }
        }

        std::lock_guard<std::mutex> l(m);
        lTot += t;
    };

    std::thread p1(rrout);
    std::thread p2(rrout);
    std::thread p3(rrout);
    std::thread p4(rrout);

    wr.join();
    p1.join();
    p2.join();
    p3.join();
    p4.join();

    ASSERT_EQ(lTot, total);
}

TEST(fuqueue, consecutive) {
    FUQueue<uint32_t, 1000> q;

    for (uint32_t i = 0; i < 1000; ++i) {
        auto s = q.lockWrite();
        s->element = i;
        q.unlockWrite(s);
    }

    for (uint32_t i = 0; i < 1000; ++i) {
        auto s = q.lockRead();
        ASSERT_EQ(s->element, i);
        q.unlockRead(s);
    }
}

TEST(fuqueue, overwrite) {
    FUQueue<uint32_t, 1000> q;

    for (int i = 0; i < 100; ++i) {
        for (uint32_t j = 0; j < 200; ++j) {
            auto s = q.lockWrite();
            s->element = j;
            q.unlockWrite(s);
        }

        for (uint32_t j = 0; j < 200; ++j) {
            auto s = q.lockRead();
            ASSERT_EQ(s->element, j);
            q.unlockRead(s);
        }
    }
}

TEST(fuqueue, DISABLED_multithreaded_stress) {
    FUQueue<uint32_t, 1000> q;

    std::atomic<uint64_t> wSum = {0};
    std::atomic<uint64_t> rSum = {0};

    auto wrFunc = [&]() {
        for (int i = 0; i < 100000; ++i) {
            const uint32_t t = cs::Random::generateValue<uint32_t>(0, 500);
            auto s = q.lockWrite();
            s->element = t;
            q.unlockWrite(s);

            wSum.fetch_add(t, std::memory_order_relaxed);
        }
    };

    auto rdFunc = [&]() {
        for (int i = 0; i < 100000; ++i) {
            auto s = q.lockRead();
            rSum.fetch_add(s->element, std::memory_order_relaxed);
            q.unlockRead(s);
        }
    };

    std::thread w1(wrFunc);
    std::thread w2(wrFunc);
    std::thread w3(wrFunc);

    std::thread r1(rdFunc);
    std::thread r2(rdFunc);
    std::thread r3(rdFunc);

    w1.join();
    w2.join();
    w3.join();

    r1.join();
    r2.join();
    r3.join();
}

TEST(boost_spsc_queue, DISABLED_multithreaded_stress) {
    boost::lockfree::spsc_queue<uint32_t, boost::lockfree::capacity<10000>> queue;

    std::atomic<uint64_t> wSum = {0};
    std::atomic<uint64_t> rSum = {0};

    std::atomic<uint64_t> executions = {0};
    std::atomic<uint64_t> enqueues = {0};

    size_t count = 10000;

    auto wrFunc = [&]() {
        for (size_t i = 0; i < count; ++i) {
            const uint32_t t = cs::Random::generateValue<uint32_t>(0, 500);

            while (!queue.push(t)) {
                executions.fetch_add(1, std::memory_order_acq_rel);
                wSum.fetch_add(t, std::memory_order_acq_rel);
            }
        }
    };

    auto rdFunc = [&]() {
        while (executions.load(std::memory_order_acquire) != enqueues.load(std::memory_order_acquire)) {
            uint32_t value = 0;
            while (queue.pop(value)) {
                rSum.fetch_add(value, std::memory_order_acq_rel);
                enqueues.fetch_add(1, std::memory_order_acq_rel);
            }
        }
    };

    std::thread w1(wrFunc);
    std::thread w2(wrFunc);
    std::thread w3(wrFunc);

    std::thread r1(rdFunc);
    std::thread r2(rdFunc);
    std::thread r3(rdFunc);

    w1.join();
    w2.join();
    w3.join();

    r1.join();
    r2.join();
    r3.join();

    ASSERT_EQ(enqueues.load(std::memory_order_acquire), executions.load(std::memory_order_acquire));
    ASSERT_EQ(wSum.load(std::memory_order_acquire), rSum.load(std::memory_order_acquire));
}

// TODO: Enable test and fix crush on linux
TEST(typed_allocator, DISABLED_one_page) {
    TypedAllocator<uint32_t> allocator(100);

    std::array<MemPtr<TypedSlot<uint32_t>>, 100> uis = {};

    for (uint32_t i = 0; i < 100; ++i) {
        uis[i] = allocator.emplace(i);
    }

    for (uint32_t i = 0; i < 100; ++i) {
        ASSERT_EQ(**(uis[i]), i);
    }

    for (uint32_t i = 0; i < 100; ++i) {
        uis[i] = MemPtr<TypedSlot<uint32_t>>();
    }
}

TEST(typed_allocator, multiple_pages) {
    TypedAllocator<uint32_t> allocator(100);

    std::array<MemPtr<TypedSlot<uint32_t>>, 1000> uis;

    for (uint32_t i = 0; i < 1000; ++i) {
        uis[i] = allocator.emplace(i);
    }

    for (uint32_t i = 0; i < 1000; ++i) {
        ASSERT_EQ(**(uis[i]), i);
    }

    for (uint32_t i = 0; i < 1000; ++i) {
        uis[i] = MemPtr<TypedSlot<uint32_t>>();
    }
}

TEST(typed_allocator, reput) {
    TypedAllocator<uint32_t> allocator(1);

    auto first = *allocator.emplace(42);

    for (uint32_t i = 0; i < 10; ++i) {
        ASSERT_EQ(*allocator.emplace(i), first);
    }
}

TEST(typed_allocator, inconsistent) {
    TypedAllocator<uint32_t> allocator(100);

    std::array<MemPtr<TypedSlot<uint32_t>>, 1000> uis;

    for (uint32_t i = 0; i < 1000; ++i) {
        uis[i] = allocator.emplace(i);

        if (i % 7 == 0) {
            uis[i] = MemPtr<TypedSlot<uint32_t>>();
        }
    }

    for (uint32_t i = 0; i < 1000; ++i) {
        if (i % 7) {
            ASSERT_EQ(**(uis[i]), i);
        }
    }
}

template <>
uint16_t getHashIndex(const uint32_t& h) {
    return h % (1 << 16);
}

TEST(FixedHashMap, base) {
    FixedHashMap<uint32_t, uint64_t, uint16_t, 100000> hm;
    const uint32_t COUNT = 100000ll;
    uint32_t hs[COUNT];

    for (uint32_t i = 0; i < COUNT; ++i) {
        hs[i] = i;
        auto& c = hm.tryStore(hs[i]);
        ASSERT_EQ(c, 0);
        c = 2;
    }

    for (uint32_t i = 0; i < COUNT; ++i) {
        ASSERT_EQ(hm.tryStore(hs[i]), 2);
    }
}

TEST(FixedHashMap, depush) {
    FixedHashMap<uint32_t, uint64_t, uint16_t, 10> hm;
    uint32_t hs[1000];

    for (uint32_t i = 0; i < 1000; ++i) {
        hs[i] = i;
        auto& c = hm.tryStore(hs[i]);
        ASSERT_EQ(c, 0);
        c = 2;
    }

    for (uint32_t i = 990; i < 1000; ++i) {
        auto& c = hm.tryStore(hs[i]);
        ASSERT_EQ(c, 2);
    }

    for (uint32_t i = 0; i < 990; ++i) {
        auto& c = hm.tryStore(hs[i]);
        ASSERT_EQ(c, 0);
    }
}

template <>
uint8_t getHashIndex(const uint16_t& h) {
    return h % (1 << 8);
}

TEST(FixedHashMap, heap) {
    const uint16_t COUNT = 10000;
    FixedHashMap<uint16_t, uint32_t, uint8_t, COUNT> hm;
    uint16_t hs[COUNT];

    for (uint16_t i = 0; i < COUNT; ++i) {
        hs[i] = i;
        auto& c = hm.tryStore(hs[i]);
        ASSERT_EQ(c, 0);
        c = 7;
    }

    for (uint16_t i = 0; i < COUNT; ++i) {
        auto c = hm.tryStore(hs[i]);
        ASSERT_EQ(c, 7);
    }
}

struct IntWithCounter {
    static uint32_t counter;
    uint32_t i;
    IntWithCounter(uint32_t _i)
    : i(_i) {
        ++counter;
    }
    IntWithCounter() {
        ++counter;
    }
    ~IntWithCounter() {
        --counter;
    }
};

uint32_t IntWithCounter::counter = 0;

TEST(FixedHashMap, destroy) {
    IntWithCounter::counter = 0;

    {
        FixedHashMap<uint16_t, IntWithCounter, uint8_t, 10> hm;

        for (uint16_t i = 0; i < 100; ++i) {
            hm.tryStore(i);
        }

        ASSERT_EQ(IntWithCounter::counter, 10);
    }

    // Todo: Typed allocator destructor
    ASSERT_EQ(IntWithCounter::counter, 0);
}

TEST(FixedCircularBuffer, BasicCreation) {
    IntWithCounter::counter = 0;
    FixedCircularBuffer<IntWithCounter, 32> buffer;

    for (uint32_t i = 0; i < 30; ++i) {
        buffer.emplace(i);
    }

    uint32_t j = 0;
    for (auto& x : buffer) {
        ASSERT_EQ(x.i, j);
        ++j;
    }

    ASSERT_EQ(j, 30);
    buffer.clear();
    ASSERT_EQ(IntWithCounter::counter, 0);
}

TEST(FixedCircularBuffer, OverlappingWhenAddingMoreThanBufferSize) {
    IntWithCounter::counter = 0;

    {
        FixedCircularBuffer<IntWithCounter, 32> buffer;
        for (uint32_t i = 0; i < 40; ++i) {
            buffer.emplace(i);
        }

        auto iter = buffer.begin();

        for (uint32_t i = 8; i < 40; ++i) {
            ASSERT_EQ(iter->i, i);
            ++iter;
        }

        ASSERT_EQ(IntWithCounter::counter, 32);
    }

    ASSERT_EQ(IntWithCounter::counter, 0);
}

TEST(FixedCircularBuffer, RemovingTwoElements) {
    FixedCircularBuffer<uint32_t, 32> buffer;
    for (uint32_t i = 0; i < 20; ++i) {
        buffer.emplace(i);
    }

    buffer.remove(buffer.frontPtr() + 10);
    buffer.remove(buffer.frontPtr() + 15);

    auto iter = buffer.begin();
    for (uint32_t i = 0; i < 18; ++i) {
        ASSERT_EQ(*iter, (i < 10 ? i : i + (i < 15 ? 1 : 2)));
        ++iter;
    }
}

TEST(FixedVector, base) {
    FixedVector<int, 10> fv;

    for (uint32_t i = 0; i < 10; ++i) {
        fv.emplace(i);
    }

    uint32_t count = 0;
    for (auto& i : fv) {
        ASSERT_EQ(count, i);
        ++count;
    }

    fv.remove(fv.begin() + 7);

    auto it = fv.begin();
    ASSERT_EQ(fv.end(), it + 9);

    for (uint32_t i = 0; i < 9; ++i) {
        ASSERT_EQ(*it, (i < 7 ? i : i + 1));
        ++it;
    }
}
```
# ..\node\tests\lib_system\main.cpp 
```cpp 
#include "gtest/gtest.h"

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    int ret = RUN_ALL_TESTS();
    return ret;
}
```
# ..\node\tests\lib_system\meta_storage_tests.cpp 
```cpp 
#include "gtest/gtest.h"

#include <iostream>
#include <lib/system/metastorage.hpp>
#include <string>

using TestIntMetaSatorage = cs::MetaStorage<int>;
using TestStringMetaStorage = cs::MetaStorage<std::string>;

template <typename T>
void printStorageSize(const T& storage) {
    std::cout << "Storage size " << storage.size() << std::endl;
}

template <typename T>
void printValue(const std::string& message, const T& value) {
    std::cout << message << " " << value << std::endl;
}

TEST(MetaStorage, DefaultCreation) {
    constexpr auto defaultSize = 0;
    TestIntMetaSatorage storage;

    printStorageSize(storage);
    std::cout << "Default size " << defaultSize << std::endl;

    ASSERT_EQ(storage.size(), defaultSize);
}

TEST(MetaStorage, Contains) {
    cs::RoundNumber defaultRoundNumber = 10;
    int value = 100;
    TestIntMetaSatorage storage;

    ASSERT_EQ(storage.append(defaultRoundNumber, std::move(value)), true);
    ASSERT_EQ(storage.contains(defaultRoundNumber), true);

    printStorageSize(storage);

    ASSERT_EQ(storage.size(), 1);
}

TEST(MetaStorage, AppendAndExtract) {
    TestIntMetaSatorage storage;
    cs::RoundNumber defaultRoundNumber = 20;
    int value = 300;

    printStorageSize(storage);

    ASSERT_EQ(storage.append(defaultRoundNumber, std::move(value)), true);
    ASSERT_EQ(storage.contains(defaultRoundNumber), true);
    ASSERT_EQ(storage.size(), 1);

    std::optional<int> extractedValue = storage.extract(defaultRoundNumber);

    ASSERT_EQ(extractedValue.has_value(), true);

    printStorageSize(storage);
    printValue("Extracted value", extractedValue.value());

    ASSERT_EQ(value, extractedValue.value());
    ASSERT_EQ(storage.size(), 0);

    std::cout << "Try to add next element" << std::endl;

    TestIntMetaSatorage::MetaElement element = {defaultRoundNumber, value};

    ASSERT_EQ(storage.append(element), true);
    printStorageSize(storage);

    ASSERT_EQ(storage.size(), 1);

    element.round = defaultRoundNumber + 1;
    ASSERT_EQ(storage.append(element), true);

    printStorageSize(storage);
    ASSERT_EQ(storage.size(), 2);
}

TEST(MetaStorage, GetMethod) {
    cs::RoundNumber defaultRoundNumber = 100;
    std::string defaultString = "Hello, world!";

    TestStringMetaStorage::Element element;
    element.round = defaultRoundNumber;
    element.meta = defaultString;

    TestStringMetaStorage storage;

    ASSERT_EQ(storage.append(element), true);

    std::string* stringPointer = storage.get(defaultRoundNumber);
    ASSERT_NE(stringPointer, nullptr);

    printValue("String pointer value", *stringPointer);
    ASSERT_EQ(*stringPointer, defaultString);

    printStorageSize(storage);
    ASSERT_EQ(storage.size(), 1);
}

TEST(MetaStorage, BeginEnd) {
    TestStringMetaStorage storage;
    printStorageSize(storage);

    for (const TestStringMetaStorage::Element& element : storage) {
        printValue("Storage element meta", element.meta);
        printValue("Storage element round", element.round);

        ASSERT_EQ(element.meta, std::string());
        ASSERT_EQ(element.round, cs::RoundNumber());
    }
}

TEST(MetaStorage, MaxAndLast) {
    cs::RoundNumber defaultRound = 1;
    const std::string defaultString = "qwerty";
    std::string value = defaultString;
    const std::string expectedString = "111";

    TestStringMetaStorage storage;
    printStorageSize(storage);

    // 1
    storage.append(defaultRound, std::move(value));
    value = defaultString;

    // 2
    storage.append(++defaultRound, std::move(value));
    value = defaultString;

    // 3
    storage.append(++defaultRound, std::move(value));
    value = expectedString;
    defaultRound += 7;

    // 10
    storage.append(defaultRound, std::move(value));
    printStorageSize(storage);

    ASSERT_EQ(storage.size(), 4);

    printValue("max() string ", storage.max());
    printValue("Expected string ", expectedString);

    ASSERT_EQ(storage.max(), expectedString);

    printValue("last() value ", storage.last());
    printValue("Expected last value ", expectedString);

    ASSERT_EQ(storage.last(), expectedString);
}
```
# ..\node\tests\lib_system\signals_tests.cpp 
```cpp 
#include "gtest/gtest.h"

#include "lib/system/timer.hpp"

#include <string>

TEST(Signals, BaseSignalUsingByPointer) {
    static const std::string expectedString = "Hello, world!";
    constexpr size_t expectedCalls = 2;

    class A {
    public:
        void generateSignal(const std::string& message) {
            std::cout << "Generated message: " << message << std::endl;
            emit signal(message);
        }

    public signals:
        cs::Signal<void(const std::string&)> signal;
    };

    class B {
    public:
        size_t callsCount() const {
            return callsCount_;
        }

    private:
        size_t callsCount_ = 0;

    public slots:
        void onSignalSlot(const std::string& message) {
            std::cout << "Slot message: " << message << std::endl;
            std::cout << "Slot calls count: " << ++callsCount_ << std::endl;

            ASSERT_EQ(expectedString, message);
        }
    };

    A a;
    B b;

    cs::Connector::connect(&a.signal, &b, &B::onSignalSlot);

    std::cout << cs::Connector::callbacks(&a.signal) << std::endl;
    ASSERT_EQ(cs::Connector::callbacks(&a.signal), 1);

    a.generateSignal(expectedString);
    a.generateSignal(expectedString);

    ASSERT_EQ(b.callsCount(), expectedCalls);
}

TEST(Signals, ConnectAndDisconnect) {
    struct Signaller {
    public signals:
        cs::Signal<void()> signal;
    };

    class A {
    public:
        size_t callsCount() const {
            return callsCount_;
        }

    private:
        size_t callsCount_ = 0;

    public slots:
        void onSignal() {
            ++callsCount_;
            std::cout << "OnSignal A, count " << callsCount_ << std::endl;
        }
    };

    class B {
    public:
        size_t callsCount() const {
            return callsCount_;
        }

    private:
        size_t callsCount_ = 0;

    public slots:
        void onSignal() {
            ++callsCount_;
            std::cout << "OnSignal B, count " << callsCount_ << std::endl;
        }
    };

    Signaller signaller;
    A a;
    B b;

    cs::Connector::connect(&signaller.signal, &a, &A::onSignal);
    cs::Connector::connect(&signaller.signal, &b, &B::onSignal);

    // generate signal
    emit signaller.signal();

    ASSERT_EQ(a.callsCount(), 1);
    ASSERT_EQ(b.callsCount(), 1);

    bool result = cs::Connector::disconnect(&signaller.signal, &a, &A::onSignal);
    ASSERT_EQ(result, true);

    emit signaller.signal();

    ASSERT_EQ(a.callsCount(), 1);
    ASSERT_EQ(b.callsCount(), 2);

    ASSERT_EQ(cs::Connector::callbacks(&signaller.signal), 1);

    result = cs::Connector::disconnect(&signaller.signal, &b, &B::onSignal);
    ASSERT_EQ(result, true);

    emit signaller.signal();

    ASSERT_EQ(a.callsCount(), 1);
    ASSERT_EQ(b.callsCount(), 2);

    ASSERT_EQ(cs::Connector::callbacks(&signaller.signal), 0);

    cs::Connector::connect(&signaller.signal, &a, &A::onSignal);

    emit signaller.signal();

    ASSERT_EQ(a.callsCount(), 2);
    ASSERT_EQ(b.callsCount(), 2);
}

TEST(Signals, MoveTest) {
    static std::atomic<bool> isCalled = false;
    cs::Signal<void()> signal1;

    class A {
    public slots:
        void onSignal() {
            isCalled = true;
            std::cout << "A on signal method\n";
        }
    };

    A a;
    cs::Connector::connect(&signal1, &a, &A::onSignal);

    cs::Signal<void()> signal2 = std::move(signal1);

    cs::Timer::singleShot(1000, cs::RunPolicy::ThreadPolicy, [&] {
        std::cout << "Calling signal2\n";
        emit signal2();
        std::cout << "Signal2 called\n";
    });

    ASSERT_EQ(cs::Connector::callbacks(&signal2), 1);
    ASSERT_EQ(cs::Connector::callbacks(&signal1), 0);

    while (!isCalled);

    ASSERT_EQ(isCalled, true);
}

void func(const std::string& message, std::reference_wrapper<bool> wrapper) {
    wrapper.get() = true;
    std::cout << message << std::endl;
}

TEST(Signals, LambdaAndFuncConnections) {
    static bool isLambdaCalled = false;
    static bool isFunctionCalled = false;

    cs::Signal<void(const std::string&, std::reference_wrapper<bool>)> signal1;
    cs::Connector::connect(&signal1, &func);

    auto lambda = [&](const std::string& message, std::reference_wrapper<bool> wrapper) {
        wrapper.get() = true;
        std::cout << "Lambda message - " << message << std::endl;
    };

    cs::Signal<void(const std::string&, std::reference_wrapper<bool>)> signal2;
    cs::Connector::connect(&signal2, lambda);

    emit signal1("Hello, world!", std::ref(isFunctionCalled));
    emit signal2("Credits tests", std::ref(isLambdaCalled));

    ASSERT_EQ(isFunctionCalled, true);
    ASSERT_EQ(isLambdaCalled, true);
}

TEST(Signals, SignalToSignalConnection) {
    static bool isCalled = false;
    cs::Signal<void()> signal1;
    cs::Signal<void()> signal2;

    cs::Connector::connect(&signal2, [&] {
        isCalled = true;
        std::cout << "Lambda called\n";
    });

    cs::Connector::connect(&signal1, &signal2);

    emit signal1();

    ASSERT_EQ(isCalled, true);
}

size_t foo() {
    static size_t callsCount = 0;
    std::cout << "Foo calls count " << ++callsCount << std::endl;

    return callsCount;
}

TEST(Signals, LambdaAndFunctionConnectionDisconnection) {
    class A {
    public signals:
        cs::Signal<void()> signal;
    };

    auto a = std::make_shared<A>();
    cs::Connector::connect(&(a->signal), &foo);

    auto lambda = []() {
        static size_t callsCount = 0;
        std::cout << "Lambda calls count " << ++callsCount << std::endl;

        return callsCount;
    };

    cs::Connector::connect(&(a->signal), lambda);

    emit a->signal();

    ASSERT_EQ(cs::Connector::callbacks(&(a->signal)), 2);
    ASSERT_EQ(foo(), 2);
    ASSERT_EQ(lambda(), 2);

    bool result = cs::Connector::disconnect(&(a->signal), &foo);
    ASSERT_EQ(result, true);

    emit a->signal();

    ASSERT_EQ(cs::Connector::callbacks(&(a->signal)), 1);
    ASSERT_EQ(foo(), 3);
    ASSERT_EQ(lambda(), 4);

    cs::Connector::connect(&(a->signal), &foo);

    emit a->signal();

    ASSERT_EQ(cs::Connector::callbacks(&(a->signal)), 2);
    ASSERT_EQ(foo(), 5);
    ASSERT_EQ(lambda(), 6);

    result = cs::Connector::disconnect(&(a->signal), lambda);
    ASSERT_EQ(result, true);

    emit a->signal();

    ASSERT_EQ(cs::Connector::callbacks(&(a->signal)), 1);
    ASSERT_EQ(foo(), 7);
    ASSERT_EQ(lambda(), 7);

    cs::Connector::disconnect(&(a->signal));

    emit a->signal();

    ASSERT_EQ(cs::Connector::callbacks(&(a->signal)), 0);
    ASSERT_EQ(foo(), 8);
    ASSERT_EQ(lambda(), 8);
}

TEST(Signals, ConstObjectConnection) {
    static bool isCalled = false;

    class A {
    public signals:
        cs::Signal<void()> signal;
    };

    class B {
    public slots:
        void onSignal() const {
            std::cout << "B on signal called" << std::endl;
            isCalled = true;
        }
    };

    const A a;
    const B b;

    cs::Connector::connect(&a.signal, &b, &B::onSignal);

    emit a.signal();
    ASSERT_TRUE(isCalled);
}

TEST(Signals, UnexpectedDisconnect) {
    static bool isCalled = false;

    class A {
    public signals:
        cs::Signal<void(const std::string&)> signal;
    };

    class B : public cs::IConnectable {
    public slots:
        void onSignal(const std::string& msg) {
            isCalled = true;
            cs::Console::writeLine(msg);
        }
    };

    A a;

    {
        B b;
        cs::Connector::connect(&a.signal, &b, &B::onSignal);
    }

    emit a.signal("cs");

    ASSERT_EQ(isCalled, false);
    ASSERT_EQ(cs::Connector::callbacks(&a.signal), 0);
}

class Checker {
public:
    Checker(bool& f)
    : flag(f) {
    }

    Checker(const Checker& checker)
    : flag(checker.flag) {
        flag = true;
    }

    Checker& operator=(const Checker&) {
        flag = true;
        return *this;
    }

    size_t value = 0;
    bool& flag;
};

TEST(Signals, NonArgumentsCopy) {
    static bool isCopied = false;
    constexpr size_t expectedValue = 10;

    class A {
    public signals:
        cs::Signal<void(Checker&)> signal;
    };

    class B {
    public slots:
        void onSignal(Checker& checker) {
            cs::Console::writeLine("B slot called");
            checker.value = expectedValue;
        }
    };

    A a;
    B b;
    Checker checker(isCopied);

    cs::Connector::connect(&a.signal, &b, &B::onSignal);

    emit a.signal(checker);

    ASSERT_EQ(isCopied, false);
    ASSERT_EQ(checker.value, expectedValue);
}

TEST(Signals, ArgumentsCopy) {
    static bool isCopied = false;

    class A {
    public signals:
        cs::Signal<void(Checker)> signal;
    };

    class B {
    public slots:
        void onSignal([[maybe_unused]] Checker checker) {
            cs::Console::writeLine("B slot called");
            checker.value = 10;
        }
    };

    A a;
    B b;
    Checker checker(isCopied);

    cs::Connector::connect(&a.signal, &b, &B::onSignal);

    emit a.signal(checker);

    ASSERT_EQ(isCopied, true);
    ASSERT_EQ(checker.value, 0);
}
```
# ..\node\tests\lib_system\timer_tests.cpp 
```cpp 
#include "gtest/gtest.h"

#include <string>
#include <atomic>

#include "lib/system/timer.hpp"
#include "lib/system/utils.hpp"

TEST(Timer, BaseTimerUsage) {
    static std::atomic<bool> isCalled = false;
    static std::atomic<bool> isFailed = false;
    static std::atomic<bool> isChecked = false;
    static std::atomic<size_t> counter = 0;
    static size_t expectedCalls = 10;
    static int awaitTime = 2500;

    class Demo {
    public slots:
        void onTick() {
            if (!isCalled) {
                cs::Console::writeLine("Timer tick done", ++counter);
            }

            if (counter == expectedCalls) {
                isCalled = true;
            }
        }
    };

    Demo demo;
    cs::Timer timer;

    cs::Connector::connect(&timer.timeOut, &demo, &Demo::onTick);

    // run timer
    timer.start(100);

    cs::Timer::singleShot(awaitTime, cs::RunPolicy::ThreadPolicy, [&] {
        if (counter != expectedCalls) {
            cs::Console::writeLine("Timer bad call, counts: ", counter);
            isFailed = true;
        }

        isChecked = true;
    });

    while (counter != expectedCalls) {
        if (isFailed) {
            break;
        }
    }

    cs::Console::writeLine("Time point before timer stop: ", cs::Utils::formattedCurrentTime());

    timer.stop();

    cs::Console::writeLine("Time point after timer stop: ", cs::Utils::formattedCurrentTime());

    while (!isChecked);

    ASSERT_EQ(isCalled, true);
    ASSERT_EQ(isFailed, false);
}

TEST(Timer, HighPreciseTimerUsage) {
    static std::atomic<bool> isCalled = false;
    static std::atomic<bool> isFailed = false;
    static std::atomic<bool> isChecked = false;
    static std::atomic<size_t> counter = 0;
    static size_t expectedCalls = 10;
    static int timeTickTime = 200;
    static int awaitTime = 3000;
    static std::chrono::high_resolution_clock::time_point timePoint;

    class A {
    public slots:
        void onTimerTick() {
            auto now = std::chrono::high_resolution_clock::now();
            auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - timePoint);

            ++counter;
            isCalled = true;

            cs::Console::writeLine("Time elapsed: ", ms.count(), ", counter: ", counter);
        }
    };

    A a;
    cs::Timer timer;
    cs::Connector::connect(&timer.timeOut, &a, &A::onTimerTick);

    cs::Timer::singleShot(awaitTime, cs::RunPolicy::ThreadPolicy, [&] {
        cs::Console::writeLine("Timer values, counter ", counter, ", expectedCalls ", expectedCalls);

        if (counter != expectedCalls) {
            cs::Console::writeLine("Timer bad call, counts: ", counter);
            isFailed = true;
        }

        isChecked = true;
    });

    while (expectedCalls != counter && !isFailed) {
        timePoint = std::chrono::high_resolution_clock::now();
        timer.start(timeTickTime, cs::Timer::Type::HighPrecise);

        while (!isCalled && !isFailed);

        isCalled = false;
        timer.stop();

        cs::Console::writeLine("Wait Cycle iteration");
    }

    cs::Console::writeLine("Left main await cycle");

    while (!isChecked);

    ASSERT_EQ(expectedCalls, counter);
    ASSERT_EQ(isFailed, false);
}
```
